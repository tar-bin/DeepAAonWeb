/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 14);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ../~/process/browser.js ***!
  \*******************************/
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz8yODZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ../~/timers-browserify/main.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ 12);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/M2RiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ../~/webpack/buildin/global.js ***!
  \**************************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanM/NjJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* unknown exports provided */
/* exports used: default */
/*!***************************************!*\
  !*** ../~/ndarray-ops/ndarray-ops.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar compile = __webpack_require__(/*! cwise-compiler */ 7)\n\nvar EmptyProc = {\n  body: \"\",\n  args: [],\n  thisVars: [],\n  localVars: []\n}\n\nfunction fixup(x) {\n  if(!x) {\n    return EmptyProc\n  }\n  for(var i=0; i<x.args.length; ++i) {\n    var a = x.args[i]\n    if(i === 0) {\n      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }\n    } else {\n      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}\n    }\n  }\n  if(!x.thisVars) {\n    x.thisVars = []\n  }\n  if(!x.localVars) {\n    x.localVars = []\n  }\n  return x\n}\n\nfunction pcompile(user_args) {\n  return compile({\n    args:     user_args.args,\n    pre:      fixup(user_args.pre),\n    body:     fixup(user_args.body),\n    post:     fixup(user_args.proc),\n    funcName: user_args.funcName\n  })\n}\n\nfunction makeOp(user_args) {\n  var args = []\n  for(var i=0; i<user_args.args.length; ++i) {\n    args.push(\"a\"+i)\n  }\n  var wrapper = new Function(\"P\", [\n    \"return function \", user_args.funcName, \"_ndarrayops(\", args.join(\",\"), \") {P(\", args.join(\",\"), \");return a0}\"\n  ].join(\"\"))\n  return wrapper(pcompile(user_args))\n}\n\nvar assign_ops = {\n  add:  \"+\",\n  sub:  \"-\",\n  mul:  \"*\",\n  div:  \"/\",\n  mod:  \"%\",\n  band: \"&\",\n  bor:  \"|\",\n  bxor: \"^\",\n  lshift: \"<<\",\n  rshift: \">>\",\n  rrshift: \">>>\"\n}\n;(function(){\n  for(var id in assign_ops) {\n    var op = assign_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\",\"b\",\"c\"],\n             body: \"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\",\"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a\"+op+\"=b\"},\n      rvalue: true,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: {args:[\"a\",\"b\",\"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\",\"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a\"+op+\"=s\"},\n      rvalue: true,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar unary_ops = {\n  not: \"!\",\n  bnot: \"~\",\n  neg: \"-\",\n  recip: \"1.0/\"\n}\n;(function(){\n  for(var id in unary_ops) {\n    var op = unary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a=\"+op+\"b\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\"],\n      body: {args:[\"a\"],\n             body:\"a=\"+op+\"a\"},\n      rvalue: true,\n      count: 2,\n      funcName: id+\"eq\"\n    })\n  }\n})();\n\nvar binary_ops = {\n  and: \"&&\",\n  or: \"||\",\n  eq: \"===\",\n  neq: \"!==\",\n  lt: \"<\",\n  gt: \">\",\n  leq: \"<=\",\n  geq: \">=\"\n}\n;(function() {\n  for(var id in binary_ops) {\n    var op = binary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\", \"b\", \"c\"],\n             body:\"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\",\"array\",\"scalar\"],\n      body: {args:[\"a\", \"b\", \"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\", \"b\"],\n             body:\"a=a\"+op+\"b\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a=a\"+op+\"s\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar math_unary = [\n  \"abs\",\n  \"acos\",\n  \"asin\",\n  \"atan\",\n  \"ceil\",\n  \"cos\",\n  \"exp\",\n  \"floor\",\n  \"log\",\n  \"round\",\n  \"sin\",\n  \"sqrt\",\n  \"tan\"\n]\n;(function() {\n  for(var i=0; i<math_unary.length; ++i) {\n    var f = math_unary[i]\n    exports[f] = makeOp({\n                    args: [\"array\", \"array\"],\n                    pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                    body: {args:[\"a\",\"b\"], body:\"a=this_f(b)\", thisVars:[\"this_f\"]},\n                    funcName: f\n                  })\n    exports[f+\"eq\"] = makeOp({\n                      args: [\"array\"],\n                      pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                      body: {args: [\"a\"], body:\"a=this_f(a)\", thisVars:[\"this_f\"]},\n                      rvalue: true,\n                      count: 2,\n                      funcName: f+\"eq\"\n                    })\n  }\n})();\n\nvar math_comm = [\n  \"max\",\n  \"min\",\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_comm.length; ++i) {\n    var f= math_comm[i]\n    exports[f] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f\n                })\n    exports[f+\"s\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"s\"\n                  })\n    exports[f+\"eq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"eq\"\n                  })\n    exports[f+\"seq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"seq\"\n                  })\n  }\n})();\n\nvar math_noncomm = [\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_noncomm.length; ++i) {\n    var f= math_noncomm[i]\n    exports[f+\"op\"] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"op\"\n                })\n    exports[f+\"ops\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"ops\"\n                  })\n    exports[f+\"opeq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"opeq\"\n                  })\n    exports[f+\"opseq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"opseq\"\n                  })\n  }\n})();\n\nexports.any = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"if(a){return true}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return false\"},\n  funcName: \"any\"\n})\n\nexports.all = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1}], body: \"if(!x){return false}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"all\"\n})\n\nexports.sum = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s+=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"sum\"\n})\n\nexports.prod = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=1\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s*=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"prod\"\n})\n\nexports.norm2squared = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm2squared\"\n})\n  \nexports.norm2 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return Math.sqrt(this_s)\"},\n  funcName: \"norm2\"\n})\n  \n\nexports.norminf = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:4}], body:\"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norminf\"\n})\n\nexports.norm1 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:3}], body: \"this_s+=a<0?-a:a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm1\"\n})\n\nexports.sup = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=-Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.inf = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.argmin = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})\n\nexports.argmax = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})  \n\nexports.random = makeOp({\n  args: [\"array\"],\n  pre: {args:[], body:\"this_f=Math.random\", thisVars:[\"this_f\"]},\n  body: {args: [\"a\"], body:\"a=this_f()\", thisVars:[\"this_f\"]},\n  funcName: \"random\"\n})\n\nexports.assign = makeOp({\n  args:[\"array\", \"array\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assign\" })\n\nexports.assigns = makeOp({\n  args:[\"array\", \"scalar\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assigns\" })\n\n\nexports.equals = compile({\n  args:[\"array\", \"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1},\n               {name:\"y\", lvalue:false, rvalue:true, count:1}], \n        body: \"if(x!==y){return false}\", \n        localVars: [], \n        thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"equals\"\n})\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L25kYXJyYXktb3BzL25kYXJyYXktb3BzLmpzPzkxNjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiY3dpc2UtY29tcGlsZXJcIilcblxudmFyIEVtcHR5UHJvYyA9IHtcbiAgYm9keTogXCJcIixcbiAgYXJnczogW10sXG4gIHRoaXNWYXJzOiBbXSxcbiAgbG9jYWxWYXJzOiBbXVxufVxuXG5mdW5jdGlvbiBmaXh1cCh4KSB7XG4gIGlmKCF4KSB7XG4gICAgcmV0dXJuIEVtcHR5UHJvY1xuICB9XG4gIGZvcih2YXIgaT0wOyBpPHguYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhID0geC5hcmdzW2ldXG4gICAgaWYoaSA9PT0gMCkge1xuICAgICAgeC5hcmdzW2ldID0ge25hbWU6IGEsIGx2YWx1ZTp0cnVlLCBydmFsdWU6ICEheC5ydmFsdWUsIGNvdW50OnguY291bnR8fDEgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4LmFyZ3NbaV0gPSB7bmFtZTogYSwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6IDF9XG4gICAgfVxuICB9XG4gIGlmKCF4LnRoaXNWYXJzKSB7XG4gICAgeC50aGlzVmFycyA9IFtdXG4gIH1cbiAgaWYoIXgubG9jYWxWYXJzKSB7XG4gICAgeC5sb2NhbFZhcnMgPSBbXVxuICB9XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIHBjb21waWxlKHVzZXJfYXJncykge1xuICByZXR1cm4gY29tcGlsZSh7XG4gICAgYXJnczogICAgIHVzZXJfYXJncy5hcmdzLFxuICAgIHByZTogICAgICBmaXh1cCh1c2VyX2FyZ3MucHJlKSxcbiAgICBib2R5OiAgICAgZml4dXAodXNlcl9hcmdzLmJvZHkpLFxuICAgIHBvc3Q6ICAgICBmaXh1cCh1c2VyX2FyZ3MucHJvYyksXG4gICAgZnVuY05hbWU6IHVzZXJfYXJncy5mdW5jTmFtZVxuICB9KVxufVxuXG5mdW5jdGlvbiBtYWtlT3AodXNlcl9hcmdzKSB7XG4gIHZhciBhcmdzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8dXNlcl9hcmdzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzLnB1c2goXCJhXCIraSlcbiAgfVxuICB2YXIgd3JhcHBlciA9IG5ldyBGdW5jdGlvbihcIlBcIiwgW1xuICAgIFwicmV0dXJuIGZ1bmN0aW9uIFwiLCB1c2VyX2FyZ3MuZnVuY05hbWUsIFwiX25kYXJyYXlvcHMoXCIsIGFyZ3Muam9pbihcIixcIiksIFwiKSB7UChcIiwgYXJncy5qb2luKFwiLFwiKSwgXCIpO3JldHVybiBhMH1cIlxuICBdLmpvaW4oXCJcIikpXG4gIHJldHVybiB3cmFwcGVyKHBjb21waWxlKHVzZXJfYXJncykpXG59XG5cbnZhciBhc3NpZ25fb3BzID0ge1xuICBhZGQ6ICBcIitcIixcbiAgc3ViOiAgXCItXCIsXG4gIG11bDogIFwiKlwiLFxuICBkaXY6ICBcIi9cIixcbiAgbW9kOiAgXCIlXCIsXG4gIGJhbmQ6IFwiJlwiLFxuICBib3I6ICBcInxcIixcbiAgYnhvcjogXCJeXCIsXG4gIGxzaGlmdDogXCI8PFwiLFxuICByc2hpZnQ6IFwiPj5cIixcbiAgcnJzaGlmdDogXCI+Pj5cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIGFzc2lnbl9vcHMpIHtcbiAgICB2YXIgb3AgPSBhc3NpZ25fb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLFxuICAgICAgICAgICAgIGJvZHk6IFwiYT1iXCIrb3ArXCJjXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYVwiK29wK1wiPWJcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJzXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkK1wic1wiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic2VxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhXCIrb3ArXCI9c1wifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIHVuYXJ5X29wcyA9IHtcbiAgbm90OiBcIiFcIixcbiAgYm5vdDogXCJ+XCIsXG4gIG5lZzogXCItXCIsXG4gIHJlY2lwOiBcIjEuMC9cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIHVuYXJ5X29wcykge1xuICAgIHZhciBvcCA9IHVuYXJ5X29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1cIitvcCtcImJcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9XCIrb3ArXCJhXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgY291bnQ6IDIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIGJpbmFyeV9vcHMgPSB7XG4gIGFuZDogXCImJlwiLFxuICBvcjogXCJ8fFwiLFxuICBlcTogXCI9PT1cIixcbiAgbmVxOiBcIiE9PVwiLFxuICBsdDogXCI8XCIsXG4gIGd0OiBcIj5cIixcbiAgbGVxOiBcIjw9XCIsXG4gIGdlcTogXCI+PVwiXG59XG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIGJpbmFyeV9vcHMpIHtcbiAgICB2YXIgb3AgPSBiaW5hcnlfb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcImNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wiY1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wic1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1hXCIrb3ArXCJiXCJ9LFxuICAgICAgcnZhbHVlOnRydWUsXG4gICAgICBjb3VudDoyLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YVwiK29wK1wic1wifSxcbiAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgY291bnQ6MixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfdW5hcnkgPSBbXG4gIFwiYWJzXCIsXG4gIFwiYWNvc1wiLFxuICBcImFzaW5cIixcbiAgXCJhdGFuXCIsXG4gIFwiY2VpbFwiLFxuICBcImNvc1wiLFxuICBcImV4cFwiLFxuICBcImZsb29yXCIsXG4gIFwibG9nXCIsXG4gIFwicm91bmRcIixcbiAgXCJzaW5cIixcbiAgXCJzcXJ0XCIsXG4gIFwidGFuXCJcbl1cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfdW5hcnkubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IG1hdGhfdW5hcnlbaV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZihhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcImVxXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfY29tbSA9IFtcbiAgXCJtYXhcIixcbiAgXCJtaW5cIixcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX2NvbW1baV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZcbiAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wiZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wiZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYSxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfbm9uY29tbSA9IFtcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfbm9uY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX25vbmNvbW1baV1cbiAgICBleHBvcnRzW2YrXCJvcFwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIsYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcGVxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYixhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcHNlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG5leHBvcnRzLmFueSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwiaWYoYSl7cmV0dXJuIHRydWV9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIGZhbHNlXCJ9LFxuICBmdW5jTmFtZTogXCJhbnlcIlxufSlcblxuZXhwb3J0cy5hbGwgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcInhcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcImlmKCF4KXtyZXR1cm4gZmFsc2V9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIHRydWVcIn0sXG4gIGZ1bmNOYW1lOiBcImFsbFwiXG59KVxuXG5leHBvcnRzLnN1bSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJ0aGlzX3MrPWFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcInN1bVwiXG59KVxuXG5leHBvcnRzLnByb2QgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MVwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwidGhpc19zKj1hXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJwcm9kXCJcbn0pXG5cbmV4cG9ydHMubm9ybTJzcXVhcmVkID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMnNxdWFyZWRcIlxufSlcbiAgXG5leHBvcnRzLm5vcm0yID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gTWF0aC5zcXJ0KHRoaXNfcylcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0yXCJcbn0pXG4gIFxuXG5leHBvcnRzLm5vcm1pbmYgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDo0fV0sIGJvZHk6XCJpZigtYT50aGlzX3Mpe3RoaXNfcz0tYX1lbHNlIGlmKGE+dGhpc19zKXt0aGlzX3M9YX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm1pbmZcIlxufSlcblxuZXhwb3J0cy5ub3JtMSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjN9XSwgYm9keTogXCJ0aGlzX3MrPWE8MD8tYTphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMVwiXG59KVxuXG5leHBvcnRzLnN1cCA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPS1JbmZpbml0eVwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIGJvZHk6XG4gICB7IGJvZHk6IFwiaWYoX2lubGluZV8xX2FyZzBfPnRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsXG4gICAgIGFyZ3M6IFt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6Mn0gXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIHBvc3Q6XG4gICB7IGJvZHk6IFwicmV0dXJuIHRoaXNfaFwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH1cbiB9KVxuXG5leHBvcnRzLmluZiA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPUluZmluaXR5XCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgYm9keTpcbiAgIHsgYm9keTogXCJpZihfaW5saW5lXzFfYXJnMF88dGhpc19oKXRoaXNfaD1faW5saW5lXzFfYXJnMF9cIixcbiAgICAgYXJnczogW3tcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcwX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoyfSBdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgcG9zdDpcbiAgIHsgYm9keTogXCJyZXR1cm4gdGhpc19oXCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfVxuIH0pXG5cbmV4cG9ydHMuYXJnbWluID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj1JbmZpbml0eTt0aGlzX2k9X2lubGluZV8wX2FyZzJfLnNsaWNlKDApfVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMl9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6MX1cbiAgICAgIF0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltdfSxcbiAgYm9keTp7XG4gICAgYm9keTpcIntpZihfaW5saW5lXzFfYXJnMV88dGhpc192KXt0aGlzX3Y9X2lubGluZV8xX2FyZzFfO2Zvcih2YXIgX2lubGluZV8xX2s9MDtfaW5saW5lXzFfazxfaW5saW5lXzFfYXJnMF8ubGVuZ3RoOysrX2lubGluZV8xX2spe3RoaXNfaVtfaW5saW5lXzFfa109X2lubGluZV8xX2FyZzBfW19pbmxpbmVfMV9rXX19fVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfV0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltcIl9pbmxpbmVfMV9rXCJdfSxcbiAgcG9zdDp7XG4gICAgYm9keTpcIntyZXR1cm4gdGhpc19pfVwiLFxuICAgIGFyZ3M6W10sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCJdLFxuICAgIGxvY2FsVmFyczpbXX1cbn0pXG5cbmV4cG9ydHMuYXJnbWF4ID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj0tSW5maW5pdHk7dGhpc19pPV9pbmxpbmVfMF9hcmcyXy5zbGljZSgwKX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzJfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjF9XG4gICAgICBdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXX0sXG4gIGJvZHk6e1xuICAgIGJvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPnRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn1dLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0sXG4gIHBvc3Q6e1xuICAgIGJvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixcbiAgICBhcmdzOltdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiXSxcbiAgICBsb2NhbFZhcnM6W119XG59KSAgXG5cbmV4cG9ydHMucmFuZG9tID0gbWFrZU9wKHtcbiAgYXJnczogW1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5yYW5kb21cIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZigpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gIGZ1bmNOYW1lOiBcInJhbmRvbVwiXG59KVxuXG5leHBvcnRzLmFzc2lnbiA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sIGJvZHk6XCJhPWJcIn0sXG4gIGZ1bmNOYW1lOiBcImFzc2lnblwiIH0pXG5cbmV4cG9ydHMuYXNzaWducyA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLCBib2R5OlwiYT1iXCJ9LFxuICBmdW5jTmFtZTogXCJhc3NpZ25zXCIgfSlcblxuXG5leHBvcnRzLmVxdWFscyA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJ4XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9LFxuICAgICAgICAgICAgICAge25hbWU6XCJ5XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgXG4gICAgICAgIGJvZHk6IFwiaWYoeCE9PXkpe3JldHVybiBmYWxzZX1cIiwgXG4gICAgICAgIGxvY2FsVmFyczogW10sIFxuICAgICAgICB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiB0cnVlXCJ9LFxuICBmdW5jTmFtZTogXCJlcXVhbHNcIlxufSlcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L25kYXJyYXktb3BzL25kYXJyYXktb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/* unknown exports provided */
/* exports used: default */
/*!*******************************!*\
  !*** ../~/ndarray/ndarray.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ 10)\nvar isBuffer = __webpack_require__(/*! is-buffer */ 11)\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L25kYXJyYXkvbmRhcnJheS5qcz8wZDdiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoXCJpcy1idWZmZXJcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG5cbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cblxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG5cbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcblxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcblxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBcImJ1ZmZlclwiXG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3JcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbmRhcnJheS9uZGFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/* exports provided: default */
/* exports used: default */
/*!********************************!*\
  !*** ../~/vue/dist/vue.esm.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * Vue.js v2.2.5\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === \"<Anonymous>\") {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \":\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.fns) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (!oldHook) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (oldHook.fns && oldHook.merged) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns\n) {\n  var res = {};\n  for (var i = 0; i < fns.length; i++) {\n    res[fns[i][0]] = fns[i][1];\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive == null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // reset scheduler before updated hook called\n  var oldQueue = queue.slice();\n  resetSchedulerState();\n\n  // call updated hooks\n  index = oldQueue.length;\n  while (index--) {\n    watcher = oldQueue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    if (!vnode.componentInstance._isMounted) {\n      vnode.componentInstance._isMounted = true;\n      callHook(vnode.componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      activateChildComponent(vnode.componentInstance, true /* direct */);\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    if (!vnode.componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (data.model) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractProps(data, Ctor, tag);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && attrs.hasOwnProperty(keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the delared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (on[event]) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = _toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var inject = vm.$options.inject;\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    var loop = function ( i ) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          /* istanbul ignore else */\n          if (process.env.NODE_ENV !== 'production') {\n            defineReactive$$1(vm, key, source._provided[provideKey], function () {\n              warn(\n                \"Avoid mutating an injected value directly since the changes will be \" +\n                \"overwritten whenever the provided component re-renders. \" +\n                \"injection being mutated: \\\"\" + key + \"\\\"\",\n                vm\n              );\n            });\n          } else {\n            defineReactive$$1(vm, key, source._provided[provideKey]);\n          }\n          break\n        }\n        source = source.$parent;\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) loop( i );\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    for (var i = 0; i < latest.length; i++) {\n      if (sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.2.5';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (on[RANGE_TOKEN]) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (on[CHECKBOX_RADIO_TOKEN]) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (!fn) { return false }\n  var invokerFns = fn.fns;\n  if (invokerFns) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      config.productionTip !== false &&\n      inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n            (i > pos || !tagName) &&\n            options.warn) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  return \"[\" + key + \",function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}]\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);\n  if (keywordMatch) {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(/*! ./../../process/browser.js */ 0), __webpack_require__(/*! ./../../webpack/buildin/global.js */ 2)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3Z1ZS9kaXN0L3Z1ZS5lc20uanM/YWU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi4yLjVcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIF90b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBjb25maWcgPSB7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKi9cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZmlsdGVyJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGxpZmVjeWNsZSBob29rcy5cbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCdcbiAgXSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIHNjaGVkdWxlciBmbHVzaCBjeWNsZS5cbiAgICovXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG59O1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHsgY2IuY2FsbChjdHgpOyB9XG4gICAgICBpZiAoX3Jlc29sdmUpIHsgX3Jlc29sdmUoY3R4KTsgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIGZvcm1hdExvY2F0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgPT09IFwiPEFub255bW91cz5cIikge1xuICAgICAgc3RyICs9IFwiIC0gdXNlIHRoZSBcXFwibmFtZVxcXCIgb3B0aW9uIGZvciBiZXR0ZXIgZGVidWdnaW5nIG1lc3NhZ2VzLlwiO1xuICAgIH1cbiAgICByZXR1cm4gKFwiXFxuKGZvdW5kIGluIFwiICsgc3RyICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWUsXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlclxuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICAgIDogcmVzXG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgZXh0ZW5kc0Zyb20gPT09ICdmdW5jdGlvbidcbiAgICAgID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20ub3B0aW9ucywgdm0pXG4gICAgICA6IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG1peGluID0gY2hpbGQubWl4aW5zW2ldO1xuICAgICAgaWYgKG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSQzKSB7XG4gICAgICAgIG1peGluID0gbWl4aW4ub3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mIGEgdmFsdWVcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdzdHJpbmcnKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnbnVtYmVyJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQm9vbGVhbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnRnVuY3Rpb24nKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnZnVuY3Rpb24nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSAnJztcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKCFjdXIpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIW9sZCkge1xuICAgICAgaWYgKCFjdXIuZm5zKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmICghb2xkSG9vaykge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvbGRIb29rLmZucyAmJiBvbGRIb29rLm1lcmdlZCkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGMgPT0gbnVsbCB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAobGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgbGFzdC50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMudGV4dCAmJiBsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoYy50YWcgJiYgYy5rZXkgPT0gbnVsbCAmJiBuZXN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICYmIGMuY29tcG9uZW50T3B0aW9uczsgfSlbMF1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIHZhciBuYW1lLCBjaGlsZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGNoaWxkLmRhdGEgJiYgKG5hbWUgPSBjaGlsZC5kYXRhLnNsb3QpKSB7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnNcbikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzW2Zuc1tpXVswXV0gPSBmbnNbaV1bMV07XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgcXVldWUgPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBxdWV1ZS5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQsIHZtO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXNldCBzY2hlZHVsZXIgYmVmb3JlIHVwZGF0ZWQgaG9vayBjYWxsZWRcbiAgdmFyIG9sZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgdXBkYXRlZCBob29rc1xuICBpbmRleCA9IG9sZFF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB3YXRjaGVyID0gb2xkUXVldWVbaW5kZXhdO1xuICAgIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+PSAwICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoTWF0aC5tYXgoaSwgaW5kZXgpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHsga2V5OiAxLCByZWY6IDEsIHNsb3Q6IDEgfTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoIUN0b3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGlmICghQ3Rvci5jaWQpIHtcbiAgICBpZiAoQ3Rvci5yZXNvbHZlZCkge1xuICAgICAgQ3RvciA9IEN0b3IucmVzb2x2ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoQ3RvciwgYmFzZUN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaXQncyBvayB0byBxdWV1ZSB0aGlzIG9uIGV2ZXJ5IHJlbmRlciBiZWNhdXNlXG4gICAgICAgIC8vICRmb3JjZVVwZGF0ZSBpcyBidWZmZXJlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAgICBjb250ZXh0LiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIUN0b3IpIHtcbiAgICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoZGF0YS5tb2RlbCkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHMoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChDdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVyc1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChwcm9wT3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEpO1xuICAgIH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNiXG4pIHtcbiAgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgcmVzID0gYmFzZUN0b3IuZXh0ZW5kKHJlcyk7XG4gICAgICB9XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgLy8gaGFuZGxlIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzIChkYXRhLCBDdG9yLCB0YWcpIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcE9wdGlvbnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIHZhciBkb21Qcm9wcyA9IGRhdGEuZG9tUHJvcHM7XG4gIGlmIChhdHRycyB8fCBwcm9wcyB8fCBkb21Qcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWxhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5KSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgZG9tUHJvcHMsIGtleSwgYWx0S2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChoYXNoKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChvbltldmVudF0pIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYWx3YXlzTm9ybWFsaXplKSB7IG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTsgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmICh2bm9kZSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgJiYgIWNoaWxkLm5zKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uJHZub2RlID0gbnVsbDsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSBfdG9TdHJpbmc7XG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuICBWdWUucHJvdG90eXBlLl90ID0gcmVuZGVyU2xvdDtcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSByZW5kZXJTdGF0aWM7XG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIGluamVjdCA9IHZtLiRvcHRpb25zLmluamVjdDtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgLy8gaXNBcnJheSBoZXJlXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGluamVjdCk7XG4gICAgdmFyIGtleXMgPSBpc0FycmF5XG4gICAgICA/IGluamVjdFxuICAgICAgOiBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpc0FycmF5ID8ga2V5IDogaW5qZWN0W2tleV07XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlKSB7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMi41JztcblxuLyogICovXG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGNoaWxkLmNsYXNzXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmXG4gICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgKVxufVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQlxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWJhaWxlZCkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5hdHRycyAmJiAhdm5vZGUuZGF0YS5hdHRycykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGF0dHJzLl9fb2JfXykge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoYXR0cnNba2V5XSA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKCFkYXRhLnN0YXRpY0NsYXNzICYmICFkYXRhLmNsYXNzICYmXG4gICAgICAoIW9sZERhdGEgfHwgKCFvbGREYXRhLnN0YXRpY0NsYXNzICYmICFvbGREYXRhLmNsYXNzKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3MpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudFxuKSB7XG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ2YXIgJCRleHAgPSBcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgJCRpZHggPSBcIiArIChtb2RlbFJzLmlkeCkgKyBcIjtcIiArXG4gICAgICBcImlmICghQXJyYXkuaXNBcnJheSgkJGV4cCkpe1wiICtcbiAgICAgICAgdmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQgKyBcIn1cIiArXG4gICAgICBcImVsc2V7JCRleHAuc3BsaWNlKCQkaWR4LCAxLCBcIiArIGFzc2lnbm1lbnQgKyBcIil9XCJcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGMpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyB2YWx1ZSArIFwiPSQkY31cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG9uW1JBTkdFX1RPS0VOXSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UsXG4gIGNhcHR1cmVcbikge1xuICBpZiAob25jZSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEub24gJiYgIXZub2RlLmRhdGEub24pIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuZG9tUHJvcHMgJiYgIXZub2RlLmRhdGEuZG9tUHJvcHMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAocHJvcHMuX19vYl9fKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChwcm9wc1trZXldID09IG51bGwpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBjdXIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG0gJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbm9ybWFsaXplKG5hbWUpXSA9IHZhbDtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKCFkYXRhLnN0YXRpY1N0eWxlICYmICFkYXRhLnN0eWxlICYmXG4gICAgICAhb2xkRGF0YS5zdGF0aWNTdHlsZSAmJiAhb2xkRGF0YS5zdHlsZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIHZub2RlLmRhdGEuc3R5bGUgPSBzdHlsZS5fX29iX18gPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGVbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcbiAgYWRkQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2VudGVyQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fbGVhdmVDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdExlYXZlRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVt2bm9kZS5rZXldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmICghZm4pIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpbnZva2VyRm5zKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgcmV0dXJuIC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKVxuICAgID8gaCgna2VlcC1hbGl2ZScpXG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0JDEpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QkMS5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgICBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGVsLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGVsLnNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzKG5vZGUuaWZDb25kaXRpb25zLCBpc0luRm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIChjb25kaXRpb25CbG9ja3MsIGlzSW5Gb3IpIHtcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvbmRpdGlvbkJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG1hcmtTdGF0aWNSb290cyhjb25kaXRpb25CbG9ja3NbaV0uYmxvY2ssIGlzSW5Gb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChldmVudHMsIG5hdGl2ZSkge1xuICB2YXIgcmVzID0gbmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQzO1xudmFyIHRyYW5zZm9ybXMkMTtcbnZhciBkYXRhR2VuRm5zO1xudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxO1xudmFyIHN0YXRpY1JlbmRlckZucztcbnZhciBvbmNlQ291bnQ7XG52YXIgY3VycmVudE9wdGlvbnM7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuICB2YXIgcHJldlN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG4gIG9uY2VDb3VudCA9IDA7XG4gIGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgd2FybiQzID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0cmFuc2Zvcm1zJDEgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcbiAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgb25jZUNvdW50ID0gcHJldk9uY2VDb3VudDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbClcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMkMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDMoXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIixcIiArIChvbmNlQ291bnQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoZWwpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChjb25kaXRpb25zKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGVsLm9uY2UgPyBnZW5PbmNlKGVsKSA6IGdlbkVsZW1lbnQoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBtYXliZUNvbXBvbmVudChlbCkgJiYgZWwudGFnICE9PSAnc2xvdCcgJiYgZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5rZXlcbiAgKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBwbGF0Zm9ybURpcmVjdGl2ZXMkMVtkaXIubmFtZV0gfHwgYmFzZURpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHdhcm4kMyk7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICB3YXJuJDMoJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIGN1cnJlbnRPcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChzbG90cykge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0pOyB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChrZXksIGVsKSB7XG4gIHJldHVybiBcIltcIiArIGtleSArIFwiLGZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5hdHRyc01hcC5zY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwpKSArIFwifV1cIlxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoZWwsIGNoZWNrU2tpcCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBlbCQxLmZvciAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCQxKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbikgOiAwO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKGNoaWxkcmVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBvbmVudCAoZWwpIHtcbiAgcmV0dXJuICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMShlbC50YWcpXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChjb21wb25lbnROYW1lLCBlbCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhKGVsKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gIHZhciBmdW5jdGlvbkNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB0aXBzID0gW107XG4gICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXAkJDEpIHtcbiAgICAgICh0aXAkJDEgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9IChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgIH1cbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyksXG4gICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgIH1cbiAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgcmV0dXJuIGNvbXBpbGVkXG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICB2YXIgbCA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5sZW5ndGg7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzLnN0YXRpY1JlbmRlckZuc1tpXSA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5zdGF0aWNSZW5kZXJGbnNbaV0sIGZuR2VuRXJyb3JzKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldID0gcmVzKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21waWxlOiBjb21waWxlLFxuICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY29tcGlsZVRvRnVuY3Rpb25zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQyXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKCgodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlL2Rpc3QvdnVlLmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!**********************!*\
  !*** ./lib/keras.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {!function(t,e){ true?module.exports=e():\"function\"==typeof define&&define.amd?define([],e):\"object\"==typeof exports?exports.KerasJS=e():t.KerasJS=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,\"a\",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p=\"\",e(e.s=625)}([function(t,e,n){var r=n(5),o=n(31),i=n(15),a=n(16),s=n(32),u=\"prototype\",l=function(t,e,n){var c,f,p,h,d=t&l.F,v=t&l.G,m=t&l.S,_=t&l.P,g=t&l.B,y=v?r:m?r[e]||(r[e]={}):(r[e]||{})[u],b=v?o:o[e]||(o[e]={}),w=b[u]||(b[u]={});v&&(n=e);for(c in n)f=!d&&y&&void 0!==y[c],p=(f?y:n)[c],h=g&&f?s(p,r):_&&\"function\"==typeof p?s(Function.call,p):p,y&&a(y,c,p,t&l.U),b[c]!=p&&i(b,c,h),_&&w[c]!=p&&(w[c]=p)};r.core=o,l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,t.exports=l},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=n(2),u=r(s),l=n(3),c=r(l),f=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,t),this.layerClass=\"Layer\",this.name=e.name,this.params=[],this.weights={},this.gpu=e.gpu,this.pipeline=e.pipeline,this._useWeblas=!1,this._pipelineEnabled=!1}return a(t,[{key:\"setWeights\",value:function(t){var e=this;this.params.forEach(function(n,r){e.weights[n]=t[r]})}},{key:\"toggleGpu\",value:function(t){var e=\"undefined\"==typeof t?!this._useWeblas:t;e&&weblas?this._useWeblas=!0:this._useWeblas=!1}},{key:\"call\",value:function(t){return t}},{key:\"transferFromPipeline\",value:function(t){if(!t.weblasTensor)throw new Error(\"Variable passed in does not contain weblas tensor.\");if(!t._fromPipeline)throw new Error(\"Variable passed in does not contain _fromPipeline.\");if(!t._actualShape)throw new Error(\"Variable passed in does not contain _actualShape.\");var e=t.weblasTensor.shape[1],n=t._actualShape.slice(0,-1).reduce(function(t,e){return t*e},1),r=new u.default([],t.weblasTensor.shape);r.tensor.data=t.weblasTensor.transfer();for(var i=new u.default([],t._actualShape),a=new u.default([],[n]),s=new u.default([],t._actualShape.slice(0,-1)),l=0;l<e;l++){var f;c.default.assign(a.tensor,r.tensor.pick(null,l)),s.replaceTensorData(a.tensor.data);var p=Array(t._actualShape.length-1).fill(null);c.default.assign((f=i.tensor).pick.apply(f,o(p).concat([l])),s.tensor)}return i._fromPipeline=!1,i._actualShape&&delete i._actualShape,i}}]),t}();e.default=f},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var i=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=n(91),u=r(s),l=n(191),c=(r(l),n(197)),f=function(t,e){if(t.length&&e.length&&t.length!==e.reduce(function(t,e){return t*e},1))throw new Error(\"Specified shape incompatible with data.\")},p=function(){function t(e,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};o(this,t),this._type=r.type||Float32Array,e&&e.length&&(e instanceof this._type||e instanceof Array)?(f(e,n),this.tensor=(0,u.default)(e,n),this.tensor=(0,u.default)(new this._type(e),n)):!e.length&&n.length?this.tensor=(0,u.default)(new this._type(n.reduce(function(t,e){return t*e},1)),n):this.tensor=(0,u.default)(new this._type([]),[])}return a(t,[{key:\"replaceTensorData\",value:function(t){if(t&&t.length&&t instanceof this._type)this.tensor.data=t;else{if(!(t&&t.length&&t instanceof Array))throw new Error(\"[Tensor] invalid input for replaceTensorData method.\");this.tensor.data=new this._type(t)}}},{key:\"createWeblasTensor\",value:function(){if(this.weblasTensor&&this.weblasTensor.delete(),1===this.tensor.shape.length){var t=this.tensor.shape[0];if(t>c.MAX_TEXTURE_SIZE)this._gpuMaxSizeExceeded=!0;else{var e=[1,t];this.weblasTensor=new weblas.pipeline.Tensor(e,this.tensor.data)}}else{if(2!==this.tensor.shape.length)throw new Error(\"[Tensor] can only create weblas Tensor for 1-D or 2-D only\");if(this.tensor.shape.some(function(t){return t>c.MAX_TEXTURE_SIZE}))this._gpuMaxSizeExceeded=!0;else{var n=this.tensor.shape;this.weblasTensor=new weblas.pipeline.Tensor(n,this.tensor.data)}}}},{key:\"deleteWeblasTensor\",value:function(){this.weblasTensor&&(this.weblasTensor.delete(),delete this.weblasTensor)}},{key:\"copyFromWeblasTensor\",value:function(t){var e=weblas.gpu.gl,r=e.context,o=e.createProgram(n(618));this.weblasTensor=new weblas.pipeline.Tensor(t.shape,null),e.selectProgram(o),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,t.texture);var a=r.getUniformLocation(o,\"source\");r.uniform1i(a,0);var s=i(this.weblasTensor.shape,2),u=s[0],l=s[1],c=e.getPad(l);e.bindOutputTexture(u,(l+c)/4,this.weblasTensor.texture),r.drawElements(r.TRIANGLES,6,r.UNSIGNED_SHORT,0),e.unbindInputTexture(r.TEXTURE0)}}]),t}();e.default=p},function(t,e,n){\"use strict\";function r(t){if(!t)return s;for(var e=0;e<t.args.length;++e){var n=t.args[e];0===e?t.args[e]={name:n,lvalue:!0,rvalue:!!t.rvalue,count:t.count||1}:t.args[e]={name:n,lvalue:!1,rvalue:!0,count:1}}return t.thisVars||(t.thisVars=[]),t.localVars||(t.localVars=[]),t}function o(t){return a({args:t.args,pre:r(t.pre),body:r(t.body),post:r(t.proc),funcName:t.funcName})}function i(t){for(var e=[],n=0;n<t.args.length;++n)e.push(\"a\"+n);var r=new Function(\"P\",[\"return function \",t.funcName,\"_ndarrayops(\",e.join(\",\"),\") {P(\",e.join(\",\"),\");return a0}\"].join(\"\"));return r(o(t))}var a=n(166),s={body:\"\",args:[],thisVars:[],localVars:[]},u={add:\"+\",sub:\"-\",mul:\"*\",div:\"/\",mod:\"%\",band:\"&\",bor:\"|\",bxor:\"^\",lshift:\"<<\",rshift:\">>\",rrshift:\">>>\"};!function(){for(var t in u){var n=u[t];e[t]=i({args:[\"array\",\"array\",\"array\"],body:{args:[\"a\",\"b\",\"c\"],body:\"a=b\"+n+\"c\"},funcName:t}),e[t+\"eq\"]=i({args:[\"array\",\"array\"],body:{args:[\"a\",\"b\"],body:\"a\"+n+\"=b\"},rvalue:!0,funcName:t+\"eq\"}),e[t+\"s\"]=i({args:[\"array\",\"array\",\"scalar\"],body:{args:[\"a\",\"b\",\"s\"],body:\"a=b\"+n+\"s\"},funcName:t+\"s\"}),e[t+\"seq\"]=i({args:[\"array\",\"scalar\"],body:{args:[\"a\",\"s\"],body:\"a\"+n+\"=s\"},rvalue:!0,funcName:t+\"seq\"})}}();var l={not:\"!\",bnot:\"~\",neg:\"-\",recip:\"1.0/\"};!function(){for(var t in l){var n=l[t];e[t]=i({args:[\"array\",\"array\"],body:{args:[\"a\",\"b\"],body:\"a=\"+n+\"b\"},funcName:t}),e[t+\"eq\"]=i({args:[\"array\"],body:{args:[\"a\"],body:\"a=\"+n+\"a\"},rvalue:!0,count:2,funcName:t+\"eq\"})}}();var c={and:\"&&\",or:\"||\",eq:\"===\",neq:\"!==\",lt:\"<\",gt:\">\",leq:\"<=\",geq:\">=\"};!function(){for(var t in c){var n=c[t];e[t]=i({args:[\"array\",\"array\",\"array\"],body:{args:[\"a\",\"b\",\"c\"],body:\"a=b\"+n+\"c\"},funcName:t}),e[t+\"s\"]=i({args:[\"array\",\"array\",\"scalar\"],body:{args:[\"a\",\"b\",\"s\"],body:\"a=b\"+n+\"s\"},funcName:t+\"s\"}),e[t+\"eq\"]=i({args:[\"array\",\"array\"],body:{args:[\"a\",\"b\"],body:\"a=a\"+n+\"b\"},rvalue:!0,count:2,funcName:t+\"eq\"}),e[t+\"seq\"]=i({args:[\"array\",\"scalar\"],body:{args:[\"a\",\"s\"],body:\"a=a\"+n+\"s\"},rvalue:!0,count:2,funcName:t+\"seq\"})}}();var f=[\"abs\",\"acos\",\"asin\",\"atan\",\"ceil\",\"cos\",\"exp\",\"floor\",\"log\",\"round\",\"sin\",\"sqrt\",\"tan\"];!function(){for(var t=0;t<f.length;++t){var n=f[t];e[n]=i({args:[\"array\",\"array\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\"],body:\"a=this_f(b)\",thisVars:[\"this_f\"]},funcName:n}),e[n+\"eq\"]=i({args:[\"array\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\"],body:\"a=this_f(a)\",thisVars:[\"this_f\"]},rvalue:!0,count:2,funcName:n+\"eq\"})}}();var p=[\"max\",\"min\",\"atan2\",\"pow\"];!function(){for(var t=0;t<p.length;++t){var n=p[t];e[n]=i({args:[\"array\",\"array\",\"array\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\",\"c\"],body:\"a=this_f(b,c)\",thisVars:[\"this_f\"]},funcName:n}),e[n+\"s\"]=i({args:[\"array\",\"array\",\"scalar\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\",\"c\"],body:\"a=this_f(b,c)\",thisVars:[\"this_f\"]},funcName:n+\"s\"}),e[n+\"eq\"]=i({args:[\"array\",\"array\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\"],body:\"a=this_f(a,b)\",thisVars:[\"this_f\"]},rvalue:!0,count:2,funcName:n+\"eq\"}),e[n+\"seq\"]=i({args:[\"array\",\"scalar\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\"],body:\"a=this_f(a,b)\",thisVars:[\"this_f\"]},rvalue:!0,count:2,funcName:n+\"seq\"})}}();var h=[\"atan2\",\"pow\"];!function(){for(var t=0;t<h.length;++t){var n=h[t];e[n+\"op\"]=i({args:[\"array\",\"array\",\"array\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\",\"c\"],body:\"a=this_f(c,b)\",thisVars:[\"this_f\"]},funcName:n+\"op\"}),e[n+\"ops\"]=i({args:[\"array\",\"array\",\"scalar\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\",\"c\"],body:\"a=this_f(c,b)\",thisVars:[\"this_f\"]},funcName:n+\"ops\"}),e[n+\"opeq\"]=i({args:[\"array\",\"array\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\"],body:\"a=this_f(b,a)\",thisVars:[\"this_f\"]},rvalue:!0,count:2,funcName:n+\"opeq\"}),e[n+\"opseq\"]=i({args:[\"array\",\"scalar\"],pre:{args:[],body:\"this_f=Math.\"+n,thisVars:[\"this_f\"]},body:{args:[\"a\",\"b\"],body:\"a=this_f(b,a)\",thisVars:[\"this_f\"]},rvalue:!0,count:2,funcName:n+\"opseq\"})}}(),e.any=a({args:[\"array\"],pre:s,body:{args:[{name:\"a\",lvalue:!1,rvalue:!0,count:1}],body:\"if(a){return true}\",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:\"return false\"},funcName:\"any\"}),e.all=a({args:[\"array\"],pre:s,body:{args:[{name:\"x\",lvalue:!1,rvalue:!0,count:1}],body:\"if(!x){return false}\",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:\"return true\"},funcName:\"all\"}),e.sum=a({args:[\"array\"],pre:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"this_s=0\"},body:{args:[{name:\"a\",lvalue:!1,rvalue:!0,count:1}],body:\"this_s+=a\",localVars:[],thisVars:[\"this_s\"]},post:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"return this_s\"},funcName:\"sum\"}),e.prod=a({args:[\"array\"],pre:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"this_s=1\"},body:{args:[{name:\"a\",lvalue:!1,rvalue:!0,count:1}],body:\"this_s*=a\",localVars:[],thisVars:[\"this_s\"]},post:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"return this_s\"},funcName:\"prod\"}),e.norm2squared=a({args:[\"array\"],pre:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"this_s=0\"},body:{args:[{name:\"a\",lvalue:!1,rvalue:!0,count:2}],body:\"this_s+=a*a\",localVars:[],thisVars:[\"this_s\"]},post:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"return this_s\"},funcName:\"norm2squared\"}),e.norm2=a({args:[\"array\"],pre:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"this_s=0\"},body:{args:[{name:\"a\",lvalue:!1,rvalue:!0,count:2}],body:\"this_s+=a*a\",localVars:[],thisVars:[\"this_s\"]},post:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"return Math.sqrt(this_s)\"},funcName:\"norm2\"}),e.norminf=a({args:[\"array\"],pre:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"this_s=0\"},body:{args:[{name:\"a\",lvalue:!1,rvalue:!0,count:4}],body:\"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\",localVars:[],thisVars:[\"this_s\"]},post:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"return this_s\"},funcName:\"norminf\"}),e.norm1=a({args:[\"array\"],pre:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"this_s=0\"},body:{args:[{name:\"a\",lvalue:!1,rvalue:!0,count:3}],body:\"this_s+=a<0?-a:a\",localVars:[],thisVars:[\"this_s\"]},post:{args:[],localVars:[],thisVars:[\"this_s\"],body:\"return this_s\"},funcName:\"norm1\"}),e.sup=a({args:[\"array\"],pre:{body:\"this_h=-Infinity\",args:[],thisVars:[\"this_h\"],localVars:[]},body:{body:\"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",args:[{name:\"_inline_1_arg0_\",lvalue:!1,rvalue:!0,count:2}],thisVars:[\"this_h\"],localVars:[]},post:{body:\"return this_h\",args:[],thisVars:[\"this_h\"],localVars:[]}}),e.inf=a({args:[\"array\"],pre:{body:\"this_h=Infinity\",args:[],thisVars:[\"this_h\"],localVars:[]},body:{body:\"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",args:[{name:\"_inline_1_arg0_\",lvalue:!1,rvalue:!0,count:2}],thisVars:[\"this_h\"],localVars:[]},post:{body:\"return this_h\",args:[],thisVars:[\"this_h\"],localVars:[]}}),e.argmin=a({args:[\"index\",\"array\",\"shape\"],pre:{body:\"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",args:[{name:\"_inline_0_arg0_\",lvalue:!1,rvalue:!1,count:0},{name:\"_inline_0_arg1_\",lvalue:!1,rvalue:!1,count:0},{name:\"_inline_0_arg2_\",lvalue:!1,rvalue:!0,count:1}],thisVars:[\"this_i\",\"this_v\"],localVars:[]},body:{body:\"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",args:[{name:\"_inline_1_arg0_\",lvalue:!1,rvalue:!0,count:2},{name:\"_inline_1_arg1_\",lvalue:!1,rvalue:!0,count:2}],thisVars:[\"this_i\",\"this_v\"],localVars:[\"_inline_1_k\"]},post:{body:\"{return this_i}\",args:[],thisVars:[\"this_i\"],localVars:[]}}),e.argmax=a({args:[\"index\",\"array\",\"shape\"],pre:{body:\"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",args:[{name:\"_inline_0_arg0_\",lvalue:!1,rvalue:!1,count:0},{name:\"_inline_0_arg1_\",lvalue:!1,rvalue:!1,count:0},{name:\"_inline_0_arg2_\",lvalue:!1,rvalue:!0,count:1}],thisVars:[\"this_i\",\"this_v\"],localVars:[]},body:{body:\"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",args:[{name:\"_inline_1_arg0_\",lvalue:!1,rvalue:!0,count:2},{name:\"_inline_1_arg1_\",lvalue:!1,rvalue:!0,count:2}],thisVars:[\"this_i\",\"this_v\"],localVars:[\"_inline_1_k\"]},post:{body:\"{return this_i}\",args:[],thisVars:[\"this_i\"],localVars:[]}}),e.random=i({args:[\"array\"],pre:{args:[],body:\"this_f=Math.random\",thisVars:[\"this_f\"]},body:{args:[\"a\"],body:\"a=this_f()\",thisVars:[\"this_f\"]},funcName:\"random\"}),e.assign=i({args:[\"array\",\"array\"],body:{args:[\"a\",\"b\"],body:\"a=b\"},funcName:\"assign\"}),e.assigns=i({args:[\"array\",\"scalar\"],body:{args:[\"a\",\"b\"],body:\"a=b\"},funcName:\"assigns\"}),e.equals=a({args:[\"array\",\"array\"],pre:s,body:{args:[{name:\"x\",lvalue:!1,rvalue:!0,count:1},{name:\"y\",lvalue:!1,rvalue:!0,count:1}],body:\"if(x!==y){return false}\",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:\"return true\"},funcName:\"equals\"})},function(t,e,n){var r=n(7);t.exports=function(t){if(!r(t))throw TypeError(t+\" is not an object!\");return t}},function(t,e){var n=t.exports=\"undefined\"!=typeof window&&window.Math==Math?window:\"undefined\"!=typeof self&&self.Math==Math?self:Function(\"return this\")();\"number\"==typeof __g&&(__g=n)},function(t,e){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,e){t.exports=function(t){return\"object\"==typeof t?null!==t:\"function\"==typeof t}},function(t,e,n){var r=n(78)(\"wks\"),o=n(47),i=n(5).Symbol,a=\"function\"==typeof i,s=t.exports=function(t){return r[t]||(r[t]=a&&i[t]||(a?i:o)(\"Symbol.\"+t))};s.store=r},function(t,e,n){t.exports=!n(6)(function(){return 7!=Object.defineProperty({},\"a\",{get:function(){return 7}}).a})},function(t,e,n){var r=n(4),o=n(146),i=n(28),a=Object.defineProperty;e.f=n(9)?Object.defineProperty:function(t,e,n){if(r(t),e=i(e,!0),r(n),o)try{return a(t,e,n)}catch(t){}if(\"get\"in n||\"set\"in n)throw TypeError(\"Accessors not supported!\");return\"value\"in n&&(t[e]=n.value),t}},function(t,e,n){var r=n(37),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,e,n){var r=n(23);t.exports=function(t){return Object(r(t))}},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e){t.exports=function(t){if(\"function\"!=typeof t)throw TypeError(t+\" is not a function!\");return t}},function(t,e,n){var r=n(10),o=n(36);t.exports=n(9)?function(t,e,n){return r.f(t,e,o(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var r=n(5),o=n(15),i=n(13),a=n(47)(\"src\"),s=\"toString\",u=Function[s],l=(\"\"+u).split(s);n(31).inspectSource=function(t){return u.call(t)},(t.exports=function(t,e,n,s){var u=\"function\"==typeof n;u&&(i(n,\"name\")||o(n,\"name\",e)),t[e]!==n&&(u&&(i(n,a)||o(n,a,t[e]?\"\"+t[e]:l.join(String(e)))),t===r?t[e]=n:s?t[e]?t[e]=n:o(t,e,n):(delete t[e],o(t,e,n)))})(Function.prototype,s,function(){return\"function\"==typeof this&&this[a]||u.call(this)})},function(t,e,n){var r=n(0),o=n(6),i=n(23),a=/\"/g,s=function(t,e,n,r){var o=String(i(t)),s=\"<\"+e;return\"\"!==n&&(s+=\" \"+n+'=\"'+String(r).replace(a,\"&quot;\")+'\"'),s+\">\"+o+\"</\"+e+\">\"};t.exports=function(t,e){var n={};n[t]=e(s),r(r.P+r.F*o(function(){var e=\"\"[t]('\"');return e!==e.toLowerCase()||e.split('\"').length>3}),\"String\",n)}},function(t,e,n){var r=n(59),o=n(23);t.exports=function(t){return r(o(t))}},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(1===t.tensor.shape.length){var e=h.default.sup(t.tensor);h.default.subseq(t.tensor,e),h.default.expeq(t.tensor);var n=h.default.sum(t.tensor);h.default.divseq(t.tensor,n)}else{if(2!==t.tensor.shape.length)throw new Error(\"[activations.softmax] tensor shape \"+t.tensor.shape+\" not supported.\");for(var r=0;r<t.tensor.shape[0];r++){var o=h.default.sup(t.tensor.pick(r,null));h.default.subseq(t.tensor.pick(r,null),o),h.default.expeq(t.tensor.pick(r,null));var i=h.default.sum(t.tensor.pick(r,null));h.default.divseq(t.tensor.pick(r,null),i)}}return this}function i(t){return g(t.tensor),this}function a(t){return y(t.tensor),this}function s(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.alpha,r=void 0===n?0:n,o=e.maxValue,i=void 0===o?null:o,a=void 0;return 0!==r&&(a=new _.default([],t.tensor.shape),h.default.mins(a.tensor,t.tensor,0),h.default.mulseq(a.tensor,r)),h.default.maxseq(t.tensor,0),i&&h.default.minseq(t.tensor,i),a&&h.default.addeq(t.tensor,a.tensor),this}function u(t){return b(t.tensor),this}function l(t){return w(t.tensor),this}function c(t){return x(t.tensor),this}function f(t){return this}Object.defineProperty(e,\"__esModule\",{value:!0}),e.softmax=o,e.softplus=i,e.softsign=a,e.relu=s,e.tanh=u,e.sigmoid=l,e.hardSigmoid=c,e.linear=f;var p=n(3),h=r(p),d=n(25),v=r(d),m=n(2),_=r(m),g=(0,v.default)({args:[\"array\"],body:function(t){t=Math.log(Math.exp(t)+1)}}),y=(0,v.default)({args:[\"array\"],body:function(t){t/=1+Math.abs(t)}}),b=(0,v.default)({args:[\"array\"],body:function(t){t=Math.tanh(t)}}),w=(0,v.default)({args:[\"array\"],body:function(t){t=1/(1+Math.exp(-t))}}),x=(0,v.default)({args:[\"array\"],body:function(t){t=.2*t+.5,t<=0?t=0:t>=1&&(t=1)}})},function(t,e,n){var r=n(60),o=n(36),i=n(18),a=n(28),s=n(13),u=n(146),l=Object.getOwnPropertyDescriptor;e.f=n(9)?l:function(t,e){if(t=i(t),e=a(e,!0),u)try{return l(t,e)}catch(t){}if(s(t,e))return o(!r.f.call(t,e),t[e])}},function(t,e,n){var r=n(13),o=n(12),i=n(108)(\"IE_PROTO\"),a=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:\"function\"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?a:null}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError(\"Can't call method on  \"+t);return t}},function(t,e,n){var r=n(6);t.exports=function(t,e){return!!t&&r(function(){e?t.call(null,function(){},1):t.call(null)})}},function(t,e,n){\"use strict\";function r(t){for(var e in t)a.indexOf(e)<0&&s.indexOf(e)<0&&console.warn(\"cwise: Unknown argument '\"+e+\"' passed to expression compiler\");for(var n=0;n<a.length;++n)if(!t[a[n]])throw new Error(\"cwise: Missing argument: \"+a[n]);return i({args:t.args,pre:o(t.pre||function(){}),body:o(t.body),post:o(t.post||function(){}),debug:!!t.printCode,funcName:t.funcName||t.body.name||\"cwise\",blockSize:t.blockSize||64})}var o=n(450),i=n(166),a=[\"args\",\"body\"],s=[\"pre\",\"post\",\"printCode\",\"funcName\",\"blockSize\"];t.exports=r},function(t,e,n){var r=n(32),o=n(59),i=n(12),a=n(11),s=n(269);t.exports=function(t,e){var n=1==t,u=2==t,l=3==t,c=4==t,f=6==t,p=5==t||f,h=e||s;return function(e,s,d){for(var v,m,_=i(e),g=o(_),y=r(s,d,3),b=a(g.length),w=0,x=n?h(e,b):u?h(e,0):void 0;b>w;w++)if((p||w in g)&&(v=g[w],m=y(v,w,_),t))if(n)x[w]=m;else if(m)switch(t){case 3:return!0;case 5:return v;case 6:return w;case 2:x.push(v)}else if(c)return!1;return f?-1:l||c?c:x}}},function(t,e,n){var r=n(0),o=n(31),i=n(6);t.exports=function(t,e){var n=(o.Object||{})[t]||Object[t],a={};a[t]=e(n),r(r.S+r.F*i(function(){n(1)}),\"Object\",a)}},function(t,e,n){var r=n(7);t.exports=function(t,e){if(!r(t))return t;var n,o;if(e&&\"function\"==typeof(n=t.toString)&&!r(o=n.call(t)))return o;if(\"function\"==typeof(n=t.valueOf)&&!r(o=n.call(t)))return o;if(!e&&\"function\"==typeof(n=t.toString)&&!r(o=n.call(t)))return o;throw TypeError(\"Can't convert object to primitive value\")}},function(t,e,n){var r=n(175),o=\"object\"==typeof self&&self&&self.Object===Object&&self,i=r||o||Function(\"return this\")();t.exports=i},function(t,e){var n=Array.isArray;t.exports=n},function(t,e){var n=t.exports={version:\"2.4.0\"};\"number\"==typeof __e&&(__e=n)},function(t,e,n){var r=n(14);t.exports=function(t,e,n){if(r(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,o){return t.call(e,n,r,o)}}return function(){return t.apply(e,arguments)}}},function(t,e,n){var r=n(162),o=n(0),i=n(78)(\"metadata\"),a=i.store||(i.store=new(n(165))),s=function(t,e,n){var o=a.get(t);if(!o){if(!n)return;a.set(t,o=new r)}var i=o.get(e);if(!i){if(!n)return;o.set(e,i=new r)}return i},u=function(t,e,n){var r=s(e,n,!1);return void 0!==r&&r.has(t)},l=function(t,e,n){var r=s(e,n,!1);return void 0===r?void 0:r.get(t)},c=function(t,e,n,r){s(n,r,!0).set(t,e)},f=function(t,e){var n=s(t,e,!1),r=[];return n&&n.forEach(function(t,e){r.push(e)}),r},p=function(t){return void 0===t||\"symbol\"==typeof t?t:String(t)},h=function(t){o(o.S,\"Reflect\",t)};t.exports={store:a,map:s,has:u,get:l,set:c,keys:f,key:p,exp:h}},function(t,e,n){\"use strict\";if(n(9)){var r=n(40),o=n(5),i=n(6),a=n(0),s=n(79),u=n(115),l=n(32),c=n(39),f=n(36),p=n(15),h=n(44),d=n(37),v=n(11),m=n(46),_=n(28),g=n(13),y=n(159),b=n(58),w=n(7),x=n(12),E=n(100),T=n(41),O=n(21),S=n(42).f,P=n(117),M=n(47),j=n(8),A=n(26),C=n(69),k=n(109),R=n(118),I=n(52),N=n(75),U=n(45),F=n(93),L=n(139),D=n(10),B=n(20),V=D.f,W=B.f,X=o.RangeError,z=o.TypeError,G=o.Uint8Array,q=\"ArrayBuffer\",H=\"Shared\"+q,Y=\"BYTES_PER_ELEMENT\",K=\"prototype\",$=Array[K],Z=u.ArrayBuffer,Q=u.DataView,J=A(0),tt=A(2),et=A(3),nt=A(4),rt=A(5),ot=A(6),it=C(!0),at=C(!1),st=R.values,ut=R.keys,lt=R.entries,ct=$.lastIndexOf,ft=$.reduce,pt=$.reduceRight,ht=$.join,dt=$.sort,vt=$.slice,mt=$.toString,_t=$.toLocaleString,gt=j(\"iterator\"),yt=j(\"toStringTag\"),bt=M(\"typed_constructor\"),wt=M(\"def_constructor\"),xt=s.CONSTR,Et=s.TYPED,Tt=s.VIEW,Ot=\"Wrong length!\",St=A(1,function(t,e){return kt(k(t,t[wt]),e)}),Pt=i(function(){return 1===new G(new Uint16Array([1]).buffer)[0]}),Mt=!!G&&!!G[K].set&&i(function(){new G(1).set({})}),jt=function(t,e){if(void 0===t)throw z(Ot);var n=+t,r=v(t);if(e&&!y(n,r))throw X(Ot);return r},At=function(t,e){var n=d(t);if(n<0||n%e)throw X(\"Wrong offset!\");return n},Ct=function(t){if(w(t)&&Et in t)return t;throw z(t+\" is not a typed array!\")},kt=function(t,e){if(!(w(t)&&bt in t))throw z(\"It is not a typed array constructor!\");return new t(e)},Rt=function(t,e){return It(k(t,t[wt]),e)},It=function(t,e){for(var n=0,r=e.length,o=kt(t,r);r>n;)o[n]=e[n++];return o},Nt=function(t,e,n){V(t,e,{get:function(){return this._d[n]}})},Ut=function(t){var e,n,r,o,i,a,s=x(t),u=arguments.length,c=u>1?arguments[1]:void 0,f=void 0!==c,p=P(s);if(void 0!=p&&!E(p)){for(a=p.call(s),r=[],e=0;!(i=a.next()).done;e++)r.push(i.value);s=r}for(f&&u>2&&(c=l(c,arguments[2],2)),e=0,n=v(s.length),o=kt(this,n);n>e;e++)o[e]=f?c(s[e],e):s[e];return o},Ft=function(){for(var t=0,e=arguments.length,n=kt(this,e);e>t;)n[t]=arguments[t++];return n},Lt=!!G&&i(function(){_t.call(new G(1))}),Dt=function(){return _t.apply(Lt?vt.call(Ct(this)):Ct(this),arguments)},Bt={copyWithin:function(t,e){return L.call(Ct(this),t,e,arguments.length>2?arguments[2]:void 0)},every:function(t){return nt(Ct(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return F.apply(Ct(this),arguments)},filter:function(t){return Rt(this,tt(Ct(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return rt(Ct(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return ot(Ct(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){J(Ct(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return at(Ct(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return it(Ct(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return ht.apply(Ct(this),arguments)},lastIndexOf:function(t){return ct.apply(Ct(this),arguments)},map:function(t){return St(Ct(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return ft.apply(Ct(this),arguments)},reduceRight:function(t){return pt.apply(Ct(this),arguments)},reverse:function(){for(var t,e=this,n=Ct(e).length,r=Math.floor(n/2),o=0;o<r;)t=e[o],e[o++]=e[--n],e[n]=t;return e},some:function(t){return et(Ct(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return dt.call(Ct(this),t)},subarray:function(t,e){var n=Ct(this),r=n.length,o=m(t,r);return new(k(n,n[wt]))(n.buffer,n.byteOffset+o*n.BYTES_PER_ELEMENT,v((void 0===e?r:m(e,r))-o))}},Vt=function(t,e){return Rt(this,vt.call(Ct(this),t,e))},Wt=function(t){Ct(this);var e=At(arguments[1],1),n=this.length,r=x(t),o=v(r.length),i=0;if(o+e>n)throw X(Ot);for(;i<o;)this[e+i]=r[i++]},Xt={entries:function(){return lt.call(Ct(this))},keys:function(){return ut.call(Ct(this))},values:function(){return st.call(Ct(this))}},zt=function(t,e){return w(t)&&t[Et]&&\"symbol\"!=typeof e&&e in t&&String(+e)==String(e)},Gt=function(t,e){return zt(t,e=_(e,!0))?f(2,t[e]):W(t,e)},qt=function(t,e,n){return!(zt(t,e=_(e,!0))&&w(n)&&g(n,\"value\"))||g(n,\"get\")||g(n,\"set\")||n.configurable||g(n,\"writable\")&&!n.writable||g(n,\"enumerable\")&&!n.enumerable?V(t,e,n):(t[e]=n.value,t)};xt||(B.f=Gt,D.f=qt),a(a.S+a.F*!xt,\"Object\",{getOwnPropertyDescriptor:Gt,defineProperty:qt}),i(function(){mt.call({})})&&(mt=_t=function(){return ht.call(this)});var Ht=h({},Bt);h(Ht,Xt),p(Ht,gt,Xt.values),h(Ht,{slice:Vt,set:Wt,constructor:function(){},toString:mt,toLocaleString:Dt}),Nt(Ht,\"buffer\",\"b\"),Nt(Ht,\"byteOffset\",\"o\"),Nt(Ht,\"byteLength\",\"l\"),Nt(Ht,\"length\",\"e\"),V(Ht,yt,{get:function(){return this[Et]}}),t.exports=function(t,e,n,u){u=!!u;var l=t+(u?\"Clamped\":\"\")+\"Array\",f=\"Uint8Array\"!=l,h=\"get\"+t,d=\"set\"+t,m=o[l],_=m||{},g=m&&O(m),y=!m||!s.ABV,x={},E=m&&m[K],P=function(t,n){var r=t._d;return r.v[h](n*e+r.o,Pt)},M=function(t,n,r){var o=t._d;u&&(r=(r=Math.round(r))<0?0:r>255?255:255&r),o.v[d](n*e+o.o,r,Pt)},j=function(t,e){V(t,e,{get:function(){return P(this,e)},set:function(t){return M(this,e,t)},enumerable:!0})};y?(m=n(function(t,n,r,o){c(t,m,l,\"_d\");var i,a,s,u,f=0,h=0;if(w(n)){if(!(n instanceof Z||(u=b(n))==q||u==H))return Et in n?It(m,n):Ut.call(m,n);i=n,h=At(r,e);var d=n.byteLength;if(void 0===o){if(d%e)throw X(Ot);if(a=d-h,a<0)throw X(Ot)}else if(a=v(o)*e,a+h>d)throw X(Ot);s=a/e}else s=jt(n,!0),a=s*e,i=new Z(a);for(p(t,\"_d\",{b:i,o:h,l:a,e:s,v:new Q(i)});f<s;)j(t,f++)}),E=m[K]=T(Ht),p(E,\"constructor\",m)):N(function(t){new m(null),new m(t)},!0)||(m=n(function(t,n,r,o){c(t,m,l);var i;return w(n)?n instanceof Z||(i=b(n))==q||i==H?void 0!==o?new _(n,At(r,e),o):void 0!==r?new _(n,At(r,e)):new _(n):Et in n?It(m,n):Ut.call(m,n):new _(jt(n,f))}),J(g!==Function.prototype?S(_).concat(S(g)):S(_),function(t){t in m||p(m,t,_[t])}),m[K]=E,r||(E.constructor=m));var A=E[gt],C=!!A&&(\"values\"==A.name||void 0==A.name),k=Xt.values;p(m,bt,!0),p(E,Et,l),p(E,Tt,!0),p(E,wt,m),(u?new m(1)[yt]==l:yt in E)||V(E,yt,{get:function(){return l}}),x[l]=m,a(a.G+a.W+a.F*(m!=_),x),a(a.S,l,{BYTES_PER_ELEMENT:e,from:Ut,of:Ft}),Y in E||p(E,Y,e),a(a.P,l,Bt),U(l),a(a.P+a.F*Mt,l,{set:Wt}),a(a.P+a.F*!C,l,Xt),a(a.P+a.F*(E.toString!=mt),l,{toString:mt}),a(a.P+a.F*i(function(){new m(1).slice()}),l,{slice:Vt}),a(a.P+a.F*(i(function(){return[1,2].toLocaleString()!=new m([1,2]).toLocaleString()})||!i(function(){E.toLocaleString.call([1,2])})),l,{toLocaleString:Dt}),I[l]=C?A:k,r||C||p(E,gt,k)}}else t.exports=function(){}},function(t,e,n){var r=n(47)(\"meta\"),o=n(7),i=n(13),a=n(10).f,s=0,u=Object.isExtensible||function(){return!0},l=!n(6)(function(){return u(Object.preventExtensions({}))}),c=function(t){a(t,r,{value:{i:\"O\"+ ++s,w:{}}})},f=function(t,e){if(!o(t))return\"symbol\"==typeof t?t:(\"string\"==typeof t?\"S\":\"P\")+t;if(!i(t,r)){if(!u(t))return\"F\";if(!e)return\"E\";c(t)}return t[r].i},p=function(t,e){if(!i(t,r)){if(!u(t))return!0;if(!e)return!1;c(t)}return t[r].w},h=function(t){return l&&d.NEED&&u(t)&&!i(t,r)&&c(t),t},d=t.exports={KEY:r,NEED:!1,fastKey:f,getWeak:p,onFreeze:h}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e){var n=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:n)(t)}},function(t,e){var n;n=function(){return this}();try{n=n||Function(\"return this\")()||(0,eval)(\"this\")}catch(t){\"object\"==typeof window&&(n=window)}t.exports=n},function(t,e){t.exports=function(t,e,n,r){if(!(t instanceof e)||void 0!==r&&r in t)throw TypeError(n+\": incorrect invocation!\");return t}},function(t,e){t.exports=!1},function(t,e,n){var r=n(4),o=n(152),i=n(96),a=n(108)(\"IE_PROTO\"),s=function(){},u=\"prototype\",l=function(){var t,e=n(95)(\"iframe\"),r=i.length,o=\"<\",a=\">\";for(e.style.display=\"none\",n(98).appendChild(e),e.src=\"javascript:\",t=e.contentWindow.document,t.open(),t.write(o+\"script\"+a+\"document.F=Object\"+o+\"/script\"+a),t.close(),l=t.F;r--;)delete l[u][i[r]];return l()};t.exports=Object.create||function(t,e){var n;return null!==t?(s[u]=r(t),n=new s,s[u]=null,n[a]=t):n=l(),void 0===e?n:o(n,e)}},function(t,e,n){var r=n(154),o=n(96).concat(\"length\",\"prototype\");e.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,e,n){var r=n(154),o=n(96);t.exports=Object.keys||function(t){return r(t,o)}},function(t,e,n){var r=n(16);t.exports=function(t,e,n){for(var o in e)r(t,o,e[o],n);return t}},function(t,e,n){\"use strict\";var r=n(5),o=n(10),i=n(9),a=n(8)(\"species\");t.exports=function(t){var e=r[t];i&&e&&!e[a]&&o.f(e,a,{configurable:!0,get:function(){return this}})}},function(t,e,n){var r=n(37),o=Math.max,i=Math.min;t.exports=function(t,e){return t=r(t),t<0?o(t+e,0):i(t,e)}},function(t,e){var n=0,r=Math.random();t.exports=function(t){return\"Symbol(\".concat(void 0===t?\"\":t,\")_\",(++n+r).toString(36))}},function(t,e,n){function r(t,e){var n=i(t,e);return o(n)?n:void 0}var o=n(480),i=n(518);t.exports=r},function(t,e,n){function r(t){return a(t)?o(t):i(t)}var o=n(465),i=n(482),a=n(88);t.exports=r},function(t,e,n){var r=n(8)(\"unscopables\"),o=Array.prototype;void 0==o[r]&&n(15)(o,r,{}),t.exports=function(t){\no[r][t]=!0}},function(t,e,n){var r=n(32),o=n(148),i=n(100),a=n(4),s=n(11),u=n(117),l={},c={},e=t.exports=function(t,e,n,f,p){var h,d,v,m,_=p?function(){return t}:u(t),g=r(n,f,e?2:1),y=0;if(\"function\"!=typeof _)throw TypeError(t+\" is not iterable!\");if(i(_)){for(h=s(t.length);h>y;y++)if(m=e?g(a(d=t[y])[0],d[1]):g(t[y]),m===l||m===c)return m}else for(v=_.call(t);!(d=v.next()).done;)if(m=o(v,g,d.value,e),m===l||m===c)return m};e.BREAK=l,e.RETURN=c},function(t,e){t.exports={}},function(t,e,n){var r=n(10).f,o=n(13),i=n(8)(\"toStringTag\");t.exports=function(t,e,n){t&&!o(t=n?t:t.prototype,i)&&r(t,i,{configurable:!0,value:e})}},function(t,e,n){var r=n(0),o=n(23),i=n(6),a=n(113),s=\"[\"+a+\"]\",u=\"​\",l=RegExp(\"^\"+s+s+\"*\"),c=RegExp(s+s+\"*$\"),f=function(t,e,n){var o={},s=i(function(){return!!a[t]()||u[t]()!=u}),l=o[t]=s?e(p):a[t];n&&(o[n]=l),r(r.P+r.F*s,\"String\",o)},p=f.trim=function(t,e){return t=String(o(t)),1&e&&(t=t.replace(l,\"\")),2&e&&(t=t.replace(c,\"\")),t};t.exports=f},function(t,e){function n(t){var e=typeof t;return null!=t&&(\"object\"==e||\"function\"==e)}t.exports=n},function(t,e,n){\"use strict\";t.exports.gemv=n(594),t.exports.gbmv=n(593),t.exports.symv=n(600),t.exports.sbmv=n(596),t.exports.spmv=n(597),t.exports.trmv=n(606),t.exports.tbmv=n(603),t.exports.trsv=n(607),t.exports.tbsv=n(604),t.exports.tpsv=n(605),t.exports.ger=n(595),t.exports.syr=n(601),t.exports.spr=n(598),t.exports.syr2=n(602),t.exports.spr2=n(599),t.exports.trmv_lower=function(e,n){return console.warn(\"trmv_lower is deprecated. Please use the 'isLower' flag with trmv.\"),t.exports.trmv(e,n,!0)},t.exports.trsv_lower=function(e,n){return console.warn(\"trsv_lower is deprecated. Please use the 'isLower' flag with trsv.\"),t.exports.trsv(e,n,!0)}},function(t,e,n){\"use strict\";function r(t,e){switch(t){case\"Convolution2D\":return[\"linear\",\"relu\"].indexOf(e.activation)>-1;case\"BatchNormalization\":return 0===e.mode;case\"MaxPooling2D\":case\"AveragePooling2D\":return!0;case\"Merge\":return[\"concat\",\"sum\",\"mul\",\"ave\",\"max\"].indexOf(e.mode)>-1;default:return!1}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.default=r},function(t,e,n){var r=n(22),o=n(8)(\"toStringTag\"),i=\"Arguments\"==r(function(){return arguments}()),a=function(t,e){try{return t[e]}catch(t){}};t.exports=function(t){var e,n,s;return void 0===t?\"Undefined\":null===t?\"Null\":\"string\"==typeof(n=a(e=Object(t),o))?n:i?r(e):\"Object\"==(s=r(e))&&\"function\"==typeof e.callee?\"Arguments\":s}},function(t,e,n){var r=n(22);t.exports=Object(\"z\").propertyIsEnumerable(0)?Object:function(t){return\"String\"==r(t)?t.split(\"\"):Object(t)}},function(t,e){e.f={}.propertyIsEnumerable},function(t,e,n){var r=n(29),o=r.Symbol;t.exports=o},function(t,e,n){function r(t){return null==t?void 0===t?u:s:l&&l in Object(t)?i(t):a(t)}var o=n(61),i=n(516),a=n(543),s=\"[object Null]\",u=\"[object Undefined]\",l=o?o.toStringTag:void 0;t.exports=r},function(t,e,n){function r(t){if(\"string\"==typeof t||o(t))return t;var e=t+\"\";return\"0\"==e&&1/t==-i?\"-0\":e}var o=n(89),i=1/0;t.exports=r},function(t,e){function n(t){return null!=t&&\"object\"==typeof t}t.exports=n},function(t,e,n){function r(t){return null==t?\"\":o(t)}var o=n(497);t.exports=r},function(t,e,n){\"use strict\";function r(t){return Array.isArray(t)?[t.length,t[0].length]:t.shape}function o(t,e,n){var o=r(t),i=r(e),a=r(n);if(o[0]!==i[0]||o[1]!==a[1]||i[1]!==a[0])throw new Error(\"Mismatched array shapes for matrix product\")}function i(t){if(Array.isArray(t)){if(Array.isArray(t))return[\"r\",\"native\"]}else if(t.shape&&2===t.shape.length)return t.order[0]?[\"r\",t.dtype]:[\"c\",t.dtype];throw new Error(\"Unrecognized data type\")}function a(t,e,n,r,a){void 0===r&&(r=1),void 0===a&&(a=0);var l=1!==r,c=0!==a,f=i(t),p=i(e),h=i(n);o(t,e,n);var d=[f,p,h,l,c].join(\":\"),v=u[d];return v||(v=u[d]=s(f,p,h,l,c)),v(t,e,n,r,a)}t.exports=a;var s=n(609),u={}},function(t,e,n){\"use strict\";function r(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var o=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),i=function(){function t(){r(this,t),this.MAX_NUM_TEXTURES=8,this.webgl=weblas.gpu.gl,this.numTextures=8}return o(t,[{key:\"_bindInputTexture\",value:function(t,e,n,r){var o=this.webgl.context;o.activeTexture(n),o.bindTexture(o.TEXTURE_2D,e);var i=o.getUniformLocation(t,r);o.uniform1i(i,n-o.TEXTURE0)}},{key:\"_compute\",value:function(){var t=this.webgl.context;t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)}},{key:\"_unbindInputTextures\",value:function(){for(var t=this.webgl.context,e=0;e<this.numTextures;e++)this.webgl.unbindInputTexture(t.TEXTURE0+e)}}]),t}();e.default=i},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if(\"value\"in o)return o.value;var a=o.get;if(void 0!==a)return a.call(r)},f=n(19),p=o(f),h=n(2),d=r(h),v=n(1),m=r(v),_=n(3),g=r(_),y=n(66),b=r(y),w=n(57),x=r(w),E=n(198),T=r(E),O=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Convolution2D\";var r=t.nbFilter,o=void 0===r?1:r,s=t.nbRow,u=void 0===s?3:s,l=t.nbCol,c=void 0===l?3:l,f=t.activation,h=void 0===f?\"linear\":f,d=t.borderMode,v=void 0===d?\"valid\":d,m=t.subsample,_=void 0===m?[1,1]:m,g=t.dimOrdering,y=void 0===g?\"tf\":g,b=t.bias,w=void 0===b||b;if(n.kernelShape=[o,u,c],n.activation=h,n.activationFunc=p[h],\"valid\"!==v&&\"same\"!==v)throw new Error(n.name+\" [Convolution2D layer] Invalid borderMode.\");if(n.borderMode=v,n.subsample=_,\"tf\"!==y&&\"th\"!==y)throw new Error(n.name+\" [Convolution2D layer] Only tf and th dim ordering are allowed.\");if(n.dimOrdering=y,n.bias=w,n.params=n.bias?[\"W\",\"b\"]:[\"W\"],n.gpu&&weblas&&(n._useWeblas=!0,n.pipeline)){var E=(0,x.default)(n.layerClass,t);E?(n._pipelineEnabled=!0,n.webglConv2D=new T.default):n._pipelineEnabled=!1}return n}return s(e,t),l(e,[{key:\"setWeights\",value:function(t){\"th\"===this.dimOrdering&&(t[0].tensor=t[0].tensor.transpose(2,3,1,0)),c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"setWeights\",this).call(this,t),this._w2row(),this._useWeblas&&(this._wRowsMat.createWeblasTensor(),this._wRowsMat._gpuMaxSizeExceeded||(this._wRowsMat.weblasTensor=this._wRowsMat.weblasTensor.transpose()),this.bias?this.weights.b.createWeblasTensor():(this._zerosVec=new d.default([],[this.weights.W.tensor.shape[3]]),this._zerosVec.createWeblasTensor()))}},{key:\"_calcOutputShape\",value:function(t){var e=t[0],n=t[1],r=u(this.kernelShape,3),o=r[0],i=r[1],a=r[2],s=\"same\"===this.borderMode?Math.floor((e+this.subsample[0]-1)/this.subsample[0]):Math.floor((e-i+this.subsample[0])/this.subsample[0]),l=\"same\"===this.borderMode?Math.floor((n+this.subsample[1]-1)/this.subsample[1]):Math.floor((n-a+this.subsample[1])/this.subsample[1]),c=o,f=\"same\"===this.borderMode?Math.max(0,Math.floor((s-1)*this.subsample[0]+i-e)):0,p=\"same\"===this.borderMode?Math.max(0,Math.floor((l-1)*this.subsample[1]+a-n)):0,h=Math.floor(f/2),d=f-h,v=Math.floor(p/2),m=p-v;this.outputShape=[s,l,c],this.inputPadding=[h,d,v,m]}},{key:\"_padInput\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(\"same\"===this.borderMode){var n=u(t.tensor.shape,3),r=n[0],o=n[1],i=n[2],a=u(this.inputPadding,4),s=a[0],l=a[1],c=a[2],f=a[3],p=r+s+l,h=o+c+f,v=new d.default([],[p,h,i]);0!==e&&g.default.assigns(v.tensor,e),g.default.assign(v.tensor.hi(r+s,o+c,i).lo(s,c,0),t.tensor),t.tensor=v.tensor}return t}},{key:\"_im2col\",value:function(t){var e=u(t.tensor.shape,3),n=e[0],r=e[1],o=e[2],i=this.kernelShape[1],a=this.kernelShape[2],s=this.outputShape[0],l=this.outputShape[1],c=s*l,f=i*a*o;if(this._imColsMat||(this._imColsMat=new d.default([],[c,f])),1===i&&1===a&&1===this.subsample[0]&&1===this.subsample[1])return this._imColsMat.replaceTensorData(t.tensor.data),this._useWeblas&&this._imColsMat.createWeblasTensor(),this._imColsMat;for(var p=new d.default([],[i,a,o]),h=0,v=0,m=n-i;v<=m;v+=this.subsample[0])for(var _=0,y=r-a;_<=y;_+=this.subsample[1])g.default.assign(p.tensor,t.tensor.hi(v+i,_+a,o).lo(v,_,0)),this._imColsMat.tensor.data.set(p.tensor.data,h),h+=f;return this._useWeblas&&this._imColsMat.createWeblasTensor(),this._imColsMat}},{key:\"_w2row\",value:function(){var t=this.weights.W.tensor.shape[2],e=u(this.kernelShape,3),n=e[0],r=e[1],o=e[2],i=r*o*t;this._wRowsMat=new d.default([],[i,n]);for(var a=new d.default([],[r,o,t]),s=new d.default([],[i]),l=0;l<n;l++)g.default.assign(a.tensor,this.weights.W.tensor.pick(null,null,null,l)),s.replaceTensorData(a.tensor.data),g.default.assign(this._wRowsMat.tensor.pick(null,l),s.tensor);return this._wRowsMat}},{key:\"_tiledIndexMapping\",value:function(t){if(!this._tiledIndexMappingRow||!this._tiledIndexMappingCol){for(var e=u(t,3),n=e[0],r=e[1],o=e[2],i=new d.default([],t),a=new d.default([],t),s=0;s<n;s++)for(var l=0;l<r;l++)g.default.assigns(i.tensor.pick(s,l,null),s*r+l);for(var c=0;c<o;c++)g.default.assigns(a.tensor.pick(null,null,c),c);if(\"same\"===this.borderMode){var f=u(this.inputPadding,4),p=f[0],h=f[1],v=f[2],m=f[3];n=n+p+h,r=r+v+m;var _=-1;this._padInput(i,_),this._padInput(a,_)}var y=this.kernelShape[1],b=this.kernelShape[2],w=this.outputShape[0],x=this.outputShape[1],E=w*x,T=y*b*o;this._tiledIndexMappingRow=new d.default([],[E,T]),this._tiledIndexMappingCol=new d.default([],[E,T]);for(var O=new d.default([],[y,b,o]),S=new d.default([],[y,b,o]),P=0,M=0,j=n-y;M<=j;M+=this.subsample[0])for(var A=0,C=r-b;A<=C;A+=this.subsample[1])g.default.assign(O.tensor,i.tensor.hi(M+y,A+b,o).lo(M,A,0)),g.default.assign(S.tensor,a.tensor.hi(M+y,A+b,o).lo(M,A,0)),this._tiledIndexMappingRow.tensor.data.set(O.tensor.data,P),this._tiledIndexMappingCol.tensor.data.set(S.tensor.data,P),P+=T;this._tiledIndexMappingRow.createWeblasTensor(),this._tiledIndexMappingCol.createWeblasTensor()}}},{key:\"_callPipelineMode\",value:function(t){if(!t.weblasTensor)throw new Error(\"Variable passed in does not contain weblas tensor.\");this._tiledIndexMapping(this.inputShape);var e=this.bias?this.weights.b.weblasTensor:this._zerosVec.weblasTensor;return t.weblasTensor=this.webglConv2D.call(t.weblasTensor,this._wRowsMat.weblasTensor,e,this.activation,t._fromPipeline?this._tiledIndexMappingRow.weblasTensor:null,t._fromPipeline?this._tiledIndexMappingCol.weblasTensor:null),t._fromPipeline=!0,t._actualShape=this.outputShape,t}},{key:\"_callRegularMode\",value:function(t){if(!t.tensor)throw new Error(\"Variable passed in does not contain tensor.\");\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0));var e=this.kernelShape[0],n=this.outputShape[0],r=this.outputShape[1],o=n*r,i=new d.default([],[o,e]);if(!this._useWeblas||this._imColsMat._gpuMaxSizeExceeded||this._wRowsMat._gpuMaxSizeExceeded){if(this.bias)for(var a=0;a<e;a++)g.default.assigns(i.tensor.pick(null,a),this.weights.b.tensor.get(a));(0,b.default)(i.tensor,this._imColsMat.tensor,this._wRowsMat.tensor,1,1)}else{var s=this.bias?this.weights.b.weblasTensor:this._zerosVec.weblasTensor;i.tensor.data=weblas.pipeline.sgemm(1,this._imColsMat.weblasTensor,this._wRowsMat.weblasTensor,1,s).transfer()}for(var u=new d.default([],this.outputShape),l=new d.default([],[n*r]),c=new d.default([],[n,r]),f=0;f<e;f++)g.default.assign(l.tensor,i.tensor.pick(null,f)),c.replaceTensorData(l.tensor.data),g.default.assign(u.tensor.pick(null,null,f),c.tensor);return t.tensor=u.tensor,this.activationFunc(t),\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(2,0,1)),t}},{key:\"call\",value:function(t){if(t._fromPipeline?this.inputShape=t._actualShape:this.inputShape=t.tensor.shape,this._calcOutputShape(this.inputShape),this._pipelineEnabled){if(!t._fromPipeline){if(this._padInput(t),this._im2col(t),this._imColsMat._gpuMaxSizeExceeded)return this._callRegularMode(t);t.weblasTensor=this._imColsMat.weblasTensor}return this._callPipelineMode(t)}return this._padInput(t),this._im2col(t),this._callRegularMode(t)}}]),e}(m.default);e.default=O},function(t,e,n){var r=n(18),o=n(11),i=n(46);t.exports=function(t){return function(e,n,a){var s,u=r(e),l=o(u.length),c=i(a,l);if(t&&n!=n){for(;l>c;)if(s=u[c++],s!=s)return!0}else for(;l>c;c++)if((t||c in u)&&u[c]===n)return t||c||0;return!t&&-1}}},function(t,e,n){\"use strict\";var r=n(5),o=n(0),i=n(16),a=n(44),s=n(35),u=n(51),l=n(39),c=n(7),f=n(6),p=n(75),h=n(53),d=n(99);t.exports=function(t,e,n,v,m,_){var g=r[t],y=g,b=m?\"set\":\"add\",w=y&&y.prototype,x={},E=function(t){var e=w[t];i(w,t,\"delete\"==t?function(t){return!(_&&!c(t))&&e.call(this,0===t?0:t)}:\"has\"==t?function(t){return!(_&&!c(t))&&e.call(this,0===t?0:t)}:\"get\"==t?function(t){return _&&!c(t)?void 0:e.call(this,0===t?0:t)}:\"add\"==t?function(t){return e.call(this,0===t?0:t),this}:function(t,n){return e.call(this,0===t?0:t,n),this})};if(\"function\"==typeof y&&(_||w.forEach&&!f(function(){(new y).entries().next()}))){var T=new y,O=T[b](_?{}:-0,1)!=T,S=f(function(){T.has(1)}),P=p(function(t){new y(t)}),M=!_&&f(function(){for(var t=new y,e=5;e--;)t[b](e,e);return!t.has(-0)});P||(y=e(function(e,n){l(e,y,t);var r=d(new g,e,y);return void 0!=n&&u(n,m,r[b],r),r}),y.prototype=w,w.constructor=y),(S||M)&&(E(\"delete\"),E(\"has\"),m&&E(\"get\")),(M||O)&&E(b),_&&w.clear&&delete w.clear}else y=v.getConstructor(e,t,m,b),a(y.prototype,n),s.NEED=!0;return h(y,t),x[t]=y,o(o.G+o.W+o.F*(y!=g),x),_||v.setStrong(y,t,m),y}},function(t,e,n){\"use strict\";var r=n(15),o=n(16),i=n(6),a=n(23),s=n(8);t.exports=function(t,e,n){var u=s(t),l=n(a,u,\"\"[t]),c=l[0],f=l[1];i(function(){var e={};return e[u]=function(){return 7},7!=\"\"[t](e)})&&(o(String.prototype,t,c),r(RegExp.prototype,u,2==e?function(t,e){return f.call(t,this,e)}:function(t){return f.call(t,this)}))}},function(t,e,n){\"use strict\";var r=n(4);t.exports=function(){var t=r(this),e=\"\";return t.global&&(e+=\"g\"),t.ignoreCase&&(e+=\"i\"),t.multiline&&(e+=\"m\"),t.unicode&&(e+=\"u\"),t.sticky&&(e+=\"y\"),e}},function(t,e){t.exports=function(t,e,n){var r=void 0===n;switch(e.length){case 0:return r?t():t.call(n);case 1:return r?t(e[0]):t.call(n,e[0]);case 2:return r?t(e[0],e[1]):t.call(n,e[0],e[1]);case 3:return r?t(e[0],e[1],e[2]):t.call(n,e[0],e[1],e[2]);case 4:return r?t(e[0],e[1],e[2],e[3]):t.call(n,e[0],e[1],e[2],e[3])}return t.apply(n,e)}},function(t,e,n){var r=n(7),o=n(22),i=n(8)(\"match\");t.exports=function(t){var e;return r(t)&&(void 0!==(e=t[i])?!!e:\"RegExp\"==o(t))}},function(t,e,n){var r=n(8)(\"iterator\"),o=!1;try{var i=[7][r]();i.return=function(){o=!0},Array.from(i,function(){throw 2})}catch(t){}t.exports=function(t,e){if(!e&&!o)return!1;var n=!1;try{var i=[7],a=i[r]();a.next=function(){return{done:n=!0}},i[r]=function(){return a},t(i)}catch(t){}return n}},function(t,e,n){t.exports=n(40)||!n(6)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete n(5)[t]})},function(t,e){e.f=Object.getOwnPropertySymbols},function(t,e,n){var r=n(5),o=\"__core-js_shared__\",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,e,n){for(var r,o=n(5),i=n(15),a=n(47),s=a(\"typed_array\"),u=a(\"view\"),l=!(!o.ArrayBuffer||!o.DataView),c=l,f=0,p=9,h=\"Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array\".split(\",\");f<p;)(r=o[h[f++]])?(i(r.prototype,s,!0),i(r.prototype,u,!0)):c=!1;t.exports={ABV:l,CONSTR:c,TYPED:s,VIEW:u}},function(t,e,n){function r(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}var o=n(530),i=n(531),a=n(532),s=n(533),u=n(534);r.prototype.clear=o,r.prototype.delete=i,r.prototype.get=a,r.prototype.has=s,r.prototype.set=u,t.exports=r},function(t,e,n){function r(t,e){for(var n=t.length;n--;)if(o(t[n][0],e))return n;return-1}var o=n(87);t.exports=r},function(t,e,n){function r(t){return\"function\"==typeof t?t:null==t?a:\"object\"==typeof t?s(t)?i(t[0],t[1]):o(t):u(t)}var o=n(483),i=n(484),a=n(125),s=n(30),u=n(574);t.exports=r},function(t,e,n){function r(t,e){return o(t)?t:i(t,e)?[t]:a(s(t))}var o=n(30),i=n(124),a=n(558),s=n(65);t.exports=r},function(t,e,n){function r(t,e){var n=t.__data__;return o(e)?n[\"string\"==typeof e?\"string\":\"hash\"]:n.map}var o=n(527);t.exports=r},function(t,e){function n(t,e){return e=null==e?r:e,!!e&&(\"number\"==typeof t||o.test(t))&&t>-1&&t%1==0&&t<e}var r=9007199254740991,o=/^(?:0|[1-9]\\d*)$/;t.exports=n},function(t,e,n){var r=n(48),o=r(Object,\"create\");t.exports=o},function(t,e){function n(t,e){return t===e||t!==t&&e!==e}t.exports=n},function(t,e,n){function r(t){return null!=t&&i(t.length)&&!o(t)}var o=n(186),i=n(128);t.exports=r},function(t,e,n){function r(t){return\"symbol\"==typeof t||i(t)&&o(t)==a}var o=n(62),i=n(64),a=\"[object Symbol]\";t.exports=r},function(t,e,n){\"use strict\";t.exports.swap=n(592),t.exports.scal=n(591),t.exports.copy=n(585),t.exports.axpy=n(584),t.exports.dot=n(587),t.exports.cpsc=n(586),t.exports.nrm2=n(589),t.exports.asum=n(583),t.exports.iamax=n(588),t.exports.rotg=n(590)},function(t,e,n){function r(t,e){return t[0]-e[0]}function o(){var t,e=this.stride,n=new Array(e.length);for(t=0;t<n.length;++t)n[t]=[Math.abs(e[t]),t];n.sort(r);var o=new Array(n.length);for(t=0;t<o.length;++t)o[t]=n[t][1];return o}function i(t,e){var n=[\"View\",e,\"d\",t].join(\"\");e<0&&(n=\"View_Nil\"+t);var r=\"generic\"===t;if(e===-1){var i=\"function \"+n+\"(a){this.data=a;};var proto=\"+n+\".prototype;proto.dtype='\"+t+\"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new \"+n+\"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_\"+n+\"(a){return new \"+n+\"(a);}\",a=new Function(i);return a()}if(0===e){var i=\"function \"+n+\"(a,d) {this.data = a;this.offset = d};var proto=\"+n+\".prototype;proto.dtype='\"+t+\"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function \"+n+\"_copy() {return new \"+n+\"(this.data,this.offset)};proto.pick=function \"+n+\"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function \"+n+\"_get(){return \"+(r?\"this.data.get(this.offset)\":\"this.data[this.offset]\")+\"};proto.set=function \"+n+\"_set(v){return \"+(r?\"this.data.set(this.offset,v)\":\"this.data[this.offset]=v\")+\"};return function construct_\"+n+\"(a,b,c,d){return new \"+n+\"(a,d)}\",a=new Function(\"TrivialArray\",i);return a(f[t][0])}var i=[\"'use strict'\"],s=u(e),l=s.map(function(t){return\"i\"+t}),c=\"this.offset+\"+s.map(function(t){return\"this.stride[\"+t+\"]*i\"+t}).join(\"+\"),p=s.map(function(t){return\"b\"+t}).join(\",\"),h=s.map(function(t){return\"c\"+t}).join(\",\");i.push(\"function \"+n+\"(a,\"+p+\",\"+h+\",d){this.data=a\",\"this.shape=[\"+p+\"]\",\"this.stride=[\"+h+\"]\",\"this.offset=d|0}\",\"var proto=\"+n+\".prototype\",\"proto.dtype='\"+t+\"'\",\"proto.dimension=\"+e),i.push(\"Object.defineProperty(proto,'size',{get:function \"+n+\"_size(){return \"+s.map(function(t){return\"this.shape[\"+t+\"]\"}).join(\"*\"),\"}})\"),1===e?i.push(\"proto.order=[0]\"):(i.push(\"Object.defineProperty(proto,'order',{get:\"),e<4?(i.push(\"function \"+n+\"_order(){\"),2===e?i.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\"):3===e&&i.push(\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})\")):i.push(\"ORDER})\")),i.push(\"proto.set=function \"+n+\"_set(\"+l.join(\",\")+\",v){\"),r?i.push(\"return this.data.set(\"+c+\",v)}\"):i.push(\"return this.data[\"+c+\"]=v}\"),i.push(\"proto.get=function \"+n+\"_get(\"+l.join(\",\")+\"){\"),r?i.push(\"return this.data.get(\"+c+\")}\"):i.push(\"return this.data[\"+c+\"]}\"),i.push(\"proto.index=function \"+n+\"_index(\",l.join(),\"){return \"+c+\"}\"),i.push(\"proto.hi=function \"+n+\"_hi(\"+l.join(\",\")+\"){return new \"+n+\"(this.data,\"+s.map(function(t){return[\"(typeof i\",t,\"!=='number'||i\",t,\"<0)?this.shape[\",t,\"]:i\",t,\"|0\"].join(\"\")}).join(\",\")+\",\"+s.map(function(t){return\"this.stride[\"+t+\"]\"}).join(\",\")+\",this.offset)}\");var d=s.map(function(t){return\"a\"+t+\"=this.shape[\"+t+\"]\"}),v=s.map(function(t){return\"c\"+t+\"=this.stride[\"+t+\"]\"});i.push(\"proto.lo=function \"+n+\"_lo(\"+l.join(\",\")+\"){var b=this.offset,d=0,\"+d.join(\",\")+\",\"+v.join(\",\"));for(var m=0;m<e;++m)i.push(\"if(typeof i\"+m+\"==='number'&&i\"+m+\">=0){d=i\"+m+\"|0;b+=c\"+m+\"*d;a\"+m+\"-=d}\");i.push(\"return new \"+n+\"(this.data,\"+s.map(function(t){return\"a\"+t}).join(\",\")+\",\"+s.map(function(t){return\"c\"+t}).join(\",\")+\",b)}\"),i.push(\"proto.step=function \"+n+\"_step(\"+l.join(\",\")+\"){var \"+s.map(function(t){return\"a\"+t+\"=this.shape[\"+t+\"]\"}).join(\",\")+\",\"+s.map(function(t){return\"b\"+t+\"=this.stride[\"+t+\"]\"}).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\");for(var m=0;m<e;++m)i.push(\"if(typeof i\"+m+\"==='number'){d=i\"+m+\"|0;if(d<0){c+=b\"+m+\"*(a\"+m+\"-1);a\"+m+\"=ceil(-a\"+m+\"/d)}else{a\"+m+\"=ceil(a\"+m+\"/d)}b\"+m+\"*=d}\");i.push(\"return new \"+n+\"(this.data,\"+s.map(function(t){return\"a\"+t}).join(\",\")+\",\"+s.map(function(t){return\"b\"+t}).join(\",\")+\",c)}\");for(var _=new Array(e),g=new Array(e),m=0;m<e;++m)_[m]=\"a[i\"+m+\"]\",g[m]=\"b[i\"+m+\"]\";i.push(\"proto.transpose=function \"+n+\"_transpose(\"+l+\"){\"+l.map(function(t,e){return t+\"=(\"+t+\"===undefined?\"+e+\":\"+t+\"|0)\"}).join(\";\"),\"var a=this.shape,b=this.stride;return new \"+n+\"(this.data,\"+_.join(\",\")+\",\"+g.join(\",\")+\",this.offset)}\"),i.push(\"proto.pick=function \"+n+\"_pick(\"+l+\"){var a=[],b=[],c=this.offset\");for(var m=0;m<e;++m)i.push(\"if(typeof i\"+m+\"==='number'&&i\"+m+\">=0){c=(c+this.stride[\"+m+\"]*i\"+m+\")|0}else{a.push(this.shape[\"+m+\"]);b.push(this.stride[\"+m+\"])}\");i.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\"),i.push(\"return function construct_\"+n+\"(data,shape,stride,offset){return new \"+n+\"(data,\"+s.map(function(t){return\"shape[\"+t+\"]\"}).join(\",\")+\",\"+s.map(function(t){return\"stride[\"+t+\"]\"}).join(\",\")+\",offset)}\");var a=new Function(\"CTOR_LIST\",\"ORDER\",i.join(\"\\n\"));return a(f[t],o)}function a(t){if(l(t))return\"buffer\";if(c)switch(Object.prototype.toString.call(t)){case\"[object Float64Array]\":return\"float64\";case\"[object Float32Array]\":return\"float32\";case\"[object Int8Array]\":return\"int8\";case\"[object Int16Array]\":return\"int16\";case\"[object Int32Array]\":return\"int32\";case\"[object Uint8Array]\":return\"uint8\";case\"[object Uint16Array]\":return\"uint16\";case\"[object Uint32Array]\":return\"uint32\";case\"[object Uint8ClampedArray]\":return\"uint8_clamped\"}return Array.isArray(t)?\"array\":\"generic\"}function s(t,e,n,r){if(void 0===t){var o=f.array[0];return o([])}\"number\"==typeof t&&(t=[t]),void 0===e&&(e=[t.length]);var s=e.length;if(void 0===n){n=new Array(s);for(var u=s-1,l=1;u>=0;--u)n[u]=l,l*=e[u]}if(void 0===r){r=0;for(var u=0;u<s;++u)n[u]<0&&(r-=(e[u]-1)*n[u])}for(var c=a(t),p=f[c];p.length<=s+1;)p.push(i(c,p.length-1));var o=p[s+1];return o(t,e,n,r)}var u=n(453),l=n(454),c=\"undefined\"!=typeof Float64Array,f={float32:[],float64:[],int8:[],int16:[],int32:[],uint8:[],uint16:[],uint32:[],array:[],uint8_clamped:[],buffer:[],generic:[]};t.exports=s},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,\"loaded\",{enumerable:!0,configurable:!1,get:function(){return t.l}}),Object.defineProperty(t,\"id\",{enumerable:!0,configurable:!1,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e,n){\"use strict\";var r=n(12),o=n(46),i=n(11);t.exports=function(t){for(var e=r(this),n=i(e.length),a=arguments.length,s=o(a>1?arguments[1]:void 0,n),u=a>2?arguments[2]:void 0,l=void 0===u?n:o(u,n);l>s;)e[s++]=t;return e}},function(t,e,n){\"use strict\";var r=n(10),o=n(36);t.exports=function(t,e,n){e in t?r.f(t,e,o(0,n)):t[e]=n}},function(t,e,n){var r=n(7),o=n(5).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,e){t.exports=\"constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\".split(\",\")},function(t,e,n){var r=n(8)(\"match\");t.exports=function(t){var e=/./;try{\"/./\"[t](e)}catch(n){try{return e[r]=!1,!\"/./\"[t](e)}catch(t){}}return!0}},function(t,e,n){t.exports=n(5).document&&document.documentElement},function(t,e,n){var r=n(7),o=n(107).set;t.exports=function(t,e,n){var i,a=e.constructor;return a!==n&&\"function\"==typeof a&&(i=a.prototype)!==n.prototype&&r(i)&&o&&o(t,i),t}},function(t,e,n){var r=n(52),o=n(8)(\"iterator\"),i=Array.prototype;t.exports=function(t){return void 0!==t&&(r.Array===t||i[o]===t)}},function(t,e,n){var r=n(22);t.exports=Array.isArray||function(t){return\"Array\"==r(t)}},function(t,e,n){\"use strict\";var r=n(41),o=n(36),i=n(53),a={};n(15)(a,n(8)(\"iterator\"),function(){return this}),t.exports=function(t,e,n){t.prototype=r(a,{next:o(1,n)}),i(t,e+\" Iterator\")}},function(t,e,n){\"use strict\";var r=n(40),o=n(0),i=n(16),a=n(15),s=n(13),u=n(52),l=n(102),c=n(53),f=n(21),p=n(8)(\"iterator\"),h=!([].keys&&\"next\"in[].keys()),d=\"@@iterator\",v=\"keys\",m=\"values\",_=function(){return this};t.exports=function(t,e,n,g,y,b,w){l(n,e,g);var x,E,T,O=function(t){if(!h&&t in j)return j[t];switch(t){case v:return function(){return new n(this,t)};case m:return function(){return new n(this,t)}}return function(){return new n(this,t)}},S=e+\" Iterator\",P=y==m,M=!1,j=t.prototype,A=j[p]||j[d]||y&&j[y],C=A||O(y),k=y?P?O(\"entries\"):C:void 0,R=\"Array\"==e?j.entries||A:A;if(R&&(T=f(R.call(new t)),T!==Object.prototype&&(c(T,S,!0),r||s(T,p)||a(T,p,_))),P&&A&&A.name!==m&&(M=!0,C=function(){return A.call(this)}),r&&!w||!h&&!M&&j[p]||a(j,p,C),u[e]=C,u[S]=_,y)if(x={values:P?C:O(m),keys:b?C:O(v),entries:k},w)for(E in x)E in j||i(j,E,x[E]);else o(o.P+o.F*(h||M),e,x);return x}},function(t,e){var n=Math.expm1;t.exports=!n||n(10)>22025.465794806718||n(10)<22025.465794806718||n(-2e-17)!=-2e-17?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:n},function(t,e){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,e,n){var r=n(5),o=n(114).set,i=r.MutationObserver||r.WebKitMutationObserver,a=r.process,s=r.Promise,u=\"process\"==n(22)(a);t.exports=function(){var t,e,n,l=function(){var r,o;for(u&&(r=a.domain)&&r.exit();t;){o=t.fn,t=t.next;try{o()}catch(r){throw t?n():e=void 0,r}}e=void 0,r&&r.enter()};if(u)n=function(){a.nextTick(l)};else if(i){var c=!0,f=document.createTextNode(\"\");new i(l).observe(f,{characterData:!0}),n=function(){f.data=c=!c}}else if(s&&s.resolve){var p=s.resolve();n=function(){p.then(l)}}else n=function(){o.call(r,l)};return function(r){var o={fn:r,next:void 0};e&&(e.next=o),t||(t=o,n()),e=o}}},function(t,e,n){var r=n(7),o=n(4),i=function(t,e){if(o(t),!r(e)&&null!==e)throw TypeError(e+\": can't set as prototype!\")};t.exports={set:Object.setPrototypeOf||(\"__proto__\"in{}?function(t,e,r){try{r=n(32)(Function.call,n(20).f(Object.prototype,\"__proto__\").set,2),r(t,[]),e=!(t instanceof Array)}catch(t){e=!0}return function(t,n){return i(t,n),e?t.__proto__=n:r(t,n),t}}({},!1):void 0),check:i}},function(t,e,n){var r=n(78)(\"keys\"),o=n(47);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,e,n){var r=n(4),o=n(14),i=n(8)(\"species\");t.exports=function(t,e){var n,a=r(t).constructor;return void 0===a||void 0==(n=r(a)[i])?e:o(n)}},function(t,e,n){var r=n(37),o=n(23);t.exports=function(t){return function(e,n){var i,a,s=String(o(e)),u=r(n),l=s.length;return u<0||u>=l?t?\"\":void 0:(i=s.charCodeAt(u),i<55296||i>56319||u+1===l||(a=s.charCodeAt(u+1))<56320||a>57343?t?s.charAt(u):i:t?s.slice(u,u+2):(i-55296<<10)+(a-56320)+65536)}}},function(t,e,n){var r=n(74),o=n(23);t.exports=function(t,e,n){if(r(e))throw TypeError(\"String#\"+n+\" doesn't accept regex!\");return String(o(t))}},function(t,e,n){\"use strict\";var r=n(37),o=n(23);t.exports=function(t){var e=String(o(this)),n=\"\",i=r(t);if(i<0||i==1/0)throw RangeError(\"Count can't be negative\");for(;i>0;(i>>>=1)&&(e+=e))1&i&&(n+=e);return n}},function(t,e){t.exports=\"\\t\\n\\v\\f\\r   ᠎             　\\u2028\\u2029\\ufeff\"},function(t,e,n){var r,o,i,a=n(32),s=n(73),u=n(98),l=n(95),c=n(5),f=c.process,p=c.setImmediate,h=c.clearImmediate,d=c.MessageChannel,v=0,m={},_=\"onreadystatechange\",g=function(){var t=+this;if(m.hasOwnProperty(t)){var e=m[t];delete m[t],e()}},y=function(t){g.call(t.data)};p&&h||(p=function(t){for(var e=[],n=1;arguments.length>n;)e.push(arguments[n++]);return m[++v]=function(){s(\"function\"==typeof t?t:Function(t),e)},r(v),v},h=function(t){delete m[t]},\"process\"==n(22)(f)?r=function(t){f.nextTick(a(g,t,1))}:d?(o=new d,i=o.port2,o.port1.onmessage=y,r=a(i.postMessage,i,1)):c.addEventListener&&\"function\"==typeof postMessage&&!c.importScripts?(r=function(t){c.postMessage(t+\"\",\"*\")},c.addEventListener(\"message\",y,!1)):r=_ in l(\"script\")?function(t){u.appendChild(l(\"script\"))[_]=function(){u.removeChild(this),g.call(t)}}:function(t){setTimeout(a(g,t,1),0)}),t.exports={set:p,clear:h}},function(t,e,n){\"use strict\";var r=n(5),o=n(9),i=n(40),a=n(79),s=n(15),u=n(44),l=n(6),c=n(39),f=n(37),p=n(11),h=n(42).f,d=n(10).f,v=n(93),m=n(53),_=\"ArrayBuffer\",g=\"DataView\",y=\"prototype\",b=\"Wrong length!\",w=\"Wrong index!\",x=r[_],E=r[g],T=r.Math,O=r.RangeError,S=r.Infinity,P=x,M=T.abs,j=T.pow,A=T.floor,C=T.log,k=T.LN2,R=\"buffer\",I=\"byteLength\",N=\"byteOffset\",U=o?\"_b\":R,F=o?\"_l\":I,L=o?\"_o\":N,D=function(t,e,n){var r,o,i,a=Array(n),s=8*n-e-1,u=(1<<s)-1,l=u>>1,c=23===e?j(2,-24)-j(2,-77):0,f=0,p=t<0||0===t&&1/t<0?1:0;for(t=M(t),t!=t||t===S?(o=t!=t?1:0,r=u):(r=A(C(t)/k),t*(i=j(2,-r))<1&&(r--,i*=2),t+=r+l>=1?c/i:c*j(2,1-l),t*i>=2&&(r++,i/=2),r+l>=u?(o=0,r=u):r+l>=1?(o=(t*i-1)*j(2,e),r+=l):(o=t*j(2,l-1)*j(2,e),r=0));e>=8;a[f++]=255&o,o/=256,e-=8);for(r=r<<e|o,s+=e;s>0;a[f++]=255&r,r/=256,s-=8);return a[--f]|=128*p,a},B=function(t,e,n){var r,o=8*n-e-1,i=(1<<o)-1,a=i>>1,s=o-7,u=n-1,l=t[u--],c=127&l;for(l>>=7;s>0;c=256*c+t[u],u--,s-=8);for(r=c&(1<<-s)-1,c>>=-s,s+=e;s>0;r=256*r+t[u],u--,s-=8);if(0===c)c=1-a;else{if(c===i)return r?NaN:l?-S:S;r+=j(2,e),c-=a}return(l?-1:1)*r*j(2,c-e)},V=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},W=function(t){return[255&t]},X=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},G=function(t){return D(t,52,8)},q=function(t){return D(t,23,4)},H=function(t,e,n){d(t[y],e,{get:function(){return this[n]}})},Y=function(t,e,n,r){var o=+n,i=f(o);if(o!=i||i<0||i+e>t[F])throw O(w);\nvar a=t[U]._b,s=i+t[L],u=a.slice(s,s+e);return r?u:u.reverse()},K=function(t,e,n,r,o,i){var a=+n,s=f(a);if(a!=s||s<0||s+e>t[F])throw O(w);for(var u=t[U]._b,l=s+t[L],c=r(+o),p=0;p<e;p++)u[l+p]=c[i?p:e-p-1]},$=function(t,e){c(t,x,_);var n=+e,r=p(n);if(n!=r)throw O(b);return r};if(a.ABV){if(!l(function(){new x})||!l(function(){new x(.5)})){x=function(t){return new P($(this,t))};for(var Z,Q=x[y]=P[y],J=h(P),tt=0;J.length>tt;)(Z=J[tt++])in x||s(x,Z,P[Z]);i||(Q.constructor=x)}var et=new E(new x(2)),nt=E[y].setInt8;et.setInt8(0,2147483648),et.setInt8(1,2147483649),!et.getInt8(0)&&et.getInt8(1)||u(E[y],{setInt8:function(t,e){nt.call(this,t,e<<24>>24)},setUint8:function(t,e){nt.call(this,t,e<<24>>24)}},!0)}else x=function(t){var e=$(this,t);this._b=v.call(Array(e),0),this[F]=e},E=function(t,e,n){c(this,E,g),c(t,x,g);var r=t[F],o=f(e);if(o<0||o>r)throw O(\"Wrong offset!\");if(n=void 0===n?r-o:p(n),o+n>r)throw O(b);this[U]=t,this[L]=o,this[F]=n},o&&(H(x,I,\"_l\"),H(E,R,\"_b\"),H(E,I,\"_l\"),H(E,N,\"_o\")),u(E[y],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var e=Y(this,2,t,arguments[1]);return(e[1]<<8|e[0])<<16>>16},getUint16:function(t){var e=Y(this,2,t,arguments[1]);return e[1]<<8|e[0]},getInt32:function(t){return V(Y(this,4,t,arguments[1]))},getUint32:function(t){return V(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return B(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return B(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,e){K(this,1,t,W,e)},setUint8:function(t,e){K(this,1,t,W,e)},setInt16:function(t,e){K(this,2,t,X,e,arguments[2])},setUint16:function(t,e){K(this,2,t,X,e,arguments[2])},setInt32:function(t,e){K(this,4,t,z,e,arguments[2])},setUint32:function(t,e){K(this,4,t,z,e,arguments[2])},setFloat32:function(t,e){K(this,4,t,q,e,arguments[2])},setFloat64:function(t,e){K(this,8,t,G,e,arguments[2])}});m(x,_),m(E,g),s(E[y],a.VIEW,!0),e[_]=x,e[g]=E},function(t,e,n){var r=n(5),o=n(31),i=n(40),a=n(161),s=n(10).f;t.exports=function(t){var e=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});\"_\"==t.charAt(0)||t in e||s(e,t,{value:a.f(t)})}},function(t,e,n){var r=n(58),o=n(8)(\"iterator\"),i=n(52);t.exports=n(31).getIteratorMethod=function(t){if(void 0!=t)return t[o]||t[\"@@iterator\"]||i[r(t)]}},function(t,e,n){\"use strict\";var r=n(50),o=n(149),i=n(52),a=n(18);t.exports=n(103)(Array,\"Array\",function(t,e){this._t=a(t),this._i=0,this._k=e},function(){var t=this._t,e=this._k,n=this._i++;return!t||n>=t.length?(this._t=void 0,o(1)):\"keys\"==e?o(0,n):\"values\"==e?o(0,t[n]):o(0,[n,t[n]])},\"values\"),i.Arguments=i.Array,r(\"keys\"),r(\"values\"),r(\"entries\")},function(t,e,n){var r=n(48),o=n(29),i=r(o,\"Map\");t.exports=i},function(t,e,n){function r(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}var o=n(535),i=n(536),a=n(537),s=n(538),u=n(539);r.prototype.clear=o,r.prototype.delete=i,r.prototype.get=a,r.prototype.has=s,r.prototype.set=u,t.exports=r},function(t,e){function n(t,e){for(var n=-1,r=null==t?0:t.length,o=Array(r);++n<r;)o[n]=e(t[n],n,t);return o}t.exports=n},function(t,e,n){function r(t,e){e=o(e,t);for(var n=0,r=e.length;null!=t&&n<r;)t=t[i(e[n++])];return n&&n==r?t:void 0}var o=n(83),i=n(63);t.exports=r},function(t,e,n){function r(t,e,n,a,s){return t===e||(null==t||null==e||!i(t)&&!i(e)?t!==t&&e!==e:o(t,e,n,a,r,s))}var o=n(478),i=n(64);t.exports=r},function(t,e,n){function r(t,e){if(o(t))return!1;var n=typeof t;return!(\"number\"!=n&&\"symbol\"!=n&&\"boolean\"!=n&&null!=t&&!i(t))||(s.test(t)||!a.test(t)||null!=e&&t in Object(e))}var o=n(30),i=n(89),a=/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,s=/^\\w*$/;t.exports=r},function(t,e){function n(t){return t}t.exports=n},function(t,e,n){var r=n(477),o=n(64),i=Object.prototype,a=i.hasOwnProperty,s=i.propertyIsEnumerable,u=r(function(){return arguments}())?r:function(t){return o(t)&&a.call(t,\"callee\")&&!s.call(t,\"callee\")};t.exports=u},function(t,e,n){function r(t,e){return o(t,e)}var o=n(123);t.exports=r},function(t,e){function n(t){return\"number\"==typeof t&&t>-1&&t%1==0&&t<=r}var r=9007199254740991;t.exports=n},function(t,e,n){function r(t){return t&&t.length?o(t,i):0}var o=n(494),i=n(125);t.exports=r},function(t,e,n){\"use strict\";function r(t,e){var n,r;if(void 0!==e&&(!Number.isFinite(e)||e%1!==e))throw new Error(\"axis of dimension to unsqueeze must be an integer\");return e=void 0===e?t.shape.length:e,n=t.shape.slice(0),r=t.stride.slice(0),n.splice(e||0,0,1),r.splice(e||0,0,(r[e]||1)*(n[e+1]||1)),o(t.data,n,r,t.offset)}var o=n(91);t.exports=r},function(t,e){function n(){throw new Error(\"setTimeout has not been defined\")}function r(){throw new Error(\"clearTimeout has not been defined\")}function o(t){if(c===setTimeout)return setTimeout(t,0);if((c===n||!c)&&setTimeout)return c=setTimeout,setTimeout(t,0);try{return c(t,0)}catch(e){try{return c.call(null,t,0)}catch(e){return c.call(this,t,0)}}}function i(t){if(f===clearTimeout)return clearTimeout(t);if((f===r||!f)&&clearTimeout)return f=clearTimeout,clearTimeout(t);try{return f(t)}catch(e){try{return f.call(null,t)}catch(e){return f.call(this,t)}}}function a(){v&&h&&(v=!1,h.length?d=h.concat(d):m=-1,d.length&&s())}function s(){if(!v){var t=o(a);v=!0;for(var e=d.length;e;){for(h=d,d=[];++m<e;)h&&h[m].run();m=-1,e=d.length}h=null,v=!1,i(t)}}function u(t,e){this.fun=t,this.array=e}function l(){}var c,f,p=t.exports={};!function(){try{c=\"function\"==typeof setTimeout?setTimeout:n}catch(t){c=n}try{f=\"function\"==typeof clearTimeout?clearTimeout:r}catch(t){f=r}}();var h,d=[],v=!1,m=-1;p.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new u(t,e)),1!==d.length||v||o(s)},u.prototype.run=function(){this.fun.apply(null,this.array)},p.title=\"browser\",p.browser=!0,p.env={},p.argv=[],p.version=\"\",p.versions={},p.on=l,p.addListener=l,p.once=l,p.off=l,p.removeListener=l,p.removeAllListeners=l,p.emit=l,p.binding=function(t){throw new Error(\"process.binding is not supported\")},p.cwd=function(){return\"/\"},p.chdir=function(t){throw new Error(\"process.chdir is not supported\")},p.umask=function(){return 0}},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(67),l=r(u),c=function(t){function e(t){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));if(\"max\"===t)r.program=r.webgl.createProgram(n(617));else{if(\"average\"!==t)throw new Error(\"[WebGLPooling2D] pooling function must be max or average.\");r.program=r.webgl.createProgram(n(616))}return r}return a(e,t),s(e,[{key:\"_bindInputTextures\",value:function(t,n){var r=this.webgl.context;this.numTextures=2,this._bindInputTexture(this.program,t.texture,r.TEXTURE0,e.INPUT_TEXTURE_NAME),this._bindInputTexture(this.program,n.texture,r.TEXTURE1,e.POOL_IMAP_TEXTURE_NAME)}},{key:\"_bindUniforms\",value:function(t,n){var r=this.webgl.context,o=t.shape[0],i=t.shape[1],a=this.webgl.getPad(i),s=n.shape[1],u=this.webgl.getPad(s);r.uniform1i(r.getUniformLocation(this.program,e.INPUT_ROWS_UNIFORM_NAME),o),r.uniform1i(r.getUniformLocation(this.program,e.CHANNELS_UNIFORM_NAME),i),r.uniform1i(r.getUniformLocation(this.program,e.CHANNELS_PAD_UNIFORM_NAME),a),r.uniform1i(r.getUniformLocation(this.program,e.POOL_ELEMENTS_UNIFORM_NAME),s),r.uniform1i(r.getUniformLocation(this.program,e.POOL_ELEMENTS_PAD_UNIFORM_NAME),u)}},{key:\"_bindOutputTexture\",value:function(t,e,n){var r=e.shape[0],o=t.shape[1],i=this.webgl.getPad(o);this.webgl.bindOutputTexture(r,(o+i)/4,n.texture)}},{key:\"call\",value:function(t,e){this.webgl.selectProgram(this.program);var n=e.shape[0],r=t.shape[1],o=new weblas.pipeline.Tensor([n,r],null);return this._bindInputTextures(t,e),this._bindUniforms(t,e),this._bindOutputTexture(t,e,o),this._compute(),this._unbindInputTextures(),o}}]),e}(l.default);c.INPUT_TEXTURE_NAME=\"X\",c.POOL_IMAP_TEXTURE_NAME=\"poolIndexMapping\",c.INPUT_ROWS_UNIFORM_NAME=\"inputRows\",c.CHANNELS_UNIFORM_NAME=\"channels\",c.CHANNELS_PAD_UNIFORM_NAME=\"channelsPad\",c.POOL_ELEMENTS_UNIFORM_NAME=\"poolElements\",c.POOL_ELEMENTS_PAD_UNIFORM_NAME=\"poolElementsPad\",e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.InputLayer=void 0;var o=n(208);Object.keys(o).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return o[t]}})});var i=n(236);Object.keys(i).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return i[t]}})});var a=n(223);Object.keys(a).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return a[t]}})});var s=n(254);Object.keys(s).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return s[t]}})});var u=n(243);Object.keys(u).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return u[t]}})});var l=n(238);Object.keys(l).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return l[t]}})});var c=n(241);Object.keys(c).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return c[t]}})});var f=n(137);Object.keys(f).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return f[t]}})});var p=n(260);Object.keys(p).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(e,t,{enumerable:!0,get:function(){return p[t]}})});var h=n(201),d=r(h);e.InputLayer=d.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"_Pooling1D\";var r=t.poolLength,a=void 0===r?2:r,s=t.stride,u=void 0===s?null:s,l=t.borderMode,c=void 0===l?\"valid\":l;return n.poolLength=a,n.stride=null===u?a:u,n.borderMode=c,n.poolingFunc=\"max\",n}return a(e,t),s(e,[{key:\"call\",value:function(t){if(\"max\"!==this.poolingFunc&&\"average\"!==this.poolingFunc)throw new Error(\"[pooling._Pooling1D] pooling function must be max or average.\");for(var e=\"valid\"===this.borderMode?Math.floor((t.tensor.shape[0]-this.poolLength+this.stride)/this.stride):Math.floor((t.tensor.shape[0]+this.stride-1)/this.stride),n=new f.default([],[e,t.tensor.shape[1]]),r=new f.default([],[t.tensor.shape[1]]),o=\"valid\"===this.borderMode?0:Math.min(0,Math.ceil((t.tensor.shape[0]-(e-1)*this.stride-this.poolLength)/2)),i=0;i<e;i++){var a=Math.max(0,o),s=this.poolLength+Math.min(0,o);h.default.assign(r.tensor,t.tensor.pick(a,null));for(var u=1,l=1;l<s&&!(a+l>t.tensor.shape[0]-1);l++)\"max\"===this.poolingFunc?h.default.maxeq(r.tensor,t.tensor.pick(a+l,null)):\"average\"===this.poolingFunc&&h.default.addeq(r.tensor,t.tensor.pick(a+l,null)),u+=1;\"average\"===this.poolingFunc&&h.default.divseq(r.tensor,u),h.default.assign(n.tensor.pick(i,null),r.tensor),o+=this.stride}return t.tensor=n.tensor,t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(1),c=r(l),f=n(2),p=r(f),h=n(3),d=r(h),v=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"_Pooling2D\";var r=t.poolSize,a=void 0===r?[2,2]:r,s=t.strides,u=void 0===s?null:s,l=t.borderMode,c=void 0===l?\"valid\":l,f=t.dimOrdering,p=void 0===f?\"tf\":f;return n.poolSize=a,n.strides=null===u?a:u,n.borderMode=c,n.dimOrdering=p,n.poolingFunc=\"max\",n}return a(e,t),u(e,[{key:\"_calcOutputShape\",value:function(t){var e=s(t,3),n=e[0],r=e[1],o=e[2],i=s(this.poolSize,2),a=i[0],u=i[1],l=\"same\"===this.borderMode?Math.floor((n+this.strides[0]-1)/this.strides[0]):Math.floor((n-a+this.strides[0])/this.strides[0]),c=\"same\"===this.borderMode?Math.floor((r+this.strides[1]-1)/this.strides[1]):Math.floor((r-u+this.strides[1])/this.strides[1]),f=\"same\"===this.borderMode?Math.max(0,Math.floor((l-1)*this.strides[0]+a-n)):0,p=\"same\"===this.borderMode?Math.max(0,Math.floor((c-1)*this.strides[1]+u-r)):0,h=Math.floor(f/2),d=f-h,v=Math.floor(p/2),m=p-v;this.outputShape=[l,c,o],this.inputPadding=[h,d,v,m]}},{key:\"_padInput\",value:function(t){if(\"same\"===this.borderMode){var e=s(t.tensor.shape,3),n=e[0],r=e[1],o=e[2],i=s(this.inputPadding,4),a=i[0],u=i[1],l=i[2],c=i[3],f=n+a+u,h=r+l+c,v=new p.default([],[f,h,o]);\"max\"===this.poolingFunc&&d.default.assigns(v.tensor,Number.NEGATIVE_INFINITY),d.default.assign(v.tensor.hi(n+a,r+l,o).lo(a,l,0),t.tensor),t.tensor=v.tensor}return t}},{key:\"_poolIndexMapping\",value:function(t){if(!this._poolIndicesPerChannel){for(var e=t[0],n=t[1],r=new p.default([],[e,n]),o=0,i=0;i<e;i++)for(var a=0;a<n;a++)r.tensor.set(i,a,o),o+=1;if(\"same\"===this.borderMode){var u=s(this.inputPadding,4),l=u[0],c=u[1],f=u[2],h=u[3];e=e+l+c,n=n+f+h;var v=new p.default([],[e,n]);d.default.assigns(v.tensor,-1),d.default.assign(v.tensor.hi(t[0]+l,t[1]+f).lo(l,f),r.tensor),r.tensor=v.tensor}var m=s(this.poolSize,2),_=m[0],g=m[1],y=this.outputShape[0],b=this.outputShape[1];this._poolIndicesPerChannel=new p.default([],[y*b,_*g]);for(var w=new p.default([],[_,g]),x=0,E=0,T=e-_;E<=T;E+=this.strides[0])for(var O=0,S=n-g;O<=S;O+=this.strides[1])d.default.assign(w.tensor,r.tensor.hi(E+_,O+g).lo(E,O)),this._poolIndicesPerChannel.tensor.data.set(w.tensor.data,x),x+=_*g;this._poolIndicesPerChannel.createWeblasTensor()}}},{key:\"_callPipelineMode\",value:function(t){if(!t.weblasTensor)throw new Error(\"Variable passed in does not contain weblas tensor.\");return this._calcOutputShape(t._actualShape),this._poolIndexMapping(t._actualShape),t.weblasTensor=this.webglPooling2D.call(t.weblasTensor,this._poolIndicesPerChannel.weblasTensor),t._fromPipeline=!0,t._actualShape=this.outputShape,t}},{key:\"_callRegularMode\",value:function(t){if(!t.tensor)throw new Error(\"Variable passed in does not contain tensor.\");\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0)),this._calcOutputShape(t.tensor.shape),this._padInput(t);for(var e=s(t.tensor.shape,3),n=e[0],r=e[1],o=e[2],i=s(this.poolSize,2),a=i[0],u=i[1],l=new p.default([],this.outputShape),c=new p.default([],[a,u,o]),f=s(this.inputPadding,4),h=f[0],v=f[1],m=f[2],_=f[3],g=0,y=0;g<=n-a;g+=this.strides[0],y++){var b=0;g<h?b=h-g:g+a>n-v&&(b=g+a-(n-v));for(var w=0,x=0;w<=r-u;w+=this.strides[1],x++){var E=0;w<m?E=m-w:w+u>r-_&&(E=w+u-(r-_)),d.default.assign(c.tensor,t.tensor.hi(g+a,w+u,o).lo(g,w,0));for(var T=0;T<o;T++)if(\"max\"===this.poolingFunc)l.tensor.set(y,x,T,d.default.sup(c.tensor.pick(null,null,T)));else if(\"average\"===this.poolingFunc){var O=(a-b)*(u-E);l.tensor.set(y,x,T,d.default.sum(c.tensor.pick(null,null,T))/O)}}}return t.tensor=l.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(2,0,1)),t}},{key:\"call\",value:function(t){return this._pipelineEnabled&&t._fromPipeline?this._callPipelineMode(t):this._callRegularMode(t)}}]),e}(c.default);e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(1),c=r(l),f=n(2),p=r(f),h=n(3),d=r(h),v=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"_Pooling3D\";var r=t.poolSize,a=void 0===r?[2,2,2]:r,s=t.strides,u=void 0===s?null:s,l=t.borderMode,c=void 0===l?\"valid\":l,f=t.dimOrdering,p=void 0===f?\"tf\":f;return n.poolSize=a,n.strides=null===u?a:u,n.borderMode=c,n.dimOrdering=p,n.poolingFunc=\"max\",n}return a(e,t),u(e,[{key:\"_calcOutputShape\",value:function(t){var e=s(t.tensor.shape,4),n=e[0],r=e[1],o=e[2],i=e[3],a=s(this.poolSize,3),u=a[0],l=a[1],c=a[2],f=\"same\"===this.borderMode?Math.floor((n+this.strides[0]-1)/this.strides[0]):Math.floor((n-u+this.strides[0])/this.strides[0]),p=\"same\"===this.borderMode?Math.floor((r+this.strides[1]-1)/this.strides[1]):Math.floor((r-l+this.strides[1])/this.strides[1]),h=\"same\"===this.borderMode?Math.floor((o+this.strides[2]-1)/this.strides[2]):Math.floor((o-c+this.strides[2])/this.strides[2]),d=\"same\"===this.borderMode?Math.max(0,Math.floor((f-1)*this.strides[0]+u-n)):0,v=\"same\"===this.borderMode?Math.max(0,Math.floor((p-1)*this.strides[1]+l-r)):0,m=\"same\"===this.borderMode?Math.max(0,Math.floor((h-1)*this.strides[2]+c-o)):0,_=Math.floor(d/2),g=d-_,y=Math.floor(v/2),b=v-y,w=Math.floor(m/2),x=m-w;this.outputShape=[f,p,h,i],this.inputPadding=[_,g,y,b,w,x]}},{key:\"_padInput\",value:function(t){if(\"same\"===this.borderMode){var e=s(t.tensor.shape,4),n=e[0],r=e[1],o=e[2],i=e[3],a=s(this.inputPadding,6),u=a[0],l=a[1],c=a[2],f=a[3],h=a[4],v=a[5],m=n+u+l,_=r+c+f,g=o+h+v,y=new p.default([],[m,_,g,i]);\"max\"===this.poolingFunc&&d.default.assigns(y.tensor,Number.NEGATIVE_INFINITY),d.default.assign(y.tensor.hi(n+u,r+c,o+h,i).lo(u,c,h,0),t.tensor),t.tensor=y.tensor}return t}},{key:\"call\",value:function(t){if(\"max\"!==this.poolingFunc&&\"average\"!==this.poolingFunc)throw new Error(\"[pooling._Pooling3D] pooling function must be max or average.\");\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,3,0)),this._calcOutputShape(t),this._padInput(t);for(var e=s(t.tensor.shape,4),n=e[0],r=e[1],o=e[2],i=e[3],a=s(this.poolSize,3),u=a[0],l=a[1],c=a[2],f=new p.default([],this.outputShape),h=new p.default([],[u,l,c,i]),v=s(this.inputPadding,6),m=v[0],_=v[1],g=v[2],y=v[3],b=v[4],w=v[5],x=0,E=0;x<=n-u;x+=this.strides[0],E++){var T=0;x<m?T=m-x:x+u>n-_&&(T=x+u-(n-_));for(var O=0,S=0;O<=r-l;O+=this.strides[1],S++){var P=0;O<g?P=g-O:O+l>r-y&&(P=O+l-(r-y));for(var M=0,j=0;M<=o-c;M+=this.strides[2],j++){var A=0;M<b?A=b-M:M+c>o-w&&(A=M+c-(o-w)),d.default.assign(h.tensor,t.tensor.hi(x+u,O+l,M+c,i).lo(x,O,M,0));for(var C=0;C<i;C++)if(\"max\"===this.poolingFunc)f.tensor.set(E,S,j,C,d.default.sup(h.tensor.pick(null,null,null,C)));else if(\"average\"===this.poolingFunc){var k=(u-T)*(l-P)*(c-A);f.tensor.set(E,S,j,C,d.default.sum(h.tensor.pick(null,null,null,C))/k)}}}}return t.tensor=f.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(3,0,1,2)),t}}]),e}(c.default);e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.GRU=e.LSTM=e.SimpleRNN=void 0;var o=n(257),i=r(o),a=n(256),s=r(a),u=n(255),l=r(u);e.SimpleRNN=i.default,e.LSTM=s.default,e.GRU=l.default},function(t,e,n){var r=n(22);t.exports=function(t,e){if(\"number\"!=typeof t&&\"Number\"!=r(t))throw TypeError(e);return+t}},function(t,e,n){\"use strict\";var r=n(12),o=n(46),i=n(11);t.exports=[].copyWithin||function(t,e){var n=r(this),a=i(n.length),s=o(t,a),u=o(e,a),l=arguments.length>2?arguments[2]:void 0,c=Math.min((void 0===l?a:o(l,a))-u,a-s),f=1;for(u<s&&s<u+c&&(f=-1,u+=c-1,s+=c-1);c-- >0;)u in n?n[s]=n[u]:delete n[s],s+=f,u+=f;return n}},function(t,e,n){var r=n(51);t.exports=function(t,e){var n=[];return r(t,!1,n.push,n,e),n}},function(t,e,n){var r=n(14),o=n(12),i=n(59),a=n(11);t.exports=function(t,e,n,s,u){r(e);var l=o(t),c=i(l),f=a(l.length),p=u?f-1:0,h=u?-1:1;if(n<2)for(;;){if(p in c){s=c[p],p+=h;break}if(p+=h,u?p<0:f<=p)throw TypeError(\"Reduce of empty array with no initial value\")}for(;u?p>=0:f>p;p+=h)p in c&&(s=e(s,c[p],p,l));return s}},function(t,e,n){\"use strict\";var r=n(14),o=n(7),i=n(73),a=[].slice,s={},u=function(t,e,n){if(!(e in s)){for(var r=[],o=0;o<e;o++)r[o]=\"a[\"+o+\"]\";s[e]=Function(\"F,a\",\"return new F(\"+r.join(\",\")+\")\")}return s[e](t,n)};t.exports=Function.bind||function(t){var e=r(this),n=a.call(arguments,1),s=function(){var r=n.concat(a.call(arguments));return this instanceof s?u(e,r.length,r):i(e,r,t)};return o(e.prototype)&&(s.prototype=e.prototype),s}},function(t,e,n){\"use strict\";var r=n(10).f,o=n(41),i=n(44),a=n(32),s=n(39),u=n(23),l=n(51),c=n(103),f=n(149),p=n(45),h=n(9),d=n(35).fastKey,v=h?\"_s\":\"size\",m=function(t,e){var n,r=d(e);if(\"F\"!==r)return t._i[r];for(n=t._f;n;n=n.n)if(n.k==e)return n};t.exports={getConstructor:function(t,e,n,c){var f=t(function(t,r){s(t,f,e,\"_i\"),t._i=o(null),t._f=void 0,t._l=void 0,t[v]=0,void 0!=r&&l(r,n,t[c],t)});return i(f.prototype,{clear:function(){for(var t=this,e=t._i,n=t._f;n;n=n.n)n.r=!0,n.p&&(n.p=n.p.n=void 0),delete e[n.i];t._f=t._l=void 0,t[v]=0},delete:function(t){var e=this,n=m(e,t);if(n){var r=n.n,o=n.p;delete e._i[n.i],n.r=!0,o&&(o.n=r),r&&(r.p=o),e._f==n&&(e._f=r),e._l==n&&(e._l=o),e[v]--}return!!n},forEach:function(t){s(this,f,\"forEach\");for(var e,n=a(t,arguments.length>1?arguments[1]:void 0,3);e=e?e.n:this._f;)for(n(e.v,e.k,this);e&&e.r;)e=e.p},has:function(t){return!!m(this,t)}}),h&&r(f.prototype,\"size\",{get:function(){return u(this[v])}}),f},def:function(t,e,n){var r,o,i=m(t,e);return i?i.v=n:(t._l=i={i:o=d(e,!0),k:e,v:n,p:r=t._l,n:void 0,r:!1},t._f||(t._f=i),r&&(r.n=i),t[v]++,\"F\"!==o&&(t._i[o]=i)),t},getEntry:m,setStrong:function(t,e,n){c(t,e,function(t,e){this._t=t,this._k=e,this._l=void 0},function(){for(var t=this,e=t._k,n=t._l;n&&n.r;)n=n.p;return t._t&&(t._l=n=n?n.n:t._t._f)?\"keys\"==e?f(0,n.k):\"values\"==e?f(0,n.v):f(0,[n.k,n.v]):(t._t=void 0,f(1))},n?\"entries\":\"values\",!n,!0),p(e)}}},function(t,e,n){var r=n(58),o=n(140);t.exports=function(t){return function(){if(r(this)!=t)throw TypeError(t+\"#toJSON isn't generic\");return o(this)}}},function(t,e,n){\"use strict\";var r=n(44),o=n(35).getWeak,i=n(4),a=n(7),s=n(39),u=n(51),l=n(26),c=n(13),f=l(5),p=l(6),h=0,d=function(t){return t._l||(t._l=new v)},v=function(){this.a=[]},m=function(t,e){return f(t.a,function(t){return t[0]===e})};v.prototype={get:function(t){var e=m(this,t);if(e)return e[1]},has:function(t){return!!m(this,t)},set:function(t,e){var n=m(this,t);n?n[1]=e:this.a.push([t,e])},delete:function(t){var e=p(this.a,function(e){return e[0]===t});return~e&&this.a.splice(e,1),!!~e}},t.exports={getConstructor:function(t,e,n,i){var l=t(function(t,r){s(t,l,e,\"_i\"),t._i=h++,t._l=void 0,void 0!=r&&u(r,n,t[i],t)});return r(l.prototype,{delete:function(t){if(!a(t))return!1;var e=o(t);return e===!0?d(this).delete(t):e&&c(e,this._i)&&delete e[this._i]},has:function(t){if(!a(t))return!1;var e=o(t);return e===!0?d(this).has(t):e&&c(e,this._i)}}),l},def:function(t,e,n){var r=o(i(e),!0);return r===!0?d(t).set(e,n):r[t._i]=n,t},ufstore:d}},function(t,e,n){t.exports=!n(9)&&!n(6)(function(){return 7!=Object.defineProperty(n(95)(\"div\"),\"a\",{get:function(){return 7}}).a})},function(t,e,n){var r=n(7),o=Math.floor;t.exports=function(t){return!r(t)&&isFinite(t)&&o(t)===t}},function(t,e,n){var r=n(4);t.exports=function(t,e,n,o){try{return o?e(r(n)[0],n[1]):e(n)}catch(e){var i=t.return;throw void 0!==i&&r(i.call(t)),e}}},function(t,e){t.exports=function(t,e){return{value:e,done:!!t}}},function(t,e){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,e,n){\"use strict\";var r=n(43),o=n(77),i=n(60),a=n(12),s=n(59),u=Object.assign;t.exports=!u||n(6)(function(){var t={},e={},n=Symbol(),r=\"abcdefghijklmnopqrst\";return t[n]=7,r.split(\"\").forEach(function(t){e[t]=t}),7!=u({},t)[n]||Object.keys(u({},e)).join(\"\")!=r})?function(t,e){for(var n=a(t),u=arguments.length,l=1,c=o.f,f=i.f;u>l;)for(var p,h=s(arguments[l++]),d=c?r(h).concat(c(h)):r(h),v=d.length,m=0;v>m;)f.call(h,p=d[m++])&&(n[p]=h[p]);return n}:u},function(t,e,n){var r=n(10),o=n(4),i=n(43);t.exports=n(9)?Object.defineProperties:function(t,e){o(t);for(var n,a=i(e),s=a.length,u=0;s>u;)r.f(t,n=a[u++],e[n]);return t}},function(t,e,n){var r=n(18),o=n(42).f,i={}.toString,a=\"object\"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],s=function(t){try{return o(t)}catch(t){return a.slice()}};t.exports.f=function(t){return a&&\"[object Window]\"==i.call(t)?s(t):o(r(t))}},function(t,e,n){var r=n(13),o=n(18),i=n(69)(!1),a=n(108)(\"IE_PROTO\");t.exports=function(t,e){var n,s=o(t),u=0,l=[];for(n in s)n!=a&&r(s,n)&&l.push(n);for(;e.length>u;)r(s,n=e[u++])&&(~i(l,n)||l.push(n));return l}},function(t,e,n){var r=n(43),o=n(18),i=n(60).f;t.exports=function(t){return function(e){for(var n,a=o(e),s=r(a),u=s.length,l=0,c=[];u>l;)i.call(a,n=s[l++])&&c.push(t?[n,a[n]]:a[n]);return c}}},function(t,e,n){var r=n(42),o=n(77),i=n(4),a=n(5).Reflect;t.exports=a&&a.ownKeys||function(t){var e=r.f(i(t)),n=o.f;return n?e.concat(n(t)):e}},function(t,e,n){var r=n(5).parseFloat,o=n(54).trim;t.exports=1/r(n(113)+\"-0\")!==-(1/0)?function(t){var e=o(String(t),3),n=r(e);return 0===n&&\"-\"==e.charAt(0)?-0:n}:r},function(t,e,n){var r=n(5).parseInt,o=n(54).trim,i=n(113),a=/^[\\-+]?0[xX]/;t.exports=8!==r(i+\"08\")||22!==r(i+\"0x16\")?function(t,e){var n=o(String(t),3);return r(n,e>>>0||(a.test(n)?16:10))}:r},function(t,e){t.exports=Object.is||function(t,e){return t===e?0!==t||1/t===1/e:t!=t&&e!=e}},function(t,e,n){var r=n(11),o=n(112),i=n(23);t.exports=function(t,e,n,a){var s=String(i(t)),u=s.length,l=void 0===n?\" \":String(n),c=r(e);if(c<=u||\"\"==l)return s;var f=c-u,p=o.call(l,Math.ceil(f/l.length));return p.length>f&&(p=p.slice(0,f)),a?p+s:s+p}},function(t,e,n){e.f=n(8)},function(t,e,n){\"use strict\";var r=n(143);t.exports=n(70)(\"Map\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var e=r.getEntry(this,t);return e&&e.v},set:function(t,e){return r.def(this,0===t?0:t,e)}},r,!0)},function(t,e,n){n(9)&&\"g\"!=/./g.flags&&n(10).f(RegExp.prototype,\"flags\",{configurable:!0,get:n(72)})},function(t,e,n){\"use strict\";var r=n(143);t.exports=n(70)(\"Set\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return r.def(this,t=0===t?0:t,t)}},r)},function(t,e,n){\"use strict\";var r,o=n(26)(0),i=n(16),a=n(35),s=n(151),u=n(145),l=n(7),c=a.getWeak,f=Object.isExtensible,p=u.ufstore,h={},d=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},v={get:function(t){if(l(t)){var e=c(t);return e===!0?p(this).get(t):e?e[this._i]:void 0}},set:function(t,e){return u.def(this,t,e)}},m=t.exports=n(70)(\"WeakMap\",d,v,u,!0,!0);7!=(new m).set((Object.freeze||Object)(h),7).get(h)&&(r=u.getConstructor(d),s(r.prototype,v),a.NEED=!0,o([\"delete\",\"has\",\"get\",\"set\"],function(t){var e=m.prototype,n=e[t];i(e,t,function(e,o){if(l(e)&&!f(e)){this._f||(this._f=new r);var i=this._f[t](e,o);return\"set\"==t?this:i}return n.call(this,e,o)})}))},function(t,e,n){\"use strict\";function r(){this.argTypes=[],this.shimArgs=[],this.arrayArgs=[],this.arrayBlockIndices=[],this.scalarArgs=[],this.offsetArgs=[],this.offsetArgIndex=[],this.indexArgs=[],this.shapeArgs=[],this.funcName=\"\",this.pre=null,this.body=null,this.post=null,this.debug=!1}function o(t){var e=new r;e.pre=t.pre,e.body=t.body,e.post=t.post;var n=t.args.slice(0);e.argTypes=n;for(var o=0;o<n.length;++o){var a=n[o];if(\"array\"===a||\"object\"==typeof a&&a.blockIndices){if(e.argTypes[o]=\"array\",e.arrayArgs.push(o),e.arrayBlockIndices.push(a.blockIndices?a.blockIndices:0),e.shimArgs.push(\"array\"+o),o<e.pre.args.length&&e.pre.args[o].count>0)throw new Error(\"cwise: pre() block may not reference array args\");if(o<e.post.args.length&&e.post.args[o].count>0)throw new Error(\"cwise: post() block may not reference array args\")}else if(\"scalar\"===a)e.scalarArgs.push(o),e.shimArgs.push(\"scalar\"+o);else if(\"index\"===a){if(e.indexArgs.push(o),o<e.pre.args.length&&e.pre.args[o].count>0)throw new Error(\"cwise: pre() block may not reference array index\");if(o<e.body.args.length&&e.body.args[o].lvalue)throw new Error(\"cwise: body() block may not write to array index\");if(o<e.post.args.length&&e.post.args[o].count>0)throw new Error(\"cwise: post() block may not reference array index\");\n}else if(\"shape\"===a){if(e.shapeArgs.push(o),o<e.pre.args.length&&e.pre.args[o].lvalue)throw new Error(\"cwise: pre() block may not write to array shape\");if(o<e.body.args.length&&e.body.args[o].lvalue)throw new Error(\"cwise: body() block may not write to array shape\");if(o<e.post.args.length&&e.post.args[o].lvalue)throw new Error(\"cwise: post() block may not write to array shape\")}else{if(\"object\"!=typeof a||!a.offset)throw new Error(\"cwise: Unknown argument type \"+n[o]);e.argTypes[o]=\"offset\",e.offsetArgs.push({array:a.array,offset:a.offset}),e.offsetArgIndex.push(o)}}if(e.arrayArgs.length<=0)throw new Error(\"cwise: No array arguments specified\");if(e.pre.args.length>n.length)throw new Error(\"cwise: Too many arguments in pre() block\");if(e.body.args.length>n.length)throw new Error(\"cwise: Too many arguments in body() block\");if(e.post.args.length>n.length)throw new Error(\"cwise: Too many arguments in post() block\");return e.debug=!!t.printCode||!!t.debug,e.funcName=t.funcName||\"cwise\",e.blockSize=t.blockSize||64,i(e)}var i=n(449);t.exports=o},function(t,e,n){\"use strict\";function r(t,e,n){var o=0|t[n];if(o<=0)return[];var i,a=new Array(o);if(n===t.length-1)for(i=0;i<o;++i)a[i]=e;else for(i=0;i<o;++i)a[i]=r(t,e,n+1);return a}function o(t,e){var n,r;for(n=new Array(t),r=0;r<t;++r)n[r]=e;return n}function i(t,e){switch(\"undefined\"==typeof e&&(e=0),typeof t){case\"number\":if(t>0)return o(0|t,e);break;case\"object\":if(\"number\"==typeof t.length)return r(t,e,0)}return[]}t.exports=i},function(t,e,n){function r(t){var e=this.__data__=new o(t);this.size=e.size}var o=n(80),i=n(552),a=n(553),s=n(554),u=n(555),l=n(556);r.prototype.clear=i,r.prototype.delete=a,r.prototype.get=s,r.prototype.has=u,r.prototype.set=l,t.exports=r},function(t,e){function n(t,e){for(var n=-1,r=e.length,o=t.length;++n<r;)t[o+n]=e[n];return t}t.exports=n},function(t,e,n){function r(t,e,n){\"__proto__\"==e&&o?o(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n}var o=n(173);t.exports=r},function(t,e,n){function r(t,e,n,a,s){var u=-1,l=t.length;for(n||(n=i),s||(s=[]);++u<l;){var c=t[u];e>0&&n(c)?e>1?r(c,e-1,n,a,s):o(s,c):a||(s[s.length]=c)}return s}var o=n(169),i=n(526);t.exports=r},function(t,e,n){function r(t,e){return t&&o(t,e,i)}var o=n(474),i=n(49);t.exports=r},function(t,e,n){var r=n(48),o=function(){try{var t=r(Object,\"defineProperty\");return t({},\"\",{}),t}catch(t){}}();t.exports=o},function(t,e,n){function r(t,e,n,r,l,c){var f=n&s,p=t.length,h=e.length;if(p!=h&&!(f&&h>p))return!1;var d=c.get(t);if(d&&c.get(e))return d==e;var v=-1,m=!0,_=n&u?new o:void 0;for(c.set(t,e),c.set(e,t);++v<p;){var g=t[v],y=e[v];if(r)var b=f?r(y,g,v,e,t,c):r(g,y,v,t,e,c);if(void 0!==b){if(b)continue;m=!1;break}if(_){if(!i(e,function(t,e){if(!a(_,e)&&(g===t||l(g,t,n,r,c)))return _.push(e)})){m=!1;break}}else if(g!==y&&!l(g,y,n,r,c)){m=!1;break}}return c.delete(t),c.delete(e),m}var o=n(459),i=n(467),a=n(500),s=1,u=2;t.exports=r},function(t,e,n){(function(e){var n=\"object\"==typeof e&&e&&e.Object===Object&&e;t.exports=n}).call(e,n(38))},function(t,e,n){var r=n(455),o=n(119),i=n(457),a=n(458),s=n(461),u=n(62),l=n(182),c=\"[object Map]\",f=\"[object Object]\",p=\"[object Promise]\",h=\"[object Set]\",d=\"[object WeakMap]\",v=\"[object DataView]\",m=l(r),_=l(o),g=l(i),y=l(a),b=l(s),w=u;(r&&w(new r(new ArrayBuffer(1)))!=v||o&&w(new o)!=c||i&&w(i.resolve())!=p||a&&w(new a)!=h||s&&w(new s)!=d)&&(w=function(t){var e=u(t),n=e==f?t.constructor:void 0,r=n?l(n):\"\";if(r)switch(r){case m:return v;case _:return c;case g:return p;case y:return h;case b:return d}return e}),t.exports=w},function(t,e){function n(t){return c.test(t)}var r=\"\\\\ud800-\\\\udfff\",o=\"\\\\u0300-\\\\u036f\",i=\"\\\\ufe20-\\\\ufe2f\",a=\"\\\\u20d0-\\\\u20ff\",s=o+i+a,u=\"\\\\ufe0e\\\\ufe0f\",l=\"\\\\u200d\",c=RegExp(\"[\"+l+r+s+u+\"]\");t.exports=n},function(t,e,n){function r(t,e,n){if(!s(n))return!1;var r=typeof e;return!!(\"number\"==r?i(n)&&a(e,n.length):\"string\"==r&&e in n)&&o(n[e],t)}var o=n(87),i=n(88),a=n(85),s=n(55);t.exports=r},function(t,e,n){function r(t){return t===t&&!o(t)}var o=n(55);t.exports=r},function(t,e){function n(t){var e=-1,n=Array(t.size);return t.forEach(function(t,r){n[++e]=[r,t]}),n}t.exports=n},function(t,e){function n(t,e){return function(n){return null!=n&&(n[t]===e&&(void 0!==e||t in Object(n)))}}t.exports=n},function(t,e){function n(t){if(null!=t){try{return o.call(t)}catch(t){}try{return t+\"\"}catch(t){}}return\"\"}var r=Function.prototype,o=r.toString;t.exports=n},function(t,e,n){function r(t){var e=null==t?0:t.length;return e?o(t,i):[]}var o=n(171),i=1/0;t.exports=r},function(t,e,n){function r(t,e){return null!=t&&i(t,e,o)}var o=n(476),i=n(519);t.exports=r},function(t,e,n){(function(t){var r=n(29),o=n(576),i=\"object\"==typeof e&&e&&!e.nodeType&&e,a=i&&\"object\"==typeof t&&t&&!t.nodeType&&t,s=a&&a.exports===i,u=s?r.Buffer:void 0,l=u?u.isBuffer:void 0,c=l||o;t.exports=c}).call(e,n(92)(t))},function(t,e,n){function r(t){if(!i(t))return!1;var e=o(t);return e==s||e==u||e==a||e==l}var o=n(62),i=n(55),a=\"[object AsyncFunction]\",s=\"[object Function]\",u=\"[object GeneratorFunction]\",l=\"[object Proxy]\";t.exports=r},function(t,e,n){var r=n(481),o=n(498),i=n(542),a=i&&i.isTypedArray,s=a?o(a):r;t.exports=s},function(t,e,n){var r=n(508),o=r();t.exports=o},function(t,e,n){function r(t){if(!t)return 0===t?t:0;if(t=o(t),t===i||t===-i){var e=t<0?-1:1;return e*a}return t===t?t:0}var o=n(578),i=1/0,a=1.7976931348623157e308;t.exports=r},function(t,e,n){\"use strict\";function r(t){var e=t.dtype;\"generic\"!==e&&\"array\"!==e||(e=\"double\");var n=f.malloc(t.size,e),r=l(n,t.shape);return c.assign(r,t),r}function o(t,e){e||(e=\"double\");for(var n=1,r=new Array(t.length),o=t.length-1;o>=0;--o)r[o]=n,n*=t[o];return l(f.malloc(n,e),t,r,0)}function i(t){\"generic\"!==t.dtype&&\"array\"!==t.dtype&&f.free(t.data)}function a(t,e){e||(e=\"double\");for(var n=1,r=new Array(t.length),o=t.length-1;o>=0;--o)r[o]=n,n*=t[o];for(var i=f.malloc(n,e),o=0;o<n;++o)i[o]=0;return l(i,t,r,0)}function s(t,e){e||(e=\"double\");for(var n=1,r=new Array(t.length),o=t.length-1;o>=0;--o)r[o]=n,n*=t[o];for(var i=f.malloc(n,e),o=0;o<n;++o)i[o]=1;return l(i,t,r,0)}function u(t,e){var n,r;e||(e=\"double\");var o=1,i=new Array(t.length);for(n=t.length-1;n>=0;--n)i[n]=o,o*=t[n];var a=f.malloc(o,e);for(n=0;n<o;++n)a[n]=0;var s=1/0,u=0;for(n=t.length-1;n>=0;n--)u+=i[n],s=Math.min(s,t[n]);for(n=0,r=0;n<s;n++,r+=u)a[r]=1;return l(a,t,i,0)}var l=n(91),c=n(3),f=n(622);e.clone=r,e.malloc=o,e.free=i,e.zeros=a,e.ones=s,e.eye=u},function(t,e,n){\"use strict\";function r(t,e){var n,r=[],i=[];if(void 0!==e&&!Array.isArray(e))throw new Error(\"axes must be an Array list of dimensions to squeeze\");for(n=0;n<t.shape.length;n++)(1!==t.shape[n]||void 0!==e&&e.indexOf(n)===-1)&&(r.push(t.shape[n]),i.push(t.stride[n]));return o(t.data,r,i,t.offset)}var o=n(91);t.exports=r},function(t,e,n){\"use strict\";var r=n(167),o=n(25),i=o({args:[\"array\",\"scalar\",\"index\"],body:function(t,e,n){var r,o=e;for(r=0;r<n.length-1;++r)o=o[n[r]];o[n[n.length-1]]=t}});t.exports=function(t){var e=r(t.shape);return i(t,e),e}},function(t,e,n){\"use strict\";function r(t,e){for(var n=1,r=t.length,o=t[0],i=t[0],a=1;a<r;++a)if(i=o,o=t[a],e(o,i)){if(a===n){n++;continue}t[n++]=o}return t.length=n,t}function o(t){for(var e=1,n=t.length,r=t[0],o=t[0],i=1;i<n;++i,o=r)if(o=r,r=t[i],r!==o){if(i===e){e++;continue}t[e++]=r}return t.length=e,t}function i(t,e,n){return 0===t.length?t:e?(n||t.sort(e),r(t,e)):(n||t.sort(),o(t))}t.exports=i},function(t,e,n){\"use strict\";function r(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function o(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.testUtils=e.layers=e.activations=e.Tensor=e.Model=void 0;var i=n(624),a=o(i),s=n(196),u=o(s),l=n(2),c=o(l),f=n(19),p=r(f),h=n(133),d=r(h),v=n(261),m=r(v);window.weblas=a.default,e.Model=u.default,e.Tensor=c.default,e.activations=p,e.layers=d,e.testUtils=m},function(t,e,n){\"use strict\";(function(t){function e(t,e,n){t[e]||Object[r](t,e,{writable:!0,configurable:!0,value:n})}if(n(447),n(619),n(267),t._babelPolyfill)throw new Error(\"only one instance of babel-polyfill is allowed\");t._babelPolyfill=!0;var r=\"defineProperty\";e(String.prototype,\"padLeft\",\"\".padStart),e(String.prototype,\"padRight\",\"\".padEnd),\"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill\".split(\",\").forEach(function(t){[][t]&&e(Array,t,Function.call.bind([][t]))})}).call(e,n(38))},function(t,e,n){\"use strict\";function r(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function o(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var a=n(264),s=o(a),u=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},l=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),c=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),f=n(579),p=o(f),h=n(571),d=o(h),v=n(561),m=o(v),_=n(566),g=o(_),y=n(49),b=o(y),w=n(581),x=o(w),E=n(129),T=o(E),O=n(127),S=o(O),P=n(565),M=o(P),j=n(133),A=r(j),C=n(2),k=o(C),R=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,t);var n=e.filepaths,r=void 0===n?{}:n,o=e.headers,a=void 0===o?{}:o,s=e.gpu,u=void 0!==s&&s,l=e.pipeline,c=void 0!==l&&l,f=e.layerCallPauses,p=void 0!==f&&f;if(!r.model||!r.weights||!r.metadata)throw new Error(\"File paths must be declared for model, weights, and metadata.\");this.filepaths=r,this.filetypes={model:\"json\",weights:\"arraybuffer\",metadata:\"json\"},this.headers=a,this.gpu=u,this.pipeline=c,this.layerCallPauses=p,this.data={model:{},weights:null,metadata:[]},this.xhrs={model:null,weights:null,metadata:null},this.xhrProgress={model:0,weights:0,metadata:0},this.modelLayersMap=new Map,this.layersWithResults=[],this.modelDAG={},this.inputTensors={},this._ready=this._initialize(),this.isRunning=!1}return c(t,[{key:\"ready\",value:function(){return this._ready}},{key:\"_interrupt\",value:function(){var t=this,e=[\"model\",\"weights\",\"metdata\"];e.forEach(function(e){t.xhrs[e]&&(t.xhrs[e].abort(),t.xhrs[e]=null)})}},{key:\"_initialize\",value:function(){var t=this,e=[\"model\",\"weights\",\"metadata\"];return s.default.all(e.map(function(e){return t._dataRequest(e,t.headers)})).then(function(){return t._createLayers(),s.default.resolve()}).catch(function(e){console.log(e),t._interrupt()})}},{key:\"_dataRequest\",value:function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new s.default(function(r,o){var i=new XMLHttpRequest;i.open(\"GET\",e.filepaths[t],!0),i.responseType=e.filetypes[t];var a=!0,s=!1,u=void 0;try{for(var c,f=(0,p.default)(n)[Symbol.iterator]();!(a=(c=f.next()).done);a=!0){var h=l(c.value,2),d=h[0],v=h[1];i.setRequestHeader(d,v)}}catch(t){s=!0,u=t}finally{try{!a&&f.return&&f.return()}finally{if(s)throw u}}i.onload=function(n){e.data[t]=i.response,e.xhrs[t]=null,e.xhrProgress[t]=100,r()},i.onprogress=function(n){if(n.lengthComputable){var r=Math.round(100*n.loaded/n.total);e.xhrProgress[t]=r}},i.onerror=function(t){return o(t)},i.send(null),e.xhrs[t]=i})}},{key:\"getLoadingProgress\",value:function(){var t=(0,x.default)(this.xhrProgress);return Math.round((0,T.default)(t)/t.length)}},{key:\"toggleGpu\",value:function(t){\"undefined\"==typeof t?this.gpu=!this.gpu:this.gpu=t;var e=!0,n=!1,r=void 0;try{for(var o,i=this.modelLayersMap.values()[Symbol.iterator]();!(e=(o=i.next()).done);e=!0){var a=o.value;a.toggleGpu(this.gpu)}}catch(t){n=!0,r=t}finally{try{!e&&i.return&&i.return()}finally{if(n)throw r}}}},{key:\"_createLayers\",value:function(){var t=this,e=this.data.model.class_name,n=[];\"Sequential\"===e?n=this.data.model.config:\"Model\"===e&&(n=this.data.model.config.layers),n.forEach(function(r,o){var i=r.class_name,a=r.config;if(!(i in A))throw new Error(\"Layer \"+i+\" specified in model configuration is not implemented!\");if(\"Sequential\"===e&&0===o){var s=\"input\",u=a.batch_input_shape.slice(1),l=new A.InputLayer({name:s,shape:u});t.modelLayersMap.set(s,l),t.modelDAG[s]={layerClass:\"InputLayer\",name:s,inbound:[],outbound:[]},t.inputTensors[s]=new k.default([],u)}else if(\"Model\"===e&&\"InputLayer\"===i){var c=a.batch_input_shape.slice(1);t.inputTensors[a.name]=new k.default([],c)}var f=void 0;if(\"Bidirectional\"===i||\"TimeDistributed\"===i){var p=(0,d.default)(a,function(t,e){return(0,m.default)(e)}),h=a.layer.config,v=a.layer.class_name,_=(0,d.default)(h,function(t,e){return(0,m.default)(e)});\"activation\"in _&&(_.activation=(0,m.default)(_.activation)),\"innerActivation\"in _&&(_.innerActivation=(0,m.default)(_.innerActivation)),_.gpu=t.gpu,f=new A[i](Object.assign(p,{layer:new A[v](_)}))}else{var y=(0,d.default)(a,function(t,e){return(0,m.default)(e)});\"activation\"in y&&(y.activation=(0,m.default)(y.activation)),\"innerActivation\"in y&&(y.innerActivation=(0,m.default)(y.innerActivation)),y.gpu=t.gpu,y.pipeline=t.pipeline,f=new A[i](y)}var b=[];if(\"Bidirectional\"===i?!function(){var t=a.layer.config.name,e=t.replace(/forward/,\"backward\"),n=f.forwardLayer.params.map(function(e){return t+\"_\"+e}),r=f.backwardLayer.params.map(function(t){return e+\"_\"+t});b=n.concat(r)}():b=\"TimeDistributed\"===i?f.layer.params.map(function(t){return a.layer.config.name+\"_\"+t}):f.params.map(function(t){return a.name+\"_\"+t}),b&&b.length){var w=b.map(function(e){var n=(0,g.default)(t.data.metadata,function(t){var n=new RegExp(\"^\"+e);return t.layer_name===a.name&&n.test(t.weight_name)});if(!n)throw new Error(\"[Model] error loading weights.\");var r=n.offset,o=n.length,i=n.shape;return new k.default(new Float32Array(t.data.weights,r,o),i)});f.setWeights(w)}if(t.modelLayersMap.set(a.name,f),t.modelDAG[a.name]={layerClass:i,name:a.name,inbound:[],outbound:[]},\"Sequential\"===e)if(0===o){var x=\"input\";t.modelDAG[x].outbound.push(a.name),t.modelDAG[a.name].inbound.push(x)}else{var E=n[o-1].config;t.modelDAG[a.name].inbound.push(E.name),t.modelDAG[E.name].outbound.push(a.name)}else\"Model\"===e&&r.inbound_nodes&&r.inbound_nodes.length&&r.inbound_nodes[0].forEach(function(e){var n=e[0];t.modelDAG[a.name].inbound.push(n),t.modelDAG[n].outbound.push(a.name)})})}},{key:\"_mergeLayerCall\",value:function(t,e,n){var r=e.map(function(t){return t.result}),o=r.every(function(t){return t._fromPipeline});return o&&t._pipelineEnabled?n&&(r=r.map(function(t){var e=new k.default([],t.tensor.shape);return e.copyFromWeblasTensor(t.weblasTensor),e._fromPipeline=!0,e._actualShape=t._actualShape.slice(),e})):r=r.map(function(t,r){return t._fromPipeline?e[r].transferFromPipeline(t):n?new k.default(t.tensor.data,t.tensor.shape):t}),t.call(r)}},{key:\"_regularLayerCall\",value:function(t,e,n){var r=e.result;if(r._fromPipeline&&t._pipelineEnabled){if(n){var o=new k.default([],r.tensor.shape);o.copyFromWeblasTensor(r.weblasTensor),o._fromPipeline=!0,o._actualShape=r._actualShape.slice(),r=o}}else r._fromPipeline?r=e.transferFromPipeline(r):n&&(r=new k.default(r.tensor.data,r.tensor.shape));return t.call(r)}},{key:\"_traverseDAG\",value:function(){function t(t){return e.apply(this,arguments)}var e=(0,a.coroutine)(regeneratorRuntime.mark(function t(e){var n,r,o,i,a,u,l,c,f,p=this;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:if(0!==e.length){t.next=4;break}return t.abrupt(\"return\",!0);case 4:if(1!==e.length){t.next=30;break}if(n=e[0],r=this.modelDAG[n],o=r.layerClass,i=r.inbound,a=r.outbound,\"InputLayer\"===o){t.next=26;break}if(u=this.modelLayersMap.get(n),!u.visited){t.next=14;break}return t.abrupt(\"return\",!1);case 14:if(l=i.map(function(t){return p.modelLayersMap.get(t)}),(0,M.default)(l.map(function(t){return t.hasResult}))){t.next=17;break}return t.abrupt(\"return\",!1);case 17:if(c=i.map(function(t){return p.modelDAG[t].outbound}).reduce(function(t,e){return t+e.length},0),f=c>=1,u.result=\"Merge\"===o?this._mergeLayerCall(u,l,f):this._regularLayerCall(u,l[0],f),u.hasResult=!0,u.visited=!0,this.layersWithResults.push(u.name),!this.layerCallPauses){t.next=26;break}return t.next=26,s.default.delay(0);case 26:return t.next=28,this._traverseDAG(a);case 28:t.next=32;break;case 30:return t.next=32,s.default.all(e.map(function(t){return p._traverseDAG([t])}));case 32:case\"end\":return t.stop()}},t,this)}));return t}()},{key:\"predict\",value:function(){function t(t){return e.apply(this,arguments)}var e=(0,a.coroutine)(regeneratorRuntime.mark(function t(e){var n,r,o,i,a,s,l,c,f,p,h,d,v,m=this;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:if(this.isRunning=!0,n=(0,b.default)(this.inputTensors).sort(),(0,S.default)((0,b.default)(e).sort(),n)){t.next=5;break}throw this.isRunning=!1,new Error(\"predict() must take an object where the keys are the named inputs of the model: \"+n+\".\");case 5:if((0,M.default)(n,function(t){return e[t]instanceof Float32Array})){t.next=8;break}throw this.isRunning=!1,new Error(\"predict() must take an object where the values are the flattened data as Float32Array.\");case 8:for(this.layersWithResults=[],r=!0,o=!1,i=void 0,t.prev=12,a=this.modelLayersMap.values()[Symbol.iterator]();!(r=(s=a.next()).done);r=!0)l=s.value,l.hasResult=!1,l.visited=!1;t.next=20;break;case 16:t.prev=16,t.t0=t.catch(12),o=!0,i=t.t0;case 20:t.prev=20,t.prev=21,!r&&a.return&&a.return();case 23:if(t.prev=23,!o){t.next=26;break}throw i;case 26:return t.finish(23);case 27:return t.finish(20);case 28:return n.forEach(function(t){var n=m.modelLayersMap.get(t);m.inputTensors[t].replaceTensorData(e[t]),n.result=n.call(m.inputTensors[t]),n.hasResult=!0,n.visited=!0}),t.next=31,this._traverseDAG(n);case 31:if(c=this.data.model.class_name,\"Sequential\"!==c){t.next=41;break}return f=(0,g.default)((0,x.default)(this.modelDAG),function(t){return!t.outbound.length}),p=this.modelLayersMap.get(f.name),h=p.result,d={output:h.tensor.data},this.isRunning=!1,t.abrupt(\"return\",d);case 41:if(\"Model\"!==c){t.next=45;break}if(v=function(){var t=(0,x.default)(m.modelDAG).filter(function(t){return!t.outbound.length}),e={};return t.forEach(function(t){var n=m.modelLayersMap.get(t.name),r=n.result;e[t.name]=r.tensor.data}),m.isRunning=!1,{v:e}}(),\"object\"!==(\"undefined\"==typeof v?\"undefined\":u(v))){t.next=45;break}return t.abrupt(\"return\",v.v);case 45:case\"end\":return t.stop()}},t,this,[[12,16,20,28],[21,,23,27]])}));return t}()}]),t}();e.default=R},function(t,e,n){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var r=document.createElement(\"canvas\"),o=r.getContext(\"webgl\")||r.getContext(\"experimental-webgl\"),i=16384;o?e.MAX_TEXTURE_SIZE=i=o.getParameter(o.MAX_TEXTURE_SIZE):console.log(\"Unable to initialize WebGL. Your browser may not support it.\"),e.MAX_TEXTURE_SIZE=i},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(67),l=r(u),c=function(t){function e(){o(this,e);var t=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.inputTransformProgram=t.webgl.createProgram(n(612)),t.mainProgram=t.webgl.createProgram(n(611)),t}return a(e,t),s(e,[{key:\"_bindInputTexturesInputTransform\",value:function(t,n,r){var o=this.webgl.context;this.numTextures=3,this._bindInputTexture(this.inputTransformProgram,t.texture,o.TEXTURE0,e.INPUT_TEXTURE_NAME),this._bindInputTexture(this.inputTransformProgram,n.texture,o.TEXTURE1,e.IMAP_ROW_TEXTURE_NAME),this._bindInputTexture(this.inputTransformProgram,r.texture,o.TEXTURE2,e.IMAP_COL_TEXTURE_NAME)}},{key:\"_bindInputTexturesMain\",value:function(t,n,r){var o=this.webgl.context;this.numTextures=3,this._bindInputTexture(this.mainProgram,t.texture,o.TEXTURE0,e.INPUT_TEXTURE_NAME),this._bindInputTexture(this.mainProgram,n.texture,o.TEXTURE1,e.WEIGHTS_TEXTURE_NAME),this._bindInputTexture(this.mainProgram,r.texture,o.TEXTURE2,e.BIAS_TEXTURE_NAME)}},{key:\"_bindUniformsInputTransform\",value:function(t,n){var r=this.webgl.context,o=t.shape[0],i=t.shape[1],a=n.shape[1],s=this.webgl.getPad(i),u=this.webgl.getPad(a);r.uniform1i(r.getUniformLocation(this.inputTransformProgram,e.INPUT_ROWS_UNIFORM_NAME),o),r.uniform1i(r.getUniformLocation(this.inputTransformProgram,e.INPUT_COLS_UNIFORM_NAME),i),r.uniform1i(r.getUniformLocation(this.inputTransformProgram,e.OUTPUT_COLS_UNIFORM_NAME),a),r.uniform1i(r.getUniformLocation(this.inputTransformProgram,e.INPUT_COL_PAD_UNIFORM_NAME),s),r.uniform1i(r.getUniformLocation(this.inputTransformProgram,e.OUTPUT_COL_PAD_UNIFORM_NAME),u)}},{key:\"_bindUniformsMain\",value:function(t,n,r){var o=this.webgl.context,i=n.shape[0],a=t.shape[1],s=this.webgl.getPad(a),u=this.webgl.getPad(i);o.uniform1i(o.getUniformLocation(this.mainProgram,e.INPUT_COLS_UNIFORM_NAME),a),o.uniform1i(o.getUniformLocation(this.mainProgram,e.OUTPUT_COLS_UNIFORM_NAME),i),o.uniform1i(o.getUniformLocation(this.mainProgram,e.INPUT_COL_PAD_UNIFORM_NAME),s),o.uniform1i(o.getUniformLocation(this.mainProgram,e.OUTPUT_COL_PAD_UNIFORM_NAME),u),\"relu\"===r&&o.uniform1i(o.getUniformLocation(this.mainProgram,e.RELU_ACTIVATION_UNIFORM_NAME),1)}},{key:\"_bindOutputTextureInputTransform\",value:function(t,e){var n=t.shape[1],r=this.webgl.getPad(n);this.webgl.bindOutputTexture(t.shape[0],(n+r)/4,e.texture)}},{key:\"_bindOutputTextureMain\",value:function(t,e,n){var r=t.shape[0],o=e.shape[0],i=this.webgl.getPad(o);this.webgl.bindOutputTexture(r,(o+i)/4,n.texture)}},{key:\"transformInput\",value:function(t,e,n){if(e.shape[0]!==n.shape[0]||e.shape[1]!==n.shape[1])throw new Error(\"Invalid indexMappingRow or indexMappingCol weblas tensor shapes.\");this.webgl.selectProgram(this.inputTransformProgram);var r=new weblas.pipeline.Tensor(e.shape,null);return this._bindInputTexturesInputTransform(t,e,n),this._bindUniformsInputTransform(t,e),this._bindOutputTextureInputTransform(e,r),this._compute(),this._unbindInputTextures(),r}},{key:\"call\",value:function(t,e,n,r,o,i){if(o&&i&&(t=this.transformInput(t,o,i)),t.shape[1]!==e.shape[1])throw new Error(\"Invalid input or weights weblas tensor shapes.\");this.webgl.selectProgram(this.mainProgram);var a=t.shape[0],s=e.shape[0],u=new weblas.pipeline.Tensor([a,s],null);return this._bindInputTexturesMain(t,e,n),this._bindUniformsMain(t,e,r),this._bindOutputTextureMain(t,e,u),this._compute(),this._unbindInputTextures(),u}}]),e}(l.default);c.INPUT_TEXTURE_NAME=\"X\",c.WEIGHTS_TEXTURE_NAME=\"W\",c.BIAS_TEXTURE_NAME=\"b\",c.INPUT_ROWS_UNIFORM_NAME=\"inputRows\",c.INPUT_COLS_UNIFORM_NAME=\"inputCols\",c.OUTPUT_COLS_UNIFORM_NAME=\"outputCols\",c.INPUT_COL_PAD_UNIFORM_NAME=\"inputColPad\",c.OUTPUT_COL_PAD_UNIFORM_NAME=\"outputColPad\",c.RELU_ACTIVATION_UNIFORM_NAME=\"relu\",c.IMAP_ROW_TEXTURE_NAME=\"indexMappingRow\",c.IMAP_COL_TEXTURE_NAME=\"indexMappingCol\",e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(67),l=r(u),c=n(188),f=r(c),p=n(129),h=r(p),d={sum:0,mul:1,concat:2,ave:3,max:4},v=function(t){function e(t){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));if(\"concat\"===t)r.program=r.webgl.createProgram(n(614));else{if(!([\"sum\",\"mul\",\"ave\",\"max\"].indexOf(t)>-1))throw new Error(t+\" mode currently not supported in WebGLMerge layer.\");r.program=r.webgl.createProgram(n(613))}return r.mode=t,r.modeCode=d[t],r}return a(e,t),s(e,[{key:\"_bindInputTexturesArray\",value:function(t){if(t.length>this.MAX_NUM_TEXTURES)throw new Error(\"Max number of inputs to WebGLMerge exceeded.\");var n=this.webgl.context;this.numTextures=t.length;for(var r=0;r<t.length;r++)n.activeTexture(n.TEXTURE0+r),n.bindTexture(n.TEXTURE_2D,t[r].texture);var o=n.getUniformLocation(this.program,e.INPUT_TEXTURES_ARRAY_NAME+\"[0]\");n.uniform1iv(o,(0,f.default)(this.numTextures))}},{key:\"_bindUniforms\",value:function(t){var n=this.webgl.context,r=t[0].shape[1],o=this.webgl.getPad(r);if(n.uniform1i(n.getUniformLocation(this.program,e.NUM_INPUTS_UNIFORM_NAME),t.length),n.uniform1i(n.getUniformLocation(this.program,e.OUTPUT_COLS_UNIFORM_NAME),r),n.uniform1i(n.getUniformLocation(this.program,e.OUTPUT_COL_PAD_UNIFORM_NAME),o),\"concat\"===this.mode){var i=t.map(function(t){return t.shape[0]}).reduce(function(t,e){return t.length>1&&(e+=t[t.length-1]),t.push(e),t},[0]).slice(0,-1),a=(0,h.default)(t.map(function(t){return t.shape[0]}));n.uniform1i(n.getUniformLocation(this.program,e.OUTPUT_ROWS_UNIFORM_NAME),a),n.uniform1iv(n.getUniformLocation(this.program,e.INPUT_CHANNEL_START_INDICES_UNIFORM_NAME),i)}else n.uniform1i(n.getUniformLocation(this.program,e.MODE_CODE_UNIFORM_NAME),this.modeCode)}},{key:\"_bindOutputTexture\",value:function(t,e){var n=t[0].shape[0];\"concat\"===this.mode&&(n=(0,h.default)(t.map(function(t){return t.shape[0]})));var r=t[0].shape[1],o=this.webgl.getPad(r);this.webgl.bindOutputTexture(n,(r+o)/4,e.texture)}},{key:\"call\",value:function(t){this.webgl.selectProgram(this.program);var e=void 0;if(\"concat\"===this.mode){if(!t.every(function(e){return e.shape[0]===t[0].shape[0]}))throw new Error(\"Non-concat axis dimension of inputs to WebGLMerge must all be the same.\");var n=t.map(function(t){return t.transpose()}),r=[(0,h.default)(n.map(function(t){return t.shape[0]})),n[0].shape[1]];e=new weblas.pipeline.Tensor(r,null),this.webgl.selectProgram(this.program),this._bindInputTexturesArray(n),this._bindUniforms(n),this._bindOutputTexture(n,e)}else e=new weblas.pipeline.Tensor(t[0].shape,null),this._bindInputTexturesArray(t),this._bindUniforms(t),this._bindOutputTexture(t,e);return this._compute(),this._unbindInputTextures(),\"concat\"===this.mode&&(e=e.transpose()),e}}]),e}(l.default);v.INPUT_TEXTURES_ARRAY_NAME=\"inputs\",v.INPUT_CHANNEL_START_INDICES_UNIFORM_NAME=\"inputChannelStartIndices\",v.NUM_INPUTS_UNIFORM_NAME=\"numInputs\",v.MODE_CODE_UNIFORM_NAME=\"modeCode\",v.OUTPUT_ROWS_UNIFORM_NAME=\"outputRows\",v.OUTPUT_COLS_UNIFORM_NAME=\"outputCols\",v.OUTPUT_COL_PAD_UNIFORM_NAME=\"outputColPad\",e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(67),l=r(u),c=function(t){function e(){o(this,e);var t=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.program=t.webgl.createProgram(n(615)),t}return a(e,t),s(e,[{key:\"_bindInputTextures\",value:function(t,n,r,o,i){var a=this.webgl.context;this.numTextures=5,this._bindInputTexture(this.program,t.texture,a.TEXTURE0,e.INPUT_TEXTURE_NAME),this._bindInputTexture(this.program,o.texture,a.TEXTURE1,e.MEAN_TEXTURE_NAME),this._bindInputTexture(this.program,i.texture,a.TEXTURE2,e.STD_TEXTURE_NAME),this._bindInputTexture(this.program,n.texture,a.TEXTURE3,e.GAMMA_TEXTURE_NAME),this._bindInputTexture(this.program,r.texture,a.TEXTURE4,e.BETA_TEXTURE_NAME)}},{key:\"_bindUniforms\",value:function(t,n){var r=this.webgl.context,o=this.webgl.getPad(t.shape[1]);r.uniform1f(r.getUniformLocation(this.program,e.EPSILON_UNIFORM_NAME),n),r.uniform1i(r.getUniformLocation(this.program,e.OUTPUT_COLS_UNIFORM_NAME),t.shape[1]),r.uniform1i(r.getUniformLocation(this.program,e.OUTPUT_COL_PAD_UNIFORM_NAME),o)}},{key:\"_bindOutputTexture\",value:function(t,e){var n=this.webgl.getPad(t.shape[1]);this.webgl.bindOutputTexture(t.shape[0],(t.shape[1]+n)/4,e.texture)}},{key:\"call\",value:function(t,e,n,r,o,i){this.webgl.selectProgram(this.program);var a=new weblas.pipeline.Tensor(t.shape,null);return this._bindInputTextures(t,n,r,o,i),this._bindUniforms(t,e),this._bindOutputTexture(t,a),this._compute(),this._unbindInputTextures(),a}}]),e}(l.default);c.INPUT_TEXTURE_NAME=\"X\",c.MEAN_TEXTURE_NAME=\"mean\",c.STD_TEXTURE_NAME=\"std\",c.GAMMA_TEXTURE_NAME=\"gamma\",c.BETA_TEXTURE_NAME=\"beta\",c.EPSILON_UNIFORM_NAME=\"epsilon\",c.OUTPUT_COLS_UNIFORM_NAME=\"outputCols\",c.OUTPUT_COL_PAD_UNIFORM_NAME=\"outputColPad\",e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(127),f=r(c),p=function(t){\nfunction e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"InputLayer\";var r=t.shape,a=void 0===r?[]:r;return n.shape=t.batchInputShape&&t.batchInputShape.length?t.batchInputShape.slice(1):a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){if(!(0,f.default)(t.tensor.shape,this.shape))throw new Error(\"[InputLayer] input tensor shape \"+t.tensor.shape+\" does not match specified shape \"+this.shape+\".\");return t}}]),e}(l.default);e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(25),f=r(c),p=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));h.call(n),n.layerClass=\"ELU\";var r=t.alpha,a=void 0===r?1:r;return n.alpha=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){return this._compute(t.tensor,this.alpha),t}}]),e}(l.default),h=function(){this._compute=(0,f.default)({args:[\"array\",\"scalar\"],body:function(t,e){t=Math.max(t,0)+e*(Math.exp(Math.min(t,0))-1)}})};e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(19),f=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"LeakyReLU\";var r=t.alpha,a=void 0===r?.3:r;return n.alpha=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){return(0,c.relu)(t,{alpha:this.alpha}),t}}]),e}(l.default);e.default=f},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(25),f=r(c),p=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n._compute=(0,f.default)({args:[\"array\",\"array\"],body:function(t,e){t=Math.max(t,0)+e*Math.min(t,0)}}),n.layerClass=\"PReLU\",n.params=[\"alphas\"],n}return a(e,t),s(e,[{key:\"call\",value:function(t){return this._compute(t.tensor,this.weights.alphas.tensor),t}}]),e}(l.default);e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(25),f=r(c),p=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n._compute=(0,f.default)({args:[\"array\",\"array\",\"array\"],body:function(t,e,n){t=e*Math.log(1+Math.exp(n*t))}}),n.layerClass=\"ParametricSoftplus\",n.params=[\"alphas\",\"betas\"],n}return a(e,t),s(e,[{key:\"call\",value:function(t){return this._compute(t.tensor,this.weights.alphas.tensor,this.weights.betas.tensor),t}}]),e}(l.default);e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(25),f=r(c),p=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n._compute=(0,f.default)({args:[\"array\",\"array\",\"array\",\"array\",\"array\"],body:function(t,e,n,r,o){t=e+Math.min(Math.max(t-e,0),Math.abs(r))+n*Math.min(t-e,0)+Math.max(t-(e+Math.abs(r)),0)*o}}),n.layerClass=\"SReLU\",n.params=[\"t_left\",\"a_left\",\"t_right\",\"a_right\"],n}return a(e,t),s(e,[{key:\"call\",value:function(t){return this._compute(t.tensor,this.weights.t_left.tensor,this.weights.a_left.tensor,this.weights.t_right.tensor,this.weights.a_right.tensor),t}}]),e}(l.default);e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(25),f=r(c),p=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));h.call(n),n.layerClass=\"ThresholdedReLU\";var r=t.theta,a=void 0===r?1:r;return n.theta=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){return this._compute(t.tensor,this.theta),t}}]),e}(l.default),h=function(){this._compute=(0,f.default)({args:[\"array\",\"scalar\"],body:function(t,e){t*=Number(t>e)}})};e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.SReLU=e.ThresholdedReLU=e.ParametricSoftplus=e.ELU=e.PReLU=e.LeakyReLU=void 0;var o=n(203),i=r(o),a=n(204),s=r(a),u=n(202),l=r(u),c=n(205),f=r(c),p=n(207),h=r(p),d=n(206),v=r(d);e.LeakyReLU=i.default,e.PReLU=s.default,e.ELU=l.default,e.ParametricSoftplus=f.default,e.ThresholdedReLU=h.default,e.SReLU=v.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(2),c=r(l),f=n(68),p=r(f),h=n(3),d=r(h),v=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"AtrousConvolution2D\";var r=t.atrousRate,a=void 0===r?[1,1]:r;return n.atrousRate=a,n}return a(e,t),u(e,[{key:\"_calcOutputShape\",value:function(t){var e=t[0],n=t[1],r=s(this.kernelShape,3),o=r[0],i=r[1],a=r[2],u=i+(i-1)*(this.atrousRate[0]-1),l=a+(a-1)*(this.atrousRate[1]-1),c=\"same\"===this.borderMode?Math.floor((e+this.subsample[0]-1)/this.subsample[0]):Math.floor((e-u+this.subsample[0])/this.subsample[0]),f=\"same\"===this.borderMode?Math.floor((n+this.subsample[1]-1)/this.subsample[1]):Math.floor((n-l+this.subsample[1])/this.subsample[1]),p=o,h=\"same\"===this.borderMode?Math.max(0,Math.floor((c-1)*this.subsample[0]+u-e)):0,d=\"same\"===this.borderMode?Math.max(0,Math.floor((f-1)*this.subsample[1]+l-n)):0,v=Math.floor(h/2),m=h-v,_=Math.floor(d/2),g=d-_;this.outputShape=[c,f,p],this.inputPadding=[v,m,_,g]}},{key:\"_im2col\",value:function(t){var e=s(t.tensor.shape,3),n=e[0],r=e[1],o=e[2],i=this.kernelShape[1],a=this.kernelShape[2],u=this.outputShape[0],l=this.outputShape[1],f=u*l,p=i*a*o,h=i+(i-1)*(this.atrousRate[0]-1),v=a+(a-1)*(this.atrousRate[1]-1);this._imColsMat||(this._imColsMat=new c.default([],[f,p]));for(var m=new c.default([],[i,a,o]),_=0,g=0,y=n-h;g<=y;g+=this.subsample[0])for(var b=0,w=r-v;b<=w;b+=this.subsample[1])d.default.assign(m.tensor,t.tensor.hi(g+h,b+v,o).lo(g,b,0).step(this.atrousRate[0],this.atrousRate[1],1)),this._imColsMat.tensor.data.set(m.tensor.data,_),_+=p;return this._useWeblas&&this._imColsMat.createWeblasTensor(),this._imColsMat}}]),e}(p.default);e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(68),f=r(c),p=n(191),h=r(p),d=n(130),v=r(d),m=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Convolution1D\";var r=t.nbFilter,a=void 0===r?1:r,s=t.filterLength,u=void 0===s?1:s,l=t.activation,c=void 0===l?\"linear\":l,p=t.borderMode,h=void 0===p?\"valid\":p,d=t.subsampleLength,v=void 0===d?1:d,m=t.bias,_=void 0===m||m;if(\"valid\"!==h&&\"same\"!==h)throw new Error(n.name+\" [Convolution1D layer] Invalid borderMode.\");n.bias=_,n.params=n.bias?[\"W\",\"b\"]:[\"W\"];var g={nbFilter:a,nbRow:u,nbCol:1,activation:c,borderMode:h,subsample:[v,1],dimOrdering:\"th\",bias:_};return n._conv2dAttrs=g,n._conv2d=new f.default(Object.assign(g,{gpu:t.gpu})),n}return a(e,t),s(e,[{key:\"setWeights\",value:function(t){var e=this._conv2dAttrs,n=e.nbFilter,r=e.nbRow,o=e.nbCol,i=t[0].tensor.shape;if(i[0]!==r||i[1]!==o||i[3]!==n){if(console.warn(\"Using legacy shape of weights\"),!(i[0]===n&(i[2]===r&i[3]===o)))throw new Error(\"Unsupported shape of weights\")}else t[0].tensor=t[0].tensor.transpose(3,2,0,1);this._conv2d.setWeights(t)}},{key:\"call\",value:function(t){t.tensor=(0,v.default)(t.tensor).transpose(0,2,1);var e=this._conv2d.call(t);return t.tensor=(0,h.default)(e.tensor).transpose(1,0,2),t}}]),e}(l.default);e.default=m},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if(\"value\"in o)return o.value;var a=o.get;if(void 0!==a)return a.call(r)},f=n(19),p=o(f),h=n(2),d=r(h),v=n(1),m=r(v),_=n(3),g=r(_),y=n(66),b=r(y),w=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Convolution3D\";var r=t.nbFilter,o=void 0===r?1:r,s=t.kernelDim1,u=void 0===s?1:s,l=t.kernelDim2,c=void 0===l?1:l,f=t.kernelDim3,h=void 0===f?1:f,d=t.activation,v=void 0===d?\"linear\":d,m=t.borderMode,_=void 0===m?\"valid\":m,g=t.subsample,y=void 0===g?[1,1,1]:g,b=t.dimOrdering,w=void 0===b?\"tf\":b,x=t.bias,E=void 0===x||x;if(n.kernelShape=[o,u,c,h],n.activation=v,n.activationFunc=p[v],\"valid\"!==_&&\"same\"!==_)throw new Error(n.name+\" [Convolution3D layer] Invalid borderMode.\");if(n.borderMode=_,n.subsample=y,\"tf\"!==w&&\"th\"!==w)throw new Error(n.name+\" [Convolution3D layer] Only tf and th dim ordering are allowed.\");return n.dimOrdering=w,n.bias=E,n.params=n.bias?[\"W\",\"b\"]:[\"W\"],n.gpu&&weblas&&(n._useWeblas=!0,n._pipelineEnabled=!1),n}return s(e,t),l(e,[{key:\"setWeights\",value:function(t){\"th\"===this.dimOrdering&&(t[0].tensor=t[0].tensor.transpose(2,3,4,1,0)),c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"setWeights\",this).call(this,t),this._wRowsMat=this._w2row(),this._useWeblas&&(this._wRowsMat.createWeblasTensor(),this._wRowsMat._gpuMaxSizeExceeded||(this._wRowsMat.weblasTensor=this._wRowsMat.weblasTensor.transpose()),this.bias?this.weights.b.createWeblasTensor():(this._zerosVec=new d.default([],[this.weights.W.tensor.shape[4]]),this._zerosVec.createWeblasTensor()))}},{key:\"_calcOutputShape\",value:function(t){var e=t.tensor.shape[0],n=t.tensor.shape[1],r=t.tensor.shape[2],o=u(this.kernelShape,4),i=o[0],a=o[1],s=o[2],l=o[3],c=\"same\"===this.borderMode?Math.floor((e+this.subsample[0]-1)/this.subsample[0]):Math.floor((e-a+this.subsample[0])/this.subsample[0]),f=\"same\"===this.borderMode?Math.floor((n+this.subsample[1]-1)/this.subsample[1]):Math.floor((n-s+this.subsample[1])/this.subsample[1]),p=\"same\"===this.borderMode?Math.floor((r+this.subsample[2]-1)/this.subsample[2]):Math.floor((r-l+this.subsample[2])/this.subsample[2]),h=i,d=\"same\"===this.borderMode?Math.max(0,Math.floor((c-1)*this.subsample[0]+a-e)):0,v=\"same\"===this.borderMode?Math.max(0,Math.floor((f-1)*this.subsample[1]+s-n)):0,m=\"same\"===this.borderMode?Math.max(0,Math.floor((p-1)*this.subsample[2]+l-r)):0,_=Math.floor(d/2),g=d-_,y=Math.floor(v/2),b=v-y,w=Math.floor(m/2),x=m-w;this.outputShape=[c,f,p,h],this.inputPadding=[_,g,y,b,w,x]}},{key:\"_padInput\",value:function(t){if(\"same\"===this.borderMode){var e=u(t.tensor.shape,4),n=e[0],r=e[1],o=e[2],i=e[3],a=u(this.inputPadding,6),s=a[0],l=a[1],c=a[2],f=a[3],p=a[4],h=a[5],v=n+s+l,m=r+c+f,_=o+p+h,y=new d.default([],[v,m,_,i]);g.default.assign(y.tensor.hi(n+s,r+c,o+p,i).lo(s,c,p,0),t.tensor),t.tensor=y.tensor}return t}},{key:\"_vol2col\",value:function(t){var e=u(t.tensor.shape,4),n=e[0],r=e[1],o=e[2],i=e[3],a=this.kernelShape[1],s=this.kernelShape[2],l=this.kernelShape[3],c=this.outputShape[0],f=this.outputShape[1],p=this.outputShape[2],h=c*f*p,v=a*s*l*i;if(this._volColsMat||(this._volColsMat=new d.default([],[h,v])),1===a&&1===s&&1===l&&1===this.subsample[0]&&1===this.subsample[1]&&1===this.subsample[2])return this._volColsMat.replaceTensorData(t.tensor.data),this._useWeblas&&this._volColsMat.createWeblasTensor(),this._volColsMat;for(var m=new d.default([],[a,s,l,i]),_=0,y=0,b=n-a;y<=b;y+=this.subsample[0])for(var w=0,x=r-s;w<=x;w+=this.subsample[1])for(var E=0,T=o-l;E<=T;E+=this.subsample[2])g.default.assign(m.tensor,t.tensor.hi(y+a,w+s,E+l,i).lo(y,w,E,0)),this._volColsMat.tensor.data.set(m.tensor.data,_),_+=v;return this._useWeblas&&this._volColsMat.createWeblasTensor(),this._volColsMat}},{key:\"_w2row\",value:function(){for(var t=this.weights.W.tensor.shape[3],e=u(this.kernelShape,4),n=e[0],r=e[1],o=e[2],i=e[3],a=r*o*i*t,s=new d.default([],[a,n]),l=new d.default([],[r,o,i,t]),c=new d.default([],[a]),f=0;f<n;f++)g.default.assign(l.tensor,this.weights.W.tensor.pick(null,null,null,null,f)),c.replaceTensorData(l.tensor.data),g.default.assign(s.tensor.pick(null,f),c.tensor);return s}},{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,3,0)),this._calcOutputShape(t),this._padInput(t),this._vol2col(t);var e=this.kernelShape[0],n=this.outputShape[0],r=this.outputShape[1],o=this.outputShape[2],i=n*r*o,a=new d.default([],[i,e]);if(!this._useWeblas||this._volColsMat._gpuMaxSizeExceeded||this._wRowsMat._gpuMaxSizeExceeded){if(this.bias)for(var s=0;s<e;s++)g.default.assigns(a.tensor.pick(null,s),this.weights.b.tensor.get(s));(0,b.default)(a.tensor,this._volColsMat.tensor,this._wRowsMat.tensor,1,1)}else{var u=this.bias?this.weights.b.weblasTensor:this._zerosVec.weblasTensor;a.tensor.data=weblas.pipeline.sgemm(1,this._volColsMat.weblasTensor,this._wRowsMat.weblasTensor,1,u).transfer()}for(var l=new d.default([],this.outputShape),c=new d.default([],[n*r*o]),f=new d.default([],[n,r,o]),p=0;p<e;p++)g.default.assign(c.tensor,a.tensor.pick(null,p)),f.replaceTensorData(c.tensor.data),g.default.assign(l.tensor.pick(null,null,null,p),f.tensor);return t.tensor=l.tensor,this.activationFunc(t),\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(3,0,1,2)),t}}]),e}(m.default);e.default=w},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Cropping1D\";var r=t.cropping,a=void 0===r?[0,0]:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.cropping=a,n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){var e=t.tensor.shape,n=[e[0]-this.cropping[0]-this.cropping[1],e[1]],r=new f.default([],n);return h.default.assign(r.tensor,t.tensor.hi(e[0]-this.cropping[1],e[2]).lo(this.cropping[0],0)),t.tensor=r.tensor,t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Cropping2D\";var r=t.cropping,a=void 0===r?[[0,0],[0,0]]:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.cropping=a,n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0));var e=t.tensor.shape,n=[e[0]-this.cropping[0][0]-this.cropping[0][1],e[1]-this.cropping[1][0]-this.cropping[1][1],e[2]],r=new f.default([],n);return h.default.assign(r.tensor,t.tensor.hi(e[0]-this.cropping[0][1],e[1]-this.cropping[1][1],e[2]).lo(this.cropping[0][0],this.cropping[1][0],0)),t.tensor=r.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(2,0,1)),t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Cropping3D\";var r=t.cropping,a=void 0===r?[[0,0],[0,0],[0,0]]:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.cropping=a,n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,3,0));var e=t.tensor.shape,n=[e[0]-this.cropping[0][0]-this.cropping[0][1],e[1]-this.cropping[1][0]-this.cropping[1][1],e[2]-this.cropping[2][0]-this.cropping[2][1],e[3]],r=new f.default([],n);return h.default.assign(r.tensor,t.tensor.hi(e[0]-this.cropping[0][1],e[1]-this.cropping[1][1],e[2]-this.cropping[2][1],e[3]).lo(this.cropping[0][0],this.cropping[1][0],this.cropping[2][0],0)),t.tensor=r.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(3,0,1,2)),t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if(\"value\"in o)return o.value;var a=o.get;if(void 0!==a)return a.call(r)},f=n(19),p=o(f),h=n(2),d=r(h),v=n(1),m=r(v),_=n(3),g=r(_),y=n(66),b=r(y),w=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Deconvolution2D\";var r=t.nbFilter,o=void 0===r?1:r,s=t.nbRow,u=void 0===s?1:s,l=t.nbCol,c=void 0===l?1:l,f=t.outputShape,h=void 0===f?[]:f,d=t.activation,v=void 0===d?\"linear\":d,m=t.borderMode,_=void 0===m?\"valid\":m,g=t.subsample,y=void 0===g?[1,1]:g,b=t.dimOrdering,w=void 0===b?\"tf\":b,x=t.bias,E=void 0===x||x;if(n.kernelShape=[o,u,c],null==h[0]?n.outputShape=h.slice(1):n.outputShape=h,n.activation=v,n.activationFunc=p[v],\"valid\"!==_&&\"same\"!==_)throw new Error(n.name+\" [Deconvolution2D layer] Invalid borderMode.\");if(n.borderMode=_,n.subsample=y,\"tf\"!==w&&\"th\"!==w)throw new Error(n.name+\" [Deconvolution2D layer] Only tf and th dim ordering are allowed.\");return n.dimOrdering=w,n.bias=E,n.params=n.bias?[\"W\",\"b\"]:[\"W\"],n.gpu&&weblas&&(n._useWeblas=!0,n._pipelineEnabled=!1),n}return s(e,t),l(e,[{key:\"setWeights\",value:function(t){\"th\"===this.dimOrdering&&(t[0].tensor=t[0].tensor.transpose(2,3,1,0)),c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"setWeights\",this).call(this,t),this._wRowsMat=this._w2row(),this._useWeblas&&(this._wRowsMat.createWeblasTensor(),this._wRowsMat._gpuMaxSizeExceeded||(this._wRowsMat.weblasTensor=this._wRowsMat.weblasTensor.transpose()))}},{key:\"_calcOutputPadding\",value:function(t){var e=t.tensor.shape[0],n=t.tensor.shape[1],r=this.kernelShape[1],o=this.kernelShape[2],i=this.outputShape[0],a=this.outputShape[1],s=\"same\"===this.borderMode?Math.max(0,Math.floor((e-1)*this.subsample[0]+r-i)):0,u=\"same\"===this.borderMode?Math.max(0,Math.floor((n-1)*this.subsample[1]+o-a)):0,l=Math.floor(s/2),c=s-l,f=Math.floor(u/2),p=u-f;this.outputPadding=[l,c,f,p]}},{key:\"_im2col\",value:function(t){for(var e=u(t.tensor.shape,3),n=e[0],r=e[1],o=e[2],i=new d.default([],[n*r,o]),a=new d.default([],[n*r]),s=new d.default([],[n,r]),l=0;l<o;l++)g.default.assign(s.tensor,t.tensor.pick(null,null,l)),a.replaceTensorData(s.tensor.data),g.default.assign(i.tensor.pick(null,l),a.tensor);return i}},{key:\"_w2row\",value:function(){for(var t=u(this.weights.W.tensor.shape,4),e=t[0],n=t[1],r=t[2],o=t[3],i=new d.default([],[r,e*n*o]),a=new d.default([],[e*n*o]),s=new d.default([],[e,n,o]),l=0;l<r;l++)g.default.assign(s.tensor,this.weights.W.tensor.pick(null,null,l,null)),a.replaceTensorData(s.tensor.data),g.default.assign(i.tensor.pick(l,null),a.tensor);return i}},{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0));\nvar e=this._im2col(t);this._useWeblas&&e.createWeblasTensor();var n=t.tensor.shape[0],r=t.tensor.shape[1],o=u(this.kernelShape,3),i=o[0],a=o[1],s=o[2],l=new d.default([],[n*r,a*s*i]);if(!this._useWeblas||e._gpuMaxSizeExceeded||this._wRowsMat._gpuMaxSizeExceeded)(0,b.default)(l.tensor,e.tensor,this._wRowsMat.tensor,1,1);else{var c=new d.default([],[this.weights.W.tensor.shape[3]]);c.createWeblasTensor(),l.tensor.data=weblas.pipeline.sgemm(1,e.weblasTensor,this._wRowsMat.weblasTensor,0,c).transfer(),e.weblasTensor.delete(),delete e.weblasTensor}this._calcOutputPadding(t);var f=u(this.outputPadding,4),p=f[0],h=f[1],v=f[2],m=f[3],_=new d.default([],this.outputShape),y=new d.default([],[this.outputShape[0]+p+h,this.outputShape[1]+v+m,this.outputShape[2]]);if(this.bias)for(var w=0;w<i;w++)g.default.assigns(y.tensor.pick(null,null,w),this.weights.b.tensor.get(w));for(var x=[a,s,i],E=new d.default([],x),T=new d.default([],[a*s*i]),O=0,S=0;S<n;S++)for(var P=0;P<r;P++){g.default.assign(T.tensor,l.tensor.pick(O,null)),E.replaceTensorData(T.tensor.data);var M=S*this.subsample[0],j=P*this.subsample[1];g.default.addeq(y.tensor.hi(M+a,j+s,this.outputShape[2]).lo(M,j,0),E.tensor),O+=1}return g.default.assign(_.tensor,y.tensor.hi(this.outputShape[0]+p,this.outputShape[1]+v,this.outputShape[2]).lo(p,v,0)),t.tensor=_.tensor,this.activationFunc(t),\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(2,0,1)),t}}]),e}(m.default);e.default=w},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(19),f=o(c),p=n(2),h=r(p),d=n(1),v=r(d),m=n(68),_=r(m),g=n(3),y=r(g),b=n(66),w=r(b),x=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return i(this,e),a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t))}return s(e,t),l(e,[{key:\"_im2col\",value:function(t){var e=u(t.tensor.shape,3),n=e[0],r=e[1],o=e[2],i=this.kernelShape[1],a=this.kernelShape[2],s=this.outputShape[0],l=this.outputShape[1],c=s*l,f=i*a;this._imColsMat||(this._imColsMat=new h.default([],[c*o,f]));for(var p=new h.default([],[i,a,1]),d=0,v=0;v<o;v++)for(var m=0,_=n-i;m<=_;m+=this.subsample[0])for(var g=0,b=r-a;g<=b;g+=this.subsample[1])y.default.assign(p.tensor,t.tensor.hi(m+i,g+a,v+1).lo(m,g,v)),this._imColsMat.tensor.data.set(p.tensor.data,d),d+=f;return this._useWeblas&&this._imColsMat.createWeblasTensor(),this._imColsMat}},{key:\"_w2row\",value:function(){var t=this.weights.W.tensor.shape[2],e=u(this.kernelShape,3),n=e[0],r=e[1],o=e[2],i=r*o;this._wRowsMat=new h.default([],[i,n*t]);for(var a=new h.default([],[r,o]),s=new h.default([],[i]),l=0,c=0;c<t;c++)for(var f=0;f<n;f++)y.default.assign(a.tensor,this.weights.W.tensor.pick(null,null,c,f)),s.replaceTensorData(a.tensor.data),y.default.assign(this._wRowsMat.tensor.pick(null,l),s.tensor),l+=1;return this._wRowsMat}},{key:\"call\",value:function(t){this._calcOutputShape(t.tensor.shape),this._padInput(t),this._im2col(t);var e=this.kernelShape[0],n=this.outputShape[0],r=this.outputShape[1],o=n*r,i=new h.default([],[o*t.tensor.shape[2],e*t.tensor.shape[2]]);!this._useWeblas||this._imColsMat._gpuMaxSizeExceeded||this._wRowsMat._gpuMaxSizeExceeded?(0,w.default)(i.tensor,this._imColsMat.tensor,this._wRowsMat.tensor,1,1):i.tensor.data=weblas.pipeline.sgemm(1,this._imColsMat.weblasTensor,this._wRowsMat.weblasTensor,1,this._zerosVec.weblasTensor).transfer();for(var a=new h.default([],[n,r,t.tensor.shape[2]*e]),s=n*r*t.tensor.shape[2]*e,u=new Float32Array(s),l=0;l<t.tensor.shape[2];l++)for(var c=0,f=l*s+l*e,p=(l+1)*s;f<p;c++,f+=e*t.tensor.shape[2])for(var d=0;d<e;d++)u[f+d-l*s]=i.tensor.data[f+d];return a.replaceTensorData(u),t.tensor=a.tensor,t}}]),e}(_.default),E=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"SeparableConvolution2D\";var r=t.nbFilter,o=void 0===r?1:r,s=t.nbRow,u=void 0===s?1:s,l=t.nbCol,c=void 0===l?1:l,p=t.activation,h=void 0===p?\"linear\":p,d=t.borderMode,v=void 0===d?\"valid\":d,m=t.subsample,_=void 0===m?[1,1]:m,g=t.depthMultiplier,y=void 0===g?1:g,b=t.dimOrdering,w=void 0===b?\"tf\":b,x=t.bias,E=void 0===x||x;if(n.activation=h,n.activationFunc=f[h],\"valid\"!==v&&\"same\"!==v)throw new Error(n.name+\" [SeparableConvolution2D layer] Invalid borderMode.\");if(n.borderMode=v,n.subsample=_,n.depthMultiplier=y,\"tf\"!==w&&\"th\"!==w)throw new Error(n.name+\" [SeparableConvolution2D layer] Only tf and th dim ordering are allowed.\");return n.dimOrdering=w,n.bias=E,n.params=n.bias?[\"depthwise_kernel\",\"pointwise_kernel\",\"b\"]:[\"depthwise_kernel\",\"pointwise_kernel\"],n.depthwiseConvAttrs={nbFilter:n.depthMultiplier,nbRow:u,nbCol:c,activation:\"linear\",borderMode:v,subsample:_,dimOrdering:w,bias:!1,gpu:t.gpu},n.pointwiseConvAttrs={nbFilter:o,nbRow:1,nbCol:1,activation:\"linear\",borderMode:v,subsample:[1,1],dimOrdering:w,bias:n.bias,gpu:t.gpu},n}return s(e,t),l(e,[{key:\"setWeights\",value:function(t){this._depthwiseConv=new x(this.depthwiseConvAttrs),this._depthwiseConv.setWeights(t.slice(0,1)),this._pointwiseConv=new _.default(this.pointwiseConvAttrs),this._pointwiseConv.setWeights(t.slice(1,3))}},{key:\"call\",value:function(t){var e=this._depthwiseConv.call(t),n=this._pointwiseConv.call(e);return t.tensor=n.tensor,this.activationFunc(t),t}}]),e}(v.default);e.default=E},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"UpSampling1D\";var r=t.length,a=void 0===r?2:r;return n.length=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){for(var e=t.tensor.shape,n=[e[0]*this.length,e[1]],r=new f.default([],n),o=0;o<this.length;o++)h.default.assign(r.tensor.lo(o,0).step(this.length,1),t.tensor);return t.tensor=r.tensor,t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"UpSampling2D\";var r=t.size,a=void 0===r?[2,2]:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.size=a,n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0));for(var e=t.tensor.shape,n=[e[0]*this.size[0],e[1]*this.size[1],e[2]],r=new f.default([],n),o=0;o<this.size[0];o++)for(var i=0;i<this.size[1];i++)h.default.assign(r.tensor.lo(o,i,0).step(this.size[0],this.size[1],1),t.tensor);return t.tensor=r.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(2,0,1)),t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"UpSampling3D\";var r=t.size,a=void 0===r?[2,2,2]:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.size=a,n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,3,0));for(var e=t.tensor.shape,n=[e[0]*this.size[0],e[1]*this.size[1],e[2]*this.size[2],e[3]],r=new f.default([],n),o=0;o<this.size[0];o++)for(var i=0;i<this.size[1];i++)for(var a=0;a<this.size[2];a++)h.default.assign(r.tensor.lo(o,i,a,0).step(this.size[0],this.size[1],this.size[2],1),t.tensor);return t.tensor=r.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(3,0,1,2)),t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"ZeroPadding1D\";var r=t.padding,a=void 0===r?1:r;return n.padding=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){var e=t.tensor.shape,n=[e[0]+2*this.padding,e[1]],r=new f.default([],n);return h.default.assign(r.tensor.hi(e[0]+this.padding,e[1]).lo(this.padding,0),t.tensor),t.tensor=r.tensor,t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"ZeroPadding2D\";var r=t.padding,a=void 0===r?[1,1]:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.padding=a,n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0));var e=t.tensor.shape,n=[e[0]+2*this.padding[0],e[1]+2*this.padding[1],e[2]],r=new f.default([],n);return h.default.assign(r.tensor.hi(e[0]+this.padding[0],e[1]+this.padding[1],e[2]).lo(this.padding[0],this.padding[1],0),t.tensor),t.tensor=r.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(2,0,1)),t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"ZeroPadding3D\";var r=t.padding,a=void 0===r?[1,1,1]:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.padding=a,n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,3,0));var e=t.tensor.shape,n=[e[0]+2*this.padding[0],e[1]+2*this.padding[1],e[2]+2*this.padding[2],e[3]],r=new f.default([],n);return h.default.assign(r.tensor.hi(e[0]+this.padding[0],e[1]+this.padding[1],e[2]+this.padding[2],e[3]).lo(this.padding[0],this.padding[1],this.padding[2],0),t.tensor),t.tensor=r.tensor,\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(3,0,1,2)),t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.Cropping3D=e.Cropping2D=e.Cropping1D=e.ZeroPadding3D=e.ZeroPadding2D=e.ZeroPadding1D=e.UpSampling3D=e.UpSampling2D=e.UpSampling1D=e.Convolution3D=e.Deconvolution2D=e.SeparableConvolution2D=e.AtrousConvolution2D=e.Convolution2D=e.Convolution1D=void 0;var o=n(210),i=r(o),a=n(68),s=r(a),u=n(209),l=r(u),c=n(216),f=r(c),p=n(215),h=r(p),d=n(211),v=r(d),m=n(217),_=r(m),g=n(218),y=r(g),b=n(219),w=r(b),x=n(220),E=r(x),T=n(221),O=r(T),S=n(222),P=r(S),M=n(212),j=r(M),A=n(213),C=r(A),k=n(214),R=r(k);e.Convolution1D=i.default,e.Convolution2D=s.default,e.AtrousConvolution2D=l.default,e.SeparableConvolution2D=f.default,e.Deconvolution2D=h.default,e.Convolution3D=v.default,e.UpSampling1D=_.default,e.UpSampling2D=y.default,e.UpSampling3D=w.default,e.ZeroPadding1D=E.default,e.ZeroPadding2D=O.default,e.ZeroPadding3D=P.default,e.Cropping1D=j.default,e.Cropping2D=C.default,e.Cropping3D=R.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(19),c=o(l),f=n(1),p=r(f),h=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Activation\";var r=t.activation,o=void 0===r?\"linear\":r;return n.activation=o,n.activationFunc=c[o],n}return s(e,t),u(e,[{key:\"call\",value:function(t){return this.activationFunc(t),t}}]),e}(p.default);e.default=h},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if(\"value\"in o)return o.value;var a=o.get;if(void 0!==a)return a.call(r)},c=n(19),f=o(c),p=n(2),h=r(p),d=n(1),v=r(d),m=n(56),_=n(3),g=r(_),y=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Dense\";var r=t.outputDim,o=void 0===r?1:r,s=t.activation,u=void 0===s?\"linear\":s,l=t.inputDim,c=void 0===l?null:l,p=t.bias,h=void 0===p||p;return n.activation=u,n.activationFunc=f[u],n.outputDim=o,n.inputDim=c,n.bias=h,n.params=n.bias?[\"W\",\"b\"]:[\"W\"],n.inputDim&&(n.inputShape=[n.inputDim]),n.gpu&&weblas&&(n._useWeblas=!0,n._pipelineEnabled=!1),n}return s(e,t),u(e,[{key:\"setWeights\",value:function(t){l(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"setWeights\",this).call(this,t),this._useWeblas&&(this.weights.W.createWeblasTensor(),this.weights.W._gpuMaxSizeExceeded||(this.weights.W.weblasTensor=this.weights.W.weblasTensor.transpose()),this.bias?this.weights.b.createWeblasTensor():(this._zerosVec=new h.default([],[this.weights.W.tensor.shape[1]]),this._zerosVec.createWeblasTensor()))}},{key:\"call\",value:function(t){var e=new h.default([],[this.outputDim]);if(this._useWeblas&&t.createWeblasTensor(),!this._useWeblas||t._gpuMaxSizeExceeded||this.weights.W._gpuMaxSizeExceeded)this.bias&&g.default.assign(e.tensor,this.weights.b.tensor),(0,m.gemv)(1,this.weights.W.tensor.transpose(1,0),t.tensor,1,e.tensor);else{var n=this.bias?this.weights.b.weblasTensor:this._zerosVec.weblasTensor;e.tensor.data=weblas.pipeline.sgemm(1,t.weblasTensor,this.weights.W.weblasTensor,1,n).transfer()}return t.tensor=e.tensor,this.activationFunc(t),t}}]),e}(v.default);e.default=y},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Dropout\";var r=t.p,a=void 0===r?.5:r;return n.p=Math.min(Math.max(0,a),1),n}return a(e,t),s(e,[{key:\"call\",value:function(t){return t}}]),e}(l.default);e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(2),l=r(u),c=n(1),f=r(c),p=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.layerClass=\"Flatten\",n}return a(e,t),s(e,[{key:\"call\",value:function(t){if(t.tensor.shape.length>1){var e=new l.default([],[t.tensor.shape.reduce(function(t,e){return t*e},1)]);e.replaceTensorData(t.tensor.data),t.tensor=e.tensor}return t}}]),e}(f.default);e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(19),c=o(l),f=n(2),p=r(f),h=n(1),d=r(h),v=n(56),m=n(3),_=r(m),g=n(25),y=r(g),b=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n._computeOutput=(0,y.default)({args:[\"array\",\"array\",\"array\"],body:function(t,e,n){t=e*n+(1-n)*t}}),n.layerClass=\"Highway\";var r=t.transformBias,o=void 0===r?-2:r,s=t.activation,u=void 0===s?\"linear\":s,l=t.bias,f=void 0===l||l;return n.transformBias=o,n.activation=u,n.activationFunc=c[u],n.bias=f,n.params=n.bias?[\"W\",\"b\",\"W_carry\",\"b_carry\"]:[\"W\",\"W_carry\"],n}return s(e,t),u(e,[{key:\"call\",value:function(t){var e=new p.default([],[this.weights.W.tensor.shape[1]]);this.bias&&_.default.assign(e.tensor,this.weights.b.tensor),(0,v.gemv)(1,this.weights.W.tensor.transpose(1,0),t.tensor,1,e.tensor),this.activationFunc(e);var n=new p.default([],[this.weights.W_carry.tensor.shape[1]]);return this.bias&&_.default.assign(n.tensor,this.weights.b_carry.tensor),(0,v.gemv)(1,this.weights.W_carry.tensor.transpose(1,0),t.tensor,1,n.tensor),c.sigmoid(n),this._computeOutput(t.tensor,e.tensor,n.tensor),t}}]),e}(d.default);e.default=b},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(2),l=r(u),c=n(1),f=r(c),p=n(56),h=n(3),d=r(h),v=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"MaxoutDense\";var r=t.outputDim,a=void 0===r?1:r,s=t.inputDim,u=void 0===s?null:s,l=t.bias,c=void 0===l||l;return n.outputDim=a,n.inputDim=u,n.bias=c,n.params=n.bias?[\"W\",\"b\"]:[\"W\"],n}return a(e,t),s(e,[{key:\"call\",value:function(t){for(var e=this.weights.W.tensor.shape[0],n=new l.default([],[this.outputDim]),r=0;r<e;r++){var o=new l.default([],[this.outputDim]);this.bias&&d.default.assign(o.tensor,this.weights.b.tensor.pick(r,null)),(0,p.gemv)(1,this.weights.W.tensor.pick(r,null,null).transpose(1,0),t.tensor,1,o.tensor),d.default.maxeq(n.tensor,o.tensor)}return t.tensor=n.tensor,t}}]),e}(f.default);e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(2),c=r(l),f=n(1),p=r(f),h=n(66),d=r(h),v=n(3),m=r(v),_=n(130),g=r(_),y=n(608),b=r(y),w=n(127),x=r(w),E=n(188),T=r(E),O=n(129),S=r(O),P=n(57),M=r(P),j=n(199),A=r(j),C=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Merge\";var r=t.mode,o=void 0===r?\"sum\":r,s=t.concatAxis,u=void 0===s?-1:s,l=t.dotAxes,c=void 0===l?-1:l,f=t.outputShape,p=void 0===f?null:f,h=t.outputMask,d=void 0===h?null:h,v=[\"sum\",\"mul\",\"concat\",\"ave\",\"cos\",\"dot\",\"max\"];if(!(v.indexOf(o)>-1))throw new Error(n.name+\" [Merge layer] \"+o+\" not available.\");if(n.mode=o,n.concatAxis=u<=0?u:u-1,Array.isArray(c)?n.dotAxes=[c[0]<=0?c[0]:c[0]-1,c[1]<=0?c[1]:c[1]-1]:n.dotAxes=[c<=0?c:c-1,c<=0?c:c-1],n.outputShape=p,n.outputMask=d,n.gpu&&weblas&&(n._useWeblas=!0,n.pipeline)){var m=(0,M.default)(n.layerClass,t);m?(n._pipelineEnabled=!0,n.webglMerge=new A.default(n.mode)):n._pipelineEnabled=!1}return n}return s(e,t),u(e,[{key:\"_validateInputs\",value:function(t){var e=this,n=t.map(function(t){return t.tensor.shape.slice()});if([\"sum\",\"mul\",\"ave\",\"cos\",\"max\"].indexOf(this.mode)>-1&&!n.every(function(t){return(0,x.default)(t,n[0])}))throw new Error(this.name+\" [Merge layer] All input shapes must be the same for mode \"+this.mode+\".\");if([\"cos\",\"dot\"].indexOf(this.mode)>-1){if(2!==t.length)throw new Error(this.name+\" [Merge layer] Exactly 2 inputs required for mode \"+this.mode+\".\");if(this.dotAxes[0]<0&&(this.dotAxes[0]=n[0].length+this.dotAxes[0]),this.dotAxes[1]<0&&(this.dotAxes[1]=n[1].length+this.dotAxes[1]),n[0][this.dotAxes[0]]!==n[1][this.dotAxes[1]])throw new Error(this.name+\" [Merge layer] Dimensions incompatibility using dot mode.\");\n}else\"concat\"===this.mode&&!function(){var t=n.slice(),r=e.concatAxis<0?t[0].length+e.concatAxis:e.concatAxis;if(0===e.concatAxis&&(r=0),(0,T.default)(t.length).forEach(function(e){t[e].splice(r,1)}),!t.every(function(e){return(0,x.default)(e,t[0])}))throw new Error(e.name+\" [Merge layer] In concat mode, all shapes must be the same except along the concat axis.\")}();return!0}},{key:\"_callPipelineMode\",value:function(t){if(!t.every(function(t){return t._fromPipeline}))return this._callRegularMode(t);var e=new c.default([],t[0].weblasTensor.shape);return e.weblasTensor=this.webglMerge.call(t.map(function(t){return t.weblasTensor})),e._fromPipeline=!0,e._actualShape=t[0]._actualShape,\"concat\"===this.mode&&(e._actualShape=[].concat(o(t[0]._actualShape.slice(0,-1)),[(0,S.default)(t.map(function(t){return t._actualShape.slice(-1)[0]}))])),e}},{key:\"_callRegularMode\",value:function(t){var e=this,n=this._validateInputs(t);if(!n)throw new Error(this.name+\" [Merge layer] Invalid inputs to call method.\");var r=void 0,o=void 0;if([\"sum\",\"mul\",\"ave\",\"max\"].indexOf(this.mode)>-1)o=t[0].tensor.shape.slice(),r=new c.default([],o);else if(\"concat\"===this.mode)!function(){o=t[0].tensor.shape.slice();var n=e.concatAxis<0?o.length+e.concatAxis:e.concatAxis;0===e.concatAxis&&(n=0),t.slice(1,t.length).forEach(function(t){var e=t.tensor.shape.slice()[n];o[n]+=e}),r=new c.default([],o)}();else if([\"cos\",\"dot\"].indexOf(this.mode)>-1){var i=t[0].tensor.shape.slice(),a=t[1].tensor.shape.slice();i.splice(this.dotAxes[0],1),a.splice(this.dotAxes[1],1),o=i.concat(a),1===o.length&&o.push(1),r=new c.default([],o)}if(\"sum\"===this.mode)for(var s=0;s<t.length;s++)m.default.addeq(r.tensor,t[s].tensor);else if(\"mul\"===this.mode){m.default.assigns(r.tensor,1);for(var u=0;u<t.length;u++)m.default.muleq(r.tensor,t[u].tensor)}else if(\"ave\"===this.mode){for(var l=0;l<t.length;l++)m.default.addeq(r.tensor,t[l].tensor);m.default.divseq(r.tensor,t.length)}else if(\"max\"===this.mode){m.default.assign(r.tensor,t[0].tensor);for(var f=1;f<t.length;f++)m.default.maxeq(r.tensor,t[f].tensor)}else if(\"concat\"===this.mode){var p=this.concatAxis<0?t[0].tensor.shape.length+this.concatAxis:this.concatAxis;0===this.concatAxis&&(p=0),0===p?(0,b.default)(r.tensor,t.map(function(t){return t.tensor})):!function(){for(var e,n=[p],o=0;o<t[0].tensor.shape.length;o++)o!==p&&n.push(o);(0,b.default)((e=r.tensor).transpose.apply(e,n),t.map(function(t){var e;return(e=t.tensor).transpose.apply(e,n)}))}()}else if(\"dot\"===this.mode){if(2!==t[0].tensor.shape.length||2!==t[1].tensor.shape.length)throw new Error(this.name+\" [Merge layer] dot mode for 3+ dim tensors not yet implemented.\");0===this.dotAxes[0]&&0===this.dotAxes[1]?(0,d.default)(r.tensor,t[0].tensor.transpose(1,0),t[1].tensor):1===this.dotAxes[0]&&1===this.dotAxes[1]&&(0,d.default)(r.tensor,t[0].tensor,t[1].tensor.transpose(1,0))}else if(\"cos\"===this.mode){if(2!==t[0].tensor.shape.length||2!==t[1].tensor.shape.length)throw new Error(this.name+\" [Merge layer] cos mode for 3+ dim tensors not yet implemented.\");var h=new c.default([],r.tensor.shape),v=new c.default([],r.tensor.shape);0===this.dotAxes[0]&&0===this.dotAxes[1]?((0,d.default)(h.tensor,t[0].tensor.transpose(1,0),t[0].tensor),(0,d.default)(v.tensor,t[1].tensor.transpose(1,0),t[1].tensor),(0,d.default)(r.tensor,t[0].tensor.transpose(1,0),t[1].tensor)):1===this.dotAxes[0]&&1===this.dotAxes[1]&&((0,d.default)(h.tensor,t[0].tensor,t[0].tensor.transpose(1,0)),(0,d.default)(v.tensor,t[1].tensor,t[1].tensor.transpose(1,0)),(0,d.default)(r.tensor,t[0].tensor,t[1].tensor.transpose(1,0))),m.default.muleq(h.tensor,v.tensor),m.default.sqrteq(h.tensor),m.default.diveq(r.tensor,h.tensor),r.tensor=(0,g.default)(r.tensor,0)}return r}},{key:\"call\",value:function(t){return this._pipelineEnabled?this._callPipelineMode(t):this._callRegularMode(t)}}]),e}(p.default);e.default=C},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(1),c=r(l),f=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Permute\";var r=t.dims,o=void 0===r?[]:r;return n.dims=o.map(function(t){return t-1}),n}return s(e,t),u(e,[{key:\"call\",value:function(t){var e;if(this.dims.length!==t.tensor.shape.length)throw new Error(this.name+\" [Permute layer] The specified dims permutation must match the number of dimensions.\");return t.tensor=(e=t.tensor).transpose.apply(e,o(this.dims)),t}}]),e}(c.default);e.default=f},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(130),f=r(c),p=n(610),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"RepeatVector\";var r=t.n,a=void 0===r?1:r;return n.n=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){if(1!==t.tensor.shape.length)throw new Error(this.name+\" [RepeatVector layer] Only 1D tensor inputs allowed.\");return t.tensor=(0,h.default)((0,f.default)(t.tensor,0),[this.n,1]),t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(2),l=r(u),c=n(1),f=r(c),p=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Reshape\";var r=t.targetShape,a=void 0===r?[]:r;return n.targetShape=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){if(this.targetShape.reduce(function(t,e){return t*e},1)!==t.tensor.size)throw new Error(this.name+\" [Reshape layer] The total size of new array must be unchanged in reshape layer.\");var e=new l.default([],this.targetShape);return e.replaceTensorData(t.tensor.data),t.tensor=e.tensor,t}}]),e}(f.default);e.default=p},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"SpatialDropout2D\";var r=t.p,a=void 0===r?.5:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.p=Math.min(Math.max(0,a),1),n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){return t}}]),e}(l.default);e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"SpatialDropout3D\";var r=t.p,a=void 0===r?.5:r,s=t.dimOrdering,u=void 0===s?\"tf\":s;return n.p=Math.min(Math.max(0,a),1),n.dimOrdering=u,n}return a(e,t),s(e,[{key:\"call\",value:function(t){return t}}]),e}(l.default);e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.MaxoutDense=e.Highway=e.Merge=e.RepeatVector=e.Permute=e.Reshape=e.Flatten=e.SpatialDropout3D=e.SpatialDropout2D=e.Dropout=e.Activation=e.Dense=void 0;var o=n(225),i=r(o),a=n(224),s=r(a),u=n(226),l=r(u),c=n(234),f=r(c),p=n(235),h=r(p),d=n(227),v=r(d),m=n(233),_=r(m),g=n(231),y=r(g),b=n(232),w=r(b),x=n(230),E=r(x),T=n(228),O=r(T),S=n(229),P=r(S);e.Dense=i.default,e.Activation=s.default,e.Dropout=l.default,e.SpatialDropout2D=f.default,e.SpatialDropout3D=h.default,e.Flatten=v.default,e.Reshape=_.default,e.Permute=y.default,e.RepeatVector=w.default,e.Merge=E.default,e.Highway=O.default,e.MaxoutDense=P.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Embedding\";var r=t.inputDim,a=void 0===r?1:r,s=t.outputDim,u=void 0===s?1:s,l=t.inputLength,c=void 0===l?0:l,f=t.maskZero,p=void 0!==f&&f,h=t.dropout,d=void 0===h?0:h;return n.inputDim=a,n.outputDim=u,n.inputLength=c,n.maskZero=p,n.dropout=d,n.params=[\"W\"],n}return a(e,t),s(e,[{key:\"call\",value:function(t){for(var e=new f.default([],[t.tensor.shape[0],this.weights.W.tensor.shape[1]]),n=0,r=t.tensor.shape[0];n<r;n++)h.default.assign(e.tensor.pick(n,null),this.weights.W.tensor.pick(t.tensor.get(n),null));return t.tensor=e.tensor,t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.Embedding=void 0;var o=n(237),i=r(o);e.Embedding=i.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"GaussianDropout\";var r=t.p,a=void 0===r?.5:r;return n.p=Math.min(Math.max(0,a),1),n}return a(e,t),s(e,[{key:\"call\",value:function(t){return t}}]),e}(l.default);e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"GaussianNoise\";t.sigma;return n}return a(e,t),s(e,[{key:\"call\",value:function(t){return t}}]),e}(l.default);e.default=c},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.GaussianNoise=e.GaussianDropout=void 0;var o=n(239),i=r(o),a=n(240),s=r(a);e.GaussianDropout=i.default,e.GaussianNoise=s.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if(\"value\"in o)return o.value;var a=o.get;if(void 0!==a)return a.call(r)},l=n(1),c=r(l),f=n(2),p=r(f),h=n(3),d=r(h),v=n(192),m=r(v),_=n(183),g=r(_),y=n(57),b=r(y),w=n(200),x=r(w),E=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"BatchNormalization\";var r=t.epsilon,a=void 0===r?.001:r,s=t.mode,u=void 0===s?0:s,l=t.axis,c=void 0===l?-1:l;if(n.epsilon=a,n.mode=u,n.axis=c,n.axisNormalized=!1,n.params=0===n.mode?[\"gamma\",\"beta\",\"running_mean\",\"running_std\"]:[\"gamma\",\"beta\"],n.gpu&&weblas&&(n._useWeblas=!0,n.pipeline)){var f=(0,b.default)(n.layerClass,t);f?(n._pipelineEnabled=!0,n.webglBatchNorm=new x.default):n._pipelineEnabled=!1}return n}return a(e,t),s(e,[{key:\"setWeights\",value:function(t){var n=this;u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"setWeights\",this).call(this,t),this._useWeblas&&this.params.forEach(function(t){n.weights[t].createWeblasTensor()})}},{key:\"_callPipelineMode\",value:function(t){return t._fromPipeline?(t.weblasTensor=this.webglBatchNorm.call(t.weblasTensor,this.epsilon,this.weights.gamma.weblasTensor,this.weights.beta.weblasTensor,this.weights.running_mean.weblasTensor,this.weights.running_std.weblasTensor),t):this._callRegularMode(t)}},{key:\"_callRegularMode\",value:function(t){var e=this;this.axisNormalized||(this.axis=this.axis<0?t.tensor.shape.length+this.axis:this.axis-1,this.axisNormalized=!0);for(var n=[],r=0;r<t.tensor.shape.length;r++)r===this.axis?n.push(1):n.push(null);for(var o=new p.default([],t.tensor.shape),i=new p.default([],t.tensor.shape),a=0;a<t.tensor.shape[this.axis];a++){var s,u;n[this.axis]=a,d.default.assigns((s=o.tensor).pick.apply(s,n),this.weights.gamma.tensor.get(a)),d.default.assigns((u=i.tensor).pick.apply(u,n),this.weights.beta.tensor.get(a))}var l=new p.default([],t.tensor.shape),c=new p.default([],t.tensor.shape);if(0===this.mode){for(var f=0;f<t.tensor.shape[this.axis];f++){var h,v;n[this.axis]=f,d.default.assigns((h=l.tensor).pick.apply(h,n),this.weights.running_mean.tensor.get(f)),d.default.assigns((v=c.tensor).pick.apply(v,n),this.weights.running_std.tensor.get(f)+this.epsilon)}d.default.sqrteq(c.tensor)}else if(1===this.mode){var _=t.tensor.shape.slice();_.splice(this.axis,1);for(var y=new p.default([],_),b=0;b<t.tensor.shape[this.axis];b++){var w;n[this.axis]=b,d.default.addeq(y.tensor,(w=t.tensor).pick.apply(w,n))}d.default.divseq(y.tensor,t.tensor.shape[this.axis]);for(var x=new p.default([],_),E=new p.default([],_),T=0;T<t.tensor.shape[this.axis];T++){var O;n[this.axis]=T,d.default.sub(E.tensor,(O=t.tensor).pick.apply(O,n),y.tensor),d.default.powseq(E.tensor,2),d.default.addeq(x.tensor,E.tensor)}d.default.divseq(x.tensor,t.tensor.shape[this.axis]),d.default.addseq(x.tensor,this.epsilon),d.default.sqrteq(x.tensor),d.default.addseq(x.tensor,this.epsilon);for(var S=0;S<t.tensor.shape[this.axis];S++){var P,M;n[this.axis]=S,d.default.assign((P=l.tensor).pick.apply(P,n),y.tensor),d.default.assign((M=c.tensor).pick.apply(M,n),x.tensor)}}else{if(2!==this.mode)throw new Error(\"[normalization.BatchNormalization] Invalid mode \"+this.mode+\".\");for(var j=function(r){var o,i,a;n[e.axis]=r;var s=(0,g.default)((0,m.default)((o=t.tensor).pick.apply(o,n))),u=s.reduce(function(t,e){return t+e},0)/s.length,f=s.map(function(t){return(t-u)*(t-u)}).reduce(function(t,e){return t+e},0)/s.length;d.default.assigns((i=l.tensor).pick.apply(i,n),u),d.default.assigns((a=c.tensor).pick.apply(a,n),f+e.epsilon)},A=0;A<t.tensor.shape[this.axis];A++)j(A);d.default.sqrteq(c.tensor)}return d.default.subeq(t.tensor,l.tensor),d.default.diveq(t.tensor,c.tensor),d.default.muleq(t.tensor,o.tensor),d.default.addeq(t.tensor,i.tensor),t}},{key:\"call\",value:function(t){return this._pipelineEnabled?this._callPipelineMode(t):this._callRegularMode(t)}}]),e}(c.default);e.default=E},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.BatchNormalization=void 0;var o=n(242),i=r(o);e.BatchNormalization=i.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=n(134),u=r(s),l=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.layerClass=\"AveragePooling1D\",n.poolingFunc=\"average\",n}return a(e,t),e}(u.default);e.default=l},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=n(135),u=r(s),l=n(57),c=r(l),f=n(132),p=r(f),h=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));if(n.layerClass=\"AveragePooling2D\",n.poolingFunc=\"average\",n.gpu&&weblas&&(n._useWeblas=!0,n.pipeline)){var r=(0,c.default)(n.layerClass,t);r?(n._pipelineEnabled=!0,n.webglPooling2D=new p.default(n.poolingFunc)):n._pipelineEnabled=!1}return n}return a(e,t),e}(u.default);e.default=h},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=n(136),u=r(s),l=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.layerClass=\"AveragePooling3D\",n.poolingFunc=\"average\",n}return a(e,t),e}(u.default);e.default=l},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(1),c=r(l),f=n(2),p=r(f),h=n(3),d=r(h),v=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.layerClass=\"GlobalAveragePooling1D\",n}return a(e,t),u(e,[{key:\"call\",value:function(t){for(var e=s(t.tensor.shape,2),n=e[0],r=e[1],o=new p.default([],[r]),i=0,a=r;i<a;i++)o.tensor.set(i,d.default.sum(t.tensor.pick(null,i))/n);return t.tensor=o.tensor,t}}]),e}(c.default);e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&s.return&&s.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(1),c=r(l),f=n(2),p=r(f),h=n(3),d=r(h),v=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"GlobalAveragePooling2D\";var r=t.dimOrdering,a=void 0===r?\"tf\":r;return n.dimOrdering=a,n}return a(e,t),u(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0));for(var e=s(t.tensor.shape,3),n=e[0],r=e[1],o=e[2],i=new p.default([],[o]),a=0,u=o;a<u;a++)i.tensor.set(a,d.default.sum(t.tensor.pick(null,null,a))/(n*r));return t.tensor=i.tensor,t}}]),e}(c.default);e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.layerClass=\"GlobalMaxPooling1D\",n}return a(e,t),s(e,[{key:\"call\",value:function(t){for(var e=t.tensor.shape[1],n=new f.default([],[e]),r=0,o=e;r<o;r++)n.tensor.set(r,h.default.sup(t.tensor.pick(null,r)));return t.tensor=n.tensor,t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(1),l=r(u),c=n(2),f=r(c),p=n(3),h=r(p),d=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"GlobalMaxPooling2D\";var r=t.dimOrdering,a=void 0===r?\"tf\":r;return n.dimOrdering=a,n}return a(e,t),s(e,[{key:\"call\",value:function(t){\"th\"===this.dimOrdering&&(t.tensor=t.tensor.transpose(1,2,0));\nfor(var e=t.tensor.shape[2],n=new f.default([],[e]),r=0,o=e;r<o;r++)n.tensor.set(r,h.default.sup(t.tensor.pick(null,null,r)));return t.tensor=n.tensor,t}}]),e}(l.default);e.default=d},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=n(134),u=r(s),l=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.layerClass=\"MaxPooling1D\",n.poolingFunc=\"max\",n}return a(e,t),e}(u.default);e.default=l},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=n(135),u=r(s),l=n(57),c=r(l),f=n(132),p=r(f),h=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));if(n.layerClass=\"MaxPooling2D\",n.poolingFunc=\"max\",n.gpu&&weblas&&(n._useWeblas=!0,n.pipeline)){var r=(0,c.default)(n.layerClass,t);r?(n._pipelineEnabled=!0,n.webglPooling2D=new p.default(n.poolingFunc)):n._pipelineEnabled=!1}return n}return a(e,t),e}(u.default);e.default=h},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function i(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function a(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var s=n(136),u=r(s),l=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.layerClass=\"MaxPooling3D\",n.poolingFunc=\"max\",n}return a(e,t),e}(u.default);e.default=l},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.GlobalAveragePooling2D=e.GlobalMaxPooling2D=e.GlobalAveragePooling1D=e.GlobalMaxPooling1D=e.AveragePooling3D=e.AveragePooling2D=e.AveragePooling1D=e.MaxPooling3D=e.MaxPooling2D=e.MaxPooling1D=void 0;var o=n(251),i=r(o),a=n(252),s=r(a),u=n(253),l=r(u),c=n(244),f=r(c),p=n(245),h=r(p),d=n(246),v=r(d),m=n(249),_=r(m),g=n(247),y=r(g),b=n(250),w=r(b),x=n(248),E=r(x);e.MaxPooling1D=i.default,e.MaxPooling2D=s.default,e.MaxPooling3D=l.default,e.AveragePooling1D=f.default,e.AveragePooling2D=h.default,e.AveragePooling3D=v.default,e.GlobalMaxPooling1D=_.default,e.GlobalAveragePooling1D=y.default,e.GlobalMaxPooling2D=w.default,e.GlobalAveragePooling2D=E.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(19),c=o(l),f=n(2),p=r(f),h=n(1),d=r(h),v=n(56),m=n(3),_=r(m),g=n(25),y=r(g),b=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n._combine=(0,y.default)({args:[\"array\",\"array\",\"array\",\"array\"],body:function(t,e,n,r){t=e+n+r}}),n._update=(0,y.default)({args:[\"array\",\"array\",\"array\"],body:function(t,e,n){t=t*(1-n)+e*n}}),n.layerClass=\"GRU\";var r=t.outputDim,o=void 0===r?1:r,s=t.activation,u=void 0===s?\"tanh\":s,l=t.innerActivation,f=void 0===l?\"hardSigmoid\":l,p=t.returnSequences,h=void 0!==p&&p,d=t.goBackwards,v=void 0!==d&&d,m=t.stateful,_=void 0!==m&&m;return n.outputDim=o,n.activation=u,n.innerActivation=f,n.activationFunc=c[u],n.innerActivationFunc=c[f],n.returnSequences=h,n.goBackwards=v,n.stateful=_,n.params=[\"W_z\",\"U_z\",\"b_z\",\"W_r\",\"U_r\",\"b_r\",\"W_h\",\"U_h\",\"b_h\"],n}return s(e,t),u(e,[{key:\"call\",value:function(t){var e=this,n=new p.default([],[t.tensor.shape[1]]),r=this.weights.b_z.tensor.shape[0],o=this.weights.b_r.tensor.shape[0],i=this.weights.b_h.tensor.shape[0],a=new p.default([],[r]),s=new p.default([],[r]),u=new p.default([],[r]),l=new p.default([],[o]),c=new p.default([],[o]),f=new p.default([],[o]),h=this.stateful&&this.currentHiddenState?this.currentHiddenState:new p.default([],[i]),d=new p.default([],[i]),m=new p.default([],[i]),g=new p.default([],[i]);this.hiddenStateSequence=new p.default([],[t.tensor.shape[0],i]);for(var y=function(){var t=[s,u,c,f,d,m];t.forEach(function(t){return _.default.assigns(t.tensor,0)})},b=function(){_.default.assign(g.tensor,h.tensor),(0,v.gemv)(1,e.weights.W_z.tensor.transpose(1,0),n.tensor,1,s.tensor),(0,v.gemv)(1,e.weights.U_z.tensor.transpose(1,0),g.tensor,1,u.tensor),e._combine(a.tensor,s.tensor,u.tensor,e.weights.b_z.tensor),e.innerActivationFunc(a),(0,v.gemv)(1,e.weights.W_r.tensor.transpose(1,0),n.tensor,1,c.tensor),(0,v.gemv)(1,e.weights.U_r.tensor.transpose(1,0),g.tensor,1,f.tensor),e._combine(l.tensor,c.tensor,f.tensor,e.weights.b_r.tensor),e.innerActivationFunc(l),_.default.muleq(l.tensor,g.tensor),(0,v.gemv)(1,e.weights.W_h.tensor.transpose(1,0),n.tensor,1,d.tensor),(0,v.gemv)(1,e.weights.U_h.tensor.transpose(1,0),l.tensor,1,m.tensor),e._combine(h.tensor,d.tensor,m.tensor,e.weights.b_h.tensor),e.activationFunc(h),e._update(h.tensor,g.tensor,a.tensor)},w=0,x=t.tensor.shape[0];w<x;w++){var E=this.goBackwards?x-w-1:w;_.default.assign(n.tensor,t.tensor.pick(E,null)),y(),b(),this.returnSequences&&_.default.assign(this.hiddenStateSequence.tensor.pick(w,null),h.tensor)}return this.returnSequences?t.tensor=this.hiddenStateSequence.tensor:t.tensor=h.tensor,this.stateful&&(this.currentHiddenState=h),t}}]),e}(d.default);e.default=b},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(19),c=o(l),f=n(2),p=r(f),h=n(1),d=r(h),v=n(56),m=n(3),_=r(m),g=n(25),y=r(g),b=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n._combine=(0,y.default)({args:[\"array\",\"array\",\"array\",\"array\"],body:function(t,e,n,r){t=e+n+r}}),n._update=(0,y.default)({args:[\"array\",\"array\",\"array\",\"array\"],body:function(t,e,n,r){t=t*n+e*r}}),n.layerClass=\"LSTM\";var r=t.outputDim,o=void 0===r?1:r,s=t.activation,u=void 0===s?\"tanh\":s,l=t.innerActivation,f=void 0===l?\"hardSigmoid\":l,p=t.returnSequences,h=void 0!==p&&p,d=t.goBackwards,v=void 0!==d&&d,m=t.stateful,_=void 0!==m&&m;return n.outputDim=o,n.activation=u,n.innerActivation=f,n.activationFunc=c[u],n.innerActivationFunc=c[f],n.returnSequences=h,n.goBackwards=v,n.stateful=_,n.params=[\"W_i\",\"U_i\",\"b_i\",\"W_c\",\"U_c\",\"b_c\",\"W_f\",\"U_f\",\"b_f\",\"W_o\",\"U_o\",\"b_o\"],n}return s(e,t),u(e,[{key:\"call\",value:function(t){var e=this,n=new p.default([],[t.tensor.shape[1]]),r=this.weights.b_i.tensor.shape[0],o=this.weights.b_c.tensor.shape[0],i=this.weights.b_f.tensor.shape[0],a=this.weights.b_o.tensor.shape[0],s=new p.default([],[r]),u=new p.default([],[r]),l=new p.default([],[r]),c=new p.default([],[i]),f=new p.default([],[i]),h=new p.default([],[i]),d=new p.default([],[a]),m=new p.default([],[a]),g=new p.default([],[a]),y=new p.default([],[o]),b=new p.default([],[o]),w=new p.default([],[o]),x=this.stateful&&this.previousCandidate?this.previousCandidate:new p.default([],[o]),E=this.stateful&&this.currentHiddenState?this.currentHiddenState:new p.default([],[o]),T=new p.default([],[o]);this.hiddenStateSequence=new p.default([],[t.tensor.shape[0],o]);for(var O=function(){var t=[u,l,f,h,m,g,b,w];t.forEach(function(t){return _.default.assigns(t.tensor,0)})},S=function(){_.default.assign(T.tensor,E.tensor),(0,v.gemv)(1,e.weights.W_i.tensor.transpose(1,0),n.tensor,1,u.tensor),(0,v.gemv)(1,e.weights.U_i.tensor.transpose(1,0),T.tensor,1,l.tensor),e._combine(s.tensor,u.tensor,l.tensor,e.weights.b_i.tensor),e.innerActivationFunc(s),(0,v.gemv)(1,e.weights.W_f.tensor.transpose(1,0),n.tensor,1,f.tensor),(0,v.gemv)(1,e.weights.U_f.tensor.transpose(1,0),T.tensor,1,h.tensor),e._combine(c.tensor,f.tensor,h.tensor,e.weights.b_f.tensor),e.innerActivationFunc(c),(0,v.gemv)(1,e.weights.W_o.tensor.transpose(1,0),n.tensor,1,m.tensor),(0,v.gemv)(1,e.weights.U_o.tensor.transpose(1,0),T.tensor,1,g.tensor),e._combine(d.tensor,m.tensor,g.tensor,e.weights.b_o.tensor),e.innerActivationFunc(d),(0,v.gemv)(1,e.weights.W_c.tensor.transpose(1,0),n.tensor,1,b.tensor),(0,v.gemv)(1,e.weights.U_c.tensor.transpose(1,0),T.tensor,1,w.tensor),e._combine(y.tensor,b.tensor,w.tensor,e.weights.b_c.tensor),e.activationFunc(y),e._update(y.tensor,x.tensor,s.tensor,c.tensor),_.default.assign(x.tensor,y.tensor),e.activationFunc(y),_.default.mul(E.tensor,d.tensor,y.tensor)},P=0,M=t.tensor.shape[0];P<M;P++){var j=this.goBackwards?M-P-1:P;_.default.assign(n.tensor,t.tensor.pick(j,null)),O(),S(),_.default.assign(this.hiddenStateSequence.tensor.pick(P,null),E.tensor)}return this.returnSequences?t.tensor=this.hiddenStateSequence.tensor:t.tensor=E.tensor,this.stateful&&(this.previousCandidate=x,this.currentHiddenState=E),t}}]),e}(d.default);e.default=b},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(19),c=o(l),f=n(2),p=r(f),h=n(1),d=r(h),v=n(56),m=n(3),_=r(m),g=n(25),y=r(g),b=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n._combine=(0,y.default)({args:[\"array\",\"array\",\"array\",\"array\"],body:function(t,e,n,r){t=e+n+r}}),n.layerClass=\"SimpleRNN\";var r=t.outputDim,o=void 0===r?1:r,s=t.activation,u=void 0===s?\"tanh\":s,l=t.returnSequences,f=void 0!==l&&l,p=t.goBackwards,h=void 0!==p&&p,d=t.stateful,v=void 0!==d&&d;return n.outputDim=o,n.activation=u,n.activationFunc=c[u],n.returnSequences=f,n.goBackwards=h,n.stateful=v,n.params=[\"W\",\"U\",\"b\"],n}return s(e,t),u(e,[{key:\"call\",value:function(t){var e=this,n=new p.default([],[t.tensor.shape[1]]),r=this.weights.b.tensor.shape[0],o=this.stateful&&this.currentHiddenState?this.currentHiddenState:new p.default([],[r]),i=new p.default([],[r]),a=new p.default([],[r]),s=new p.default([],[r]);this.hiddenStateSequence=new p.default([],[t.tensor.shape[0],r]);for(var u=function(){var t=[i,a];t.forEach(function(t){return _.default.assigns(t.tensor,0)})},l=function(){_.default.assign(s.tensor,o.tensor),(0,v.gemv)(1,e.weights.W.tensor.transpose(1,0),n.tensor,1,i.tensor),(0,v.gemv)(1,e.weights.U.tensor.transpose(1,0),s.tensor,1,a.tensor),e._combine(o.tensor,i.tensor,a.tensor,e.weights.b.tensor),e.activationFunc(o)},c=0,f=t.tensor.shape[0];c<f;c++){var h=this.goBackwards?f-c-1:c;_.default.assign(n.tensor,t.tensor.pick(h,null)),u(),l(),this.returnSequences&&_.default.assign(this.hiddenStateSequence.tensor.pick(c,null),o.tensor)}return this.returnSequences?t.tensor=this.hiddenStateSequence.tensor:t.tensor=o.tensor,this.stateful&&(this.currentHiddenState=o),t}}]),e}(d.default);e.default=b},function(t,e,n){\"use strict\";function r(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function o(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(1),c=o(l),f=n(2),p=o(f),h=n(3),d=o(h),v=n(573),m=o(v),_=n(137),g=r(_),y=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"Bidirectional\";var r=t.layer,o=t.mergeMode,s=void 0===o?\"concat\":o;if(!r)throw new Error(\"[Bidirectional] wrapped layer is undefined.\");n.forwardLayer=r;var u=(0,m.default)(r,[\"outputDim\",\"activation\",\"innerActivation\",\"returnSequences\",\"goBackwards\",\"stateful\"]);return u.goBackwards=!u.goBackwards,n.backwardLayer=new g[r.layerClass](u),n.mergeMode=s,n}return s(e,t),u(e,[{key:\"setWeights\",value:function(t){this.forwardLayer.setWeights(t.slice(0,t.length/2)),this.backwardLayer.setWeights(t.slice(t.length/2))}},{key:\"call\",value:function(t){var e=new p.default(t.tensor.data,t.tensor.shape),n=new p.default(t.tensor.data,t.tensor.shape),r=this.forwardLayer.call(e),o=this.backwardLayer.call(n);if(\"concat\"===this.mergeMode){var i=r.tensor.shape.slice();i[i.length-1]+=o.tensor.shape[i.length-1];var a=new p.default([],i);this.forwardLayer.returnSequences?(d.default.assign(a.tensor.hi(i[0],r.tensor.shape[1]).lo(0,0),r.tensor),d.default.assign(a.tensor.hi(i[0],i[1]).lo(0,r.tensor.shape[1]),o.tensor.step(-1))):(d.default.assign(a.tensor.hi(r.tensor.shape[0]).lo(0),r.tensor),d.default.assign(a.tensor.hi(i[0]).lo(r.tensor.shape[0]),o.tensor)),t.tensor=a.tensor}else if(\"sum\"===this.mergeMode){var s=r.tensor.shape.slice(),u=new p.default([],s);d.default.addeq(u.tensor,r.tensor),d.default.addeq(u.tensor,o.tensor),t.tensor=u.tensor}else if(\"mul\"===this.mergeMode){var l=r.tensor.shape.slice(),c=new p.default([],l);d.default.assigns(c.tensor,1),d.default.muleq(c.tensor,r.tensor),d.default.muleq(c.tensor,o.tensor),t.tensor=c.tensor}else if(\"ave\"===this.mergeMode){var f=r.tensor.shape.slice(),h=new p.default([],f);d.default.addeq(h.tensor,r.tensor),d.default.addeq(h.tensor,o.tensor),d.default.divseq(h.tensor,2),t.tensor=h.tensor}return t}}]),e}(c.default);e.default=y},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function a(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function s(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,\"__esModule\",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(1),c=r(l),f=n(2),p=r(f),h=n(3),d=r(h),v=function(t){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));n.layerClass=\"TimeDistributed\";var r=t.layer;if(!r)throw new Error(\"[TimeDistributed] wrapped layer is undefined.\");return n.layer=r,n}return s(e,t),u(e,[{key:\"setWeights\",value:function(t){this.layer.setWeights(t)}},{key:\"call\",value:function(t){var e,n,r=[].concat(o(t.tensor.shape.slice(1))),i=new p.default([],r);d.default.assign(i.tensor,(e=t.tensor).pick.apply(e,[0].concat(o(r.map(function(t){return null})))));var a=this.layer.call(i),s=a.tensor.shape.slice(),u=new p.default([],[t.tensor.shape[0]].concat(o(s)));d.default.assign((n=u.tensor).pick.apply(n,[0].concat(o(s.map(function(t){return null})))),a.tensor);for(var l=1,c=t.tensor.shape[0];l<c;l++){var f,h,v=new p.default([],r);d.default.assign(v.tensor,(f=t.tensor).pick.apply(f,[l].concat(o(r.map(function(t){return null}))))),a=this.layer.call(v),d.default.assign((h=u.tensor).pick.apply(h,[l].concat(o(s.map(function(t){return null})))),a.tensor)}return t.tensor=u.tensor,t}}]),e}(c.default);e.default=v},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,\"__esModule\",{value:!0}),e.Bidirectional=e.TimeDistributed=void 0;var o=n(259),i=r(o),a=n(258),s=r(a);e.TimeDistributed=i.default,e.Bidirectional=s.default},function(t,e,n){\"use strict\";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e-4,r=(0,u.default)((0,a.default)(t)),o=e;if(r.length!==o.length)return!1;for(var i=0;i<r.length;i++){if(!(0,c.default)(r[i]))return!1;if(r[i]<o[i]-n||r[i]>o[i]+n)return!1}return!0}Object.defineProperty(e,\"__esModule\",{value:!0}),e.approxEquals=o;var i=n(192),a=r(i),s=n(183),u=r(s),l=n(570),c=r(l)},function(t,e,n){\"use strict\";function r(t){var e=t.length;if(e%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");return\"=\"===t[e-2]?2:\"=\"===t[e-1]?1:0}function o(t){return 3*t.length/4-r(t)}function i(t){var e,n,o,i,a,s,u=t.length;a=r(t),s=new f(3*u/4-a),o=a>0?u-4:u;var l=0;for(e=0,n=0;e<o;e+=4,n+=3)i=c[t.charCodeAt(e)]<<18|c[t.charCodeAt(e+1)]<<12|c[t.charCodeAt(e+2)]<<6|c[t.charCodeAt(e+3)],s[l++]=i>>16&255,s[l++]=i>>8&255,s[l++]=255&i;return 2===a?(i=c[t.charCodeAt(e)]<<2|c[t.charCodeAt(e+1)]>>4,s[l++]=255&i):1===a&&(i=c[t.charCodeAt(e)]<<10|c[t.charCodeAt(e+1)]<<4|c[t.charCodeAt(e+2)]>>2,s[l++]=i>>8&255,s[l++]=255&i),s}function a(t){return l[t>>18&63]+l[t>>12&63]+l[t>>6&63]+l[63&t]}function s(t,e,n){for(var r,o=[],i=e;i<n;i+=3)r=(t[i]<<16)+(t[i+1]<<8)+t[i+2],o.push(a(r));return o.join(\"\")}function u(t){for(var e,n=t.length,r=n%3,o=\"\",i=[],a=16383,u=0,c=n-r;u<c;u+=a)i.push(s(t,u,u+a>c?c:u+a));return 1===r?(e=t[n-1],o+=l[e>>2],o+=l[e<<4&63],o+=\"==\"):2===r&&(e=(t[n-2]<<8)+t[n-1],o+=l[e>>10],o+=l[e>>4&63],o+=l[e<<2&63],o+=\"=\"),i.push(o),i.join(\"\")}e.byteLength=o,e.toByteArray=i,e.fromByteArray=u;for(var l=[],c=[],f=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,p=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",h=0,d=p.length;h<d;++h)l[h]=p[h],c[p.charCodeAt(h)]=h;c[\"-\".charCodeAt(0)]=62,c[\"_\".charCodeAt(0)]=63},function(t,e,n){\"use strict\";\"use restrict\";function r(t){var e=32;return t&=-t,t&&e--,65535&t&&(e-=16),16711935&t&&(e-=8),252645135&t&&(e-=4),858993459&t&&(e-=2),1431655765&t&&(e-=1),e}var o=32;e.INT_BITS=o,e.INT_MAX=2147483647,e.INT_MIN=-1<<o-1,e.sign=function(t){return(t>0)-(t<0)},e.abs=function(t){var e=t>>o-1;return(t^e)-e},e.min=function(t,e){return e^(t^e)&-(t<e)},e.max=function(t,e){return t^(t^e)&-(t<e)},e.isPow2=function(t){return!(t&t-1||!t)},e.log2=function(t){var e,n;return e=(t>65535)<<4,t>>>=e,n=(t>255)<<3,t>>>=n,e|=n,n=(t>15)<<2,t>>>=n,e|=n,n=(t>3)<<1,t>>>=n,e|=n,e|t>>1},e.log10=function(t){return t>=1e9?9:t>=1e8?8:t>=1e7?7:t>=1e6?6:t>=1e5?5:t>=1e4?4:t>=1e3?3:t>=100?2:t>=10?1:0},e.popCount=function(t){return t-=t>>>1&1431655765,t=(858993459&t)+(t>>>2&858993459),16843009*(t+(t>>>4)&252645135)>>>24},e.countTrailingZeros=r,e.nextPow2=function(t){return t+=0===t,--t,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t+1},e.prevPow2=function(t){return t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t-(t>>>1)},e.parity=function(t){return t^=t>>>16,t^=t>>>8,t^=t>>>4,t&=15,27030>>>t&1};var i=new Array(256);!function(t){for(var e=0;e<256;++e){var n=e,r=e,o=7;for(n>>>=1;n;n>>>=1)r<<=1,r|=1&n,--o;t[e]=r<<o&255}}(i),e.reverse=function(t){return i[255&t]<<24|i[t>>>8&255]<<16|i[t>>>16&255]<<8|i[t>>>24&255]},e.interleave2=function(t,e){return t&=65535,t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),e&=65535,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),t|e<<1},e.deinterleave2=function(t,e){return t=t>>>e&1431655765,t=858993459&(t|t>>>1),t=252645135&(t|t>>>2),t=16711935&(t|t>>>4),t=65535&(t|t>>>16),t<<16>>16},e.interleave3=function(t,e,n){return t&=1023,t=4278190335&(t|t<<16),t=251719695&(t|t<<8),t=3272356035&(t|t<<4),t=1227133513&(t|t<<2),e&=1023,e=4278190335&(e|e<<16),e=251719695&(e|e<<8),e=3272356035&(e|e<<4),e=1227133513&(e|e<<2),t|=e<<1,n&=1023,n=4278190335&(n|n<<16),n=251719695&(n|n<<8),n=3272356035&(n|n<<4),n=1227133513&(n|n<<2),t|n<<2},e.deinterleave3=function(t,e){return t=t>>>e&1227133513,t=3272356035&(t|t>>>2),t=251719695&(t|t>>>4),t=4278190335&(t|t>>>8),t=1023&(t|t>>>16),t<<22>>22},e.nextCombination=function(t){var e=t|t-1;return e+1|(~e&-~e)-1>>>r(t)+1}},function(t,e,n){(function(e,n,r){!function(e){t.exports=e()}(function(){var t,o,i;return function t(e,n,r){function o(a,s){if(!n[a]){if(!e[a]){var u=\"function\"==typeof _dereq_&&_dereq_;if(!s&&u)return u(a,!0);if(i)return i(a,!0);var l=new Error(\"Cannot find module '\"+a+\"'\");throw l.code=\"MODULE_NOT_FOUND\",l}var c=n[a]={exports:{}};e[a][0].call(c.exports,function(t){var n=e[a][1][t];return o(n?n:t)},c,c.exports,t,e,n,r)}return n[a].exports}for(var i=\"function\"==typeof _dereq_&&_dereq_,a=0;a<r.length;a++)o(r[a]);return o}({1:[function(t,e,n){\"use strict\";e.exports=function(t){function e(t){var e=new n(t),r=e.promise();return e.setHowMany(1),e.setUnwrap(),e.init(),r}var n=t._SomePromiseArray;t.any=function(t){return e(t)},t.prototype.any=function(){return e(this)}}},{}],2:[function(t,n,r){\"use strict\";function o(){this._customScheduler=!1,this._isTickUsed=!1,this._lateQueue=new c(16),this._normalQueue=new c(16),this._haveDrainedQueues=!1,this._trampolineEnabled=!0;var t=this;this.drainQueues=function(){t._drainQueues()},this._schedule=l}function i(t,e,n){this._lateQueue.push(t,e,n),this._queueTick()}function a(t,e,n){this._normalQueue.push(t,e,n),this._queueTick()}function s(t){this._normalQueue._pushOne(t),this._queueTick()}var u;try{throw new Error}catch(t){u=t}var l=t(\"./schedule\"),c=t(\"./queue\"),f=t(\"./util\");o.prototype.setScheduler=function(t){var e=this._schedule;return this._schedule=t,this._customScheduler=!0,e},o.prototype.hasCustomScheduler=function(){return this._customScheduler},o.prototype.enableTrampoline=function(){this._trampolineEnabled=!0},o.prototype.disableTrampolineIfNecessary=function(){f.hasDevTools&&(this._trampolineEnabled=!1)},o.prototype.haveItemsQueued=function(){return this._isTickUsed||this._haveDrainedQueues},o.prototype.fatalError=function(t,n){n?(e.stderr.write(\"Fatal \"+(t instanceof Error?t.stack:t)+\"\\n\"),e.exit(2)):this.throwLater(t)},o.prototype.throwLater=function(t,e){if(1===arguments.length&&(e=t,t=function(){throw e}),\"undefined\"!=typeof setTimeout)setTimeout(function(){t(e)},0);else try{this._schedule(function(){t(e)})}catch(t){throw new Error(\"No async scheduler available\\n\\n    See http://goo.gl/MqrFmX\\n\")}},f.hasDevTools?(o.prototype.invokeLater=function(t,e,n){this._trampolineEnabled?i.call(this,t,e,n):this._schedule(function(){setTimeout(function(){t.call(e,n)},100)})},o.prototype.invoke=function(t,e,n){this._trampolineEnabled?a.call(this,t,e,n):this._schedule(function(){t.call(e,n)})},o.prototype.settlePromises=function(t){this._trampolineEnabled?s.call(this,t):this._schedule(function(){t._settlePromises()})}):(o.prototype.invokeLater=i,o.prototype.invoke=a,o.prototype.settlePromises=s),o.prototype._drainQueue=function(t){for(;t.length()>0;){var e=t.shift();if(\"function\"==typeof e){var n=t.shift(),r=t.shift();e.call(n,r)}else e._settlePromises()}},o.prototype._drainQueues=function(){this._drainQueue(this._normalQueue),this._reset(),this._haveDrainedQueues=!0,this._drainQueue(this._lateQueue)},o.prototype._queueTick=function(){this._isTickUsed||(this._isTickUsed=!0,this._schedule(this.drainQueues))},o.prototype._reset=function(){this._isTickUsed=!1},n.exports=o,n.exports.firstLineError=u},{\"./queue\":26,\"./schedule\":29,\"./util\":36}],3:[function(t,e,n){\"use strict\";e.exports=function(t,e,n,r){var o=!1,i=function(t,e){this._reject(e)},a=function(t,e){e.promiseRejectionQueued=!0,e.bindingPromise._then(i,i,null,this,t)},s=function(t,e){0===(50397184&this._bitField)&&this._resolveCallback(e.target)},u=function(t,e){e.promiseRejectionQueued||this._reject(t)};t.prototype.bind=function(i){o||(o=!0,t.prototype._propagateFrom=r.propagateFromFunction(),t.prototype._boundValue=r.boundValueFunction());var l=n(i),c=new t(e);c._propagateFrom(this,1);var f=this._target();if(c._setBoundTo(l),l instanceof t){var p={promiseRejectionQueued:!1,promise:c,target:f,bindingPromise:l};f._then(e,a,void 0,c,p),l._then(s,u,void 0,c,p),c._setOnCancel(l)}else c._resolveCallback(f);return c},t.prototype._setBoundTo=function(t){void 0!==t?(this._bitField=2097152|this._bitField,this._boundTo=t):this._bitField=this._bitField&-2097153},t.prototype._isBound=function(){return 2097152===(2097152&this._bitField)},t.bind=function(e,n){return t.resolve(n).bind(e)}}},{}],4:[function(t,e,n){\"use strict\";function r(){try{Promise===i&&(Promise=o)}catch(t){}return i}var o;\"undefined\"!=typeof Promise&&(o=Promise);var i=t(\"./promise\")();i.noConflict=r,e.exports=i},{\"./promise\":22}],5:[function(t,e,n){\"use strict\";var r=Object.create;if(r){var o=r(null),i=r(null);o[\" size\"]=i[\" size\"]=0}e.exports=function(e){function n(t,n){var r;if(null!=t&&(r=t[n]),\"function\"!=typeof r){var o=\"Object \"+s.classString(t)+\" has no method '\"+s.toString(n)+\"'\";throw new e.TypeError(o)}return r}function r(t){var e=this.pop(),r=n(t,e);return r.apply(t,this)}function o(t){return t[this]}function i(t){var e=+this;return e<0&&(e=Math.max(0,e+t.length)),t[e]}var a,s=t(\"./util\"),u=s.canEvaluate;s.isIdentifier;e.prototype.call=function(t){var e=[].slice.call(arguments,1);return e.push(t),this._then(r,void 0,void 0,e,void 0)},e.prototype.get=function(t){var e,n=\"number\"==typeof t;if(n)e=i;else if(u){var r=a(t);e=null!==r?r:o}else e=o;return this._then(e,void 0,void 0,t,void 0)}}},{\"./util\":36}],6:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o){var i=t(\"./util\"),a=i.tryCatch,s=i.errorObj,u=e._async;e.prototype.break=e.prototype.cancel=function(){if(!o.cancellation())return this._warn(\"cancellation is disabled\");for(var t=this,e=t;t._isCancellable();){if(!t._cancelBy(e)){e._isFollowing()?e._followee().cancel():e._cancelBranched();break}var n=t._cancellationParent;if(null==n||!n._isCancellable()){t._isFollowing()?t._followee().cancel():t._cancelBranched();break}t._isFollowing()&&t._followee().cancel(),t._setWillBeCancelled(),e=t,t=n}},e.prototype._branchHasCancelled=function(){this._branchesRemainingToCancel--},e.prototype._enoughBranchesHaveCancelled=function(){return void 0===this._branchesRemainingToCancel||this._branchesRemainingToCancel<=0},e.prototype._cancelBy=function(t){return t===this?(this._branchesRemainingToCancel=0,this._invokeOnCancel(),!0):(this._branchHasCancelled(),!!this._enoughBranchesHaveCancelled()&&(this._invokeOnCancel(),!0))},e.prototype._cancelBranched=function(){this._enoughBranchesHaveCancelled()&&this._cancel()},e.prototype._cancel=function(){this._isCancellable()&&(this._setCancelled(),u.invoke(this._cancelPromises,this,void 0))},e.prototype._cancelPromises=function(){this._length()>0&&this._settlePromises()},e.prototype._unsetOnCancel=function(){this._onCancelField=void 0},e.prototype._isCancellable=function(){return this.isPending()&&!this._isCancelled()},e.prototype.isCancellable=function(){return this.isPending()&&!this.isCancelled()},e.prototype._doInvokeOnCancel=function(t,e){if(i.isArray(t))for(var n=0;n<t.length;++n)this._doInvokeOnCancel(t[n],e);else if(void 0!==t)if(\"function\"==typeof t){if(!e){var r=a(t).call(this._boundValue());r===s&&(this._attachExtraTrace(r.e),\nu.throwLater(r.e))}}else t._resultCancelled(this)},e.prototype._invokeOnCancel=function(){var t=this._onCancel();this._unsetOnCancel(),u.invoke(this._doInvokeOnCancel,this,t)},e.prototype._invokeInternalOnCancel=function(){this._isCancellable()&&(this._doInvokeOnCancel(this._onCancel(),!0),this._unsetOnCancel())},e.prototype._resultCancelled=function(){this.cancel()}}},{\"./util\":36}],7:[function(t,e,n){\"use strict\";e.exports=function(e){function n(t,n,s){return function(u){var l=s._boundValue();t:for(var c=0;c<t.length;++c){var f=t[c];if(f===Error||null!=f&&f.prototype instanceof Error){if(u instanceof f)return i(n).call(l,u)}else if(\"function\"==typeof f){var p=i(f).call(l,u);if(p===a)return p;if(p)return i(n).call(l,u)}else if(r.isObject(u)){for(var h=o(f),d=0;d<h.length;++d){var v=h[d];if(f[v]!=u[v])continue t}return i(n).call(l,u)}}return e}}var r=t(\"./util\"),o=t(\"./es5\").keys,i=r.tryCatch,a=r.errorObj;return n}},{\"./es5\":13,\"./util\":36}],8:[function(t,e,n){\"use strict\";e.exports=function(t){function e(){this._trace=new e.CapturedTrace(r())}function n(){if(o)return new e}function r(){var t=i.length-1;if(t>=0)return i[t]}var o=!1,i=[];return t.prototype._promiseCreated=function(){},t.prototype._pushContext=function(){},t.prototype._popContext=function(){return null},t._peekContext=t.prototype._peekContext=function(){},e.prototype._pushContext=function(){void 0!==this._trace&&(this._trace._promiseCreated=null,i.push(this._trace))},e.prototype._popContext=function(){if(void 0!==this._trace){var t=i.pop(),e=t._promiseCreated;return t._promiseCreated=null,e}return null},e.CapturedTrace=null,e.create=n,e.deactivateLongStackTraces=function(){},e.activateLongStackTraces=function(){var n=t.prototype._pushContext,i=t.prototype._popContext,a=t._peekContext,s=t.prototype._peekContext,u=t.prototype._promiseCreated;e.deactivateLongStackTraces=function(){t.prototype._pushContext=n,t.prototype._popContext=i,t._peekContext=a,t.prototype._peekContext=s,t.prototype._promiseCreated=u,o=!1},o=!0,t.prototype._pushContext=e.prototype._pushContext,t.prototype._popContext=e.prototype._popContext,t._peekContext=t.prototype._peekContext=r,t.prototype._promiseCreated=function(){var t=this._peekContext();t&&null==t._promiseCreated&&(t._promiseCreated=this)}},e}},{}],9:[function(t,n,r){\"use strict\";n.exports=function(n,r){function o(t,e){return{promise:e}}function i(){return!1}function a(t,e,n){var r=this;try{t(e,n,function(t){if(\"function\"!=typeof t)throw new TypeError(\"onCancel must be a function, got: \"+D.toString(t));r._attachCancellationCallback(t)})}catch(t){return t}}function s(t){if(!this._isCancellable())return this;var e=this._onCancel();void 0!==e?D.isArray(e)?e.push(t):this._setOnCancel([e,t]):this._setOnCancel(t)}function u(){return this._onCancelField}function l(t){this._onCancelField=t}function c(){this._cancellationParent=void 0,this._onCancelField=void 0}function f(t,e){if(0!==(1&e)){this._cancellationParent=t;var n=t._branchesRemainingToCancel;void 0===n&&(n=0),t._branchesRemainingToCancel=n+1}0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function p(t,e){0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function h(){var t=this._boundTo;return void 0!==t&&t instanceof n?t.isFulfilled()?t.value():void 0:t}function d(){this._trace=new k(this._peekContext())}function v(t,e){if(B(t)){var n=this._trace;if(void 0!==n&&e&&(n=n._parent),void 0!==n)n.attachExtraTrace(t);else if(!t.__stackCleaned__){var r=T(t);D.notEnumerableProp(t,\"stack\",r.message+\"\\n\"+r.stack.join(\"\\n\")),D.notEnumerableProp(t,\"__stackCleaned__\",!0)}}}function m(t,e,n,r,o){if(void 0===t&&null!==e&&$){if(void 0!==o&&o._returnedNonUndefined())return;if(0===(65535&r._bitField))return;n&&(n+=\" \");var i=\"\",a=\"\";if(e._trace){for(var s=e._trace.stack.split(\"\\n\"),u=x(s),l=u.length-1;l>=0;--l){var c=u[l];if(!W.test(c)){var f=c.match(X);f&&(i=\"at \"+f[1]+\":\"+f[2]+\":\"+f[3]+\" \");break}}if(u.length>0)for(var p=u[0],l=0;l<s.length;++l)if(s[l]===p){l>0&&(a=\"\\n\"+s[l-1]);break}}var h=\"a promise was created in a \"+n+\"handler \"+i+\"but was not returned from it, see http://goo.gl/rRqMUw\"+a;r._warn(h,!0,e)}}function _(t,e){var n=t+\" is deprecated and will be removed in a future version.\";return e&&(n+=\" Use \"+e+\" instead.\"),g(n)}function g(t,e,r){if(at.warnings){var o,i=new L(t);if(e)r._attachExtraTrace(i);else if(at.longStackTraces&&(o=n._peekContext()))o.attachExtraTrace(i);else{var a=T(i);i.stack=a.message+\"\\n\"+a.stack.join(\"\\n\")}et(\"warning\",i)||O(i,\"\",!0)}}function y(t,e){for(var n=0;n<e.length-1;++n)e[n].push(\"From previous event:\"),e[n]=e[n].join(\"\\n\");return n<e.length&&(e[n]=e[n].join(\"\\n\")),t+\"\\n\"+e.join(\"\\n\")}function b(t){for(var e=0;e<t.length;++e)(0===t[e].length||e+1<t.length&&t[e][0]===t[e+1][0])&&(t.splice(e,1),e--)}function w(t){for(var e=t[0],n=1;n<t.length;++n){for(var r=t[n],o=e.length-1,i=e[o],a=-1,s=r.length-1;s>=0;--s)if(r[s]===i){a=s;break}for(var s=a;s>=0;--s){var u=r[s];if(e[o]!==u)break;e.pop(),o--}e=r}}function x(t){for(var e=[],n=0;n<t.length;++n){var r=t[n],o=\"    (No stack trace)\"===r||z.test(r),i=o&&rt(r);o&&!i&&(q&&\" \"!==r.charAt(0)&&(r=\"    \"+r),e.push(r))}return e}function E(t){for(var e=t.stack.replace(/\\s+$/g,\"\").split(\"\\n\"),n=0;n<e.length;++n){var r=e[n];if(\"    (No stack trace)\"===r||z.test(r))break}return n>0&&\"SyntaxError\"!=t.name&&(e=e.slice(n)),e}function T(t){var e=t.stack,n=t.toString();return e=\"string\"==typeof e&&e.length>0?E(t):[\"    (No stack trace)\"],{message:n,stack:\"SyntaxError\"==t.name?e:x(e)}}function O(t,e,n){if(\"undefined\"!=typeof console){var r;if(D.isObject(t)){var o=t.stack;r=e+G(o,t)}else r=e+String(t);\"function\"==typeof N?N(r,n):\"function\"!=typeof console.log&&\"object\"!=typeof console.log||console.log(r)}}function S(t,e,n,r){var o=!1;try{\"function\"==typeof e&&(o=!0,\"rejectionHandled\"===t?e(r):e(n,r))}catch(t){F.throwLater(t)}\"unhandledRejection\"===t?et(t,n,r)||o||O(n,\"Unhandled rejection \"):et(t,r)}function P(t){var e;if(\"function\"==typeof t)e=\"[function \"+(t.name||\"anonymous\")+\"]\";else{e=t&&\"function\"==typeof t.toString?t.toString():D.toString(t);var n=/\\[object [a-zA-Z0-9$_]+\\]/;if(n.test(e))try{var r=JSON.stringify(t);e=r}catch(t){}0===e.length&&(e=\"(empty array)\")}return\"(<\"+M(e)+\">, no stack trace)\"}function M(t){var e=41;return t.length<e?t:t.substr(0,e-3)+\"...\"}function j(){return\"function\"==typeof it}function A(t){var e=t.match(ot);if(e)return{fileName:e[1],line:parseInt(e[2],10)}}function C(t,e){if(j()){for(var n,r,o=t.stack.split(\"\\n\"),i=e.stack.split(\"\\n\"),a=-1,s=-1,u=0;u<o.length;++u){var l=A(o[u]);if(l){n=l.fileName,a=l.line;break}}for(var u=0;u<i.length;++u){var l=A(i[u]);if(l){r=l.fileName,s=l.line;break}}a<0||s<0||!n||!r||n!==r||a>=s||(rt=function(t){if(V.test(t))return!0;var e=A(t);return!!(e&&e.fileName===n&&a<=e.line&&e.line<=s)})}}function k(t){this._parent=t,this._promisesCreated=0;var e=this._length=1+(void 0===t?0:t._length);it(this,k),e>32&&this.uncycle()}var R,I,N,U=n._getDomain,F=n._async,L=t(\"./errors\").Warning,D=t(\"./util\"),B=D.canAttachTrace,V=/[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/,W=/\\((?:timers\\.js):\\d+:\\d+\\)/,X=/[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/,z=null,G=null,q=!1,H=!(0==D.env(\"BLUEBIRD_DEBUG\")),Y=!(0==D.env(\"BLUEBIRD_WARNINGS\")||!H&&!D.env(\"BLUEBIRD_WARNINGS\")),K=!(0==D.env(\"BLUEBIRD_LONG_STACK_TRACES\")||!H&&!D.env(\"BLUEBIRD_LONG_STACK_TRACES\")),$=0!=D.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\")&&(Y||!!D.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));n.prototype.suppressUnhandledRejections=function(){var t=this._target();t._bitField=t._bitField&-1048577|524288},n.prototype._ensurePossibleRejectionHandled=function(){0===(524288&this._bitField)&&(this._setRejectionIsUnhandled(),F.invokeLater(this._notifyUnhandledRejection,this,void 0))},n.prototype._notifyUnhandledRejectionIsHandled=function(){S(\"rejectionHandled\",R,void 0,this)},n.prototype._setReturnedNonUndefined=function(){this._bitField=268435456|this._bitField},n.prototype._returnedNonUndefined=function(){return 0!==(268435456&this._bitField)},n.prototype._notifyUnhandledRejection=function(){if(this._isRejectionUnhandled()){var t=this._settledValue();this._setUnhandledRejectionIsNotified(),S(\"unhandledRejection\",I,t,this)}},n.prototype._setUnhandledRejectionIsNotified=function(){this._bitField=262144|this._bitField},n.prototype._unsetUnhandledRejectionIsNotified=function(){this._bitField=this._bitField&-262145},n.prototype._isUnhandledRejectionNotified=function(){return(262144&this._bitField)>0},n.prototype._setRejectionIsUnhandled=function(){this._bitField=1048576|this._bitField},n.prototype._unsetRejectionIsUnhandled=function(){this._bitField=this._bitField&-1048577,this._isUnhandledRejectionNotified()&&(this._unsetUnhandledRejectionIsNotified(),this._notifyUnhandledRejectionIsHandled())},n.prototype._isRejectionUnhandled=function(){return(1048576&this._bitField)>0},n.prototype._warn=function(t,e,n){return g(t,e,n||this)},n.onPossiblyUnhandledRejection=function(t){var e=U();I=\"function\"==typeof t?null===e?t:D.domainBind(e,t):void 0},n.onUnhandledRejectionHandled=function(t){var e=U();R=\"function\"==typeof t?null===e?t:D.domainBind(e,t):void 0};var Z=function(){};n.longStackTraces=function(){if(F.haveItemsQueued()&&!at.longStackTraces)throw new Error(\"cannot enable long stack traces after promises have been created\\n\\n    See http://goo.gl/MqrFmX\\n\");if(!at.longStackTraces&&j()){var t=n.prototype._captureStackTrace,e=n.prototype._attachExtraTrace;at.longStackTraces=!0,Z=function(){if(F.haveItemsQueued()&&!at.longStackTraces)throw new Error(\"cannot enable long stack traces after promises have been created\\n\\n    See http://goo.gl/MqrFmX\\n\");n.prototype._captureStackTrace=t,n.prototype._attachExtraTrace=e,r.deactivateLongStackTraces(),F.enableTrampoline(),at.longStackTraces=!1},n.prototype._captureStackTrace=d,n.prototype._attachExtraTrace=v,r.activateLongStackTraces(),F.disableTrampolineIfNecessary()}},n.hasLongStackTraces=function(){return at.longStackTraces&&j()};var Q=function(){try{if(\"function\"==typeof CustomEvent){var t=new CustomEvent(\"CustomEvent\");return D.global.dispatchEvent(t),function(t,e){var n=new CustomEvent(t.toLowerCase(),{detail:e,cancelable:!0});return!D.global.dispatchEvent(n)}}if(\"function\"==typeof Event){var t=new Event(\"CustomEvent\");return D.global.dispatchEvent(t),function(t,e){var n=new Event(t.toLowerCase(),{cancelable:!0});return n.detail=e,!D.global.dispatchEvent(n)}}var t=document.createEvent(\"CustomEvent\");return t.initCustomEvent(\"testingtheevent\",!1,!0,{}),D.global.dispatchEvent(t),function(t,e){var n=document.createEvent(\"CustomEvent\");return n.initCustomEvent(t.toLowerCase(),!1,!0,e),!D.global.dispatchEvent(n)}}catch(t){}return function(){return!1}}(),J=function(){return D.isNode?function(){return e.emit.apply(e,arguments)}:D.global?function(t){var e=\"on\"+t.toLowerCase(),n=D.global[e];return!!n&&(n.apply(D.global,[].slice.call(arguments,1)),!0)}:function(){return!1}}(),tt={promiseCreated:o,promiseFulfilled:o,promiseRejected:o,promiseResolved:o,promiseCancelled:o,promiseChained:function(t,e,n){return{promise:e,child:n}},warning:function(t,e){return{warning:e}},unhandledRejection:function(t,e,n){return{reason:e,promise:n}},rejectionHandled:o},et=function(t){var e=!1;try{e=J.apply(null,arguments)}catch(t){F.throwLater(t),e=!0}var n=!1;try{n=Q(t,tt[t].apply(null,arguments))}catch(t){F.throwLater(t),n=!0}return n||e};n.config=function(t){if(t=Object(t),\"longStackTraces\"in t&&(t.longStackTraces?n.longStackTraces():!t.longStackTraces&&n.hasLongStackTraces()&&Z()),\"warnings\"in t){var e=t.warnings;at.warnings=!!e,$=at.warnings,D.isObject(e)&&\"wForgottenReturn\"in e&&($=!!e.wForgottenReturn)}if(\"cancellation\"in t&&t.cancellation&&!at.cancellation){if(F.haveItemsQueued())throw new Error(\"cannot enable cancellation after promises are in use\");n.prototype._clearCancellationData=c,n.prototype._propagateFrom=f,n.prototype._onCancel=u,n.prototype._setOnCancel=l,n.prototype._attachCancellationCallback=s,n.prototype._execute=a,nt=f,at.cancellation=!0}return\"monitoring\"in t&&(t.monitoring&&!at.monitoring?(at.monitoring=!0,n.prototype._fireEvent=et):!t.monitoring&&at.monitoring&&(at.monitoring=!1,n.prototype._fireEvent=i)),n},n.prototype._fireEvent=i,n.prototype._execute=function(t,e,n){try{t(e,n)}catch(t){return t}},n.prototype._onCancel=function(){},n.prototype._setOnCancel=function(t){},n.prototype._attachCancellationCallback=function(t){},n.prototype._captureStackTrace=function(){},n.prototype._attachExtraTrace=function(){},n.prototype._clearCancellationData=function(){},n.prototype._propagateFrom=function(t,e){};var nt=p,rt=function(){return!1},ot=/[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;D.inherits(k,Error),r.CapturedTrace=k,k.prototype.uncycle=function(){var t=this._length;if(!(t<2)){for(var e=[],n={},r=0,o=this;void 0!==o;++r)e.push(o),o=o._parent;t=this._length=r;for(var r=t-1;r>=0;--r){var i=e[r].stack;void 0===n[i]&&(n[i]=r)}for(var r=0;r<t;++r){var a=e[r].stack,s=n[a];if(void 0!==s&&s!==r){s>0&&(e[s-1]._parent=void 0,e[s-1]._length=1),e[r]._parent=void 0,e[r]._length=1;var u=r>0?e[r-1]:this;s<t-1?(u._parent=e[s+1],u._parent.uncycle(),u._length=u._parent._length+1):(u._parent=void 0,u._length=1);for(var l=u._length+1,c=r-2;c>=0;--c)e[c]._length=l,l++;return}}}},k.prototype.attachExtraTrace=function(t){if(!t.__stackCleaned__){this.uncycle();for(var e=T(t),n=e.message,r=[e.stack],o=this;void 0!==o;)r.push(x(o.stack.split(\"\\n\"))),o=o._parent;w(r),b(r),D.notEnumerableProp(t,\"stack\",y(n,r)),D.notEnumerableProp(t,\"__stackCleaned__\",!0)}};var it=function(){var t=/^\\s*at\\s*/,e=function(t,e){return\"string\"==typeof t?t:void 0!==e.name&&void 0!==e.message?e.toString():P(e)};if(\"number\"==typeof Error.stackTraceLimit&&\"function\"==typeof Error.captureStackTrace){Error.stackTraceLimit+=6,z=t,G=e;var n=Error.captureStackTrace;return rt=function(t){return V.test(t)},function(t,e){Error.stackTraceLimit+=6,n(t,e),Error.stackTraceLimit-=6}}var r=new Error;if(\"string\"==typeof r.stack&&r.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\")>=0)return z=/@/,G=e,q=!0,function(t){t.stack=(new Error).stack};var o;try{throw new Error}catch(t){o=\"stack\"in t}return\"stack\"in r||!o||\"number\"!=typeof Error.stackTraceLimit?(G=function(t,e){return\"string\"==typeof t?t:\"object\"!=typeof e&&\"function\"!=typeof e||void 0===e.name||void 0===e.message?P(e):e.toString()},null):(z=t,G=e,function(t){Error.stackTraceLimit+=6;try{throw new Error}catch(e){t.stack=e.stack}Error.stackTraceLimit-=6})}([]);\"undefined\"!=typeof console&&\"undefined\"!=typeof console.warn&&(N=function(t){console.warn(t)},D.isNode&&e.stderr.isTTY?N=function(t,e){var n=e?\"\u001b[33m\":\"\u001b[31m\";console.warn(n+t+\"\u001b[0m\\n\")}:D.isNode||\"string\"!=typeof(new Error).stack||(N=function(t,e){console.warn(\"%c\"+t,e?\"color: darkorange\":\"color: red\")}));var at={warnings:Y,longStackTraces:!1,cancellation:!1,monitoring:!1};return K&&n.longStackTraces(),{longStackTraces:function(){return at.longStackTraces},warnings:function(){return at.warnings},cancellation:function(){return at.cancellation},monitoring:function(){return at.monitoring},propagateFromFunction:function(){return nt},boundValueFunction:function(){return h},checkForgottenReturns:m,setBounds:C,warn:g,deprecated:_,CapturedTrace:k,fireDomEvent:Q,fireGlobalEvent:J}}},{\"./errors\":12,\"./util\":36}],10:[function(t,e,n){\"use strict\";e.exports=function(t){function e(){return this.value}function n(){throw this.reason}t.prototype.return=t.prototype.thenReturn=function(n){return n instanceof t&&n.suppressUnhandledRejections(),this._then(e,void 0,void 0,{value:n},void 0)},t.prototype.throw=t.prototype.thenThrow=function(t){return this._then(n,void 0,void 0,{reason:t},void 0)},t.prototype.catchThrow=function(t){if(arguments.length<=1)return this._then(void 0,n,void 0,{reason:t},void 0);var e=arguments[1],r=function(){throw e};return this.caught(t,r)},t.prototype.catchReturn=function(n){if(arguments.length<=1)return n instanceof t&&n.suppressUnhandledRejections(),this._then(void 0,e,void 0,{value:n},void 0);var r=arguments[1];r instanceof t&&r.suppressUnhandledRejections();var o=function(){return r};return this.caught(n,o)}}},{}],11:[function(t,e,n){\"use strict\";e.exports=function(t,e){function n(){return i(this)}function r(t,n){return o(t,n,e,e)}var o=t.reduce,i=t.all;t.prototype.each=function(t){return o(this,t,e,0)._then(n,void 0,void 0,this,void 0)},t.prototype.mapSeries=function(t){return o(this,t,e,e)},t.each=function(t,r){return o(t,r,e,0)._then(n,void 0,void 0,t,void 0)},t.mapSeries=r}},{}],12:[function(t,e,n){\"use strict\";function r(t,e){function n(r){return this instanceof n?(f(this,\"message\",\"string\"==typeof r?r:e),f(this,\"name\",t),void(Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):Error.call(this))):new n(r)}return c(n,Error),n}function o(t){return this instanceof o?(f(this,\"name\",\"OperationalError\"),f(this,\"message\",t),this.cause=t,this.isOperational=!0,void(t instanceof Error?(f(this,\"message\",t.message),f(this,\"stack\",t.stack)):Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor))):new o(t)}var i,a,s=t(\"./es5\"),u=s.freeze,l=t(\"./util\"),c=l.inherits,f=l.notEnumerableProp,p=r(\"Warning\",\"warning\"),h=r(\"CancellationError\",\"cancellation error\"),d=r(\"TimeoutError\",\"timeout error\"),v=r(\"AggregateError\",\"aggregate error\");try{i=TypeError,a=RangeError}catch(t){i=r(\"TypeError\",\"type error\"),a=r(\"RangeError\",\"range error\")}for(var m=\"join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse\".split(\" \"),_=0;_<m.length;++_)\"function\"==typeof Array.prototype[m[_]]&&(v.prototype[m[_]]=Array.prototype[m[_]]);s.defineProperty(v.prototype,\"length\",{value:0,configurable:!1,writable:!0,enumerable:!0}),v.prototype.isOperational=!0;var g=0;v.prototype.toString=function(){var t=Array(4*g+1).join(\" \"),e=\"\\n\"+t+\"AggregateError of:\\n\";g++,t=Array(4*g+1).join(\" \");for(var n=0;n<this.length;++n){for(var r=this[n]===this?\"[Circular AggregateError]\":this[n]+\"\",o=r.split(\"\\n\"),i=0;i<o.length;++i)o[i]=t+o[i];r=o.join(\"\\n\"),e+=r+\"\\n\"}return g--,e},c(o,Error);var y=Error.__BluebirdErrorTypes__;y||(y=u({CancellationError:h,TimeoutError:d,OperationalError:o,RejectionError:o,AggregateError:v}),s.defineProperty(Error,\"__BluebirdErrorTypes__\",{value:y,writable:!1,enumerable:!1,configurable:!1})),e.exports={Error:Error,TypeError:i,RangeError:a,CancellationError:y.CancellationError,OperationalError:y.OperationalError,TimeoutError:y.TimeoutError,AggregateError:y.AggregateError,Warning:p}},{\"./es5\":13,\"./util\":36}],13:[function(t,e,n){var r=function(){\"use strict\";return void 0===this}();if(r)e.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:r,propertyIsWritable:function(t,e){var n=Object.getOwnPropertyDescriptor(t,e);return!(n&&!n.writable&&!n.set)}};else{var o={}.hasOwnProperty,i={}.toString,a={}.constructor.prototype,s=function(t){var e=[];for(var n in t)o.call(t,n)&&e.push(n);return e},u=function(t,e){return{value:t[e]}},l=function(t,e,n){return t[e]=n.value,t},c=function(t){return t},f=function(t){try{return Object(t).constructor.prototype}catch(t){return a}},p=function(t){try{return\"[object Array]\"===i.call(t)}catch(t){return!1}};e.exports={isArray:p,keys:s,names:s,defineProperty:l,getDescriptor:u,freeze:c,getPrototypeOf:f,isES5:r,propertyIsWritable:function(){return!0}}}},{}],14:[function(t,e,n){\"use strict\";e.exports=function(t,e){var n=t.map;t.prototype.filter=function(t,r){return n(this,t,r,e)},t.filter=function(t,r,o){return n(t,r,o,e)}}},{}],15:[function(t,e,n){\"use strict\";e.exports=function(e,n){function r(t,e,n){this.promise=t,this.type=e,this.handler=n,this.called=!1,this.cancelPromise=null}function o(t){this.finallyHandler=t}function i(t,e){return null!=t.cancelPromise&&(arguments.length>1?t.cancelPromise._reject(e):t.cancelPromise._cancel(),t.cancelPromise=null,!0)}function a(){return u.call(this,this.promise._target()._settledValue())}function s(t){if(!i(this,t))return f.e=t,f}function u(t){var r=this.promise,u=this.handler;if(!this.called){this.called=!0;var l=this.isFinallyHandler()?u.call(r._boundValue()):u.call(r._boundValue(),t);if(void 0!==l){r._setReturnedNonUndefined();var p=n(l,r);if(p instanceof e){if(null!=this.cancelPromise){if(p._isCancelled()){var h=new c(\"late cancellation observer\");return r._attachExtraTrace(h),f.e=h,f}p.isPending()&&p._attachCancellationCallback(new o(this))}return p._then(a,s,void 0,this,void 0)}}}return r.isRejected()?(i(this),f.e=t,f):(i(this),t)}var l=t(\"./util\"),c=e.CancellationError,f=l.errorObj;return r.prototype.isFinallyHandler=function(){return 0===this.type},o.prototype._resultCancelled=function(){i(this.finallyHandler)},e.prototype._passThrough=function(t,e,n,o){return\"function\"!=typeof t?this.then():this._then(n,o,void 0,new r(this,e,t),void 0)},e.prototype.lastly=e.prototype.finally=function(t){return this._passThrough(t,0,u,u)},e.prototype.tap=function(t){return this._passThrough(t,1,u)},r}},{\"./util\":36}],16:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o,i,a){function s(t,n,r){for(var i=0;i<n.length;++i){r._pushContext();var a=h(n[i])(t);if(r._popContext(),a===p){r._pushContext();var s=e.reject(p.e);return r._popContext(),s}var u=o(a,r);if(u instanceof e)return u}return null}function u(t,n,o,i){if(a.cancellation()){var s=new e(r),u=this._finallyPromise=new e(r);this._promise=s.lastly(function(){return u}),s._captureStackTrace(),s._setOnCancel(this)}else{var l=this._promise=new e(r);l._captureStackTrace()}this._stack=i,this._generatorFunction=t,this._receiver=n,this._generator=void 0,this._yieldHandlers=\"function\"==typeof o?[o].concat(d):d,this._yieldedPromise=null,this._cancellationPhase=!1}var l=t(\"./errors\"),c=l.TypeError,f=t(\"./util\"),p=f.errorObj,h=f.tryCatch,d=[];f.inherits(u,i),u.prototype._isResolved=function(){return null===this._promise},u.prototype._cleanup=function(){this._promise=this._generator=null,a.cancellation()&&null!==this._finallyPromise&&(this._finallyPromise._fulfill(),this._finallyPromise=null)},u.prototype._promiseCancelled=function(){if(!this._isResolved()){var t,n=\"undefined\"!=typeof this._generator.return;if(n)this._promise._pushContext(),t=h(this._generator.return).call(this._generator,void 0),this._promise._popContext();else{var r=new e.CancellationError(\"generator .return() sentinel\");e.coroutine.returnSentinel=r,this._promise._attachExtraTrace(r),this._promise._pushContext(),t=h(this._generator.throw).call(this._generator,r),this._promise._popContext()}this._cancellationPhase=!0,this._yieldedPromise=null,this._continue(t)}},u.prototype._promiseFulfilled=function(t){this._yieldedPromise=null,this._promise._pushContext();var e=h(this._generator.next).call(this._generator,t);this._promise._popContext(),this._continue(e)},u.prototype._promiseRejected=function(t){this._yieldedPromise=null,this._promise._attachExtraTrace(t),this._promise._pushContext();var e=h(this._generator.throw).call(this._generator,t);this._promise._popContext(),this._continue(e)},u.prototype._resultCancelled=function(){if(this._yieldedPromise instanceof e){var t=this._yieldedPromise;this._yieldedPromise=null,t.cancel()}},u.prototype.promise=function(){return this._promise},u.prototype._run=function(){this._generator=this._generatorFunction.call(this._receiver),this._receiver=this._generatorFunction=void 0,this._promiseFulfilled(void 0)},u.prototype._continue=function(t){var n=this._promise;if(t===p)return this._cleanup(),this._cancellationPhase?n.cancel():n._rejectCallback(t.e,!1);var r=t.value;if(t.done===!0)return this._cleanup(),this._cancellationPhase?n.cancel():n._resolveCallback(r);var i=o(r,this._promise);if(!(i instanceof e)&&(i=s(i,this._yieldHandlers,this._promise),null===i))return void this._promiseRejected(new c(\"A value %s was yielded that could not be treated as a promise\\n\\n    See http://goo.gl/MqrFmX\\n\\n\".replace(\"%s\",r)+\"From coroutine:\\n\"+this._stack.split(\"\\n\").slice(1,-7).join(\"\\n\")));i=i._target();var a=i._bitField;0===(50397184&a)?(this._yieldedPromise=i,i._proxy(this,null)):0!==(33554432&a)?e._async.invoke(this._promiseFulfilled,this,i._value()):0!==(16777216&a)?e._async.invoke(this._promiseRejected,this,i._reason()):this._promiseCancelled()},e.coroutine=function(t,e){if(\"function\"!=typeof t)throw new c(\"generatorFunction must be a function\\n\\n    See http://goo.gl/MqrFmX\\n\");var n=Object(e).yieldHandler,r=u,o=(new Error).stack;return function(){var e=t.apply(this,arguments),i=new r(void 0,void 0,n,o),a=i.promise();return i._generator=e,i._promiseFulfilled(void 0),a}},e.coroutine.addYieldHandler=function(t){if(\"function\"!=typeof t)throw new c(\"expecting a function but got \"+f.classString(t));d.push(t)},e.spawn=function(t){if(a.deprecated(\"Promise.spawn()\",\"Promise.coroutine()\"),\"function\"!=typeof t)return n(\"generatorFunction must be a function\\n\\n    See http://goo.gl/MqrFmX\\n\");var r=new u(t,this),o=r.promise();return r._run(e.spawn),o}}},{\"./errors\":12,\"./util\":36}],17:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o,i,a){var s=t(\"./util\");s.canEvaluate,s.tryCatch,s.errorObj;e.join=function(){var t,e=arguments.length-1;if(e>0&&\"function\"==typeof arguments[e]){t=arguments[e];var r}var o=[].slice.call(arguments);t&&o.pop();var r=new n(o).promise();return void 0!==t?r.spread(t):r}}},{\"./util\":36}],18:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o,i,a){function s(t,e,n,r){this.constructor$(t),this._promise._captureStackTrace();var o=l();this._callback=null===o?e:c.domainBind(o,e),this._preservedValues=r===i?new Array(this.length()):null,this._limit=n,this._inFlight=0,this._queue=[],h.invoke(this._asyncInit,this,void 0)}function u(t,n,o,i){if(\"function\"!=typeof n)return r(\"expecting a function but got \"+c.classString(n));var a=0;if(void 0!==o){if(\"object\"!=typeof o||null===o)return e.reject(new TypeError(\"options argument must be an object but it is \"+c.classString(o)));if(\"number\"!=typeof o.concurrency)return e.reject(new TypeError(\"'concurrency' must be a number but it is \"+c.classString(o.concurrency)));a=o.concurrency}return a=\"number\"==typeof a&&isFinite(a)&&a>=1?a:0,new s(t,n,a,i).promise()}var l=e._getDomain,c=t(\"./util\"),f=c.tryCatch,p=c.errorObj,h=e._async;c.inherits(s,n),s.prototype._asyncInit=function(){this._init$(void 0,-2)},s.prototype._init=function(){},s.prototype._promiseFulfilled=function(t,n){var r=this._values,i=this.length(),s=this._preservedValues,u=this._limit;if(n<0){if(n=n*-1-1,r[n]=t,u>=1&&(this._inFlight--,this._drainQueue(),this._isResolved()))return!0}else{if(u>=1&&this._inFlight>=u)return r[n]=t,this._queue.push(n),!1;null!==s&&(s[n]=t);var l=this._promise,c=this._callback,h=l._boundValue();l._pushContext();var d=f(c).call(h,t,n,i),v=l._popContext();if(a.checkForgottenReturns(d,v,null!==s?\"Promise.filter\":\"Promise.map\",l),d===p)return this._reject(d.e),!0;var m=o(d,this._promise);if(m instanceof e){m=m._target();var _=m._bitField;if(0===(50397184&_))return u>=1&&this._inFlight++,r[n]=m,m._proxy(this,(n+1)*-1),!1;if(0===(33554432&_))return 0!==(16777216&_)?(this._reject(m._reason()),!0):(this._cancel(),!0);d=m._value()}r[n]=d}var g=++this._totalResolved;return g>=i&&(null!==s?this._filter(r,s):this._resolve(r),!0)},s.prototype._drainQueue=function(){for(var t=this._queue,e=this._limit,n=this._values;t.length>0&&this._inFlight<e;){if(this._isResolved())return;var r=t.pop();this._promiseFulfilled(n[r],r)}},s.prototype._filter=function(t,e){for(var n=e.length,r=new Array(n),o=0,i=0;i<n;++i)t[i]&&(r[o++]=e[i]);r.length=o,this._resolve(r)},s.prototype.preservedValues=function(){return this._preservedValues},e.prototype.map=function(t,e){return u(this,t,e,null)},e.map=function(t,e,n,r){return u(t,e,n,r)}}},{\"./util\":36}],19:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o,i){var a=t(\"./util\"),s=a.tryCatch;e.method=function(t){if(\"function\"!=typeof t)throw new e.TypeError(\"expecting a function but got \"+a.classString(t));return function(){var r=new e(n);r._captureStackTrace(),r._pushContext();var o=s(t).apply(this,arguments),a=r._popContext();return i.checkForgottenReturns(o,a,\"Promise.method\",r),r._resolveFromSyncValue(o),r}},e.attempt=e.try=function(t){if(\"function\"!=typeof t)return o(\"expecting a function but got \"+a.classString(t));var r=new e(n);r._captureStackTrace(),r._pushContext();var u;if(arguments.length>1){i.deprecated(\"calling Promise.try with more than 1 argument\");var l=arguments[1],c=arguments[2];u=a.isArray(l)?s(t).apply(c,l):s(t).call(c,l)}else u=s(t)();var f=r._popContext();return i.checkForgottenReturns(u,f,\"Promise.try\",r),r._resolveFromSyncValue(u),r},e.prototype._resolveFromSyncValue=function(t){t===a.errorObj?this._rejectCallback(t.e,!1):this._resolveCallback(t,!0)}}},{\"./util\":36}],20:[function(t,e,n){\"use strict\";function r(t){return t instanceof Error&&c.getPrototypeOf(t)===Error.prototype}function o(t){var e;if(r(t)){e=new l(t),e.name=t.name,e.message=t.message,e.stack=t.stack;for(var n=c.keys(t),o=0;o<n.length;++o){var i=n[o];f.test(i)||(e[i]=t[i])}return e}return a.markAsOriginatingFromRejection(t),t}function i(t,e){return function(n,r){if(null!==t){if(n){var i=o(s(n));t._attachExtraTrace(i),t._reject(i)}else if(e){var a=[].slice.call(arguments,1);t._fulfill(a)}else t._fulfill(r);t=null}}}var a=t(\"./util\"),s=a.maybeWrapAsError,u=t(\"./errors\"),l=u.OperationalError,c=t(\"./es5\"),f=/^(?:name|message|stack|cause)$/;e.exports=i},{\"./errors\":12,\"./es5\":13,\"./util\":36}],21:[function(t,e,n){\"use strict\";e.exports=function(e){function n(t,e){var n=this;if(!i.isArray(t))return r.call(n,t,e);var o=s(e).apply(n._boundValue(),[null].concat(t));o===u&&a.throwLater(o.e)}function r(t,e){var n=this,r=n._boundValue(),o=void 0===t?s(e).call(r,null):s(e).call(r,null,t);o===u&&a.throwLater(o.e)}function o(t,e){var n=this;if(!t){var r=new Error(t+\"\");r.cause=t,t=r}var o=s(e).call(n._boundValue(),t);o===u&&a.throwLater(o.e)}var i=t(\"./util\"),a=e._async,s=i.tryCatch,u=i.errorObj;e.prototype.asCallback=e.prototype.nodeify=function(t,e){if(\"function\"==typeof t){var i=r;void 0!==e&&Object(e).spread&&(i=n),this._then(i,o,void 0,this,t)}return this}}},{\"./util\":36}],22:[function(t,n,r){\"use strict\";n.exports=function(){function r(){}function o(t,e){if(\"function\"!=typeof e)throw new y(\"expecting a function but got \"+d.classString(e));if(t.constructor!==i)throw new y(\"the promise constructor cannot be invoked directly\\n\\n    See http://goo.gl/MqrFmX\\n\")}function i(t){this._bitField=0,this._fulfillmentHandler0=void 0,this._rejectionHandler0=void 0,this._promise0=void 0,this._receiver0=void 0,t!==w&&(o(this,t),this._resolveFromExecutor(t)),this._promiseCreated(),this._fireEvent(\"promiseCreated\",this)}function a(t){this.promise._resolveCallback(t)}function s(t){this.promise._rejectCallback(t,!1)}function u(t){var e=new i(w);e._fulfillmentHandler0=t,e._rejectionHandler0=t,e._promise0=t,e._receiver0=t}var l,c=function(){return new y(\"circular promise resolution chain\\n\\n    See http://goo.gl/MqrFmX\\n\")},f=function(){return new i.PromiseInspection(this._target())},p=function(t){return i.reject(new y(t))},h={},d=t(\"./util\");l=d.isNode?function(){var t=e.domain;return void 0===t&&(t=null),t}:function(){return null},d.notEnumerableProp(i,\"_getDomain\",l);var v=t(\"./es5\"),m=t(\"./async\"),_=new m;v.defineProperty(i,\"_async\",{value:_});var g=t(\"./errors\"),y=i.TypeError=g.TypeError;i.RangeError=g.RangeError;var b=i.CancellationError=g.CancellationError;i.TimeoutError=g.TimeoutError,i.OperationalError=g.OperationalError,i.RejectionError=g.OperationalError,i.AggregateError=g.AggregateError;var w=function(){},x={},E={},T=t(\"./thenables\")(i,w),O=t(\"./promise_array\")(i,w,T,p,r),S=t(\"./context\")(i),P=S.create,M=t(\"./debuggability\")(i,S),j=(M.CapturedTrace,t(\"./finally\")(i,T)),A=t(\"./catch_filter\")(E),C=t(\"./nodeback\"),k=d.errorObj,R=d.tryCatch;return i.prototype.toString=function(){return\"[object Promise]\"},i.prototype.caught=i.prototype.catch=function(t){var e=arguments.length;\nif(e>1){var n,r=new Array(e-1),o=0;for(n=0;n<e-1;++n){var i=arguments[n];if(!d.isObject(i))return p(\"expecting an object but got A catch statement predicate \"+d.classString(i));r[o++]=i}return r.length=o,t=arguments[n],this.then(void 0,A(r,t,this))}return this.then(void 0,t)},i.prototype.reflect=function(){return this._then(f,f,void 0,this,void 0)},i.prototype.then=function(t,e){if(M.warnings()&&arguments.length>0&&\"function\"!=typeof t&&\"function\"!=typeof e){var n=\".then() only accepts functions but was passed: \"+d.classString(t);arguments.length>1&&(n+=\", \"+d.classString(e)),this._warn(n)}return this._then(t,e,void 0,void 0,void 0)},i.prototype.done=function(t,e){var n=this._then(t,e,void 0,void 0,void 0);n._setIsFinal()},i.prototype.spread=function(t){return\"function\"!=typeof t?p(\"expecting a function but got \"+d.classString(t)):this.all()._then(t,void 0,void 0,x,void 0)},i.prototype.toJSON=function(){var t={isFulfilled:!1,isRejected:!1,fulfillmentValue:void 0,rejectionReason:void 0};return this.isFulfilled()?(t.fulfillmentValue=this.value(),t.isFulfilled=!0):this.isRejected()&&(t.rejectionReason=this.reason(),t.isRejected=!0),t},i.prototype.all=function(){return arguments.length>0&&this._warn(\".all() was passed arguments but it does not take any\"),new O(this).promise()},i.prototype.error=function(t){return this.caught(d.originatesFromRejection,t)},i.getNewLibraryCopy=n.exports,i.is=function(t){return t instanceof i},i.fromNode=i.fromCallback=function(t){var e=new i(w);e._captureStackTrace();var n=arguments.length>1&&!!Object(arguments[1]).multiArgs,r=R(t)(C(e,n));return r===k&&e._rejectCallback(r.e,!0),e._isFateSealed()||e._setAsyncGuaranteed(),e},i.all=function(t){return new O(t).promise()},i.cast=function(t){var e=T(t);return e instanceof i||(e=new i(w),e._captureStackTrace(),e._setFulfilled(),e._rejectionHandler0=t),e},i.resolve=i.fulfilled=i.cast,i.reject=i.rejected=function(t){var e=new i(w);return e._captureStackTrace(),e._rejectCallback(t,!0),e},i.setScheduler=function(t){if(\"function\"!=typeof t)throw new y(\"expecting a function but got \"+d.classString(t));return _.setScheduler(t)},i.prototype._then=function(t,e,n,r,o){var a=void 0!==o,s=a?o:new i(w),u=this._target(),c=u._bitField;a||(s._propagateFrom(this,3),s._captureStackTrace(),void 0===r&&0!==(2097152&this._bitField)&&(r=0!==(50397184&c)?this._boundValue():u===this?void 0:this._boundTo),this._fireEvent(\"promiseChained\",this,s));var f=l();if(0!==(50397184&c)){var p,h,v=u._settlePromiseCtx;0!==(33554432&c)?(h=u._rejectionHandler0,p=t):0!==(16777216&c)?(h=u._fulfillmentHandler0,p=e,u._unsetRejectionIsUnhandled()):(v=u._settlePromiseLateCancellationObserver,h=new b(\"late cancellation observer\"),u._attachExtraTrace(h),p=e),_.invoke(v,u,{handler:null===f?p:\"function\"==typeof p&&d.domainBind(f,p),promise:s,receiver:r,value:h})}else u._addCallbacks(t,e,s,r,f);return s},i.prototype._length=function(){return 65535&this._bitField},i.prototype._isFateSealed=function(){return 0!==(117506048&this._bitField)},i.prototype._isFollowing=function(){return 67108864===(67108864&this._bitField)},i.prototype._setLength=function(t){this._bitField=this._bitField&-65536|65535&t},i.prototype._setFulfilled=function(){this._bitField=33554432|this._bitField,this._fireEvent(\"promiseFulfilled\",this)},i.prototype._setRejected=function(){this._bitField=16777216|this._bitField,this._fireEvent(\"promiseRejected\",this)},i.prototype._setFollowing=function(){this._bitField=67108864|this._bitField,this._fireEvent(\"promiseResolved\",this)},i.prototype._setIsFinal=function(){this._bitField=4194304|this._bitField},i.prototype._isFinal=function(){return(4194304&this._bitField)>0},i.prototype._unsetCancelled=function(){this._bitField=this._bitField&-65537},i.prototype._setCancelled=function(){this._bitField=65536|this._bitField,this._fireEvent(\"promiseCancelled\",this)},i.prototype._setWillBeCancelled=function(){this._bitField=8388608|this._bitField},i.prototype._setAsyncGuaranteed=function(){_.hasCustomScheduler()||(this._bitField=134217728|this._bitField)},i.prototype._receiverAt=function(t){var e=0===t?this._receiver0:this[4*t-4+3];if(e!==h)return void 0===e&&this._isBound()?this._boundValue():e},i.prototype._promiseAt=function(t){return this[4*t-4+2]},i.prototype._fulfillmentHandlerAt=function(t){return this[4*t-4+0]},i.prototype._rejectionHandlerAt=function(t){return this[4*t-4+1]},i.prototype._boundValue=function(){},i.prototype._migrateCallback0=function(t){var e=(t._bitField,t._fulfillmentHandler0),n=t._rejectionHandler0,r=t._promise0,o=t._receiverAt(0);void 0===o&&(o=h),this._addCallbacks(e,n,r,o,null)},i.prototype._migrateCallbackAt=function(t,e){var n=t._fulfillmentHandlerAt(e),r=t._rejectionHandlerAt(e),o=t._promiseAt(e),i=t._receiverAt(e);void 0===i&&(i=h),this._addCallbacks(n,r,o,i,null)},i.prototype._addCallbacks=function(t,e,n,r,o){var i=this._length();if(i>=65531&&(i=0,this._setLength(0)),0===i)this._promise0=n,this._receiver0=r,\"function\"==typeof t&&(this._fulfillmentHandler0=null===o?t:d.domainBind(o,t)),\"function\"==typeof e&&(this._rejectionHandler0=null===o?e:d.domainBind(o,e));else{var a=4*i-4;this[a+2]=n,this[a+3]=r,\"function\"==typeof t&&(this[a+0]=null===o?t:d.domainBind(o,t)),\"function\"==typeof e&&(this[a+1]=null===o?e:d.domainBind(o,e))}return this._setLength(i+1),i},i.prototype._proxy=function(t,e){this._addCallbacks(void 0,void 0,e,t,null)},i.prototype._resolveCallback=function(t,e){if(0===(117506048&this._bitField)){if(t===this)return this._rejectCallback(c(),!1);var n=T(t,this);if(!(n instanceof i))return this._fulfill(t);e&&this._propagateFrom(n,2);var r=n._target();if(r===this)return void this._reject(c());var o=r._bitField;if(0===(50397184&o)){var a=this._length();a>0&&r._migrateCallback0(this);for(var s=1;s<a;++s)r._migrateCallbackAt(this,s);this._setFollowing(),this._setLength(0),this._setFollowee(r)}else if(0!==(33554432&o))this._fulfill(r._value());else if(0!==(16777216&o))this._reject(r._reason());else{var u=new b(\"late cancellation observer\");r._attachExtraTrace(u),this._reject(u)}}},i.prototype._rejectCallback=function(t,e,n){var r=d.ensureErrorObject(t),o=r===t;if(!o&&!n&&M.warnings()){var i=\"a promise was rejected with a non-error: \"+d.classString(t);this._warn(i,!0)}this._attachExtraTrace(r,!!e&&o),this._reject(t)},i.prototype._resolveFromExecutor=function(t){var e=this;this._captureStackTrace(),this._pushContext();var n=!0,r=this._execute(t,function(t){e._resolveCallback(t)},function(t){e._rejectCallback(t,n)});n=!1,this._popContext(),void 0!==r&&e._rejectCallback(r,!0)},i.prototype._settlePromiseFromHandler=function(t,e,n,r){var o=r._bitField;if(0===(65536&o)){r._pushContext();var i;e===x?n&&\"number\"==typeof n.length?i=R(t).apply(this._boundValue(),n):(i=k,i.e=new y(\"cannot .spread() a non-array: \"+d.classString(n))):i=R(t).call(e,n);var a=r._popContext();o=r._bitField,0===(65536&o)&&(i===E?r._reject(n):i===k?r._rejectCallback(i.e,!1):(M.checkForgottenReturns(i,a,\"\",r,this),r._resolveCallback(i)))}},i.prototype._target=function(){for(var t=this;t._isFollowing();)t=t._followee();return t},i.prototype._followee=function(){return this._rejectionHandler0},i.prototype._setFollowee=function(t){this._rejectionHandler0=t},i.prototype._settlePromise=function(t,e,n,o){var a=t instanceof i,s=this._bitField,u=0!==(134217728&s);0!==(65536&s)?(a&&t._invokeInternalOnCancel(),n instanceof j&&n.isFinallyHandler()?(n.cancelPromise=t,R(e).call(n,o)===k&&t._reject(k.e)):e===f?t._fulfill(f.call(n)):n instanceof r?n._promiseCancelled(t):a||t instanceof O?t._cancel():n.cancel()):\"function\"==typeof e?a?(u&&t._setAsyncGuaranteed(),this._settlePromiseFromHandler(e,n,o,t)):e.call(n,o,t):n instanceof r?n._isResolved()||(0!==(33554432&s)?n._promiseFulfilled(o,t):n._promiseRejected(o,t)):a&&(u&&t._setAsyncGuaranteed(),0!==(33554432&s)?t._fulfill(o):t._reject(o))},i.prototype._settlePromiseLateCancellationObserver=function(t){var e=t.handler,n=t.promise,r=t.receiver,o=t.value;\"function\"==typeof e?n instanceof i?this._settlePromiseFromHandler(e,r,o,n):e.call(r,o,n):n instanceof i&&n._reject(o)},i.prototype._settlePromiseCtx=function(t){this._settlePromise(t.promise,t.handler,t.receiver,t.value)},i.prototype._settlePromise0=function(t,e,n){var r=this._promise0,o=this._receiverAt(0);this._promise0=void 0,this._receiver0=void 0,this._settlePromise(r,t,o,e)},i.prototype._clearCallbackDataAtIndex=function(t){var e=4*t-4;this[e+2]=this[e+3]=this[e+0]=this[e+1]=void 0},i.prototype._fulfill=function(t){var e=this._bitField;if(!((117506048&e)>>>16)){if(t===this){var n=c();return this._attachExtraTrace(n),this._reject(n)}this._setFulfilled(),this._rejectionHandler0=t,(65535&e)>0&&(0!==(134217728&e)?this._settlePromises():_.settlePromises(this))}},i.prototype._reject=function(t){var e=this._bitField;if(!((117506048&e)>>>16))return this._setRejected(),this._fulfillmentHandler0=t,this._isFinal()?_.fatalError(t,d.isNode):void((65535&e)>0?_.settlePromises(this):this._ensurePossibleRejectionHandled())},i.prototype._fulfillPromises=function(t,e){for(var n=1;n<t;n++){var r=this._fulfillmentHandlerAt(n),o=this._promiseAt(n),i=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(o,r,i,e)}},i.prototype._rejectPromises=function(t,e){for(var n=1;n<t;n++){var r=this._rejectionHandlerAt(n),o=this._promiseAt(n),i=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(o,r,i,e)}},i.prototype._settlePromises=function(){var t=this._bitField,e=65535&t;if(e>0){if(0!==(16842752&t)){var n=this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0,n,t),this._rejectPromises(e,n)}else{var r=this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0,r,t),this._fulfillPromises(e,r)}this._setLength(0)}this._clearCancellationData()},i.prototype._settledValue=function(){var t=this._bitField;return 0!==(33554432&t)?this._rejectionHandler0:0!==(16777216&t)?this._fulfillmentHandler0:void 0},i.defer=i.pending=function(){M.deprecated(\"Promise.defer\",\"new Promise\");var t=new i(w);return{promise:t,resolve:a,reject:s}},d.notEnumerableProp(i,\"_makeSelfResolutionError\",c),t(\"./method\")(i,w,T,p,M),t(\"./bind\")(i,w,T,M),t(\"./cancel\")(i,O,p,M),t(\"./direct_resolve\")(i),t(\"./synchronous_inspection\")(i),t(\"./join\")(i,O,T,w,_,l),i.Promise=i,i.version=\"3.4.7\",t(\"./map.js\")(i,O,p,T,w,M),t(\"./call_get.js\")(i),t(\"./using.js\")(i,p,T,P,w,M),t(\"./timers.js\")(i,w,M),t(\"./generators.js\")(i,p,w,T,r,M),t(\"./nodeify.js\")(i),t(\"./promisify.js\")(i,w),t(\"./props.js\")(i,O,T,p),t(\"./race.js\")(i,w,T,p),t(\"./reduce.js\")(i,O,p,T,w,M),t(\"./settle.js\")(i,O,M),t(\"./some.js\")(i,O,p),t(\"./filter.js\")(i,w),t(\"./each.js\")(i,w),t(\"./any.js\")(i),d.toFastProperties(i),d.toFastProperties(i.prototype),u({a:1}),u({b:2}),u({c:3}),u(1),u(function(){}),u(void 0),u(!1),u(new i(w)),M.setBounds(m.firstLineError,d.lastLineError),i}},{\"./any.js\":1,\"./async\":2,\"./bind\":3,\"./call_get.js\":5,\"./cancel\":6,\"./catch_filter\":7,\"./context\":8,\"./debuggability\":9,\"./direct_resolve\":10,\"./each.js\":11,\"./errors\":12,\"./es5\":13,\"./filter.js\":14,\"./finally\":15,\"./generators.js\":16,\"./join\":17,\"./map.js\":18,\"./method\":19,\"./nodeback\":20,\"./nodeify.js\":21,\"./promise_array\":23,\"./promisify.js\":24,\"./props.js\":25,\"./race.js\":27,\"./reduce.js\":28,\"./settle.js\":30,\"./some.js\":31,\"./synchronous_inspection\":32,\"./thenables\":33,\"./timers.js\":34,\"./using.js\":35,\"./util\":36}],23:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o,i){function a(t){switch(t){case-2:return[];case-3:return{}}}function s(t){var r=this._promise=new e(n);t instanceof e&&r._propagateFrom(t,3),r._setOnCancel(this),this._values=t,this._length=0,this._totalResolved=0,this._init(void 0,-2)}var u=t(\"./util\");u.isArray;return u.inherits(s,i),s.prototype.length=function(){return this._length},s.prototype.promise=function(){return this._promise},s.prototype._init=function t(n,i){var s=r(this._values,this._promise);if(s instanceof e){s=s._target();var l=s._bitField;if(this._values=s,0===(50397184&l))return this._promise._setAsyncGuaranteed(),s._then(t,this._reject,void 0,this,i);if(0===(33554432&l))return 0!==(16777216&l)?this._reject(s._reason()):this._cancel();s=s._value()}if(s=u.asArray(s),null===s){var c=o(\"expecting an array or an iterable object but got \"+u.classString(s)).reason();return void this._promise._rejectCallback(c,!1)}return 0===s.length?void(i===-5?this._resolveEmptyArray():this._resolve(a(i))):void this._iterate(s)},s.prototype._iterate=function(t){var n=this.getActualLength(t.length);this._length=n,this._values=this.shouldCopyValues()?new Array(n):this._values;for(var o=this._promise,i=!1,a=null,s=0;s<n;++s){var u=r(t[s],o);u instanceof e?(u=u._target(),a=u._bitField):a=null,i?null!==a&&u.suppressUnhandledRejections():null!==a?0===(50397184&a)?(u._proxy(this,s),this._values[s]=u):i=0!==(33554432&a)?this._promiseFulfilled(u._value(),s):0!==(16777216&a)?this._promiseRejected(u._reason(),s):this._promiseCancelled(s):i=this._promiseFulfilled(u,s)}i||o._setAsyncGuaranteed()},s.prototype._isResolved=function(){return null===this._values},s.prototype._resolve=function(t){this._values=null,this._promise._fulfill(t)},s.prototype._cancel=function(){!this._isResolved()&&this._promise._isCancellable()&&(this._values=null,this._promise._cancel())},s.prototype._reject=function(t){this._values=null,this._promise._rejectCallback(t,!1)},s.prototype._promiseFulfilled=function(t,e){this._values[e]=t;var n=++this._totalResolved;return n>=this._length&&(this._resolve(this._values),!0)},s.prototype._promiseCancelled=function(){return this._cancel(),!0},s.prototype._promiseRejected=function(t){return this._totalResolved++,this._reject(t),!0},s.prototype._resultCancelled=function(){if(!this._isResolved()){var t=this._values;if(this._cancel(),t instanceof e)t.cancel();else for(var n=0;n<t.length;++n)t[n]instanceof e&&t[n].cancel()}},s.prototype.shouldCopyValues=function(){return!0},s.prototype.getActualLength=function(t){return t},s}},{\"./util\":36}],24:[function(t,e,n){\"use strict\";e.exports=function(e,n){function r(t){return!x.test(t)}function o(t){try{return t.__isPromisified__===!0}catch(t){return!1}}function i(t,e,n){var r=h.getDataPropertyOrDefault(t,e+n,b);return!!r&&o(r)}function a(t,e,n){for(var r=0;r<t.length;r+=2){var o=t[r];if(n.test(o))for(var i=o.replace(n,\"\"),a=0;a<t.length;a+=2)if(t[a]===i)throw new g(\"Cannot promisify an API that has normal methods with '%s'-suffix\\n\\n    See http://goo.gl/MqrFmX\\n\".replace(\"%s\",e))}}function s(t,e,n,r){for(var s=h.inheritedDataKeys(t),u=[],l=0;l<s.length;++l){var c=s[l],f=t[c],p=r===E||E(c,f,t);\"function\"!=typeof f||o(f)||i(t,c,e)||!r(c,f,t,p)||u.push(c,f)}return a(u,e,n),u}function u(t,r,o,i,a,s){function u(){var o=r;r===p&&(o=this);var i=new e(n);i._captureStackTrace();var a=\"string\"==typeof c&&this!==l?this[c]:t,u=d(i,s);try{a.apply(o,v(arguments,u))}catch(t){i._rejectCallback(m(t),!0,!0)}return i._isFateSealed()||i._setAsyncGuaranteed(),i}var l=function(){return this}(),c=t;return\"string\"==typeof c&&(t=i),h.notEnumerableProp(u,\"__isPromisified__\",!0),u}function l(t,e,n,r,o){for(var i=new RegExp(T(e)+\"$\"),a=s(t,e,i,n),u=0,l=a.length;u<l;u+=2){var c=a[u],f=a[u+1],d=c+e;if(r===O)t[d]=O(c,p,c,f,e,o);else{var v=r(f,function(){return O(c,p,c,f,e,o)});h.notEnumerableProp(v,\"__isPromisified__\",!0),t[d]=v}}return h.toFastProperties(t),t}function c(t,e,n){return O(t,e,void 0,t,null,n)}var f,p={},h=t(\"./util\"),d=t(\"./nodeback\"),v=h.withAppended,m=h.maybeWrapAsError,_=h.canEvaluate,g=t(\"./errors\").TypeError,y=\"Async\",b={__isPromisified__:!0},w=[\"arity\",\"length\",\"name\",\"arguments\",\"caller\",\"callee\",\"prototype\",\"__isPromisified__\"],x=new RegExp(\"^(?:\"+w.join(\"|\")+\")$\"),E=function(t){return h.isIdentifier(t)&&\"_\"!==t.charAt(0)&&\"constructor\"!==t},T=function(t){return t.replace(/([$])/,\"\\\\$\")},O=_?f:u;e.promisify=function(t,e){if(\"function\"!=typeof t)throw new g(\"expecting a function but got \"+h.classString(t));if(o(t))return t;e=Object(e);var n=void 0===e.context?p:e.context,i=!!e.multiArgs,a=c(t,n,i);return h.copyDescriptors(t,a,r),a},e.promisifyAll=function(t,e){if(\"function\"!=typeof t&&\"object\"!=typeof t)throw new g(\"the target of promisifyAll must be an object or a function\\n\\n    See http://goo.gl/MqrFmX\\n\");e=Object(e);var n=!!e.multiArgs,r=e.suffix;\"string\"!=typeof r&&(r=y);var o=e.filter;\"function\"!=typeof o&&(o=E);var i=e.promisifier;if(\"function\"!=typeof i&&(i=O),!h.isIdentifier(r))throw new RangeError(\"suffix must be a valid identifier\\n\\n    See http://goo.gl/MqrFmX\\n\");for(var a=h.inheritedDataKeys(t),s=0;s<a.length;++s){var u=t[a[s]];\"constructor\"!==a[s]&&h.isClass(u)&&(l(u.prototype,r,o,i,n),l(u,r,o,i,n))}return l(t,r,o,i,n)}}},{\"./errors\":12,\"./nodeback\":20,\"./util\":36}],25:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o){function i(t){var e,n=!1;if(void 0!==s&&t instanceof s)e=f(t),n=!0;else{var r=c.keys(t),o=r.length;e=new Array(2*o);for(var i=0;i<o;++i){var a=r[i];e[i]=t[a],e[i+o]=a}}this.constructor$(e),this._isMap=n,this._init$(void 0,-3)}function a(t){var n,a=r(t);return l(a)?(n=a instanceof e?a._then(e.props,void 0,void 0,void 0,void 0):new i(a).promise(),a instanceof e&&n._propagateFrom(a,2),n):o(\"cannot await properties of a non-object\\n\\n    See http://goo.gl/MqrFmX\\n\")}var s,u=t(\"./util\"),l=u.isObject,c=t(\"./es5\");\"function\"==typeof Map&&(s=Map);var f=function(){function t(t,r){this[e]=t,this[e+n]=r,e++}var e=0,n=0;return function(r){n=r.size,e=0;var o=new Array(2*r.size);return r.forEach(t,o),o}}(),p=function(t){for(var e=new s,n=t.length/2|0,r=0;r<n;++r){var o=t[n+r],i=t[r];e.set(o,i)}return e};u.inherits(i,n),i.prototype._init=function(){},i.prototype._promiseFulfilled=function(t,e){this._values[e]=t;var n=++this._totalResolved;if(n>=this._length){var r;if(this._isMap)r=p(this._values);else{r={};for(var o=this.length(),i=0,a=this.length();i<a;++i)r[this._values[i+o]]=this._values[i]}return this._resolve(r),!0}return!1},i.prototype.shouldCopyValues=function(){return!1},i.prototype.getActualLength=function(t){return t>>1},e.prototype.props=function(){return a(this)},e.props=function(t){return a(t)}}},{\"./es5\":13,\"./util\":36}],26:[function(t,e,n){\"use strict\";function r(t,e,n,r,o){for(var i=0;i<o;++i)n[i+r]=t[i+e],t[i+e]=void 0}function o(t){this._capacity=t,this._length=0,this._front=0}o.prototype._willBeOverCapacity=function(t){return this._capacity<t},o.prototype._pushOne=function(t){var e=this.length();this._checkCapacity(e+1);var n=this._front+e&this._capacity-1;this[n]=t,this._length=e+1},o.prototype.push=function(t,e,n){var r=this.length()+3;if(this._willBeOverCapacity(r))return this._pushOne(t),this._pushOne(e),void this._pushOne(n);var o=this._front+r-3;this._checkCapacity(r);var i=this._capacity-1;this[o+0&i]=t,this[o+1&i]=e,this[o+2&i]=n,this._length=r},o.prototype.shift=function(){var t=this._front,e=this[t];return this[t]=void 0,this._front=t+1&this._capacity-1,this._length--,e},o.prototype.length=function(){return this._length},o.prototype._checkCapacity=function(t){this._capacity<t&&this._resizeTo(this._capacity<<1)},o.prototype._resizeTo=function(t){var e=this._capacity;this._capacity=t;var n=this._front,o=this._length,i=n+o&e-1;r(this,0,this,e,i)},e.exports=o},{}],27:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o){function i(t,i){var u=r(t);if(u instanceof e)return s(u);if(t=a.asArray(t),null===t)return o(\"expecting an array or an iterable object but got \"+a.classString(t));var l=new e(n);void 0!==i&&l._propagateFrom(i,3);for(var c=l._fulfill,f=l._reject,p=0,h=t.length;p<h;++p){var d=t[p];(void 0!==d||p in t)&&e.cast(d)._then(c,f,void 0,l,null)}return l}var a=t(\"./util\"),s=function(t){return t.then(function(e){return i(e,t)})};e.race=function(t){return i(t,void 0)},e.prototype.race=function(){return i(this,void 0)}}},{\"./util\":36}],28:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o,i,a){function s(t,n,r,o){this.constructor$(t);var a=p();this._fn=null===a?n:h.domainBind(a,n),void 0!==r&&(r=e.resolve(r),r._attachCancellationCallback(this)),this._initialValue=r,this._currentCancellable=null,o===i?this._eachValues=Array(this._length):0===o?this._eachValues=null:this._eachValues=void 0,this._promise._captureStackTrace(),this._init$(void 0,-5)}function u(t,e){this.isFulfilled()?e._resolve(t):e._reject(t)}function l(t,e,n,o){if(\"function\"!=typeof e)return r(\"expecting a function but got \"+h.classString(e));var i=new s(t,e,n,o);return i.promise()}function c(t){this.accum=t,this.array._gotAccum(t);var n=o(this.value,this.array._promise);return n instanceof e?(this.array._currentCancellable=n,n._then(f,void 0,void 0,this,void 0)):f.call(this,n)}function f(t){var n=this.array,r=n._promise,o=d(n._fn);r._pushContext();var i;i=void 0!==n._eachValues?o.call(r._boundValue(),t,this.index,this.length):o.call(r._boundValue(),this.accum,t,this.index,this.length),i instanceof e&&(n._currentCancellable=i);var s=r._popContext();return a.checkForgottenReturns(i,s,void 0!==n._eachValues?\"Promise.each\":\"Promise.reduce\",r),i}var p=e._getDomain,h=t(\"./util\"),d=h.tryCatch;h.inherits(s,n),s.prototype._gotAccum=function(t){void 0!==this._eachValues&&null!==this._eachValues&&t!==i&&this._eachValues.push(t)},s.prototype._eachComplete=function(t){return null!==this._eachValues&&this._eachValues.push(t),this._eachValues},s.prototype._init=function(){},s.prototype._resolveEmptyArray=function(){this._resolve(void 0!==this._eachValues?this._eachValues:this._initialValue)},s.prototype.shouldCopyValues=function(){return!1},s.prototype._resolve=function(t){this._promise._resolveCallback(t),this._values=null},s.prototype._resultCancelled=function(t){return t===this._initialValue?this._cancel():void(this._isResolved()||(this._resultCancelled$(),this._currentCancellable instanceof e&&this._currentCancellable.cancel(),this._initialValue instanceof e&&this._initialValue.cancel()))},s.prototype._iterate=function(t){this._values=t;var n,r,o=t.length;if(void 0!==this._initialValue?(n=this._initialValue,r=0):(n=e.resolve(t[0]),r=1),this._currentCancellable=n,!n.isRejected())for(;r<o;++r){var i={accum:null,value:t[r],index:r,length:o,array:this};n=n._then(c,void 0,void 0,i,void 0)}void 0!==this._eachValues&&(n=n._then(this._eachComplete,void 0,void 0,this,void 0)),n._then(u,u,void 0,n,this)},e.prototype.reduce=function(t,e){return l(this,t,e,null)},e.reduce=function(t,e,n,r){return l(t,e,n,r)}}},{\"./util\":36}],29:[function(t,o,i){\"use strict\";var a,s=t(\"./util\"),u=function(){throw new Error(\"No async scheduler available\\n\\n    See http://goo.gl/MqrFmX\\n\")},l=s.getNativePromise();if(s.isNode&&\"undefined\"==typeof MutationObserver){var c=n.setImmediate,f=e.nextTick;a=s.isRecentNode?function(t){c.call(n,t)}:function(t){f.call(e,t)}}else if(\"function\"==typeof l&&\"function\"==typeof l.resolve){var p=l.resolve();a=function(t){p.then(t)}}else a=\"undefined\"==typeof MutationObserver||\"undefined\"!=typeof window&&window.navigator&&(window.navigator.standalone||window.cordova)?\"undefined\"!=typeof r?function(t){r(t)}:\"undefined\"!=typeof setTimeout?function(t){setTimeout(t,0)}:u:function(){var t=document.createElement(\"div\"),e={attributes:!0},n=!1,r=document.createElement(\"div\"),o=new MutationObserver(function(){t.classList.toggle(\"foo\"),n=!1});o.observe(r,e);var i=function(){n||(n=!0,r.classList.toggle(\"foo\"))};return function(n){var r=new MutationObserver(function(){r.disconnect(),n()});r.observe(t,e),i()}}();o.exports=a},{\"./util\":36}],30:[function(t,e,n){\"use strict\";e.exports=function(e,n,r){function o(t){this.constructor$(t)}var i=e.PromiseInspection,a=t(\"./util\");a.inherits(o,n),o.prototype._promiseResolved=function(t,e){this._values[t]=e;var n=++this._totalResolved;return n>=this._length&&(this._resolve(this._values),!0)},o.prototype._promiseFulfilled=function(t,e){var n=new i;return n._bitField=33554432,n._settledValueField=t,this._promiseResolved(e,n)},o.prototype._promiseRejected=function(t,e){var n=new i;return n._bitField=16777216,n._settledValueField=t,this._promiseResolved(e,n)},e.settle=function(t){return r.deprecated(\".settle()\",\".reflect()\"),new o(t).promise()},e.prototype.settle=function(){return e.settle(this)}}},{\"./util\":36}],31:[function(t,e,n){\"use strict\";e.exports=function(e,n,r){function o(t){this.constructor$(t),this._howMany=0,this._unwrap=!1,this._initialized=!1}function i(t,e){if((0|e)!==e||e<0)return r(\"expecting a positive integer\\n\\n    See http://goo.gl/MqrFmX\\n\");var n=new o(t),i=n.promise();return n.setHowMany(e),n.init(),i}var a=t(\"./util\"),s=t(\"./errors\").RangeError,u=t(\"./errors\").AggregateError,l=a.isArray,c={};a.inherits(o,n),o.prototype._init=function(){if(this._initialized){if(0===this._howMany)return void this._resolve([]);this._init$(void 0,-5);var t=l(this._values);!this._isResolved()&&t&&this._howMany>this._canPossiblyFulfill()&&this._reject(this._getRangeError(this.length()))}},o.prototype.init=function(){this._initialized=!0,this._init()},o.prototype.setUnwrap=function(){this._unwrap=!0},o.prototype.howMany=function(){return this._howMany},o.prototype.setHowMany=function(t){this._howMany=t},o.prototype._promiseFulfilled=function(t){return this._addFulfilled(t),this._fulfilled()===this.howMany()&&(this._values.length=this.howMany(),1===this.howMany()&&this._unwrap?this._resolve(this._values[0]):this._resolve(this._values),!0)},o.prototype._promiseRejected=function(t){return this._addRejected(t),this._checkOutcome()},o.prototype._promiseCancelled=function(){return this._values instanceof e||null==this._values?this._cancel():(this._addRejected(c),this._checkOutcome())},o.prototype._checkOutcome=function(){if(this.howMany()>this._canPossiblyFulfill()){for(var t=new u,e=this.length();e<this._values.length;++e)this._values[e]!==c&&t.push(this._values[e]);return t.length>0?this._reject(t):this._cancel(),!0}return!1},o.prototype._fulfilled=function(){return this._totalResolved},o.prototype._rejected=function(){return this._values.length-this.length()},o.prototype._addRejected=function(t){this._values.push(t)},o.prototype._addFulfilled=function(t){this._values[this._totalResolved++]=t},o.prototype._canPossiblyFulfill=function(){return this.length()-this._rejected()},o.prototype._getRangeError=function(t){var e=\"Input array must contain at least \"+this._howMany+\" items but contains only \"+t+\" items\";return new s(e)},o.prototype._resolveEmptyArray=function(){this._reject(this._getRangeError(0))},e.some=function(t,e){return i(t,e)},e.prototype.some=function(t){return i(this,t)},e._SomePromiseArray=o}},{\"./errors\":12,\"./util\":36}],32:[function(t,e,n){\"use strict\";e.exports=function(t){function e(t){void 0!==t?(t=t._target(),this._bitField=t._bitField,this._settledValueField=t._isFateSealed()?t._settledValue():void 0):(this._bitField=0,this._settledValueField=void 0)}e.prototype._settledValue=function(){return this._settledValueField};var n=e.prototype.value=function(){if(!this.isFulfilled())throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\n\\n    See http://goo.gl/MqrFmX\\n\");return this._settledValue()},r=e.prototype.error=e.prototype.reason=function(){if(!this.isRejected())throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\n\\n    See http://goo.gl/MqrFmX\\n\");return this._settledValue()},o=e.prototype.isFulfilled=function(){return 0!==(33554432&this._bitField)},i=e.prototype.isRejected=function(){return 0!==(16777216&this._bitField)},a=e.prototype.isPending=function(){return 0===(50397184&this._bitField)},s=e.prototype.isResolved=function(){return 0!==(50331648&this._bitField)};e.prototype.isCancelled=function(){return 0!==(8454144&this._bitField)},t.prototype.__isCancelled=function(){return 65536===(65536&this._bitField)},t.prototype._isCancelled=function(){return this._target().__isCancelled()},t.prototype.isCancelled=function(){return 0!==(8454144&this._target()._bitField)},t.prototype.isPending=function(){return a.call(this._target())},t.prototype.isRejected=function(){return i.call(this._target())},t.prototype.isFulfilled=function(){return o.call(this._target())},t.prototype.isResolved=function(){return s.call(this._target())},t.prototype.value=function(){return n.call(this._target())},t.prototype.reason=function(){var t=this._target();return t._unsetRejectionIsUnhandled(),r.call(t)},t.prototype._value=function(){return this._settledValue()},t.prototype._reason=function(){return this._unsetRejectionIsUnhandled(),this._settledValue()},t.PromiseInspection=e}},{}],33:[function(t,e,n){\"use strict\";e.exports=function(e,n){function r(t,r){if(c(t)){if(t instanceof e)return t;var o=i(t);if(o===l){r&&r._pushContext();var u=e.reject(o.e);return r&&r._popContext(),u}if(\"function\"==typeof o){if(a(t)){var u=new e(n);return t._then(u._fulfill,u._reject,void 0,u,null),u}return s(t,o,r)}}return t}function o(t){return t.then}function i(t){try{return o(t)}catch(t){return l.e=t,l}}function a(t){try{return f.call(t,\"_promise0\")}catch(t){return!1}}function s(t,r,o){function i(t){s&&(s._resolveCallback(t),s=null)}function a(t){s&&(s._rejectCallback(t,f,!0),s=null)}var s=new e(n),c=s;o&&o._pushContext(),s._captureStackTrace(),o&&o._popContext();var f=!0,p=u.tryCatch(r).call(t,i,a);return f=!1,s&&p===l&&(s._rejectCallback(p.e,!0,!0),s=null),c}var u=t(\"./util\"),l=u.errorObj,c=u.isObject,f={}.hasOwnProperty;return r}},{\"./util\":36}],34:[function(t,e,n){\"use strict\";e.exports=function(e,n,r){function o(t){this.handle=t}function i(t){return clearTimeout(this.handle),t}function a(t){throw clearTimeout(this.handle),t}var s=t(\"./util\"),u=e.TimeoutError;o.prototype._resultCancelled=function(){clearTimeout(this.handle)};var l=function(t){return c(+this).thenReturn(t)},c=e.delay=function(t,i){var a,s;return void 0!==i?(a=e.resolve(i)._then(l,null,null,t,void 0),r.cancellation()&&i instanceof e&&a._setOnCancel(i)):(a=new e(n),s=setTimeout(function(){a._fulfill()},+t),r.cancellation()&&a._setOnCancel(new o(s)),a._captureStackTrace()),a._setAsyncGuaranteed(),a};e.prototype.delay=function(t){return c(t,this)};var f=function(t,e,n){var r;r=\"string\"!=typeof e?e instanceof Error?e:new u(\"operation timed out\"):new u(e),s.markAsOriginatingFromRejection(r),t._attachExtraTrace(r),t._reject(r),null!=n&&n.cancel()};e.prototype.timeout=function(t,e){t=+t;var n,s,u=new o(setTimeout(function(){n.isPending()&&f(n,e,s)},t));return r.cancellation()?(s=this.then(),n=s._then(i,a,void 0,u,void 0),n._setOnCancel(u)):n=this._then(i,a,void 0,u,void 0),n}}},{\"./util\":36}],35:[function(t,e,n){\"use strict\";e.exports=function(e,n,r,o,i,a){function s(t){setTimeout(function(){throw t},0)}function u(t){var e=r(t);return e!==t&&\"function\"==typeof t._isDisposable&&\"function\"==typeof t._getDisposer&&t._isDisposable()&&e._setDisposable(t._getDisposer()),e}function l(t,n){function o(){if(a>=l)return c._fulfill();var i=u(t[a++]);if(i instanceof e&&i._isDisposable()){try{i=r(i._getDisposer().tryDispose(n),t.promise)}catch(t){return s(t)}if(i instanceof e)return i._then(o,s,null,null,null)}o()}var a=0,l=t.length,c=new e(i);return o(),c}function c(t,e,n){this._data=t,this._promise=e,this._context=n}function f(t,e,n){this.constructor$(t,e,n)}function p(t){return c.isDisposer(t)?(this.resources[this.index]._setDisposable(t),t.promise()):t}function h(t){this.length=t,this.promise=null,this[t-1]=null}var d=t(\"./util\"),v=t(\"./errors\").TypeError,m=t(\"./util\").inherits,_=d.errorObj,g=d.tryCatch,y={};c.prototype.data=function(){return this._data},c.prototype.promise=function(){return this._promise},c.prototype.resource=function(){return this.promise().isFulfilled()?this.promise().value():y},c.prototype.tryDispose=function(t){var e=this.resource(),n=this._context;void 0!==n&&n._pushContext();var r=e!==y?this.doDispose(e,t):null;return void 0!==n&&n._popContext(),this._promise._unsetDisposable(),this._data=null,r},c.isDisposer=function(t){return null!=t&&\"function\"==typeof t.resource&&\"function\"==typeof t.tryDispose},m(f,c),f.prototype.doDispose=function(t,e){var n=this.data();return n.call(t,t,e)},h.prototype._resultCancelled=function(){for(var t=this.length,n=0;n<t;++n){var r=this[n];r instanceof e&&r.cancel();\n}},e.using=function(){var t=arguments.length;if(t<2)return n(\"you must pass at least 2 arguments to Promise.using\");var o=arguments[t-1];if(\"function\"!=typeof o)return n(\"expecting a function but got \"+d.classString(o));var i,s=!0;2===t&&Array.isArray(arguments[0])?(i=arguments[0],t=i.length,s=!1):(i=arguments,t--);for(var u=new h(t),f=0;f<t;++f){var v=i[f];if(c.isDisposer(v)){var m=v;v=v.promise(),v._setDisposable(m)}else{var y=r(v);y instanceof e&&(v=y._then(p,null,null,{resources:u,index:f},void 0))}u[f]=v}for(var b=new Array(u.length),f=0;f<b.length;++f)b[f]=e.resolve(u[f]).reflect();var w=e.all(b).then(function(t){for(var e=0;e<t.length;++e){var n=t[e];if(n.isRejected())return _.e=n.error(),_;if(!n.isFulfilled())return void w.cancel();t[e]=n.value()}x._pushContext(),o=g(o);var r=s?o.apply(void 0,t):o(t),i=x._popContext();return a.checkForgottenReturns(r,i,\"Promise.using\",x),r}),x=w.lastly(function(){var t=new e.PromiseInspection(w);return l(u,t)});return u.promise=x,x._setOnCancel(u),x},e.prototype._setDisposable=function(t){this._bitField=131072|this._bitField,this._disposer=t},e.prototype._isDisposable=function(){return(131072&this._bitField)>0},e.prototype._getDisposer=function(){return this._disposer},e.prototype._unsetDisposable=function(){this._bitField=this._bitField&-131073,this._disposer=void 0},e.prototype.disposer=function(t){if(\"function\"==typeof t)return new f(t,this,o());throw new v}}},{\"./errors\":12,\"./util\":36}],36:[function(t,r,o){\"use strict\";function i(){try{var t=C;return C=null,t.apply(this,arguments)}catch(t){return A.e=t,A}}function a(t){return C=t,i}function s(t){return null==t||t===!0||t===!1||\"string\"==typeof t||\"number\"==typeof t}function u(t){return\"function\"==typeof t||\"object\"==typeof t&&null!==t}function l(t){return s(t)?new Error(g(t)):t}function c(t,e){var n,r=t.length,o=new Array(r+1);for(n=0;n<r;++n)o[n]=t[n];return o[n]=e,o}function f(t,e,n){if(!M.isES5)return{}.hasOwnProperty.call(t,e)?t[e]:void 0;var r=Object.getOwnPropertyDescriptor(t,e);return null!=r?null==r.get&&null==r.set?r.value:n:void 0}function p(t,e,n){if(s(t))return t;var r={value:n,configurable:!0,enumerable:!1,writable:!0};return M.defineProperty(t,e,r),t}function h(t){throw t}function d(t){try{if(\"function\"==typeof t){var e=M.names(t.prototype),n=M.isES5&&e.length>1,r=e.length>0&&!(1===e.length&&\"constructor\"===e[0]),o=N.test(t+\"\")&&M.names(t).length>0;if(n||r||o)return!0}return!1}catch(t){return!1}}function v(t){function e(){}e.prototype=t;for(var n=8;n--;)new e;return t}function m(t){return U.test(t)}function _(t,e,n){for(var r=new Array(t),o=0;o<t;++o)r[o]=e+o+n;return r}function g(t){try{return t+\"\"}catch(t){return\"[no string representation]\"}}function y(t){return null!==t&&\"object\"==typeof t&&\"string\"==typeof t.message&&\"string\"==typeof t.name}function b(t){try{p(t,\"isOperational\",!0)}catch(t){}}function w(t){return null!=t&&(t instanceof Error.__BluebirdErrorTypes__.OperationalError||t.isOperational===!0)}function x(t){return y(t)&&M.propertyIsWritable(t,\"stack\")}function E(t){return{}.toString.call(t)}function T(t,e,n){for(var r=M.names(t),o=0;o<r.length;++o){var i=r[o];if(n(i))try{M.defineProperty(e,i,M.getDescriptor(t,i))}catch(t){}}}function O(t){return V?{NODE_ENV:\"production\"}[t]:void 0}function S(){if(\"function\"==typeof Promise)try{var t=new Promise(function(){});if(\"[object Promise]\"==={}.toString.call(t))return Promise}catch(t){}}function P(t,e){return t.bind(e)}var M=t(\"./es5\"),j=\"undefined\"==typeof navigator,A={e:{}},C,k=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:\"undefined\"!=typeof n?n:void 0!==this?this:null,R=function(t,e){function n(){this.constructor=t,this.constructor$=e;for(var n in e.prototype)r.call(e.prototype,n)&&\"$\"!==n.charAt(n.length-1)&&(this[n+\"$\"]=e.prototype[n])}var r={}.hasOwnProperty;return n.prototype=e.prototype,t.prototype=new n,t.prototype},I=function(){var t=[Array.prototype,Object.prototype,Function.prototype],e=function(e){for(var n=0;n<t.length;++n)if(t[n]===e)return!0;return!1};if(M.isES5){var n=Object.getOwnPropertyNames;return function(t){for(var r=[],o=Object.create(null);null!=t&&!e(t);){var i;try{i=n(t)}catch(t){return r}for(var a=0;a<i.length;++a){var s=i[a];if(!o[s]){o[s]=!0;var u=Object.getOwnPropertyDescriptor(t,s);null!=u&&null==u.get&&null==u.set&&r.push(s)}}t=M.getPrototypeOf(t)}return r}}var r={}.hasOwnProperty;return function(n){if(e(n))return[];var o=[];t:for(var i in n)if(r.call(n,i))o.push(i);else{for(var a=0;a<t.length;++a)if(r.call(t[a],i))continue t;o.push(i)}return o}}(),N=/this\\s*\\.\\s*\\S+\\s*=/,U=/^[a-z$_][a-z$_0-9]*$/i,F=function(){return\"stack\"in new Error?function(t){return x(t)?t:new Error(g(t))}:function(t){if(x(t))return t;try{throw new Error(g(t))}catch(t){return t}}}(),L=function(t){return M.isArray(t)?t:null};if(\"undefined\"!=typeof Symbol&&Symbol.iterator){var D=\"function\"==typeof Array.from?function(t){return Array.from(t)}:function(t){for(var e,n=[],r=t[Symbol.iterator]();!(e=r.next()).done;)n.push(e.value);return n};L=function(t){return M.isArray(t)?t:null!=t&&\"function\"==typeof t[Symbol.iterator]?D(t):null}}var B=\"undefined\"!=typeof e&&\"[object process]\"===E(e).toLowerCase(),V=\"undefined\"!=typeof e&&!0,W={isClass:d,isIdentifier:m,inheritedDataKeys:I,getDataPropertyOrDefault:f,thrower:h,isArray:M.isArray,asArray:L,notEnumerableProp:p,isPrimitive:s,isObject:u,isError:y,canEvaluate:j,errorObj:A,tryCatch:a,inherits:R,withAppended:c,maybeWrapAsError:l,toFastProperties:v,filledRange:_,toString:g,canAttachTrace:x,ensureErrorObject:F,originatesFromRejection:w,markAsOriginatingFromRejection:b,classString:E,copyDescriptors:T,hasDevTools:\"undefined\"!=typeof chrome&&chrome&&\"function\"==typeof chrome.loadTimes,isNode:B,hasEnvVariables:V,env:O,global:k,getNativePromise:S,domainBind:P};W.isRecentNode=W.isNode&&function(){var t=e.versions.node.split(\".\").map(Number);return 0===t[0]&&t[1]>10||t[0]>0}(),W.isNode&&W.toFastProperties(e);try{throw new Error}catch(t){W.lastLineError=t}r.exports=W},{\"./es5\":13}]},{},[4])(4)}),\"undefined\"!=typeof window&&null!==window?window.P=window.Promise:\"undefined\"!=typeof self&&null!==self&&(self.P=self.Promise)}).call(e,n(131),n(38),n(621).setImmediate)},function(t,e,n){\"use strict\";(function(t){function r(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&\"function\"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}function o(){return a.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function i(t,e){if(o()<e)throw new RangeError(\"Invalid typed array length\");return a.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e),t.__proto__=a.prototype):(null===t&&(t=new a(e)),t.length=e),t}function a(t,e,n){if(!(a.TYPED_ARRAY_SUPPORT||this instanceof a))return new a(t,e,n);if(\"number\"==typeof t){if(\"string\"==typeof e)throw new Error(\"If encoding is specified then the first argument must be a string\");return c(this,t)}return s(this,t,e,n)}function s(t,e,n,r){if(\"number\"==typeof e)throw new TypeError('\"value\" argument must not be a number');return\"undefined\"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?h(t,e,n,r):\"string\"==typeof e?f(t,e,n):d(t,e)}function u(t){if(\"number\"!=typeof t)throw new TypeError('\"size\" argument must be a number');if(t<0)throw new RangeError('\"size\" argument must not be negative')}function l(t,e,n,r){return u(e),e<=0?i(t,e):void 0!==n?\"string\"==typeof r?i(t,e).fill(n,r):i(t,e).fill(n):i(t,e)}function c(t,e){if(u(e),t=i(t,e<0?0:0|v(e)),!a.TYPED_ARRAY_SUPPORT)for(var n=0;n<e;++n)t[n]=0;return t}function f(t,e,n){if(\"string\"==typeof n&&\"\"!==n||(n=\"utf8\"),!a.isEncoding(n))throw new TypeError('\"encoding\" must be a valid string encoding');var r=0|_(e,n);t=i(t,r);var o=t.write(e,n);return o!==r&&(t=t.slice(0,o)),t}function p(t,e){var n=e.length<0?0:0|v(e.length);t=i(t,n);for(var r=0;r<n;r+=1)t[r]=255&e[r];return t}function h(t,e,n,r){if(e.byteLength,n<0||e.byteLength<n)throw new RangeError(\"'offset' is out of bounds\");if(e.byteLength<n+(r||0))throw new RangeError(\"'length' is out of bounds\");return e=void 0===n&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,n):new Uint8Array(e,n,r),a.TYPED_ARRAY_SUPPORT?(t=e,t.__proto__=a.prototype):t=p(t,e),t}function d(t,e){if(a.isBuffer(e)){var n=0|v(e.length);return t=i(t,n),0===t.length?t:(e.copy(t,0,0,n),t)}if(e){if(\"undefined\"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||\"length\"in e)return\"number\"!=typeof e.length||$(e.length)?i(t,0):p(t,e);if(\"Buffer\"===e.type&&J(e.data))return p(t,e.data)}throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\")}function v(t){if(t>=o())throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+o().toString(16)+\" bytes\");return 0|t}function m(t){return+t!=t&&(t=0),a.alloc(+t)}function _(t,e){if(a.isBuffer(t))return t.length;if(\"undefined\"!=typeof ArrayBuffer&&\"function\"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;\"string\"!=typeof t&&(t=\"\"+t);var n=t.length;if(0===n)return 0;for(var r=!1;;)switch(e){case\"ascii\":case\"latin1\":case\"binary\":return n;case\"utf8\":case\"utf-8\":case void 0:return G(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*n;case\"hex\":return n>>>1;case\"base64\":return Y(t).length;default:if(r)return G(t).length;e=(\"\"+e).toLowerCase(),r=!0}}function g(t,e,n){var r=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return\"\";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return\"\";if(n>>>=0,e>>>=0,n<=e)return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return R(this,e,n);case\"utf8\":case\"utf-8\":return j(this,e,n);case\"ascii\":return C(this,e,n);case\"latin1\":case\"binary\":return k(this,e,n);case\"base64\":return M(this,e,n);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return I(this,e,n);default:if(r)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),r=!0}}function y(t,e,n){var r=t[e];t[e]=t[n],t[n]=r}function b(t,e,n,r,o){if(0===t.length)return-1;if(\"string\"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=o?0:t.length-1),n<0&&(n=t.length+n),n>=t.length){if(o)return-1;n=t.length-1}else if(n<0){if(!o)return-1;n=0}if(\"string\"==typeof e&&(e=a.from(e,r)),a.isBuffer(e))return 0===e.length?-1:w(t,e,n,r,o);if(\"number\"==typeof e)return e&=255,a.TYPED_ARRAY_SUPPORT&&\"function\"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,e,n):Uint8Array.prototype.lastIndexOf.call(t,e,n):w(t,[e],n,r,o);throw new TypeError(\"val must be string, number or Buffer\")}function w(t,e,n,r,o){function i(t,e){return 1===a?t[e]:t.readUInt16BE(e*a)}var a=1,s=t.length,u=e.length;if(void 0!==r&&(r=String(r).toLowerCase(),\"ucs2\"===r||\"ucs-2\"===r||\"utf16le\"===r||\"utf-16le\"===r)){if(t.length<2||e.length<2)return-1;a=2,s/=2,u/=2,n/=2}var l;if(o){var c=-1;for(l=n;l<s;l++)if(i(t,l)===i(e,c===-1?0:l-c)){if(c===-1&&(c=l),l-c+1===u)return c*a}else c!==-1&&(l-=l-c),c=-1}else for(n+u>s&&(n=s-u),l=n;l>=0;l--){for(var f=!0,p=0;p<u;p++)if(i(t,l+p)!==i(e,p)){f=!1;break}if(f)return l}return-1}function x(t,e,n,r){n=Number(n)||0;var o=t.length-n;r?(r=Number(r),r>o&&(r=o)):r=o;var i=e.length;if(i%2!==0)throw new TypeError(\"Invalid hex string\");r>i/2&&(r=i/2);for(var a=0;a<r;++a){var s=parseInt(e.substr(2*a,2),16);if(isNaN(s))return a;t[n+a]=s}return a}function E(t,e,n,r){return K(G(e,t.length-n),t,n,r)}function T(t,e,n,r){return K(q(e),t,n,r)}function O(t,e,n,r){return T(t,e,n,r)}function S(t,e,n,r){return K(Y(e),t,n,r)}function P(t,e,n,r){return K(H(e,t.length-n),t,n,r)}function M(t,e,n){return 0===e&&n===t.length?Z.fromByteArray(t):Z.fromByteArray(t.slice(e,n))}function j(t,e,n){n=Math.min(t.length,n);for(var r=[],o=e;o<n;){var i=t[o],a=null,s=i>239?4:i>223?3:i>191?2:1;if(o+s<=n){var u,l,c,f;switch(s){case 1:i<128&&(a=i);break;case 2:u=t[o+1],128===(192&u)&&(f=(31&i)<<6|63&u,f>127&&(a=f));break;case 3:u=t[o+1],l=t[o+2],128===(192&u)&&128===(192&l)&&(f=(15&i)<<12|(63&u)<<6|63&l,f>2047&&(f<55296||f>57343)&&(a=f));break;case 4:u=t[o+1],l=t[o+2],c=t[o+3],128===(192&u)&&128===(192&l)&&128===(192&c)&&(f=(15&i)<<18|(63&u)<<12|(63&l)<<6|63&c,f>65535&&f<1114112&&(a=f))}}null===a?(a=65533,s=1):a>65535&&(a-=65536,r.push(a>>>10&1023|55296),a=56320|1023&a),r.push(a),o+=s}return A(r)}function A(t){var e=t.length;if(e<=tt)return String.fromCharCode.apply(String,t);for(var n=\"\",r=0;r<e;)n+=String.fromCharCode.apply(String,t.slice(r,r+=tt));return n}function C(t,e,n){var r=\"\";n=Math.min(t.length,n);for(var o=e;o<n;++o)r+=String.fromCharCode(127&t[o]);return r}function k(t,e,n){var r=\"\";n=Math.min(t.length,n);for(var o=e;o<n;++o)r+=String.fromCharCode(t[o]);return r}function R(t,e,n){var r=t.length;(!e||e<0)&&(e=0),(!n||n<0||n>r)&&(n=r);for(var o=\"\",i=e;i<n;++i)o+=z(t[i]);return o}function I(t,e,n){for(var r=t.slice(e,n),o=\"\",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}function N(t,e,n){if(t%1!==0||t<0)throw new RangeError(\"offset is not uint\");if(t+e>n)throw new RangeError(\"Trying to access beyond buffer length\")}function U(t,e,n,r,o,i){if(!a.isBuffer(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>o||e<i)throw new RangeError('\"value\" argument is out of bounds');if(n+r>t.length)throw new RangeError(\"Index out of range\")}function F(t,e,n,r){e<0&&(e=65535+e+1);for(var o=0,i=Math.min(t.length-n,2);o<i;++o)t[n+o]=(e&255<<8*(r?o:1-o))>>>8*(r?o:1-o)}function L(t,e,n,r){e<0&&(e=4294967295+e+1);for(var o=0,i=Math.min(t.length-n,4);o<i;++o)t[n+o]=e>>>8*(r?o:3-o)&255}function D(t,e,n,r,o,i){if(n+r>t.length)throw new RangeError(\"Index out of range\");if(n<0)throw new RangeError(\"Index out of range\")}function B(t,e,n,r,o){return o||D(t,e,n,4,3.4028234663852886e38,-3.4028234663852886e38),Q.write(t,e,n,r,23,4),n+4}function V(t,e,n,r,o){return o||D(t,e,n,8,1.7976931348623157e308,-1.7976931348623157e308),Q.write(t,e,n,r,52,8),n+8}function W(t){if(t=X(t).replace(et,\"\"),t.length<2)return\"\";for(;t.length%4!==0;)t+=\"=\";return t}function X(t){return t.trim?t.trim():t.replace(/^\\s+|\\s+$/g,\"\")}function z(t){return t<16?\"0\"+t.toString(16):t.toString(16)}function G(t,e){e=e||1/0;for(var n,r=t.length,o=null,i=[],a=0;a<r;++a){if(n=t.charCodeAt(a),n>55295&&n<57344){if(!o){if(n>56319){(e-=3)>-1&&i.push(239,191,189);continue}if(a+1===r){(e-=3)>-1&&i.push(239,191,189);continue}o=n;continue}if(n<56320){(e-=3)>-1&&i.push(239,191,189),o=n;continue}n=(o-55296<<10|n-56320)+65536}else o&&(e-=3)>-1&&i.push(239,191,189);if(o=null,n<128){if((e-=1)<0)break;i.push(n)}else if(n<2048){if((e-=2)<0)break;i.push(n>>6|192,63&n|128)}else if(n<65536){if((e-=3)<0)break;i.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error(\"Invalid code point\");if((e-=4)<0)break;i.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return i}function q(t){for(var e=[],n=0;n<t.length;++n)e.push(255&t.charCodeAt(n));return e}function H(t,e){for(var n,r,o,i=[],a=0;a<t.length&&!((e-=2)<0);++a)n=t.charCodeAt(a),r=n>>8,o=n%256,i.push(o),i.push(r);return i}function Y(t){return Z.toByteArray(W(t))}function K(t,e,n,r){for(var o=0;o<r&&!(o+n>=e.length||o>=t.length);++o)e[o+n]=t[o];return o}function $(t){return t!==t}var Z=n(262),Q=n(452),J=n(266);e.Buffer=a,e.SlowBuffer=m,e.INSPECT_MAX_BYTES=50,a.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:r(),e.kMaxLength=o(),a.poolSize=8192,a._augment=function(t){return t.__proto__=a.prototype,t},a.from=function(t,e,n){return s(null,t,e,n)},a.TYPED_ARRAY_SUPPORT&&(a.prototype.__proto__=Uint8Array.prototype,a.__proto__=Uint8Array,\"undefined\"!=typeof Symbol&&Symbol.species&&a[Symbol.species]===a&&Object.defineProperty(a,Symbol.species,{value:null,configurable:!0})),a.alloc=function(t,e,n){return l(null,t,e,n)},a.allocUnsafe=function(t){return c(null,t)},a.allocUnsafeSlow=function(t){return c(null,t)},a.isBuffer=function(t){return!(null==t||!t._isBuffer)},a.compare=function(t,e){if(!a.isBuffer(t)||!a.isBuffer(e))throw new TypeError(\"Arguments must be Buffers\");if(t===e)return 0;for(var n=t.length,r=e.length,o=0,i=Math.min(n,r);o<i;++o)if(t[o]!==e[o]){n=t[o],r=e[o];break}return n<r?-1:r<n?1:0},a.isEncoding=function(t){switch(String(t).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},a.concat=function(t,e){if(!J(t))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===t.length)return a.alloc(0);var n;if(void 0===e)for(e=0,n=0;n<t.length;++n)e+=t[n].length;var r=a.allocUnsafe(e),o=0;for(n=0;n<t.length;++n){var i=t[n];if(!a.isBuffer(i))throw new TypeError('\"list\" argument must be an Array of Buffers');i.copy(r,o),o+=i.length}return r},a.byteLength=_,a.prototype._isBuffer=!0,a.prototype.swap16=function(){var t=this.length;if(t%2!==0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var e=0;e<t;e+=2)y(this,e,e+1);return this},a.prototype.swap32=function(){var t=this.length;if(t%4!==0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var e=0;e<t;e+=4)y(this,e,e+3),y(this,e+1,e+2);return this},a.prototype.swap64=function(){var t=this.length;if(t%8!==0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var e=0;e<t;e+=8)y(this,e,e+7),y(this,e+1,e+6),y(this,e+2,e+5),y(this,e+3,e+4);return this},a.prototype.toString=function(){var t=0|this.length;return 0===t?\"\":0===arguments.length?j(this,0,t):g.apply(this,arguments)},a.prototype.equals=function(t){if(!a.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");return this===t||0===a.compare(this,t)},a.prototype.inspect=function(){var t=\"\",n=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString(\"hex\",0,n).match(/.{2}/g).join(\" \"),this.length>n&&(t+=\" ... \")),\"<Buffer \"+t+\">\"},a.prototype.compare=function(t,e,n,r,o){if(!a.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");if(void 0===e&&(e=0),void 0===n&&(n=t?t.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),e<0||n>t.length||r<0||o>this.length)throw new RangeError(\"out of range index\");if(r>=o&&e>=n)return 0;if(r>=o)return-1;if(e>=n)return 1;if(e>>>=0,n>>>=0,r>>>=0,o>>>=0,this===t)return 0;for(var i=o-r,s=n-e,u=Math.min(i,s),l=this.slice(r,o),c=t.slice(e,n),f=0;f<u;++f)if(l[f]!==c[f]){i=l[f],s=c[f];break}return i<s?-1:s<i?1:0},a.prototype.includes=function(t,e,n){return this.indexOf(t,e,n)!==-1},a.prototype.indexOf=function(t,e,n){return b(this,t,e,n,!0)},a.prototype.lastIndexOf=function(t,e,n){return b(this,t,e,n,!1)},a.prototype.write=function(t,e,n,r){if(void 0===e)r=\"utf8\",n=this.length,e=0;else if(void 0===n&&\"string\"==typeof e)r=e,n=this.length,e=0;else{if(!isFinite(e))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");e|=0,isFinite(n)?(n|=0,void 0===r&&(r=\"utf8\")):(r=n,n=void 0)}var o=this.length-e;if((void 0===n||n>o)&&(n=o),t.length>0&&(n<0||e<0)||e>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");r||(r=\"utf8\");for(var i=!1;;)switch(r){case\"hex\":return x(this,t,e,n);case\"utf8\":case\"utf-8\":return E(this,t,e,n);case\"ascii\":return T(this,t,e,n);case\"latin1\":case\"binary\":return O(this,t,e,n);case\"base64\":return S(this,t,e,n);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return P(this,t,e,n);default:if(i)throw new TypeError(\"Unknown encoding: \"+r);r=(\"\"+r).toLowerCase(),i=!0}},a.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};var tt=4096;a.prototype.slice=function(t,e){var n=this.length;t=~~t,e=void 0===e?n:~~e,t<0?(t+=n,t<0&&(t=0)):t>n&&(t=n),e<0?(e+=n,e<0&&(e=0)):e>n&&(e=n),e<t&&(e=t);var r;if(a.TYPED_ARRAY_SUPPORT)r=this.subarray(t,e),r.__proto__=a.prototype;else{var o=e-t;r=new a(o,void 0);for(var i=0;i<o;++i)r[i]=this[i+t]}return r},a.prototype.readUIntLE=function(t,e,n){t|=0,e|=0,n||N(t,e,this.length);for(var r=this[t],o=1,i=0;++i<e&&(o*=256);)r+=this[t+i]*o;return r},a.prototype.readUIntBE=function(t,e,n){t|=0,e|=0,n||N(t,e,this.length);for(var r=this[t+--e],o=1;e>0&&(o*=256);)r+=this[t+--e]*o;return r},a.prototype.readUInt8=function(t,e){return e||N(t,1,this.length),this[t]},a.prototype.readUInt16LE=function(t,e){return e||N(t,2,this.length),this[t]|this[t+1]<<8},a.prototype.readUInt16BE=function(t,e){return e||N(t,2,this.length),this[t]<<8|this[t+1]},a.prototype.readUInt32LE=function(t,e){return e||N(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},a.prototype.readUInt32BE=function(t,e){return e||N(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},a.prototype.readIntLE=function(t,e,n){t|=0,e|=0,n||N(t,e,this.length);for(var r=this[t],o=1,i=0;++i<e&&(o*=256);)r+=this[t+i]*o;return o*=128,r>=o&&(r-=Math.pow(2,8*e)),r},a.prototype.readIntBE=function(t,e,n){t|=0,e|=0,n||N(t,e,this.length);for(var r=e,o=1,i=this[t+--r];r>0&&(o*=256);)i+=this[t+--r]*o;return o*=128,i>=o&&(i-=Math.pow(2,8*e)),i},a.prototype.readInt8=function(t,e){return e||N(t,1,this.length),128&this[t]?(255-this[t]+1)*-1:this[t]},a.prototype.readInt16LE=function(t,e){e||N(t,2,this.length);var n=this[t]|this[t+1]<<8;return 32768&n?4294901760|n:n},a.prototype.readInt16BE=function(t,e){e||N(t,2,this.length);var n=this[t+1]|this[t]<<8;return 32768&n?4294901760|n:n},a.prototype.readInt32LE=function(t,e){return e||N(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},a.prototype.readInt32BE=function(t,e){return e||N(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},a.prototype.readFloatLE=function(t,e){return e||N(t,4,this.length),Q.read(this,t,!0,23,4)},a.prototype.readFloatBE=function(t,e){return e||N(t,4,this.length),Q.read(this,t,!1,23,4)},a.prototype.readDoubleLE=function(t,e){return e||N(t,8,this.length),Q.read(this,t,!0,52,8)},a.prototype.readDoubleBE=function(t,e){return e||N(t,8,this.length),Q.read(this,t,!1,52,8)},a.prototype.writeUIntLE=function(t,e,n,r){if(t=+t,e|=0,n|=0,!r){var o=Math.pow(2,8*n)-1;U(this,t,e,n,o,0)}var i=1,a=0;for(this[e]=255&t;++a<n&&(i*=256);)this[e+a]=t/i&255;return e+n},a.prototype.writeUIntBE=function(t,e,n,r){if(t=+t,e|=0,n|=0,!r){var o=Math.pow(2,8*n)-1;U(this,t,e,n,o,0)}var i=n-1,a=1;for(this[e+i]=255&t;--i>=0&&(a*=256);)this[e+i]=t/a&255;return e+n},a.prototype.writeUInt8=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,1,255,0),a.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},a.prototype.writeUInt16LE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,2,65535,0),a.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):F(this,t,e,!0),e+2},a.prototype.writeUInt16BE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,2,65535,0),a.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):F(this,t,e,!1),e+2},a.prototype.writeUInt32LE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,4,4294967295,0),a.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):L(this,t,e,!0),e+4},a.prototype.writeUInt32BE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,4,4294967295,0),a.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):L(this,t,e,!1),e+4},a.prototype.writeIntLE=function(t,e,n,r){if(t=+t,e|=0,!r){var o=Math.pow(2,8*n-1);U(this,t,e,n,o-1,-o)}var i=0,a=1,s=0;for(this[e]=255&t;++i<n&&(a*=256);)t<0&&0===s&&0!==this[e+i-1]&&(s=1),this[e+i]=(t/a>>0)-s&255;return e+n},a.prototype.writeIntBE=function(t,e,n,r){if(t=+t,e|=0,!r){var o=Math.pow(2,8*n-1);U(this,t,e,n,o-1,-o)}var i=n-1,a=1,s=0;for(this[e+i]=255&t;--i>=0&&(a*=256);)t<0&&0===s&&0!==this[e+i+1]&&(s=1),this[e+i]=(t/a>>0)-s&255;return e+n},a.prototype.writeInt8=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,1,127,-128),a.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},a.prototype.writeInt16LE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,2,32767,-32768),a.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):F(this,t,e,!0),e+2},a.prototype.writeInt16BE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,2,32767,-32768),a.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):F(this,t,e,!1),e+2},a.prototype.writeInt32LE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,4,2147483647,-2147483648),a.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):L(this,t,e,!0),e+4},a.prototype.writeInt32BE=function(t,e,n){return t=+t,e|=0,n||U(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),a.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):L(this,t,e,!1),e+4},a.prototype.writeFloatLE=function(t,e,n){return B(this,t,e,!0,n)},a.prototype.writeFloatBE=function(t,e,n){return B(this,t,e,!1,n)},a.prototype.writeDoubleLE=function(t,e,n){return V(this,t,e,!0,n)},a.prototype.writeDoubleBE=function(t,e,n){return V(this,t,e,!1,n)},a.prototype.copy=function(t,e,n,r){if(n||(n=0),r||0===r||(r=this.length),e>=t.length&&(e=t.length),e||(e=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError(\"targetStart out of bounds\");if(n<0||n>=this.length)throw new RangeError(\"sourceStart out of bounds\");if(r<0)throw new RangeError(\"sourceEnd out of bounds\");r>this.length&&(r=this.length),t.length-e<r-n&&(r=t.length-e+n);var o,i=r-n;if(this===t&&n<e&&e<r)for(o=i-1;o>=0;--o)t[o+e]=this[o+n];else if(i<1e3||!a.TYPED_ARRAY_SUPPORT)for(o=0;o<i;++o)t[o+e]=this[o+n];else Uint8Array.prototype.set.call(t,this.subarray(n,n+i),e);return i},a.prototype.fill=function(t,e,n,r){if(\"string\"==typeof t){if(\"string\"==typeof e?(r=e,e=0,n=this.length):\"string\"==typeof n&&(r=n,n=this.length),1===t.length){var o=t.charCodeAt(0);o<256&&(t=o)}if(void 0!==r&&\"string\"!=typeof r)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof r&&!a.isEncoding(r))throw new TypeError(\"Unknown encoding: \"+r)}else\"number\"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<n)throw new RangeError(\"Out of range index\");if(n<=e)return this;e>>>=0,n=void 0===n?this.length:n>>>0,t||(t=0);var i;if(\"number\"==typeof t)for(i=e;i<n;++i)this[i]=t;else{var s=a.isBuffer(t)?t:G(new a(t,r).toString()),u=s.length;for(i=0;i<n-e;++i)this[i+e]=s[i%u]}return this};var et=/[^+\\/0-9A-Za-z-_]/g}).call(e,n(38))},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return\"[object Array]\"==n.call(t)}},function(t,e,n){n(276),t.exports=n(31).RegExp.escape},function(t,e,n){var r=n(7),o=n(101),i=n(8)(\"species\");t.exports=function(t){var e;return o(t)&&(e=t.constructor,\"function\"!=typeof e||e!==Array&&!o(e.prototype)||(e=void 0),r(e)&&(e=e[i],null===e&&(e=void 0))),void 0===e?Array:e}},function(t,e,n){var r=n(268);t.exports=function(t,e){return new(r(t))(e)}},function(t,e,n){\"use strict\";var r=n(4),o=n(28),i=\"number\";t.exports=function(t){if(\"string\"!==t&&t!==i&&\"default\"!==t)throw TypeError(\"Incorrect hint\");return o(r(this),t!=i)}},function(t,e,n){var r=n(43),o=n(77),i=n(60);t.exports=function(t){var e=r(t),n=o.f;if(n)for(var a,s=n(t),u=i.f,l=0;s.length>l;)u.call(t,a=s[l++])&&e.push(a);return e}},function(t,e,n){var r=n(43),o=n(18);t.exports=function(t,e){for(var n,i=o(t),a=r(i),s=a.length,u=0;s>u;)if(i[n=a[u++]]===e)return n}},function(t,e,n){\"use strict\";var r=n(274),o=n(73),i=n(14);t.exports=function(){for(var t=i(this),e=arguments.length,n=Array(e),a=0,s=r._,u=!1;e>a;)(n[a]=arguments[a++])===s&&(u=!0);return function(){var r,i=this,a=arguments.length,l=0,c=0;if(!u&&!a)return o(t,n,i);if(r=n.slice(),u)for(;e>l;l++)r[l]===s&&(r[l]=arguments[c++]);for(;a>c;)r.push(arguments[c++]);return o(t,r,i)}}},function(t,e,n){t.exports=n(5)},function(t,e){t.exports=function(t,e){var n=e===Object(e)?function(t){return e[t]}:e;return function(e){return String(e).replace(t,n)}}},function(t,e,n){var r=n(0),o=n(275)(/[\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\");r(r.S,\"RegExp\",{escape:function(t){return o(t)}})},function(t,e,n){var r=n(0);r(r.P,\"Array\",{copyWithin:n(139)}),n(50)(\"copyWithin\")},function(t,e,n){\"use strict\";var r=n(0),o=n(26)(4);r(r.P+r.F*!n(24)([].every,!0),\"Array\",{every:function(t){return o(this,t,arguments[1])}})},function(t,e,n){var r=n(0);r(r.P,\"Array\",{fill:n(93)}),n(50)(\"fill\")},function(t,e,n){\"use strict\";var r=n(0),o=n(26)(2);r(r.P+r.F*!n(24)([].filter,!0),\"Array\",{filter:function(t){return o(this,t,arguments[1])}})},function(t,e,n){\"use strict\";var r=n(0),o=n(26)(6),i=\"findIndex\",a=!0;i in[]&&Array(1)[i](function(){a=!1}),r(r.P+r.F*a,\"Array\",{findIndex:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),n(50)(i)},function(t,e,n){\"use strict\";var r=n(0),o=n(26)(5),i=\"find\",a=!0;i in[]&&Array(1)[i](function(){a=!1}),r(r.P+r.F*a,\"Array\",{find:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),n(50)(i)},function(t,e,n){\"use strict\";var r=n(0),o=n(26)(0),i=n(24)([].forEach,!0);r(r.P+r.F*!i,\"Array\",{forEach:function(t){return o(this,t,arguments[1])}})},function(t,e,n){\"use strict\";var r=n(32),o=n(0),i=n(12),a=n(148),s=n(100),u=n(11),l=n(94),c=n(117);o(o.S+o.F*!n(75)(function(t){Array.from(t)}),\"Array\",{from:function(t){var e,n,o,f,p=i(t),h=\"function\"==typeof this?this:Array,d=arguments.length,v=d>1?arguments[1]:void 0,m=void 0!==v,_=0,g=c(p);if(m&&(v=r(v,d>2?arguments[2]:void 0,2)),void 0==g||h==Array&&s(g))for(e=u(p.length),n=new h(e);e>_;_++)l(n,_,m?v(p[_],_):p[_]);else for(f=g.call(p),n=new h;!(o=f.next()).done;_++)l(n,_,m?a(f,v,[o.value,_],!0):o.value);return n.length=_,n}})},function(t,e,n){\"use strict\";var r=n(0),o=n(69)(!1),i=[].indexOf,a=!!i&&1/[1].indexOf(1,-0)<0;r(r.P+r.F*(a||!n(24)(i)),\"Array\",{indexOf:function(t){return a?i.apply(this,arguments)||0:o(this,t,arguments[1])}})},function(t,e,n){var r=n(0);r(r.S,\"Array\",{isArray:n(101)})},function(t,e,n){\"use strict\";var r=n(0),o=n(18),i=[].join;r(r.P+r.F*(n(59)!=Object||!n(24)(i)),\"Array\",{join:function(t){return i.call(o(this),void 0===t?\",\":t)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(18),i=n(37),a=n(11),s=[].lastIndexOf,u=!!s&&1/[1].lastIndexOf(1,-0)<0;r(r.P+r.F*(u||!n(24)(s)),\"Array\",{lastIndexOf:function(t){if(u)return s.apply(this,arguments)||0;var e=o(this),n=a(e.length),r=n-1;for(arguments.length>1&&(r=Math.min(r,i(arguments[1]))),r<0&&(r=n+r);r>=0;r--)if(r in e&&e[r]===t)return r||0;return-1}})},function(t,e,n){\"use strict\";var r=n(0),o=n(26)(1);r(r.P+r.F*!n(24)([].map,!0),\"Array\",{map:function(t){return o(this,t,arguments[1])}})},function(t,e,n){\"use strict\";var r=n(0),o=n(94);r(r.S+r.F*n(6)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),\"Array\",{of:function(){for(var t=0,e=arguments.length,n=new(\"function\"==typeof this?this:Array)(e);e>t;)o(n,t,arguments[t++]);return n.length=e,n}})},function(t,e,n){\"use strict\";var r=n(0),o=n(141);r(r.P+r.F*!n(24)([].reduceRight,!0),\"Array\",{reduceRight:function(t){return o(this,t,arguments.length,arguments[1],!0)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(141);r(r.P+r.F*!n(24)([].reduce,!0),\"Array\",{reduce:function(t){return o(this,t,arguments.length,arguments[1],!1)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(98),i=n(22),a=n(46),s=n(11),u=[].slice;r(r.P+r.F*n(6)(function(){o&&u.call(o)}),\"Array\",{slice:function(t,e){var n=s(this.length),r=i(this);if(e=void 0===e?n:e,\"Array\"==r)return u.call(this,t,e);for(var o=a(t,n),l=a(e,n),c=s(l-o),f=Array(c),p=0;p<c;p++)f[p]=\"String\"==r?this.charAt(o+p):this[o+p];return f}})},function(t,e,n){\"use strict\";var r=n(0),o=n(26)(3);r(r.P+r.F*!n(24)([].some,!0),\"Array\",{some:function(t){return o(this,t,arguments[1])}})},function(t,e,n){\"use strict\";var r=n(0),o=n(14),i=n(12),a=n(6),s=[].sort,u=[1,2,3];r(r.P+r.F*(a(function(){u.sort(void 0)})||!a(function(){u.sort(null)})||!n(24)(s)),\"Array\",{sort:function(t){return void 0===t?s.call(i(this)):s.call(i(this),o(t))}})},function(t,e,n){n(45)(\"Array\")},function(t,e,n){var r=n(0);r(r.S,\"Date\",{now:function(){return(new Date).getTime()}})},function(t,e,n){\"use strict\";var r=n(0),o=n(6),i=Date.prototype.getTime,a=function(t){return t>9?t:\"0\"+t};r(r.P+r.F*(o(function(){return\"0385-07-25T07:06:39.999Z\"!=new Date(-5e13-1).toISOString()})||!o(function(){new Date(NaN).toISOString()})),\"Date\",{toISOString:function(){if(!isFinite(i.call(this)))throw RangeError(\"Invalid time value\");\nvar t=this,e=t.getUTCFullYear(),n=t.getUTCMilliseconds(),r=e<0?\"-\":e>9999?\"+\":\"\";return r+(\"00000\"+Math.abs(e)).slice(r?-6:-4)+\"-\"+a(t.getUTCMonth()+1)+\"-\"+a(t.getUTCDate())+\"T\"+a(t.getUTCHours())+\":\"+a(t.getUTCMinutes())+\":\"+a(t.getUTCSeconds())+\".\"+(n>99?n:\"0\"+a(n))+\"Z\"}})},function(t,e,n){\"use strict\";var r=n(0),o=n(12),i=n(28);r(r.P+r.F*n(6)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),\"Date\",{toJSON:function(t){var e=o(this),n=i(e);return\"number\"!=typeof n||isFinite(n)?e.toISOString():null}})},function(t,e,n){var r=n(8)(\"toPrimitive\"),o=Date.prototype;r in o||n(15)(o,r,n(270))},function(t,e,n){var r=Date.prototype,o=\"Invalid Date\",i=\"toString\",a=r[i],s=r.getTime;new Date(NaN)+\"\"!=o&&n(16)(r,i,function(){var t=s.call(this);return t===t?a.call(this):o})},function(t,e,n){var r=n(0);r(r.P,\"Function\",{bind:n(142)})},function(t,e,n){\"use strict\";var r=n(7),o=n(21),i=n(8)(\"hasInstance\"),a=Function.prototype;i in a||n(10).f(a,i,{value:function(t){if(\"function\"!=typeof this||!r(t))return!1;if(!r(this.prototype))return t instanceof this;for(;t=o(t);)if(this.prototype===t)return!0;return!1}})},function(t,e,n){var r=n(10).f,o=n(36),i=n(13),a=Function.prototype,s=/^\\s*function ([^ (]*)/,u=\"name\",l=Object.isExtensible||function(){return!0};u in a||n(9)&&r(a,u,{configurable:!0,get:function(){try{var t=this,e=(\"\"+t).match(s)[1];return i(t,u)||!l(t)||r(t,u,o(5,e)),e}catch(t){return\"\"}}})},function(t,e,n){var r=n(0),o=n(150),i=Math.sqrt,a=Math.acosh;r(r.S+r.F*!(a&&710==Math.floor(a(Number.MAX_VALUE))&&a(1/0)==1/0),\"Math\",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:o(t-1+i(t-1)*i(t+1))}})},function(t,e,n){function r(t){return isFinite(t=+t)&&0!=t?t<0?-r(-t):Math.log(t+Math.sqrt(t*t+1)):t}var o=n(0),i=Math.asinh;o(o.S+o.F*!(i&&1/i(0)>0),\"Math\",{asinh:r})},function(t,e,n){var r=n(0),o=Math.atanh;r(r.S+r.F*!(o&&1/o(-0)<0),\"Math\",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,e,n){var r=n(0),o=n(105);r(r.S,\"Math\",{cbrt:function(t){return o(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,e,n){var r=n(0),o=Math.exp;r(r.S,\"Math\",{cosh:function(t){return(o(t=+t)+o(-t))/2}})},function(t,e,n){var r=n(0),o=n(104);r(r.S+r.F*(o!=Math.expm1),\"Math\",{expm1:o})},function(t,e,n){var r=n(0),o=n(105),i=Math.pow,a=i(2,-52),s=i(2,-23),u=i(2,127)*(2-s),l=i(2,-126),c=function(t){return t+1/a-1/a};r(r.S,\"Math\",{fround:function(t){var e,n,r=Math.abs(t),i=o(t);return r<l?i*c(r/l/s)*l*s:(e=(1+s/a)*r,n=e-(e-r),n>u||n!=n?i*(1/0):i*n)}})},function(t,e,n){var r=n(0),o=Math.abs;r(r.S,\"Math\",{hypot:function(t,e){for(var n,r,i=0,a=0,s=arguments.length,u=0;a<s;)n=o(arguments[a++]),u<n?(r=u/n,i=i*r*r+1,u=n):n>0?(r=n/u,i+=r*r):i+=n;return u===1/0?1/0:u*Math.sqrt(i)}})},function(t,e,n){var r=n(0),o=Math.imul;r(r.S+r.F*n(6)(function(){return o(4294967295,5)!=-5||2!=o.length}),\"Math\",{imul:function(t,e){var n=65535,r=+t,o=+e,i=n&r,a=n&o;return 0|i*a+((n&r>>>16)*a+i*(n&o>>>16)<<16>>>0)}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{log1p:n(150)})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{sign:n(105)})},function(t,e,n){var r=n(0),o=n(104),i=Math.exp;r(r.S+r.F*n(6)(function(){return!Math.sinh(-2e-17)!=-2e-17}),\"Math\",{sinh:function(t){return Math.abs(t=+t)<1?(o(t)-o(-t))/2:(i(t-1)-i(-t-1))*(Math.E/2)}})},function(t,e,n){var r=n(0),o=n(104),i=Math.exp;r(r.S,\"Math\",{tanh:function(t){var e=o(t=+t),n=o(-t);return e==1/0?1:n==1/0?-1:(e-n)/(i(t)+i(-t))}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,e,n){\"use strict\";var r=n(5),o=n(13),i=n(22),a=n(99),s=n(28),u=n(6),l=n(42).f,c=n(20).f,f=n(10).f,p=n(54).trim,h=\"Number\",d=r[h],v=d,m=d.prototype,_=i(n(41)(m))==h,g=\"trim\"in String.prototype,y=function(t){var e=s(t,!1);if(\"string\"==typeof e&&e.length>2){e=g?e.trim():p(e,3);var n,r,o,i=e.charCodeAt(0);if(43===i||45===i){if(n=e.charCodeAt(2),88===n||120===n)return NaN}else if(48===i){switch(e.charCodeAt(1)){case 66:case 98:r=2,o=49;break;case 79:case 111:r=8,o=55;break;default:return+e}for(var a,u=e.slice(2),l=0,c=u.length;l<c;l++)if(a=u.charCodeAt(l),a<48||a>o)return NaN;return parseInt(u,r)}}return+e};if(!d(\" 0o1\")||!d(\"0b1\")||d(\"+0x1\")){d=function(t){var e=arguments.length<1?0:t,n=this;return n instanceof d&&(_?u(function(){m.valueOf.call(n)}):i(n)!=h)?a(new v(y(e)),n,d):y(e)};for(var b,w=n(9)?l(v):\"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger\".split(\",\"),x=0;w.length>x;x++)o(v,b=w[x])&&!o(d,b)&&f(d,b,c(v,b));d.prototype=m,m.constructor=d,n(16)(r,h,d)}},function(t,e,n){var r=n(0);r(r.S,\"Number\",{EPSILON:Math.pow(2,-52)})},function(t,e,n){var r=n(0),o=n(5).isFinite;r(r.S,\"Number\",{isFinite:function(t){return\"number\"==typeof t&&o(t)}})},function(t,e,n){var r=n(0);r(r.S,\"Number\",{isInteger:n(147)})},function(t,e,n){var r=n(0);r(r.S,\"Number\",{isNaN:function(t){return t!=t}})},function(t,e,n){var r=n(0),o=n(147),i=Math.abs;r(r.S,\"Number\",{isSafeInteger:function(t){return o(t)&&i(t)<=9007199254740991}})},function(t,e,n){var r=n(0);r(r.S,\"Number\",{MAX_SAFE_INTEGER:9007199254740991})},function(t,e,n){var r=n(0);r(r.S,\"Number\",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,e,n){var r=n(0),o=n(157);r(r.S+r.F*(Number.parseFloat!=o),\"Number\",{parseFloat:o})},function(t,e,n){var r=n(0),o=n(158);r(r.S+r.F*(Number.parseInt!=o),\"Number\",{parseInt:o})},function(t,e,n){\"use strict\";var r=n(0),o=n(37),i=n(138),a=n(112),s=1..toFixed,u=Math.floor,l=[0,0,0,0,0,0],c=\"Number.toFixed: incorrect invocation!\",f=\"0\",p=function(t,e){for(var n=-1,r=e;++n<6;)r+=t*l[n],l[n]=r%1e7,r=u(r/1e7)},h=function(t){for(var e=6,n=0;--e>=0;)n+=l[e],l[e]=u(n/t),n=n%t*1e7},d=function(){for(var t=6,e=\"\";--t>=0;)if(\"\"!==e||0===t||0!==l[t]){var n=String(l[t]);e=\"\"===e?n:e+a.call(f,7-n.length)+n}return e},v=function(t,e,n){return 0===e?n:e%2===1?v(t,e-1,n*t):v(t*t,e/2,n)},m=function(t){for(var e=0,n=t;n>=4096;)e+=12,n/=4096;for(;n>=2;)e+=1,n/=2;return e};r(r.P+r.F*(!!s&&(\"0.000\"!==8e-5.toFixed(3)||\"1\"!==.9.toFixed(0)||\"1.25\"!==1.255.toFixed(2)||\"1000000000000000128\"!==(0xde0b6b3a7640080).toFixed(0))||!n(6)(function(){s.call({})})),\"Number\",{toFixed:function(t){var e,n,r,s,u=i(this,c),l=o(t),_=\"\",g=f;if(l<0||l>20)throw RangeError(c);if(u!=u)return\"NaN\";if(u<=-1e21||u>=1e21)return String(u);if(u<0&&(_=\"-\",u=-u),u>1e-21)if(e=m(u*v(2,69,1))-69,n=e<0?u*v(2,-e,1):u/v(2,e,1),n*=4503599627370496,e=52-e,e>0){for(p(0,n),r=l;r>=7;)p(1e7,0),r-=7;for(p(v(10,r,1),0),r=e-1;r>=23;)h(1<<23),r-=23;h(1<<r),p(1,1),h(2),g=d()}else p(0,n),p(1<<-e,0),g=d()+a.call(f,l);return l>0?(s=g.length,g=_+(s<=l?\"0.\"+a.call(f,l-s)+g:g.slice(0,s-l)+\".\"+g.slice(s-l))):g=_+g,g}})},function(t,e,n){\"use strict\";var r=n(0),o=n(6),i=n(138),a=1..toPrecision;r(r.P+r.F*(o(function(){return\"1\"!==a.call(1,void 0)})||!o(function(){a.call({})})),\"Number\",{toPrecision:function(t){var e=i(this,\"Number#toPrecision: incorrect invocation!\");return void 0===t?a.call(e):a.call(e,t)}})},function(t,e,n){var r=n(0);r(r.S+r.F,\"Object\",{assign:n(151)})},function(t,e,n){var r=n(0);r(r.S,\"Object\",{create:n(41)})},function(t,e,n){var r=n(0);r(r.S+r.F*!n(9),\"Object\",{defineProperties:n(152)})},function(t,e,n){var r=n(0);r(r.S+r.F*!n(9),\"Object\",{defineProperty:n(10).f})},function(t,e,n){var r=n(7),o=n(35).onFreeze;n(27)(\"freeze\",function(t){return function(e){return t&&r(e)?t(o(e)):e}})},function(t,e,n){var r=n(18),o=n(20).f;n(27)(\"getOwnPropertyDescriptor\",function(){return function(t,e){return o(r(t),e)}})},function(t,e,n){n(27)(\"getOwnPropertyNames\",function(){return n(153).f})},function(t,e,n){var r=n(12),o=n(21);n(27)(\"getPrototypeOf\",function(){return function(t){return o(r(t))}})},function(t,e,n){var r=n(7);n(27)(\"isExtensible\",function(t){return function(e){return!!r(e)&&(!t||t(e))}})},function(t,e,n){var r=n(7);n(27)(\"isFrozen\",function(t){return function(e){return!r(e)||!!t&&t(e)}})},function(t,e,n){var r=n(7);n(27)(\"isSealed\",function(t){return function(e){return!r(e)||!!t&&t(e)}})},function(t,e,n){var r=n(0);r(r.S,\"Object\",{is:n(159)})},function(t,e,n){var r=n(12),o=n(43);n(27)(\"keys\",function(){return function(t){return o(r(t))}})},function(t,e,n){var r=n(7),o=n(35).onFreeze;n(27)(\"preventExtensions\",function(t){return function(e){return t&&r(e)?t(o(e)):e}})},function(t,e,n){var r=n(7),o=n(35).onFreeze;n(27)(\"seal\",function(t){return function(e){return t&&r(e)?t(o(e)):e}})},function(t,e,n){var r=n(0);r(r.S,\"Object\",{setPrototypeOf:n(107).set})},function(t,e,n){\"use strict\";var r=n(58),o={};o[n(8)(\"toStringTag\")]=\"z\",o+\"\"!=\"[object z]\"&&n(16)(Object.prototype,\"toString\",function(){return\"[object \"+r(this)+\"]\"},!0)},function(t,e,n){var r=n(0),o=n(157);r(r.G+r.F*(parseFloat!=o),{parseFloat:o})},function(t,e,n){var r=n(0),o=n(158);r(r.G+r.F*(parseInt!=o),{parseInt:o})},function(t,e,n){\"use strict\";var r,o,i,a=n(40),s=n(5),u=n(32),l=n(58),c=n(0),f=n(7),p=n(14),h=n(39),d=n(51),v=n(109),m=n(114).set,_=n(106)(),g=\"Promise\",y=s.TypeError,b=s.process,w=s[g],b=s.process,x=\"process\"==l(b),E=function(){},T=!!function(){try{var t=w.resolve(1),e=(t.constructor={})[n(8)(\"species\")]=function(t){t(E,E)};return(x||\"function\"==typeof PromiseRejectionEvent)&&t.then(E)instanceof e}catch(t){}}(),O=function(t,e){return t===e||t===w&&e===i},S=function(t){var e;return!(!f(t)||\"function\"!=typeof(e=t.then))&&e},P=function(t){return O(w,t)?new M(t):new o(t)},M=o=function(t){var e,n;this.promise=new t(function(t,r){if(void 0!==e||void 0!==n)throw y(\"Bad Promise constructor\");e=t,n=r}),this.resolve=p(e),this.reject=p(n)},j=function(t){try{t()}catch(t){return{error:t}}},A=function(t,e){if(!t._n){t._n=!0;var n=t._c;_(function(){for(var r=t._v,o=1==t._s,i=0,a=function(e){var n,i,a=o?e.ok:e.fail,s=e.resolve,u=e.reject,l=e.domain;try{a?(o||(2==t._h&&R(t),t._h=1),a===!0?n=r:(l&&l.enter(),n=a(r),l&&l.exit()),n===e.promise?u(y(\"Promise-chain cycle\")):(i=S(n))?i.call(n,s,u):s(n)):u(r)}catch(t){u(t)}};n.length>i;)a(n[i++]);t._c=[],t._n=!1,e&&!t._h&&C(t)})}},C=function(t){m.call(s,function(){var e,n,r,o=t._v;if(k(t)&&(e=j(function(){x?b.emit(\"unhandledRejection\",o,t):(n=s.onunhandledrejection)?n({promise:t,reason:o}):(r=s.console)&&r.error&&r.error(\"Unhandled promise rejection\",o)}),t._h=x||k(t)?2:1),t._a=void 0,e)throw e.error})},k=function(t){if(1==t._h)return!1;for(var e,n=t._a||t._c,r=0;n.length>r;)if(e=n[r++],e.fail||!k(e.promise))return!1;return!0},R=function(t){m.call(s,function(){var e;x?b.emit(\"rejectionHandled\",t):(e=s.onrejectionhandled)&&e({promise:t,reason:t._v})})},I=function(t){var e=this;e._d||(e._d=!0,e=e._w||e,e._v=t,e._s=2,e._a||(e._a=e._c.slice()),A(e,!0))},N=function(t){var e,n=this;if(!n._d){n._d=!0,n=n._w||n;try{if(n===t)throw y(\"Promise can't be resolved itself\");(e=S(t))?_(function(){var r={_w:n,_d:!1};try{e.call(t,u(N,r,1),u(I,r,1))}catch(t){I.call(r,t)}}):(n._v=t,n._s=1,A(n,!1))}catch(t){I.call({_w:n,_d:!1},t)}}};T||(w=function(t){h(this,w,g,\"_h\"),p(t),r.call(this);try{t(u(N,this,1),u(I,this,1))}catch(t){I.call(this,t)}},r=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},r.prototype=n(44)(w.prototype,{then:function(t,e){var n=P(v(this,w));return n.ok=\"function\"!=typeof t||t,n.fail=\"function\"==typeof e&&e,n.domain=x?b.domain:void 0,this._c.push(n),this._a&&this._a.push(n),this._s&&A(this,!1),n.promise},catch:function(t){return this.then(void 0,t)}}),M=function(){var t=new r;this.promise=t,this.resolve=u(N,t,1),this.reject=u(I,t,1)}),c(c.G+c.W+c.F*!T,{Promise:w}),n(53)(w,g),n(45)(g),i=n(31)[g],c(c.S+c.F*!T,g,{reject:function(t){var e=P(this),n=e.reject;return n(t),e.promise}}),c(c.S+c.F*(a||!T),g,{resolve:function(t){if(t instanceof w&&O(t.constructor,this))return t;var e=P(this),n=e.resolve;return n(t),e.promise}}),c(c.S+c.F*!(T&&n(75)(function(t){w.all(t).catch(E)})),g,{all:function(t){var e=this,n=P(e),r=n.resolve,o=n.reject,i=j(function(){var n=[],i=0,a=1;d(t,!1,function(t){var s=i++,u=!1;n.push(void 0),a++,e.resolve(t).then(function(t){u||(u=!0,n[s]=t,--a||r(n))},o)}),--a||r(n)});return i&&o(i.error),n.promise},race:function(t){var e=this,n=P(e),r=n.reject,o=j(function(){d(t,!1,function(t){e.resolve(t).then(n.resolve,r)})});return o&&r(o.error),n.promise}})},function(t,e,n){var r=n(0),o=n(14),i=n(4),a=(n(5).Reflect||{}).apply,s=Function.apply;r(r.S+r.F*!n(6)(function(){a(function(){})}),\"Reflect\",{apply:function(t,e,n){var r=o(t),u=i(n);return a?a(r,e,u):s.call(r,e,u)}})},function(t,e,n){var r=n(0),o=n(41),i=n(14),a=n(4),s=n(7),u=n(6),l=n(142),c=(n(5).Reflect||{}).construct,f=u(function(){function t(){}return!(c(function(){},[],t)instanceof t)}),p=!u(function(){c(function(){})});r(r.S+r.F*(f||p),\"Reflect\",{construct:function(t,e){i(t),a(e);var n=arguments.length<3?t:i(arguments[2]);if(p&&!f)return c(t,e,n);if(t==n){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var r=[null];return r.push.apply(r,e),new(l.apply(t,r))}var u=n.prototype,h=o(s(u)?u:Object.prototype),d=Function.apply.call(t,h,e);return s(d)?d:h}})},function(t,e,n){var r=n(10),o=n(0),i=n(4),a=n(28);o(o.S+o.F*n(6)(function(){Reflect.defineProperty(r.f({},1,{value:1}),1,{value:2})}),\"Reflect\",{defineProperty:function(t,e,n){i(t),e=a(e,!0),i(n);try{return r.f(t,e,n),!0}catch(t){return!1}}})},function(t,e,n){var r=n(0),o=n(20).f,i=n(4);r(r.S,\"Reflect\",{deleteProperty:function(t,e){var n=o(i(t),e);return!(n&&!n.configurable)&&delete t[e]}})},function(t,e,n){\"use strict\";var r=n(0),o=n(4),i=function(t){this._t=o(t),this._i=0;var e,n=this._k=[];for(e in t)n.push(e)};n(102)(i,\"Object\",function(){var t,e=this,n=e._k;do if(e._i>=n.length)return{value:void 0,done:!0};while(!((t=n[e._i++])in e._t));return{value:t,done:!1}}),r(r.S,\"Reflect\",{enumerate:function(t){return new i(t)}})},function(t,e,n){var r=n(20),o=n(0),i=n(4);o(o.S,\"Reflect\",{getOwnPropertyDescriptor:function(t,e){return r.f(i(t),e)}})},function(t,e,n){var r=n(0),o=n(21),i=n(4);r(r.S,\"Reflect\",{getPrototypeOf:function(t){return o(i(t))}})},function(t,e,n){function r(t,e){var n,s,c=arguments.length<3?t:arguments[2];return l(t)===c?t[e]:(n=o.f(t,e))?a(n,\"value\")?n.value:void 0!==n.get?n.get.call(c):void 0:u(s=i(t))?r(s,e,c):void 0}var o=n(20),i=n(21),a=n(13),s=n(0),u=n(7),l=n(4);s(s.S,\"Reflect\",{get:r})},function(t,e,n){var r=n(0);r(r.S,\"Reflect\",{has:function(t,e){return e in t}})},function(t,e,n){var r=n(0),o=n(4),i=Object.isExtensible;r(r.S,\"Reflect\",{isExtensible:function(t){return o(t),!i||i(t)}})},function(t,e,n){var r=n(0);r(r.S,\"Reflect\",{ownKeys:n(156)})},function(t,e,n){var r=n(0),o=n(4),i=Object.preventExtensions;r(r.S,\"Reflect\",{preventExtensions:function(t){o(t);try{return i&&i(t),!0}catch(t){return!1}}})},function(t,e,n){var r=n(0),o=n(107);o&&r(r.S,\"Reflect\",{setPrototypeOf:function(t,e){o.check(t,e);try{return o.set(t,e),!0}catch(t){return!1}}})},function(t,e,n){function r(t,e,n){var u,p,h=arguments.length<4?t:arguments[3],d=i.f(c(t),e);if(!d){if(f(p=a(t)))return r(p,e,n,h);d=l(0)}return s(d,\"value\")?!(d.writable===!1||!f(h))&&(u=i.f(h,e)||l(0),u.value=n,o.f(h,e,u),!0):void 0!==d.set&&(d.set.call(h,n),!0)}var o=n(10),i=n(20),a=n(21),s=n(13),u=n(0),l=n(36),c=n(4),f=n(7);u(u.S,\"Reflect\",{set:r})},function(t,e,n){var r=n(5),o=n(99),i=n(10).f,a=n(42).f,s=n(74),u=n(72),l=r.RegExp,c=l,f=l.prototype,p=/a/g,h=/a/g,d=new l(p)!==p;if(n(9)&&(!d||n(6)(function(){return h[n(8)(\"match\")]=!1,l(p)!=p||l(h)==h||\"/a/i\"!=l(p,\"i\")}))){l=function(t,e){var n=this instanceof l,r=s(t),i=void 0===e;return!n&&r&&t.constructor===l&&i?t:o(d?new c(r&&!i?t.source:t,e):c((r=t instanceof l)?t.source:t,r&&i?u.call(t):e),n?this:f,l)};for(var v=(function(t){t in l||i(l,t,{configurable:!0,get:function(){return c[t]},set:function(e){c[t]=e}})}),m=a(c),_=0;m.length>_;)v(m[_++]);f.constructor=l,l.prototype=f,n(16)(r,\"RegExp\",l)}n(45)(\"RegExp\")},function(t,e,n){n(71)(\"match\",1,function(t,e,n){return[function(n){\"use strict\";var r=t(this),o=void 0==n?void 0:n[e];return void 0!==o?o.call(n,r):new RegExp(n)[e](String(r))},n]})},function(t,e,n){n(71)(\"replace\",2,function(t,e,n){return[function(r,o){\"use strict\";var i=t(this),a=void 0==r?void 0:r[e];return void 0!==a?a.call(r,i,o):n.call(String(i),r,o)},n]})},function(t,e,n){n(71)(\"search\",1,function(t,e,n){return[function(n){\"use strict\";var r=t(this),o=void 0==n?void 0:n[e];return void 0!==o?o.call(n,r):new RegExp(n)[e](String(r))},n]})},function(t,e,n){n(71)(\"split\",2,function(t,e,r){\"use strict\";var o=n(74),i=r,a=[].push,s=\"split\",u=\"length\",l=\"lastIndex\";if(\"c\"==\"abbc\"[s](/(b)*/)[1]||4!=\"test\"[s](/(?:)/,-1)[u]||2!=\"ab\"[s](/(?:ab)*/)[u]||4!=\".\"[s](/(.?)(.?)/)[u]||\".\"[s](/()()/)[u]>1||\"\"[s](/.?/)[u]){var c=void 0===/()??/.exec(\"\")[1];r=function(t,e){var n=String(this);if(void 0===t&&0===e)return[];if(!o(t))return i.call(n,t,e);var r,s,f,p,h,d=[],v=(t.ignoreCase?\"i\":\"\")+(t.multiline?\"m\":\"\")+(t.unicode?\"u\":\"\")+(t.sticky?\"y\":\"\"),m=0,_=void 0===e?4294967295:e>>>0,g=new RegExp(t.source,v+\"g\");for(c||(r=new RegExp(\"^\"+g.source+\"$(?!\\\\s)\",v));(s=g.exec(n))&&(f=s.index+s[0][u],!(f>m&&(d.push(n.slice(m,s.index)),!c&&s[u]>1&&s[0].replace(r,function(){for(h=1;h<arguments[u]-2;h++)void 0===arguments[h]&&(s[h]=void 0)}),s[u]>1&&s.index<n[u]&&a.apply(d,s.slice(1)),p=s[0][u],m=f,d[u]>=_)));)g[l]===s.index&&g[l]++;return m===n[u]?!p&&g.test(\"\")||d.push(\"\"):d.push(n.slice(m)),d[u]>_?d.slice(0,_):d}}else\"0\"[s](void 0,0)[u]&&(r=function(t,e){return void 0===t&&0===e?[]:i.call(this,t,e)});return[function(n,o){var i=t(this),a=void 0==n?void 0:n[e];return void 0!==a?a.call(n,i,o):r.call(String(i),n,o)},r]})},function(t,e,n){\"use strict\";n(163);var r=n(4),o=n(72),i=n(9),a=\"toString\",s=/./[a],u=function(t){n(16)(RegExp.prototype,a,t,!0)};n(6)(function(){return\"/a/b\"!=s.call({source:\"a\",flags:\"b\"})})?u(function(){var t=r(this);return\"/\".concat(t.source,\"/\",\"flags\"in t?t.flags:!i&&t instanceof RegExp?o.call(t):void 0)}):s.name!=a&&u(function(){return s.call(this)})},function(t,e,n){\"use strict\";n(17)(\"anchor\",function(t){return function(e){return t(this,\"a\",\"name\",e)}})},function(t,e,n){\"use strict\";n(17)(\"big\",function(t){return function(){return t(this,\"big\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(17)(\"blink\",function(t){return function(){return t(this,\"blink\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(17)(\"bold\",function(t){return function(){return t(this,\"b\",\"\",\"\")}})},function(t,e,n){\"use strict\";var r=n(0),o=n(110)(!1);r(r.P,\"String\",{codePointAt:function(t){return o(this,t)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(11),i=n(111),a=\"endsWith\",s=\"\"[a];r(r.P+r.F*n(97)(a),\"String\",{endsWith:function(t){var e=i(this,t,a),n=arguments.length>1?arguments[1]:void 0,r=o(e.length),u=void 0===n?r:Math.min(o(n),r),l=String(t);return s?s.call(e,l,u):e.slice(u-l.length,u)===l}})},function(t,e,n){\"use strict\";n(17)(\"fixed\",function(t){return function(){return t(this,\"tt\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(17)(\"fontcolor\",function(t){return function(e){return t(this,\"font\",\"color\",e)}})},function(t,e,n){\"use strict\";n(17)(\"fontsize\",function(t){return function(e){return t(this,\"font\",\"size\",e)}})},function(t,e,n){var r=n(0),o=n(46),i=String.fromCharCode,a=String.fromCodePoint;r(r.S+r.F*(!!a&&1!=a.length),\"String\",{fromCodePoint:function(t){for(var e,n=[],r=arguments.length,a=0;r>a;){if(e=+arguments[a++],o(e,1114111)!==e)throw RangeError(e+\" is not a valid code point\");n.push(e<65536?i(e):i(((e-=65536)>>10)+55296,e%1024+56320))}return n.join(\"\")}})},function(t,e,n){\"use strict\";var r=n(0),o=n(111),i=\"includes\";r(r.P+r.F*n(97)(i),\"String\",{includes:function(t){return!!~o(this,t,i).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,n){\"use strict\";n(17)(\"italics\",function(t){return function(){return t(this,\"i\",\"\",\"\")}})},function(t,e,n){\"use strict\";var r=n(110)(!0);n(103)(String,\"String\",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=r(e,n),this._i+=t.length,{value:t,done:!1})})},function(t,e,n){\"use strict\";n(17)(\"link\",function(t){return function(e){return t(this,\"a\",\"href\",e)}})},function(t,e,n){var r=n(0),o=n(18),i=n(11);r(r.S,\"String\",{raw:function(t){for(var e=o(t.raw),n=i(e.length),r=arguments.length,a=[],s=0;n>s;)a.push(String(e[s++])),s<r&&a.push(String(arguments[s]));return a.join(\"\")}})},function(t,e,n){var r=n(0);r(r.P,\"String\",{repeat:n(112)})},function(t,e,n){\"use strict\";n(17)(\"small\",function(t){return function(){return t(this,\"small\",\"\",\"\")}})},function(t,e,n){\"use strict\";var r=n(0),o=n(11),i=n(111),a=\"startsWith\",s=\"\"[a];r(r.P+r.F*n(97)(a),\"String\",{startsWith:function(t){var e=i(this,t,a),n=o(Math.min(arguments.length>1?arguments[1]:void 0,e.length)),r=String(t);return s?s.call(e,r,n):e.slice(n,n+r.length)===r}})},function(t,e,n){\"use strict\";n(17)(\"strike\",function(t){return function(){return t(this,\"strike\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(17)(\"sub\",function(t){return function(){return t(this,\"sub\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(17)(\"sup\",function(t){return function(){return t(this,\"sup\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(54)(\"trim\",function(t){return function(){return t(this,3)}})},function(t,e,n){\"use strict\";var r=n(5),o=n(13),i=n(9),a=n(0),s=n(16),u=n(35).KEY,l=n(6),c=n(78),f=n(53),p=n(47),h=n(8),d=n(161),v=n(116),m=n(272),_=n(271),g=n(101),y=n(4),b=n(18),w=n(28),x=n(36),E=n(41),T=n(153),O=n(20),S=n(10),P=n(43),M=O.f,j=S.f,A=T.f,C=r.Symbol,k=r.JSON,R=k&&k.stringify,I=\"prototype\",N=h(\"_hidden\"),U=h(\"toPrimitive\"),F={}.propertyIsEnumerable,L=c(\"symbol-registry\"),D=c(\"symbols\"),B=c(\"op-symbols\"),V=Object[I],W=\"function\"==typeof C,X=r.QObject,z=!X||!X[I]||!X[I].findChild,G=i&&l(function(){return 7!=E(j({},\"a\",{get:function(){return j(this,\"a\",{value:7}).a}})).a})?function(t,e,n){var r=M(V,e);r&&delete V[e],j(t,e,n),r&&t!==V&&j(V,e,r)}:j,q=function(t){var e=D[t]=E(C[I]);return e._k=t,e},H=W&&\"symbol\"==typeof C.iterator?function(t){return\"symbol\"==typeof t}:function(t){return t instanceof C},Y=function(t,e,n){return t===V&&Y(B,e,n),y(t),e=w(e,!0),y(n),o(D,e)?(n.enumerable?(o(t,N)&&t[N][e]&&(t[N][e]=!1),n=E(n,{enumerable:x(0,!1)})):(o(t,N)||j(t,N,x(1,{})),t[N][e]=!0),G(t,e,n)):j(t,e,n)},K=function(t,e){y(t);for(var n,r=_(e=b(e)),o=0,i=r.length;i>o;)Y(t,n=r[o++],e[n]);return t},$=function(t,e){return void 0===e?E(t):K(E(t),e)},Z=function(t){var e=F.call(this,t=w(t,!0));return!(this===V&&o(D,t)&&!o(B,t))&&(!(e||!o(this,t)||!o(D,t)||o(this,N)&&this[N][t])||e)},Q=function(t,e){if(t=b(t),e=w(e,!0),t!==V||!o(D,e)||o(B,e)){var n=M(t,e);return!n||!o(D,e)||o(t,N)&&t[N][e]||(n.enumerable=!0),n}},J=function(t){for(var e,n=A(b(t)),r=[],i=0;n.length>i;)o(D,e=n[i++])||e==N||e==u||r.push(e);return r},tt=function(t){for(var e,n=t===V,r=A(n?B:b(t)),i=[],a=0;r.length>a;)!o(D,e=r[a++])||n&&!o(V,e)||i.push(D[e]);return i};W||(C=function(){if(this instanceof C)throw TypeError(\"Symbol is not a constructor!\");var t=p(arguments.length>0?arguments[0]:void 0),e=function(n){this===V&&e.call(B,n),o(this,N)&&o(this[N],t)&&(this[N][t]=!1),G(this,t,x(1,n))};return i&&z&&G(V,t,{configurable:!0,set:e}),q(t)},s(C[I],\"toString\",function(){return this._k}),O.f=Q,S.f=Y,n(42).f=T.f=J,n(60).f=Z,n(77).f=tt,i&&!n(40)&&s(V,\"propertyIsEnumerable\",Z,!0),d.f=function(t){return q(h(t))}),a(a.G+a.W+a.F*!W,{Symbol:C});for(var et=\"hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\".split(\",\"),nt=0;et.length>nt;)h(et[nt++]);for(var et=P(h.store),nt=0;et.length>nt;)v(et[nt++]);a(a.S+a.F*!W,\"Symbol\",{for:function(t){return o(L,t+=\"\")?L[t]:L[t]=C(t)},keyFor:function(t){if(H(t))return m(L,t);throw TypeError(t+\" is not a symbol!\")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),a(a.S+a.F*!W,\"Object\",{create:$,defineProperty:Y,defineProperties:K,getOwnPropertyDescriptor:Q,getOwnPropertyNames:J,getOwnPropertySymbols:tt}),k&&a(a.S+a.F*(!W||l(function(){var t=C();return\"[null]\"!=R([t])||\"{}\"!=R({a:t})||\"{}\"!=R(Object(t))})),\"JSON\",{stringify:function(t){if(void 0!==t&&!H(t)){for(var e,n,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return e=r[1],\"function\"==typeof e&&(n=e),!n&&g(e)||(e=function(t,e){if(n&&(e=n.call(this,t,e)),!H(e))return e}),r[1]=e,R.apply(k,r)}}}),C[I][U]||n(15)(C[I],U,C[I].valueOf),f(C,\"Symbol\"),f(Math,\"Math\",!0),f(r.JSON,\"JSON\",!0)},function(t,e,n){\"use strict\";var r=n(0),o=n(79),i=n(115),a=n(4),s=n(46),u=n(11),l=n(7),c=n(5).ArrayBuffer,f=n(109),p=i.ArrayBuffer,h=i.DataView,d=o.ABV&&c.isView,v=p.prototype.slice,m=o.VIEW,_=\"ArrayBuffer\";r(r.G+r.W+r.F*(c!==p),{ArrayBuffer:p}),r(r.S+r.F*!o.CONSTR,_,{isView:function(t){return d&&d(t)||l(t)&&m in t}}),r(r.P+r.U+r.F*n(6)(function(){return!new p(2).slice(1,void 0).byteLength}),_,{slice:function(t,e){if(void 0!==v&&void 0===e)return v.call(a(this),t);for(var n=a(this).byteLength,r=s(t,n),o=s(void 0===e?n:e,n),i=new(f(this,p))(u(o-r)),l=new h(this),c=new h(i),d=0;r<o;)c.setUint8(d++,l.getUint8(r++));return i}}),n(45)(_)},function(t,e,n){var r=n(0);r(r.G+r.W+r.F*!n(79).ABV,{DataView:n(115).DataView})},function(t,e,n){n(34)(\"Float32\",4,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Float64\",8,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Int16\",2,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Int32\",4,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Int8\",1,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Uint16\",2,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Uint32\",4,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Uint8\",1,function(t){return function(e,n,r){return t(this,e,n,r)}})},function(t,e,n){n(34)(\"Uint8\",1,function(t){return function(e,n,r){return t(this,e,n,r)}},!0)},function(t,e,n){\"use strict\";var r=n(145);n(70)(\"WeakSet\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return r.def(this,t,!0)}},r,!1,!0)},function(t,e,n){\"use strict\";var r=n(0),o=n(69)(!0);r(r.P,\"Array\",{includes:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),n(50)(\"includes\")},function(t,e,n){var r=n(0),o=n(106)(),i=n(5).process,a=\"process\"==n(22)(i);r(r.G,{asap:function(t){var e=a&&i.domain;o(e?e.bind(t):t)}})},function(t,e,n){var r=n(0),o=n(22);r(r.S,\"Error\",{isError:function(t){return\"Error\"===o(t)}})},function(t,e,n){var r=n(0);r(r.P+r.R,\"Map\",{toJSON:n(144)(\"Map\")})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{iaddh:function(t,e,n,r){var o=t>>>0,i=e>>>0,a=n>>>0;return i+(r>>>0)+((o&a|(o|a)&~(o+a>>>0))>>>31)|0}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{imulh:function(t,e){var n=65535,r=+t,o=+e,i=r&n,a=o&n,s=r>>16,u=o>>16,l=(s*a>>>0)+(i*a>>>16);return s*u+(l>>16)+((i*u>>>0)+(l&n)>>16)}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{isubh:function(t,e,n,r){var o=t>>>0,i=e>>>0,a=n>>>0;return i-(r>>>0)-((~o&a|~(o^a)&o-a>>>0)>>>31)|0}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{umulh:function(t,e){var n=65535,r=+t,o=+e,i=r&n,a=o&n,s=r>>>16,u=o>>>16,l=(s*a>>>0)+(i*a>>>16);return s*u+(l>>>16)+((i*u>>>0)+(l&n)>>>16)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(12),i=n(14),a=n(10);n(9)&&r(r.P+n(76),\"Object\",{__defineGetter__:function(t,e){a.f(o(this),t,{get:i(e),enumerable:!0,configurable:!0})}})},function(t,e,n){\"use strict\";var r=n(0),o=n(12),i=n(14),a=n(10);n(9)&&r(r.P+n(76),\"Object\",{__defineSetter__:function(t,e){a.f(o(this),t,{set:i(e),enumerable:!0,configurable:!0})}})},function(t,e,n){var r=n(0),o=n(155)(!0);r(r.S,\"Object\",{entries:function(t){return o(t)}})},function(t,e,n){var r=n(0),o=n(156),i=n(18),a=n(20),s=n(94);r(r.S,\"Object\",{getOwnPropertyDescriptors:function(t){for(var e,n=i(t),r=a.f,u=o(n),l={},c=0;u.length>c;)s(l,e=u[c++],r(n,e));return l}})},function(t,e,n){\"use strict\";var r=n(0),o=n(12),i=n(28),a=n(21),s=n(20).f;n(9)&&r(r.P+n(76),\"Object\",{__lookupGetter__:function(t){var e,n=o(this),r=i(t,!0);do if(e=s(n,r))return e.get;while(n=a(n))}})},function(t,e,n){\"use strict\";var r=n(0),o=n(12),i=n(28),a=n(21),s=n(20).f;n(9)&&r(r.P+n(76),\"Object\",{__lookupSetter__:function(t){var e,n=o(this),r=i(t,!0);do if(e=s(n,r))return e.set;while(n=a(n))}})},function(t,e,n){var r=n(0),o=n(155)(!1);r(r.S,\"Object\",{values:function(t){return o(t)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(5),i=n(31),a=n(106)(),s=n(8)(\"observable\"),u=n(14),l=n(4),c=n(39),f=n(44),p=n(15),h=n(51),d=h.RETURN,v=function(t){return null==t?void 0:u(t)},m=function(t){var e=t._c;e&&(t._c=void 0,e())},_=function(t){return void 0===t._o},g=function(t){_(t)||(t._o=void 0,m(t))},y=function(t,e){l(t),this._c=void 0,this._o=t,t=new b(this);try{var n=e(t),r=n;null!=n&&(\"function\"==typeof n.unsubscribe?n=function(){r.unsubscribe()}:u(n),this._c=n)}catch(e){return void t.error(e)}_(this)&&m(this)};y.prototype=f({},{unsubscribe:function(){g(this)}});var b=function(t){this._s=t};b.prototype=f({},{next:function(t){var e=this._s;if(!_(e)){var n=e._o;try{var r=v(n.next);if(r)return r.call(n,t)}catch(t){try{g(e)}finally{throw t}}}},error:function(t){var e=this._s;if(_(e))throw t;var n=e._o;e._o=void 0;try{var r=v(n.error);if(!r)throw t;t=r.call(n,t)}catch(t){try{m(e)}finally{throw t}}return m(e),t},complete:function(t){var e=this._s;if(!_(e)){var n=e._o;e._o=void 0;try{var r=v(n.complete);t=r?r.call(n,t):void 0}catch(t){try{m(e)}finally{throw t}}return m(e),t}}});var w=function(t){c(this,w,\"Observable\",\"_f\")._f=u(t)};f(w.prototype,{subscribe:function(t){return new y(t,this._f)},forEach:function(t){var e=this;return new(i.Promise||o.Promise)(function(n,r){u(t);var o=e.subscribe({next:function(e){try{return t(e)}catch(t){r(t),o.unsubscribe()}},error:r,complete:n})})}}),f(w,{from:function(t){var e=\"function\"==typeof this?this:w,n=v(l(t)[s]);if(n){var r=l(n.call(t));return r.constructor===e?r:new e(function(t){return r.subscribe(t)})}return new e(function(e){var n=!1;return a(function(){if(!n){try{if(h(t,!1,function(t){if(e.next(t),n)return d})===d)return}catch(t){if(n)throw t;return void e.error(t)}e.complete()}}),function(){n=!0}})},of:function(){for(var t=0,e=arguments.length,n=Array(e);t<e;)n[t]=arguments[t++];return new(\"function\"==typeof this?this:w)(function(t){var e=!1;return a(function(){if(!e){for(var r=0;r<n.length;++r)if(t.next(n[r]),e)return;t.complete()}}),function(){e=!0}})}}),p(w.prototype,s,function(){return this}),r(r.G,{Observable:w}),n(45)(\"Observable\")},function(t,e,n){var r=n(33),o=n(4),i=r.key,a=r.set;r.exp({defineMetadata:function(t,e,n,r){a(t,e,o(n),i(r))}})},function(t,e,n){var r=n(33),o=n(4),i=r.key,a=r.map,s=r.store;r.exp({deleteMetadata:function(t,e){var n=arguments.length<3?void 0:i(arguments[2]),r=a(o(e),n,!1);if(void 0===r||!r.delete(t))return!1;if(r.size)return!0;var u=s.get(e);return u.delete(n),!!u.size||s.delete(e)}})},function(t,e,n){var r=n(164),o=n(140),i=n(33),a=n(4),s=n(21),u=i.keys,l=i.key,c=function(t,e){var n=u(t,e),i=s(t);if(null===i)return n;var a=c(i,e);return a.length?n.length?o(new r(n.concat(a))):a:n};i.exp({getMetadataKeys:function(t){return c(a(t),arguments.length<2?void 0:l(arguments[1]))}})},function(t,e,n){var r=n(33),o=n(4),i=n(21),a=r.has,s=r.get,u=r.key,l=function(t,e,n){var r=a(t,e,n);if(r)return s(t,e,n);var o=i(e);return null!==o?l(t,o,n):void 0};r.exp({getMetadata:function(t,e){return l(t,o(e),arguments.length<3?void 0:u(arguments[2]))}})},function(t,e,n){var r=n(33),o=n(4),i=r.keys,a=r.key;r.exp({getOwnMetadataKeys:function(t){return i(o(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,e,n){var r=n(33),o=n(4),i=r.get,a=r.key;\nr.exp({getOwnMetadata:function(t,e){return i(t,o(e),arguments.length<3?void 0:a(arguments[2]))}})},function(t,e,n){var r=n(33),o=n(4),i=n(21),a=r.has,s=r.key,u=function(t,e,n){var r=a(t,e,n);if(r)return!0;var o=i(e);return null!==o&&u(t,o,n)};r.exp({hasMetadata:function(t,e){return u(t,o(e),arguments.length<3?void 0:s(arguments[2]))}})},function(t,e,n){var r=n(33),o=n(4),i=r.has,a=r.key;r.exp({hasOwnMetadata:function(t,e){return i(t,o(e),arguments.length<3?void 0:a(arguments[2]))}})},function(t,e,n){var r=n(33),o=n(4),i=n(14),a=r.key,s=r.set;r.exp({metadata:function(t,e){return function(n,r){s(t,e,(void 0!==r?o:i)(n),a(r))}}})},function(t,e,n){var r=n(0);r(r.P+r.R,\"Set\",{toJSON:n(144)(\"Set\")})},function(t,e,n){\"use strict\";var r=n(0),o=n(110)(!0);r(r.P,\"String\",{at:function(t){return o(this,t)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(23),i=n(11),a=n(74),s=n(72),u=RegExp.prototype,l=function(t,e){this._r=t,this._s=e};n(102)(l,\"RegExp String\",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),r(r.P,\"String\",{matchAll:function(t){if(o(this),!a(t))throw TypeError(t+\" is not a regexp!\");var e=String(this),n=\"flags\"in u?String(t.flags):s.call(t),r=new RegExp(t.source,~n.indexOf(\"g\")?n:\"g\"+n);return r.lastIndex=i(t.lastIndex),new l(r,e)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(160);r(r.P,\"String\",{padEnd:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,e,n){\"use strict\";var r=n(0),o=n(160);r(r.P,\"String\",{padStart:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,e,n){\"use strict\";n(54)(\"trimLeft\",function(t){return function(){return t(this,1)}},\"trimStart\")},function(t,e,n){\"use strict\";n(54)(\"trimRight\",function(t){return function(){return t(this,2)}},\"trimEnd\")},function(t,e,n){n(116)(\"asyncIterator\")},function(t,e,n){n(116)(\"observable\")},function(t,e,n){var r=n(0);r(r.S,\"System\",{global:n(5)})},function(t,e,n){for(var r=n(118),o=n(16),i=n(5),a=n(15),s=n(52),u=n(8),l=u(\"iterator\"),c=u(\"toStringTag\"),f=s.Array,p=[\"NodeList\",\"DOMTokenList\",\"MediaList\",\"StyleSheetList\",\"CSSRuleList\"],h=0;h<5;h++){var d,v=p[h],m=i[v],_=m&&m.prototype;if(_){_[l]||a(_,l,f),_[c]||a(_,c,v),s[v]=f;for(d in r)_[d]||o(_,d,r[d],!0)}}},function(t,e,n){var r=n(0),o=n(114);r(r.G+r.B,{setImmediate:o.set,clearImmediate:o.clear})},function(t,e,n){var r=n(5),o=n(0),i=n(73),a=n(273),s=r.navigator,u=!!s&&/MSIE .\\./.test(s.userAgent),l=function(t){return u?function(e,n){return t(i(a,[].slice.call(arguments,2),\"function\"==typeof e?e:Function(e)),n)}:t};o(o.G+o.B+o.F*u,{setTimeout:l(r.setTimeout),setInterval:l(r.setInterval)})},function(t,e,n){n(396),n(335),n(337),n(336),n(339),n(341),n(346),n(340),n(338),n(348),n(347),n(343),n(344),n(342),n(334),n(345),n(349),n(350),n(302),n(304),n(303),n(352),n(351),n(322),n(332),n(333),n(323),n(324),n(325),n(326),n(327),n(328),n(329),n(330),n(331),n(305),n(306),n(307),n(308),n(309),n(310),n(311),n(312),n(313),n(314),n(315),n(316),n(317),n(318),n(319),n(320),n(321),n(383),n(388),n(395),n(386),n(378),n(379),n(384),n(389),n(391),n(374),n(375),n(376),n(377),n(380),n(381),n(382),n(385),n(387),n(390),n(392),n(393),n(394),n(297),n(299),n(298),n(301),n(300),n(286),n(284),n(290),n(287),n(293),n(295),n(283),n(289),n(280),n(294),n(278),n(292),n(291),n(285),n(288),n(277),n(279),n(282),n(281),n(296),n(118),n(368),n(373),n(163),n(369),n(370),n(371),n(372),n(353),n(162),n(164),n(165),n(408),n(397),n(398),n(403),n(406),n(407),n(401),n(404),n(402),n(405),n(399),n(400),n(354),n(355),n(356),n(357),n(358),n(361),n(359),n(360),n(362),n(363),n(364),n(365),n(367),n(366),n(409),n(435),n(438),n(437),n(439),n(440),n(436),n(441),n(442),n(420),n(423),n(419),n(417),n(418),n(421),n(422),n(412),n(434),n(443),n(411),n(413),n(415),n(414),n(416),n(425),n(426),n(428),n(427),n(430),n(429),n(431),n(432),n(433),n(410),n(424),n(446),n(445),n(444),t.exports=n(31)},function(t,e,n){\"use strict\";function r(t,e,n){var r,o,i=t.length,a=e.arrayArgs.length,s=e.indexArgs.length>0,u=[],l=[],c=0,f=0;for(r=0;r<i;++r)l.push([\"i\",r,\"=0\"].join(\"\"));for(o=0;o<a;++o)for(r=0;r<i;++r)f=c,c=t[r],0===r?l.push([\"d\",o,\"s\",r,\"=t\",o,\"p\",c].join(\"\")):l.push([\"d\",o,\"s\",r,\"=(t\",o,\"p\",c,\"-s\",f,\"*t\",o,\"p\",f,\")\"].join(\"\"));for(u.push(\"var \"+l.join(\",\")),r=i-1;r>=0;--r)c=t[r],u.push([\"for(i\",r,\"=0;i\",r,\"<s\",c,\";++i\",r,\"){\"].join(\"\"));for(u.push(n),r=0;r<i;++r){for(f=c,c=t[r],o=0;o<a;++o)u.push([\"p\",o,\"+=d\",o,\"s\",r].join(\"\"));s&&(r>0&&u.push([\"index[\",f,\"]-=s\",f].join(\"\")),u.push([\"++index[\",c,\"]\"].join(\"\"))),u.push(\"}\")}return u.join(\"\\n\")}function o(t,e,n,o){for(var i=e.length,a=n.arrayArgs.length,s=n.blockSize,u=n.indexArgs.length>0,l=[],c=0;c<a;++c)l.push([\"var offset\",c,\"=p\",c].join(\"\"));for(var c=t;c<i;++c)l.push([\"for(var j\"+c+\"=SS[\",e[c],\"]|0;j\",c,\">0;){\"].join(\"\")),l.push([\"if(j\",c,\"<\",s,\"){\"].join(\"\")),l.push([\"s\",e[c],\"=j\",c].join(\"\")),l.push([\"j\",c,\"=0\"].join(\"\")),l.push([\"}else{s\",e[c],\"=\",s].join(\"\")),l.push([\"j\",c,\"-=\",s,\"}\"].join(\"\")),u&&l.push([\"index[\",e[c],\"]=j\",c].join(\"\"));for(var c=0;c<a;++c){for(var f=[\"offset\"+c],p=t;p<i;++p)f.push([\"j\",p,\"*t\",c,\"p\",e[p]].join(\"\"));l.push([\"p\",c,\"=(\",f.join(\"+\"),\")\"].join(\"\"))}l.push(r(e,n,o));for(var c=t;c<i;++c)l.push(\"}\");return l.join(\"\\n\")}function i(t){for(var e=0,n=t[0].length;e<n;){for(var r=1;r<t.length;++r)if(t[r][e]!==t[0][e])return e;++e}return e}function a(t,e,n){for(var r=t.body,o=[],i=[],a=0;a<t.args.length;++a){var s=t.args[a];if(!(s.count<=0)){var u=new RegExp(s.name,\"g\"),l=\"\",c=e.arrayArgs.indexOf(a);switch(e.argTypes[a]){case\"offset\":var f=e.offsetArgIndex.indexOf(a),p=e.offsetArgs[f];c=p.array,l=\"+q\"+f;case\"array\":l=\"p\"+c+l;var h=\"l\"+a,d=\"a\"+c;if(0===e.arrayBlockIndices[c])1===s.count?\"generic\"===n[c]?s.lvalue?(o.push([\"var \",h,\"=\",d,\".get(\",l,\")\"].join(\"\")),r=r.replace(u,h),i.push([d,\".set(\",l,\",\",h,\")\"].join(\"\"))):r=r.replace(u,[d,\".get(\",l,\")\"].join(\"\")):r=r.replace(u,[d,\"[\",l,\"]\"].join(\"\")):\"generic\"===n[c]?(o.push([\"var \",h,\"=\",d,\".get(\",l,\")\"].join(\"\")),r=r.replace(u,h),s.lvalue&&i.push([d,\".set(\",l,\",\",h,\")\"].join(\"\"))):(o.push([\"var \",h,\"=\",d,\"[\",l,\"]\"].join(\"\")),r=r.replace(u,h),s.lvalue&&i.push([d,\"[\",l,\"]=\",h].join(\"\")));else{for(var v=[s.name],m=[l],_=0;_<Math.abs(e.arrayBlockIndices[c]);_++)v.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\"),m.push(\"$\"+(_+1)+\"*t\"+c+\"b\"+_);if(u=new RegExp(v.join(\"\"),\"g\"),l=m.join(\"+\"),\"generic\"===n[c])throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\");r=r.replace(u,[d,\"[\",l,\"]\"].join(\"\"))}break;case\"scalar\":r=r.replace(u,\"Y\"+e.scalarArgs.indexOf(a));break;case\"index\":r=r.replace(u,\"index\");break;case\"shape\":r=r.replace(u,\"shape\")}}}return[o.join(\"\\n\"),r,i.join(\"\\n\")].join(\"\\n\").trim()}function s(t){for(var e=new Array(t.length),n=!0,r=0;r<t.length;++r){var o=t[r],i=o.match(/\\d+/);i=i?i[0]:\"\",0===o.charAt(0)?e[r]=\"u\"+o.charAt(1)+i:e[r]=o.charAt(0)+i,r>0&&(n=n&&e[r]===e[r-1])}return n?e[0]:e.join(\"\")}function u(t,e){for(var n=e[1].length-Math.abs(t.arrayBlockIndices[0])|0,u=new Array(t.arrayArgs.length),c=new Array(t.arrayArgs.length),f=0;f<t.arrayArgs.length;++f)c[f]=e[2*f],u[f]=e[2*f+1];for(var p=[],h=[],d=[],v=[],m=[],f=0;f<t.arrayArgs.length;++f){t.arrayBlockIndices[f]<0?(d.push(0),v.push(n),p.push(n),h.push(n+t.arrayBlockIndices[f])):(d.push(t.arrayBlockIndices[f]),v.push(t.arrayBlockIndices[f]+n),p.push(0),h.push(t.arrayBlockIndices[f]));for(var _=[],g=0;g<u[f].length;g++)d[f]<=u[f][g]&&u[f][g]<v[f]&&_.push(u[f][g]-d[f]);m.push(_)}for(var y=[\"SS\"],b=[\"'use strict'\"],w=[],g=0;g<n;++g)w.push([\"s\",g,\"=SS[\",g,\"]\"].join(\"\"));for(var f=0;f<t.arrayArgs.length;++f){y.push(\"a\"+f),y.push(\"t\"+f),y.push(\"p\"+f);for(var g=0;g<n;++g)w.push([\"t\",f,\"p\",g,\"=t\",f,\"[\",d[f]+g,\"]\"].join(\"\"));for(var g=0;g<Math.abs(t.arrayBlockIndices[f]);++g)w.push([\"t\",f,\"b\",g,\"=t\",f,\"[\",p[f]+g,\"]\"].join(\"\"))}for(var f=0;f<t.scalarArgs.length;++f)y.push(\"Y\"+f);if(t.shapeArgs.length>0&&w.push(\"shape=SS.slice(0)\"),t.indexArgs.length>0){for(var x=new Array(n),f=0;f<n;++f)x[f]=\"0\";w.push([\"index=[\",x.join(\",\"),\"]\"].join(\"\"))}for(var f=0;f<t.offsetArgs.length;++f){for(var E=t.offsetArgs[f],T=[],g=0;g<E.offset.length;++g)0!==E.offset[g]&&(1===E.offset[g]?T.push([\"t\",E.array,\"p\",g].join(\"\")):T.push([E.offset[g],\"*t\",E.array,\"p\",g].join(\"\")));0===T.length?w.push(\"q\"+f+\"=0\"):w.push([\"q\",f,\"=\",T.join(\"+\")].join(\"\"))}var O=l([].concat(t.pre.thisVars).concat(t.body.thisVars).concat(t.post.thisVars));w=w.concat(O),b.push(\"var \"+w.join(\",\"));for(var f=0;f<t.arrayArgs.length;++f)b.push(\"p\"+f+\"|=0\");t.pre.body.length>3&&b.push(a(t.pre,t,c));var S=a(t.body,t,c),P=i(m);P<n?b.push(o(P,m[0],t,S)):b.push(r(m[0],t,S)),t.post.body.length>3&&b.push(a(t.post,t,c)),t.debug&&console.log(\"-----Generated cwise routine for \",e,\":\\n\"+b.join(\"\\n\")+\"\\n----------\");var M=[t.funcName||\"unnamed\",\"_cwise_loop_\",u[0].join(\"s\"),\"m\",P,s(c)].join(\"\"),j=new Function([\"function \",M,\"(\",y.join(\",\"),\"){\",b.join(\"\\n\"),\"} return \",M].join(\"\"));return j()}var l=n(193);t.exports=u},function(t,e,n){\"use strict\";function r(t){var e=[\"'use strict'\",\"var CACHED={}\"],n=[],r=t.funcName+\"_cwise_thunk\";e.push([\"return function \",r,\"(\",t.shimArgs.join(\",\"),\"){\"].join(\"\"));for(var i=[],a=[],s=[[\"array\",t.arrayArgs[0],\".shape.slice(\",Math.max(0,t.arrayBlockIndices[0]),t.arrayBlockIndices[0]<0?\",\"+t.arrayBlockIndices[0]+\")\":\")\"].join(\"\")],u=[],l=[],c=0;c<t.arrayArgs.length;++c){var f=t.arrayArgs[c];n.push([\"t\",f,\"=array\",f,\".dtype,\",\"r\",f,\"=array\",f,\".order\"].join(\"\")),i.push(\"t\"+f),i.push(\"r\"+f),a.push(\"t\"+f),a.push(\"r\"+f+\".join()\"),s.push(\"array\"+f+\".data\"),s.push(\"array\"+f+\".stride\"),s.push(\"array\"+f+\".offset|0\"),c>0&&(u.push(\"array\"+t.arrayArgs[0]+\".shape.length===array\"+f+\".shape.length+\"+(Math.abs(t.arrayBlockIndices[0])-Math.abs(t.arrayBlockIndices[c]))),l.push(\"array\"+t.arrayArgs[0]+\".shape[shapeIndex+\"+Math.max(0,t.arrayBlockIndices[0])+\"]===array\"+f+\".shape[shapeIndex+\"+Math.max(0,t.arrayBlockIndices[c])+\"]\"))}t.arrayArgs.length>1&&(e.push(\"if (!(\"+u.join(\" && \")+\")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\"),e.push(\"for(var shapeIndex=array\"+t.arrayArgs[0]+\".shape.length-\"+Math.abs(t.arrayBlockIndices[0])+\"; shapeIndex-->0;) {\"),e.push(\"if (!(\"+l.join(\" && \")+\")) throw new Error('cwise: Arrays do not all have the same shape!')\"),e.push(\"}\"));for(var c=0;c<t.scalarArgs.length;++c)s.push(\"scalar\"+t.scalarArgs[c]);n.push([\"type=[\",a.join(\",\"),\"].join()\"].join(\"\")),n.push(\"proc=CACHED[type]\"),e.push(\"var \"+n.join(\",\")),e.push([\"if(!proc){\",\"CACHED[type]=proc=compile([\",i.join(\",\"),\"])}\",\"return proc(\",s.join(\",\"),\")}\"].join(\"\")),t.debug&&console.log(\"-----Generated thunk:\\n\"+e.join(\"\\n\")+\"\\n----------\");var p=new Function(\"compile\",e.join(\"\\n\"));return p(o.bind(void 0,t))}var o=n(448);t.exports=r},function(t,e,n){\"use strict\";(function(e){function r(t,e,n){this.name=t,this.lvalue=e,this.rvalue=n,this.count=0}function o(t,e,n,r){this.body=t,this.args=e,this.thisVars=n,this.localVars=r}function i(t){if(\"eval\"===t)throw new Error(\"cwise-parser: eval() not allowed\");return\"undefined\"!=typeof window?t in window:\"undefined\"!=typeof e?t in e:\"undefined\"!=typeof self&&t in self}function a(t){for(var e=t.body[0].expression.callee.params,n=new Array(e.length),r=0;r<e.length;++r)n[r]=e[r].name;return n}function s(t){function e(t){var e=m+t.replace(/\\_/g,\"__\");return x.push(e),e}function n(t){var e=\"this_\"+t.replace(/\\_/g,\"__\");return E.push(e),e}function s(t,e){for(var n=t.range[0],r=t.range[1],o=n+1;o<r;++o)b[o]=\"\";b[n]=e}function f(t){return\"'\"+t.replace(/\\_/g,\"\\\\_\").replace(/\\'/g,\"'\")+\"'\"}function p(t){return b.slice(t.range[0],t.range[1]).join(\"\")}function h(t){return\"AssignmentExpression\"===t.parent.type&&t.parent.left===t?\"=\"===t.parent.operator?T:T|O:\"UpdateExpression\"===t.parent.type?T|O:O}for(var d=[\"(\",t,\")()\"].join(\"\"),v=u.parse(d,{range:!0}),m=\"_inline_\"+c++ +\"_\",_=a(v),g=new Array(_.length),y=0;y<_.length;++y)g[y]=new r([m,\"arg\",y,\"_\"].join(\"\"),!1,!1);for(var b=new Array(d.length),y=0,w=d.length;y<w;++y)b[y]=d.charAt(y);var x=[],E=[],T=1,O=2;!function t(r,o){if(r.parent=o,\"MemberExpression\"===r.type)r.computed?(t(r.object,r),t(r.property,r)):\"ThisExpression\"===r.object.type?s(r,n(r.property.name)):t(r.object,r);else{if(\"ThisExpression\"===r.type)throw new Error(\"cwise-parser: Computed this is not allowed\");if(\"Identifier\"===r.type){var a=r.name,u=_.indexOf(a);if(u>=0){var l=g[u],c=h(r);c&T&&(l.lvalue=!0),c&O&&(l.rvalue=!0),++l.count,s(r,l.name)}else i(a)||s(r,e(a))}else if(\"Literal\"===r.type)\"string\"==typeof r.value&&s(r,f(r.value));else{if(\"WithStatement\"===r.type)throw new Error(\"cwise-parser: with() statements not allowed\");for(var p=Object.keys(r),d=0,v=p.length;d<v;++d)if(\"parent\"!==p[d]){var m=r[p[d]];if(m)if(m instanceof Array)for(var y=0;y<m.length;++y)m[y]&&\"string\"==typeof m[y].type&&t(m[y],r);else\"string\"==typeof m.type&&t(m,r)}}}}(v.body[0].expression.callee.body,void 0),l(x),l(E);var S=new o(p(v.body[0].expression.callee.body),g,E,x);return S}var u=n(451),l=n(193),c=0;t.exports=s}).call(e,n(38))},function(t,e,n){var r,o,i;!function(n,a){\"use strict\";o=[e],r=a,i=\"function\"==typeof r?r.apply(e,o):r,!(void 0!==i&&(t.exports=i))}(this,function(t){\"use strict\";function e(t,e){if(!t)throw new Error(\"ASSERT: \"+e)}function n(t){return t>=48&&t<=57}function r(t){return\"0123456789abcdefABCDEF\".indexOf(t)>=0}function o(t){return\"01234567\".indexOf(t)>=0}function i(t){return 32===t||9===t||11===t||12===t||160===t||t>=5760&&[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279].indexOf(t)>=0}function a(t){return 10===t||13===t||8232===t||8233===t}function s(t){return 36===t||95===t||t>=65&&t<=90||t>=97&&t<=122||92===t||t>=128&&ie.NonAsciiIdentifierStart.test(String.fromCharCode(t))}function u(t){return 36===t||95===t||t>=65&&t<=90||t>=97&&t<=122||t>=48&&t<=57||92===t||t>=128&&ie.NonAsciiIdentifierPart.test(String.fromCharCode(t))}function l(t){switch(t){case\"class\":case\"enum\":case\"export\":case\"extends\":case\"import\":case\"super\":return!0;default:return!1}}function c(t){switch(t){case\"implements\":case\"interface\":case\"package\":case\"private\":case\"protected\":case\"public\":case\"static\":case\"yield\":case\"let\":return!0;default:return!1}}function f(t){return\"eval\"===t||\"arguments\"===t}function p(t){if(ue&&c(t))return!0;switch(t.length){case 2:return\"if\"===t||\"in\"===t||\"do\"===t;case 3:return\"var\"===t||\"for\"===t||\"new\"===t||\"try\"===t||\"let\"===t;case 4:return\"this\"===t||\"else\"===t||\"case\"===t||\"void\"===t||\"with\"===t||\"enum\"===t;case 5:return\"while\"===t||\"break\"===t||\"catch\"===t||\"throw\"===t||\"const\"===t||\"yield\"===t||\"class\"===t||\"super\"===t;case 6:return\"return\"===t||\"typeof\"===t||\"delete\"===t||\"switch\"===t||\"export\"===t||\"import\"===t;case 7:return\"default\"===t||\"finally\"===t||\"extends\"===t;case 8:return\"function\"===t||\"continue\"===t||\"debugger\"===t;case 10:return\"instanceof\"===t;default:return!1}}function h(t,n,r,o,i){var a;e(\"number\"==typeof r,\"Comment must have valid position\"),ve.lastCommentStart>=r||(ve.lastCommentStart=r,a={type:t,value:n},me.range&&(a.range=[r,o]),me.loc&&(a.loc=i),me.comments.push(a),me.attachComment&&(me.leadingComments.push(a),me.trailingComments.push(a)))}function d(t){var e,n,r,o;for(e=le-t,n={start:{line:ce,column:le-fe-t}};le<pe;)if(r=se.charCodeAt(le),++le,a(r))return me.comments&&(o=se.slice(e+t,le-1),n.end={line:ce,column:le-fe-1},h(\"Line\",o,e,le-1,n)),13===r&&10===se.charCodeAt(le)&&++le,++ce,void(fe=le);me.comments&&(o=se.slice(e+t,le),n.end={line:ce,column:le-fe},h(\"Line\",o,e,le,n))}function v(){var t,e,n,r;for(me.comments&&(t=le-2,e={start:{line:ce,column:le-fe-2}});le<pe;)if(n=se.charCodeAt(le),a(n))13===n&&10===se.charCodeAt(le+1)&&++le,++ce,++le,fe=le,le>=pe&&V({},oe.UnexpectedToken,\"ILLEGAL\");else if(42===n){if(47===se.charCodeAt(le+1))return++le,++le,void(me.comments&&(r=se.slice(t+2,le-2),e.end={line:ce,column:le-fe},h(\"Block\",r,t,le,e)));++le}else++le;V({},oe.UnexpectedToken,\"ILLEGAL\")}function m(){var t,e;for(e=0===le;le<pe;)if(t=se.charCodeAt(le),i(t))++le;else if(a(t))++le,13===t&&10===se.charCodeAt(le)&&++le,++ce,fe=le,e=!0;else if(47===t)if(t=se.charCodeAt(le+1),47===t)++le,++le,d(2),e=!0;else{if(42!==t)break;++le,++le,v()}else if(e&&45===t){if(45!==se.charCodeAt(le+1)||62!==se.charCodeAt(le+2))break;le+=3,d(3)}else{if(60!==t)break;if(\"!--\"!==se.slice(le+1,le+4))break;++le,++le,++le,++le,d(4)}}function _(t){var e,n,o,i=0;for(n=\"u\"===t?4:2,e=0;e<n;++e){if(!(le<pe&&r(se[le])))return\"\";o=se[le++],i=16*i+\"0123456789abcdef\".indexOf(o.toLowerCase())}return String.fromCharCode(i)}function g(){var t,e;for(t=se.charCodeAt(le++),e=String.fromCharCode(t),92===t&&(117!==se.charCodeAt(le)&&V({},oe.UnexpectedToken,\"ILLEGAL\"),++le,t=_(\"u\"),t&&\"\\\\\"!==t&&s(t.charCodeAt(0))||V({},oe.UnexpectedToken,\"ILLEGAL\"),e=t);le<pe&&(t=se.charCodeAt(le),u(t));)++le,e+=String.fromCharCode(t),92===t&&(e=e.substr(0,e.length-1),117!==se.charCodeAt(le)&&V({},oe.UnexpectedToken,\"ILLEGAL\"),++le,t=_(\"u\"),t&&\"\\\\\"!==t&&u(t.charCodeAt(0))||V({},oe.UnexpectedToken,\"ILLEGAL\"),e+=t);return e}function y(){var t,e;for(t=le++;le<pe;){if(e=se.charCodeAt(le),92===e)return le=t,g();if(!u(e))break;++le}return se.slice(t,le)}function b(){var t,e,n;return t=le,e=92===se.charCodeAt(le)?g():y(),n=1===e.length?Jt.Identifier:p(e)?Jt.Keyword:\"null\"===e?Jt.NullLiteral:\"true\"===e||\"false\"===e?Jt.BooleanLiteral:Jt.Identifier,{type:n,value:e,lineNumber:ce,lineStart:fe,start:t,end:le}}function w(){var t,e,n,r,o=le,i=se.charCodeAt(le),a=se[le];switch(i){case 46:case 40:case 41:case 59:case 44:case 123:case 125:case 91:case 93:case 58:case 63:case 126:return++le,me.tokenize&&(40===i?me.openParenToken=me.tokens.length:123===i&&(me.openCurlyToken=me.tokens.length)),{type:Jt.Punctuator,value:String.fromCharCode(i),lineNumber:ce,lineStart:fe,start:o,end:le};default:if(t=se.charCodeAt(le+1),61===t)switch(i){case 43:case 45:case 47:case 60:case 62:case 94:case 124:case 37:case 38:case 42:return le+=2,{type:Jt.Punctuator,value:String.fromCharCode(i)+String.fromCharCode(t),lineNumber:ce,lineStart:fe,start:o,end:le};case 33:case 61:return le+=2,61===se.charCodeAt(le)&&++le,{type:Jt.Punctuator,value:se.slice(o,le),lineNumber:ce,lineStart:fe,start:o,end:le}}}return r=se.substr(le,4),\">>>=\"===r?(le+=4,{type:Jt.Punctuator,value:r,lineNumber:ce,lineStart:fe,start:o,end:le}):(n=r.substr(0,3),\">>>\"===n||\"<<=\"===n||\">>=\"===n?(le+=3,{type:Jt.Punctuator,value:n,lineNumber:ce,lineStart:fe,start:o,end:le}):(e=n.substr(0,2),a===e[1]&&\"+-<>&|\".indexOf(a)>=0||\"=>\"===e?(le+=2,{type:Jt.Punctuator,value:e,lineNumber:ce,lineStart:fe,start:o,end:le}):\"<>=!+-*%&|^/\".indexOf(a)>=0?(++le,{type:Jt.Punctuator,value:a,lineNumber:ce,lineStart:fe,start:o,end:le}):void V({},oe.UnexpectedToken,\"ILLEGAL\")))}function x(t){for(var e=\"\";le<pe&&r(se[le]);)e+=se[le++];return 0===e.length&&V({},oe.UnexpectedToken,\"ILLEGAL\"),s(se.charCodeAt(le))&&V({},oe.UnexpectedToken,\"ILLEGAL\"),{type:Jt.NumericLiteral,value:parseInt(\"0x\"+e,16),lineNumber:ce,lineStart:fe,start:t,end:le}}function E(t){for(var e=\"0\"+se[le++];le<pe&&o(se[le]);)e+=se[le++];return(s(se.charCodeAt(le))||n(se.charCodeAt(le)))&&V({},oe.UnexpectedToken,\"ILLEGAL\"),{type:Jt.NumericLiteral,value:parseInt(e,8),octal:!0,lineNumber:ce,lineStart:fe,start:t,end:le}}function T(){var t,e;for(t=le+1;t<pe;++t){if(e=se[t],\"8\"===e||\"9\"===e)return!1;if(!o(e))return!0}return!0}function O(){var t,r,i;if(i=se[le],e(n(i.charCodeAt(0))||\".\"===i,\"Numeric literal must start with a decimal digit or a decimal point\"),r=le,t=\"\",\".\"!==i){if(t=se[le++],i=se[le],\"0\"===t){if(\"x\"===i||\"X\"===i)return++le,x(r);if(o(i)&&T())return E(r)}for(;n(se.charCodeAt(le));)t+=se[le++];i=se[le]}if(\".\"===i){for(t+=se[le++];n(se.charCodeAt(le));)t+=se[le++];i=se[le]}if(\"e\"===i||\"E\"===i)if(t+=se[le++],i=se[le],\"+\"!==i&&\"-\"!==i||(t+=se[le++]),n(se.charCodeAt(le)))for(;n(se.charCodeAt(le));)t+=se[le++];else V({},oe.UnexpectedToken,\"ILLEGAL\");return s(se.charCodeAt(le))&&V({},oe.UnexpectedToken,\"ILLEGAL\"),{type:Jt.NumericLiteral,value:parseFloat(t),lineNumber:ce,lineStart:fe,start:r,end:le}}function S(){var t,n,r,i,s,u,l,c,f=\"\",p=!1;for(l=ce,c=fe,t=se[le],e(\"'\"===t||'\"'===t,\"String literal must starts with a quote\"),n=le,++le;le<pe;){if(r=se[le++],r===t){t=\"\";break}if(\"\\\\\"===r)if(r=se[le++],r&&a(r.charCodeAt(0)))++ce,\"\\r\"===r&&\"\\n\"===se[le]&&++le,fe=le;else switch(r){case\"u\":case\"x\":u=le,s=_(r),s?f+=s:(le=u,f+=r);break;case\"n\":f+=\"\\n\";break;case\"r\":f+=\"\\r\";break;case\"t\":f+=\"\\t\";break;case\"b\":f+=\"\\b\";break;case\"f\":f+=\"\\f\";break;case\"v\":f+=\"\\v\";break;default:o(r)?(i=\"01234567\".indexOf(r),0!==i&&(p=!0),le<pe&&o(se[le])&&(p=!0,i=8*i+\"01234567\".indexOf(se[le++]),\"0123\".indexOf(r)>=0&&le<pe&&o(se[le])&&(i=8*i+\"01234567\".indexOf(se[le++]))),f+=String.fromCharCode(i)):f+=r}else{if(a(r.charCodeAt(0)))break;f+=r}}return\"\"!==t&&V({},oe.UnexpectedToken,\"ILLEGAL\"),{type:Jt.StringLiteral,value:f,octal:p,startLineNumber:l,startLineStart:c,lineNumber:ce,lineStart:fe,start:n,end:le}}function P(t,e){var n;try{n=new RegExp(t,e)}catch(t){V({},oe.InvalidRegExp)}return n}function M(){var t,n,r,o,i;for(t=se[le],e(\"/\"===t,\"Regular expression literal must start with a slash\"),n=se[le++],r=!1,o=!1;le<pe;)if(t=se[le++],n+=t,\"\\\\\"===t)t=se[le++],a(t.charCodeAt(0))&&V({},oe.UnterminatedRegExp),n+=t;else if(a(t.charCodeAt(0)))V({},oe.UnterminatedRegExp);else if(r)\"]\"===t&&(r=!1);else{if(\"/\"===t){o=!0;break}\"[\"===t&&(r=!0)}return o||V({},oe.UnterminatedRegExp),i=n.substr(1,n.length-2),{value:i,literal:n}}function j(){var t,e,n,r;for(e=\"\",n=\"\";le<pe&&(t=se[le],u(t.charCodeAt(0)));)if(++le,\"\\\\\"===t&&le<pe)if(t=se[le],\"u\"===t){if(++le,r=le,t=_(\"u\"))for(n+=t,e+=\"\\\\u\";r<le;++r)e+=se[r];else le=r,n+=\"u\",e+=\"\\\\u\";W({},oe.UnexpectedToken,\"ILLEGAL\")}else e+=\"\\\\\",W({},oe.UnexpectedToken,\"ILLEGAL\");else n+=t,e+=t;return{value:n,literal:e}}function A(){var t,e,n,r;return de=null,m(),t=le,e=M(),n=j(),r=P(e.value,n.value),me.tokenize?{type:Jt.RegularExpression,value:r,lineNumber:ce,lineStart:fe,start:t,end:le}:{literal:e.literal+n.literal,value:r,start:t,end:le}}function C(){var t,e,n,r;return m(),t=le,e={start:{line:ce,column:le-fe}},n=A(),e.end={line:ce,column:le-fe},me.tokenize||(me.tokens.length>0&&(r=me.tokens[me.tokens.length-1],r.range[0]===t&&\"Punctuator\"===r.type&&(\"/\"!==r.value&&\"/=\"!==r.value||me.tokens.pop())),me.tokens.push({type:\"RegularExpression\",value:n.literal,range:[t,le],loc:e})),n}function k(t){return t.type===Jt.Identifier||t.type===Jt.Keyword||t.type===Jt.BooleanLiteral||t.type===Jt.NullLiteral}function R(){var t,e;if(t=me.tokens[me.tokens.length-1],!t)return C();if(\"Punctuator\"===t.type){if(\"]\"===t.value)return w();if(\")\"===t.value)return e=me.tokens[me.openParenToken-1],!e||\"Keyword\"!==e.type||\"if\"!==e.value&&\"while\"!==e.value&&\"for\"!==e.value&&\"with\"!==e.value?w():C();if(\"}\"===t.value){if(me.tokens[me.openCurlyToken-3]&&\"Keyword\"===me.tokens[me.openCurlyToken-3].type){if(e=me.tokens[me.openCurlyToken-4],!e)return w()}else{if(!me.tokens[me.openCurlyToken-4]||\"Keyword\"!==me.tokens[me.openCurlyToken-4].type)return w();if(e=me.tokens[me.openCurlyToken-5],!e)return C()}return ee.indexOf(e.value)>=0?w():C()}return C()}return\"Keyword\"===t.type&&\"this\"!==t.value?C():w()}function I(){var t;return m(),le>=pe?{type:Jt.EOF,lineNumber:ce,lineStart:fe,start:le,end:le}:(t=se.charCodeAt(le),s(t)?b():40===t||41===t||59===t?w():39===t||34===t?S():46===t?n(se.charCodeAt(le+1))?O():w():n(t)?O():me.tokenize&&47===t?R():w())}function N(){var t,e,n;return m(),t={start:{line:ce,column:le-fe}},e=I(),t.end={line:ce,column:le-fe},e.type!==Jt.EOF&&(n=se.slice(e.start,e.end),me.tokens.push({type:te[e.type],value:n,range:[e.start,e.end],loc:t})),e}function U(){var t;return t=de,le=t.end,ce=t.lineNumber,fe=t.lineStart,de=\"undefined\"!=typeof me.tokens?N():I(),le=t.end,ce=t.lineNumber,fe=t.lineStart,t}function F(){var t,e,n;t=le,e=ce,n=fe,de=\"undefined\"!=typeof me.tokens?N():I(),le=t,ce=e,fe=n}function L(t,e){this.line=t,this.column=e}function D(t,e,n,r){this.start=new L(t,e),this.end=new L(n,r)}function B(){var t,e,n,r;return t=le,e=ce,n=fe,m(),r=ce!==e,le=t,ce=e,fe=n,r}function V(t,n){var r,o=Array.prototype.slice.call(arguments,2),i=n.replace(/%(\\d)/g,function(t,n){return e(n<o.length,\"Message reference must be in range\"),o[n]});throw\"number\"==typeof t.lineNumber?(r=new Error(\"Line \"+t.lineNumber+\": \"+i),r.index=t.start,r.lineNumber=t.lineNumber,r.column=t.start-fe+1):(r=new Error(\"Line \"+ce+\": \"+i),r.index=le,r.lineNumber=ce,r.column=le-fe+1),r.description=i,r}function W(){try{V.apply(null,arguments)}catch(t){if(!me.errors)throw t;me.errors.push(t)}}function X(t){if(t.type===Jt.EOF&&V(t,oe.UnexpectedEOS),t.type===Jt.NumericLiteral&&V(t,oe.UnexpectedNumber),t.type===Jt.StringLiteral&&V(t,oe.UnexpectedString),t.type===Jt.Identifier&&V(t,oe.UnexpectedIdentifier),t.type===Jt.Keyword){if(l(t.value))V(t,oe.UnexpectedReserved);else if(ue&&c(t.value))return void W(t,oe.StrictReservedWord);V(t,oe.UnexpectedToken,t.value)}V(t,oe.UnexpectedToken,t.value)}function z(t){var e=U();e.type===Jt.Punctuator&&e.value===t||X(e)}function G(t){var e=U();e.type===Jt.Keyword&&e.value===t||X(e)}function q(t){return de.type===Jt.Punctuator&&de.value===t}function H(t){return de.type===Jt.Keyword&&de.value===t}function Y(){var t;return de.type===Jt.Punctuator&&(t=de.value,\"=\"===t||\"*=\"===t||\"/=\"===t||\"%=\"===t||\"+=\"===t||\"-=\"===t||\"<<=\"===t||\">>=\"===t||\">>>=\"===t||\"&=\"===t||\"^=\"===t||\"|=\"===t)}function K(){var t,e=le,n=ce,r=fe,o=de;return 59===se.charCodeAt(le)||q(\";\")?void U():(t=ce,m(),ce!==t?(le=e,ce=n,fe=r,void(de=o)):void(de.type===Jt.EOF||q(\"}\")||X(de)))}function $(t){return t.type===ne.Identifier||t.type===ne.MemberExpression}function Z(){var t,e=[];for(t=de,z(\"[\");!q(\"]\");)q(\",\")?(U(),e.push(null)):(e.push(mt()),q(\"]\")||z(\",\"));return U(),he.markEnd(he.createArrayExpression(e),t)}function Q(t,e){var n,r,o;return n=ue,o=de,r=Xt(),e&&ue&&f(t[0].name)&&W(e,oe.StrictParamName),ue=n,he.markEnd(he.createFunctionExpression(null,t,[],r),o)}function J(){var t,e;return e=de,t=U(),t.type===Jt.StringLiteral||t.type===Jt.NumericLiteral?(ue&&t.octal&&W(t,oe.StrictOctalLiteral),he.markEnd(he.createLiteral(t),e)):he.markEnd(he.createIdentifier(t.value),e)}function tt(){var t,e,n,r,o,i;return t=de,i=de,t.type===Jt.Identifier?(n=J(),\"get\"!==t.value||q(\":\")?\"set\"!==t.value||q(\":\")?(z(\":\"),r=mt(),he.markEnd(he.createProperty(\"init\",n,r),i)):(e=J(),z(\"(\"),t=de,t.type!==Jt.Identifier?(z(\")\"),W(t,oe.UnexpectedToken,t.value),r=Q([])):(o=[bt()],z(\")\"),r=Q(o,t)),he.markEnd(he.createProperty(\"set\",e,r),i)):(e=J(),z(\"(\"),z(\")\"),r=Q([]),he.markEnd(he.createProperty(\"get\",e,r),i))):t.type!==Jt.EOF&&t.type!==Jt.Punctuator?(e=J(),z(\":\"),r=mt(),he.markEnd(he.createProperty(\"init\",e,r),i)):void X(t)}function et(){var t,e,n,r,o,i=[],a={},s=String;for(o=de,z(\"{\");!q(\"}\");)t=tt(),e=t.key.type===ne.Identifier?t.key.name:s(t.key.value),r=\"init\"===t.kind?re.Data:\"get\"===t.kind?re.Get:re.Set,n=\"$\"+e,Object.prototype.hasOwnProperty.call(a,n)?(a[n]===re.Data?ue&&r===re.Data?W({},oe.StrictDuplicateProperty):r!==re.Data&&W({},oe.AccessorDataProperty):r===re.Data?W({},oe.AccessorDataProperty):a[n]&r&&W({},oe.AccessorGetSet),a[n]|=r):a[n]=r,i.push(t),q(\"}\")||z(\",\");return z(\"}\"),he.markEnd(he.createObjectExpression(i),o)}function nt(){var t;return z(\"(\"),t=_t(),z(\")\"),t}function rt(){var t,e,n,r;if(q(\"(\"))return nt();if(q(\"[\"))return Z();if(q(\"{\"))return et();if(t=de.type,r=de,t===Jt.Identifier)n=he.createIdentifier(U().value);else if(t===Jt.StringLiteral||t===Jt.NumericLiteral)ue&&de.octal&&W(de,oe.StrictOctalLiteral),n=he.createLiteral(U());else if(t===Jt.Keyword){if(H(\"function\"))return qt();H(\"this\")?(U(),n=he.createThisExpression()):X(U())}else t===Jt.BooleanLiteral?(e=U(),e.value=\"true\"===e.value,n=he.createLiteral(e)):t===Jt.NullLiteral?(e=U(),e.value=null,n=he.createLiteral(e)):q(\"/\")||q(\"/=\")?(n=\"undefined\"!=typeof me.tokens?he.createLiteral(C()):he.createLiteral(A()),F()):X(U());return he.markEnd(n,r)}function ot(){var t=[];if(z(\"(\"),!q(\")\"))for(;le<pe&&(t.push(mt()),!q(\")\"));)z(\",\");return z(\")\"),t}function it(){var t,e;return e=de,t=U(),k(t)||X(t),he.markEnd(he.createIdentifier(t.value),e)}function at(){return z(\".\"),it()}function st(){var t;return z(\"[\"),t=_t(),z(\"]\"),t}function ut(){var t,e,n;return n=de,G(\"new\"),t=ct(),e=q(\"(\")?ot():[],he.markEnd(he.createNewExpression(t,e),n)}function lt(){var t,e,n,r,o=ve.allowIn;for(r=de,ve.allowIn=!0,t=H(\"new\")?ut():rt();;){if(q(\".\"))n=at(),t=he.createMemberExpression(\".\",t,n);else if(q(\"(\"))e=ot(),t=he.createCallExpression(t,e);else{if(!q(\"[\"))break;n=st(),t=he.createMemberExpression(\"[\",t,n)}he.markEnd(t,r)}return ve.allowIn=o,t}function ct(){var t,n,r;for(e(ve.allowIn,\"callee of new expression always allow in keyword.\"),r=de,t=H(\"new\")?ut():rt();q(\".\")||q(\"[\");)q(\"[\")?(n=st(),t=he.createMemberExpression(\"[\",t,n)):(n=at(),t=he.createMemberExpression(\".\",t,n)),he.markEnd(t,r);return t}function ft(){var t,e,n=de;return t=lt(),de.type===Jt.Punctuator&&(!q(\"++\")&&!q(\"--\")||B()||(ue&&t.type===ne.Identifier&&f(t.name)&&W({},oe.StrictLHSPostfix),$(t)||W({},oe.InvalidLHSInAssignment),e=U(),t=he.markEnd(he.createPostfixExpression(e.value,t),n))),t}function pt(){var t,e,n;return de.type!==Jt.Punctuator&&de.type!==Jt.Keyword?e=ft():q(\"++\")||q(\"--\")?(n=de,t=U(),e=pt(),ue&&e.type===ne.Identifier&&f(e.name)&&W({},oe.StrictLHSPrefix),$(e)||W({},oe.InvalidLHSInAssignment),e=he.createUnaryExpression(t.value,e),e=he.markEnd(e,n)):q(\"+\")||q(\"-\")||q(\"~\")||q(\"!\")?(n=de,t=U(),e=pt(),e=he.createUnaryExpression(t.value,e),e=he.markEnd(e,n)):H(\"delete\")||H(\"void\")||H(\"typeof\")?(n=de,t=U(),e=pt(),e=he.createUnaryExpression(t.value,e),e=he.markEnd(e,n),ue&&\"delete\"===e.operator&&e.argument.type===ne.Identifier&&W({},oe.StrictDelete)):e=ft(),e}function ht(t,e){var n=0;if(t.type!==Jt.Punctuator&&t.type!==Jt.Keyword)return 0;switch(t.value){case\"||\":n=1;break;case\"&&\":n=2;break;case\"|\":n=3;break;case\"^\":n=4;break;case\"&\":n=5;break;case\"==\":case\"!=\":case\"===\":case\"!==\":n=6;break;case\"<\":case\">\":case\"<=\":case\">=\":case\"instanceof\":n=7;break;case\"in\":n=e?7:0;break;case\"<<\":case\">>\":case\">>>\":n=8;break;case\"+\":case\"-\":n=9;break;case\"*\":case\"/\":case\"%\":n=11}return n}function dt(){var t,e,n,r,o,i,a,s,u,l;if(t=de,u=pt(),r=de,o=ht(r,ve.allowIn),0===o)return u;for(r.prec=o,U(),e=[t,de],a=pt(),i=[u,r,a];(o=ht(de,ve.allowIn))>0;){for(;i.length>2&&o<=i[i.length-2].prec;)a=i.pop(),s=i.pop().value,u=i.pop(),n=he.createBinaryExpression(s,u,a),e.pop(),t=e[e.length-1],he.markEnd(n,t),i.push(n);r=U(),r.prec=o,i.push(r),e.push(de),n=pt(),i.push(n)}for(l=i.length-1,n=i[l],e.pop();l>1;)n=he.createBinaryExpression(i[l-1].value,i[l-2],n),l-=2,t=e.pop(),he.markEnd(n,t);return n}function vt(){var t,e,n,r,o;return o=de,t=dt(),q(\"?\")&&(U(),e=ve.allowIn,ve.allowIn=!0,n=mt(),ve.allowIn=e,z(\":\"),r=mt(),t=he.createConditionalExpression(t,n,r),he.markEnd(t,o)),t}function mt(){var t,e,n,r,o;return t=de,o=de,r=e=vt(),Y()&&($(e)||W({},oe.InvalidLHSInAssignment),ue&&e.type===ne.Identifier&&f(e.name)&&W(t,oe.StrictLHSAssignment),t=U(),n=mt(),r=he.markEnd(he.createAssignmentExpression(t.value,e,n),o)),r}function _t(){var t,e=de;if(t=mt(),q(\",\")){for(t=he.createSequenceExpression([t]);le<pe&&q(\",\");)U(),t.expressions.push(mt());he.markEnd(t,e)}return t}function gt(){for(var t,e=[];le<pe&&!q(\"}\")&&(t=Ht(),\"undefined\"!=typeof t);)e.push(t);return e}function yt(){var t,e;return e=de,z(\"{\"),t=gt(),z(\"}\"),he.markEnd(he.createBlockStatement(t),e)}function bt(){var t,e;return e=de,t=U(),t.type!==Jt.Identifier&&X(t),he.markEnd(he.createIdentifier(t.value),e)}function wt(t){var e,n,r=null;return n=de,e=bt(),ue&&f(e.name)&&W({},oe.StrictVarName),\"const\"===t?(z(\"=\"),r=mt()):q(\"=\")&&(U(),r=mt()),he.markEnd(he.createVariableDeclarator(e,r),n)}function xt(t){var e=[];do{if(e.push(wt(t)),!q(\",\"))break;U()}while(le<pe);return e}function Et(){var t;return G(\"var\"),t=xt(),K(),he.createVariableDeclaration(t,\"var\")}function Tt(t){var e,n;return n=de,G(t),e=xt(t),K(),he.markEnd(he.createVariableDeclaration(e,t),n)}function Ot(){return z(\";\"),he.createEmptyStatement()}function St(){var t=_t();return K(),he.createExpressionStatement(t)}function Pt(){var t,e,n;\nreturn G(\"if\"),z(\"(\"),t=_t(),z(\")\"),e=Wt(),H(\"else\")?(U(),n=Wt()):n=null,he.createIfStatement(t,e,n)}function Mt(){var t,e,n;return G(\"do\"),n=ve.inIteration,ve.inIteration=!0,t=Wt(),ve.inIteration=n,G(\"while\"),z(\"(\"),e=_t(),z(\")\"),q(\";\")&&U(),he.createDoWhileStatement(t,e)}function jt(){var t,e,n;return G(\"while\"),z(\"(\"),t=_t(),z(\")\"),n=ve.inIteration,ve.inIteration=!0,e=Wt(),ve.inIteration=n,he.createWhileStatement(t,e)}function At(){var t,e,n;return n=de,t=U(),e=xt(),he.markEnd(he.createVariableDeclaration(e,t.value),n)}function Ct(){var t,e,n,r,o,i,a,s=ve.allowIn;return t=e=n=null,G(\"for\"),z(\"(\"),q(\";\")?U():(H(\"var\")||H(\"let\")?(ve.allowIn=!1,t=At(),ve.allowIn=s,1===t.declarations.length&&H(\"in\")&&(U(),r=t,o=_t(),t=null)):(ve.allowIn=!1,t=_t(),ve.allowIn=s,H(\"in\")&&($(t)||W({},oe.InvalidLHSInForIn),U(),r=t,o=_t(),t=null)),\"undefined\"==typeof r&&z(\";\")),\"undefined\"==typeof r&&(q(\";\")||(e=_t()),z(\";\"),q(\")\")||(n=_t())),z(\")\"),a=ve.inIteration,ve.inIteration=!0,i=Wt(),ve.inIteration=a,\"undefined\"==typeof r?he.createForStatement(t,e,n,i):he.createForInStatement(r,o,i)}function kt(){var t,e=null;return G(\"continue\"),59===se.charCodeAt(le)?(U(),ve.inIteration||V({},oe.IllegalContinue),he.createContinueStatement(null)):B()?(ve.inIteration||V({},oe.IllegalContinue),he.createContinueStatement(null)):(de.type===Jt.Identifier&&(e=bt(),t=\"$\"+e.name,Object.prototype.hasOwnProperty.call(ve.labelSet,t)||V({},oe.UnknownLabel,e.name)),K(),null!==e||ve.inIteration||V({},oe.IllegalContinue),he.createContinueStatement(e))}function Rt(){var t,e=null;return G(\"break\"),59===se.charCodeAt(le)?(U(),ve.inIteration||ve.inSwitch||V({},oe.IllegalBreak),he.createBreakStatement(null)):B()?(ve.inIteration||ve.inSwitch||V({},oe.IllegalBreak),he.createBreakStatement(null)):(de.type===Jt.Identifier&&(e=bt(),t=\"$\"+e.name,Object.prototype.hasOwnProperty.call(ve.labelSet,t)||V({},oe.UnknownLabel,e.name)),K(),null!==e||ve.inIteration||ve.inSwitch||V({},oe.IllegalBreak),he.createBreakStatement(e))}function It(){var t=null;return G(\"return\"),ve.inFunctionBody||W({},oe.IllegalReturn),32===se.charCodeAt(le)&&s(se.charCodeAt(le+1))?(t=_t(),K(),he.createReturnStatement(t)):B()?he.createReturnStatement(null):(q(\";\")||q(\"}\")||de.type===Jt.EOF||(t=_t()),K(),he.createReturnStatement(t))}function Nt(){var t,e;return ue&&(m(),W({},oe.StrictModeWith)),G(\"with\"),z(\"(\"),t=_t(),z(\")\"),e=Wt(),he.createWithStatement(t,e)}function Ut(){var t,e,n,r=[];for(n=de,H(\"default\")?(U(),t=null):(G(\"case\"),t=_t()),z(\":\");le<pe&&!(q(\"}\")||H(\"default\")||H(\"case\"));)e=Wt(),r.push(e);return he.markEnd(he.createSwitchCase(t,r),n)}function Ft(){var t,e,n,r,o;if(G(\"switch\"),z(\"(\"),t=_t(),z(\")\"),z(\"{\"),e=[],q(\"}\"))return U(),he.createSwitchStatement(t,e);for(r=ve.inSwitch,ve.inSwitch=!0,o=!1;le<pe&&!q(\"}\");)n=Ut(),null===n.test&&(o&&V({},oe.MultipleDefaultsInSwitch),o=!0),e.push(n);return ve.inSwitch=r,z(\"}\"),he.createSwitchStatement(t,e)}function Lt(){var t;return G(\"throw\"),B()&&V({},oe.NewlineAfterThrow),t=_t(),K(),he.createThrowStatement(t)}function Dt(){var t,e,n;return n=de,G(\"catch\"),z(\"(\"),q(\")\")&&X(de),t=bt(),ue&&f(t.name)&&W({},oe.StrictCatchVariable),z(\")\"),e=yt(),he.markEnd(he.createCatchClause(t,e),n)}function Bt(){var t,e=[],n=null;return G(\"try\"),t=yt(),H(\"catch\")&&e.push(Dt()),H(\"finally\")&&(U(),n=yt()),0!==e.length||n||V({},oe.NoCatchOrFinally),he.createTryStatement(t,[],e,n)}function Vt(){return G(\"debugger\"),K(),he.createDebuggerStatement()}function Wt(){var t,e,n,r,o=de.type;if(o===Jt.EOF&&X(de),o===Jt.Punctuator&&\"{\"===de.value)return yt();if(r=de,o===Jt.Punctuator)switch(de.value){case\";\":return he.markEnd(Ot(),r);case\"(\":return he.markEnd(St(),r)}if(o===Jt.Keyword)switch(de.value){case\"break\":return he.markEnd(Rt(),r);case\"continue\":return he.markEnd(kt(),r);case\"debugger\":return he.markEnd(Vt(),r);case\"do\":return he.markEnd(Mt(),r);case\"for\":return he.markEnd(Ct(),r);case\"function\":return he.markEnd(Gt(),r);case\"if\":return he.markEnd(Pt(),r);case\"return\":return he.markEnd(It(),r);case\"switch\":return he.markEnd(Ft(),r);case\"throw\":return he.markEnd(Lt(),r);case\"try\":return he.markEnd(Bt(),r);case\"var\":return he.markEnd(Et(),r);case\"while\":return he.markEnd(jt(),r);case\"with\":return he.markEnd(Nt(),r)}return t=_t(),t.type===ne.Identifier&&q(\":\")?(U(),n=\"$\"+t.name,Object.prototype.hasOwnProperty.call(ve.labelSet,n)&&V({},oe.Redeclaration,\"Label\",t.name),ve.labelSet[n]=!0,e=Wt(),delete ve.labelSet[n],he.markEnd(he.createLabeledStatement(t,e),r)):(K(),he.markEnd(he.createExpressionStatement(t),r))}function Xt(){var t,e,n,r,o,i,a,s,u,l=[];for(u=de,z(\"{\");le<pe&&de.type===Jt.StringLiteral&&(e=de,t=Ht(),l.push(t),t.expression.type===ne.Literal);)n=se.slice(e.start+1,e.end-1),\"use strict\"===n?(ue=!0,r&&W(r,oe.StrictOctalLiteral)):!r&&e.octal&&(r=e);for(o=ve.labelSet,i=ve.inIteration,a=ve.inSwitch,s=ve.inFunctionBody,ve.labelSet={},ve.inIteration=!1,ve.inSwitch=!1,ve.inFunctionBody=!0;le<pe&&!q(\"}\")&&(t=Ht(),\"undefined\"!=typeof t);)l.push(t);return z(\"}\"),ve.labelSet=o,ve.inIteration=i,ve.inSwitch=a,ve.inFunctionBody=s,he.markEnd(he.createBlockStatement(l),u)}function zt(t){var e,n,r,o,i,a,s=[];if(z(\"(\"),!q(\")\"))for(o={};le<pe&&(n=de,e=bt(),i=\"$\"+n.value,ue?(f(n.value)&&(r=n,a=oe.StrictParamName),Object.prototype.hasOwnProperty.call(o,i)&&(r=n,a=oe.StrictParamDupe)):t||(f(n.value)?(t=n,a=oe.StrictParamName):c(n.value)?(t=n,a=oe.StrictReservedWord):Object.prototype.hasOwnProperty.call(o,i)&&(t=n,a=oe.StrictParamDupe)),s.push(e),o[i]=!0,!q(\")\"));)z(\",\");return z(\")\"),{params:s,stricted:r,firstRestricted:t,message:a}}function Gt(){var t,e,n,r,o,i,a,s,u,l=[];return u=de,G(\"function\"),n=de,t=bt(),ue?f(n.value)&&W(n,oe.StrictFunctionName):f(n.value)?(i=n,a=oe.StrictFunctionName):c(n.value)&&(i=n,a=oe.StrictReservedWord),o=zt(i),l=o.params,r=o.stricted,i=o.firstRestricted,o.message&&(a=o.message),s=ue,e=Xt(),ue&&i&&V(i,a),ue&&r&&W(r,a),ue=s,he.markEnd(he.createFunctionDeclaration(t,l,[],e),u)}function qt(){var t,e,n,r,o,i,a,s,u=null,l=[];return s=de,G(\"function\"),q(\"(\")||(t=de,u=bt(),ue?f(t.value)&&W(t,oe.StrictFunctionName):f(t.value)?(n=t,r=oe.StrictFunctionName):c(t.value)&&(n=t,r=oe.StrictReservedWord)),o=zt(n),l=o.params,e=o.stricted,n=o.firstRestricted,o.message&&(r=o.message),a=ue,i=Xt(),ue&&n&&V(n,r),ue&&e&&W(e,r),ue=a,he.markEnd(he.createFunctionExpression(u,l,[],i),s)}function Ht(){if(de.type===Jt.Keyword)switch(de.value){case\"const\":case\"let\":return Tt(de.value);case\"function\":return Gt();default:return Wt()}if(de.type!==Jt.EOF)return Wt()}function Yt(){for(var t,e,n,r,o=[];le<pe&&(e=de,e.type===Jt.StringLiteral)&&(t=Ht(),o.push(t),t.expression.type===ne.Literal);)n=se.slice(e.start+1,e.end-1),\"use strict\"===n?(ue=!0,r&&W(r,oe.StrictOctalLiteral)):!r&&e.octal&&(r=e);for(;le<pe&&(t=Ht(),\"undefined\"!=typeof t);)o.push(t);return o}function Kt(){var t,e;return m(),F(),e=de,ue=!1,t=Yt(),he.markEnd(he.createProgram(t),e)}function $t(){var t,e,n,r=[];for(t=0;t<me.tokens.length;++t)e=me.tokens[t],n={type:e.type,value:e.value},me.range&&(n.range=e.range),me.loc&&(n.loc=e.loc),r.push(n);me.tokens=r}function Zt(t,e){var n,r,o;n=String,\"string\"==typeof t||t instanceof String||(t=n(t)),he=ae,se=t,le=0,ce=se.length>0?1:0,fe=0,pe=se.length,de=null,ve={allowIn:!0,labelSet:{},inFunctionBody:!1,inIteration:!1,inSwitch:!1,lastCommentStart:-1},me={},e=e||{},e.tokens=!0,me.tokens=[],me.tokenize=!0,me.openParenToken=-1,me.openCurlyToken=-1,me.range=\"boolean\"==typeof e.range&&e.range,me.loc=\"boolean\"==typeof e.loc&&e.loc,\"boolean\"==typeof e.comment&&e.comment&&(me.comments=[]),\"boolean\"==typeof e.tolerant&&e.tolerant&&(me.errors=[]);try{if(F(),de.type===Jt.EOF)return me.tokens;for(r=U();de.type!==Jt.EOF;)try{r=U()}catch(t){if(r=de,me.errors){me.errors.push(t);break}throw t}$t(),o=me.tokens,\"undefined\"!=typeof me.comments&&(o.comments=me.comments),\"undefined\"!=typeof me.errors&&(o.errors=me.errors)}catch(t){throw t}finally{me={}}return o}function Qt(t,e){var n,r;r=String,\"string\"==typeof t||t instanceof String||(t=r(t)),he=ae,se=t,le=0,ce=se.length>0?1:0,fe=0,pe=se.length,de=null,ve={allowIn:!0,labelSet:{},inFunctionBody:!1,inIteration:!1,inSwitch:!1,lastCommentStart:-1},me={},\"undefined\"!=typeof e&&(me.range=\"boolean\"==typeof e.range&&e.range,me.loc=\"boolean\"==typeof e.loc&&e.loc,me.attachComment=\"boolean\"==typeof e.attachComment&&e.attachComment,me.loc&&null!==e.source&&void 0!==e.source&&(me.source=r(e.source)),\"boolean\"==typeof e.tokens&&e.tokens&&(me.tokens=[]),\"boolean\"==typeof e.comment&&e.comment&&(me.comments=[]),\"boolean\"==typeof e.tolerant&&e.tolerant&&(me.errors=[]),me.attachComment&&(me.range=!0,me.comments=[],me.bottomRightStack=[],me.trailingComments=[],me.leadingComments=[]));try{n=Kt(),\"undefined\"!=typeof me.comments&&(n.comments=me.comments),\"undefined\"!=typeof me.tokens&&($t(),n.tokens=me.tokens),\"undefined\"!=typeof me.errors&&(n.errors=me.errors)}catch(t){throw t}finally{me={}}return n}var Jt,te,ee,ne,re,oe,ie,ae,se,ue,le,ce,fe,pe,he,de,ve,me;Jt={BooleanLiteral:1,EOF:2,Identifier:3,Keyword:4,NullLiteral:5,NumericLiteral:6,Punctuator:7,StringLiteral:8,RegularExpression:9},te={},te[Jt.BooleanLiteral]=\"Boolean\",te[Jt.EOF]=\"<end>\",te[Jt.Identifier]=\"Identifier\",te[Jt.Keyword]=\"Keyword\",te[Jt.NullLiteral]=\"Null\",te[Jt.NumericLiteral]=\"Numeric\",te[Jt.Punctuator]=\"Punctuator\",te[Jt.StringLiteral]=\"String\",te[Jt.RegularExpression]=\"RegularExpression\",ee=[\"(\",\"{\",\"[\",\"in\",\"typeof\",\"instanceof\",\"new\",\"return\",\"case\",\"delete\",\"throw\",\"void\",\"=\",\"+=\",\"-=\",\"*=\",\"/=\",\"%=\",\"<<=\",\">>=\",\">>>=\",\"&=\",\"|=\",\"^=\",\",\",\"+\",\"-\",\"*\",\"/\",\"%\",\"++\",\"--\",\"<<\",\">>\",\">>>\",\"&\",\"|\",\"^\",\"!\",\"~\",\"&&\",\"||\",\"?\",\":\",\"===\",\"==\",\">=\",\"<=\",\"<\",\">\",\"!=\",\"!==\"],ne={AssignmentExpression:\"AssignmentExpression\",ArrayExpression:\"ArrayExpression\",BlockStatement:\"BlockStatement\",BinaryExpression:\"BinaryExpression\",BreakStatement:\"BreakStatement\",CallExpression:\"CallExpression\",CatchClause:\"CatchClause\",ConditionalExpression:\"ConditionalExpression\",ContinueStatement:\"ContinueStatement\",DoWhileStatement:\"DoWhileStatement\",DebuggerStatement:\"DebuggerStatement\",EmptyStatement:\"EmptyStatement\",ExpressionStatement:\"ExpressionStatement\",ForStatement:\"ForStatement\",ForInStatement:\"ForInStatement\",FunctionDeclaration:\"FunctionDeclaration\",FunctionExpression:\"FunctionExpression\",Identifier:\"Identifier\",IfStatement:\"IfStatement\",Literal:\"Literal\",LabeledStatement:\"LabeledStatement\",LogicalExpression:\"LogicalExpression\",MemberExpression:\"MemberExpression\",NewExpression:\"NewExpression\",ObjectExpression:\"ObjectExpression\",Program:\"Program\",Property:\"Property\",ReturnStatement:\"ReturnStatement\",SequenceExpression:\"SequenceExpression\",SwitchStatement:\"SwitchStatement\",SwitchCase:\"SwitchCase\",ThisExpression:\"ThisExpression\",ThrowStatement:\"ThrowStatement\",TryStatement:\"TryStatement\",UnaryExpression:\"UnaryExpression\",UpdateExpression:\"UpdateExpression\",VariableDeclaration:\"VariableDeclaration\",VariableDeclarator:\"VariableDeclarator\",WhileStatement:\"WhileStatement\",WithStatement:\"WithStatement\"},re={Data:1,Get:2,Set:4},oe={UnexpectedToken:\"Unexpected token %0\",UnexpectedNumber:\"Unexpected number\",UnexpectedString:\"Unexpected string\",UnexpectedIdentifier:\"Unexpected identifier\",UnexpectedReserved:\"Unexpected reserved word\",UnexpectedEOS:\"Unexpected end of input\",NewlineAfterThrow:\"Illegal newline after throw\",InvalidRegExp:\"Invalid regular expression\",UnterminatedRegExp:\"Invalid regular expression: missing /\",InvalidLHSInAssignment:\"Invalid left-hand side in assignment\",InvalidLHSInForIn:\"Invalid left-hand side in for-in\",MultipleDefaultsInSwitch:\"More than one default clause in switch statement\",NoCatchOrFinally:\"Missing catch or finally after try\",UnknownLabel:\"Undefined label '%0'\",Redeclaration:\"%0 '%1' has already been declared\",IllegalContinue:\"Illegal continue statement\",IllegalBreak:\"Illegal break statement\",IllegalReturn:\"Illegal return statement\",StrictModeWith:\"Strict mode code may not include a with statement\",StrictCatchVariable:\"Catch variable may not be eval or arguments in strict mode\",StrictVarName:\"Variable name may not be eval or arguments in strict mode\",StrictParamName:\"Parameter name eval or arguments is not allowed in strict mode\",StrictParamDupe:\"Strict mode function may not have duplicate parameter names\",StrictFunctionName:\"Function name may not be eval or arguments in strict mode\",StrictOctalLiteral:\"Octal literals are not allowed in strict mode.\",StrictDelete:\"Delete of an unqualified identifier in strict mode.\",StrictDuplicateProperty:\"Duplicate data property in object literal not allowed in strict mode\",AccessorDataProperty:\"Object literal may not have data and accessor property with the same name\",AccessorGetSet:\"Object literal may not have multiple get/set accessors with the same name\",StrictLHSAssignment:\"Assignment to eval or arguments is not allowed in strict mode\",StrictLHSPostfix:\"Postfix increment/decrement may not have eval or arguments operand in strict mode\",StrictLHSPrefix:\"Prefix increment/decrement may not have eval or arguments operand in strict mode\",StrictReservedWord:\"Use of future reserved word in strict mode\"},ie={NonAsciiIdentifierStart:new RegExp(\"[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]\"),NonAsciiIdentifierPart:new RegExp(\"[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮ̀-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁ҃-҇Ҋ-ԧԱ-Ֆՙա-և֑-ׇֽֿׁׂׅׄא-תװ-ײؐ-ؚؠ-٩ٮ-ۓە-ۜ۟-۪ۨ-ۼۿܐ-݊ݍ-ޱ߀-ߵߺࠀ-࠭ࡀ-࡛ࢠࢢ-ࢬࣤ-ࣾऀ-ॣ०-९ॱ-ॷॹ-ॿঁ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-ৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૯ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍ୖୗଡ଼ଢ଼ୟ-ୣ୦-୯ୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௯ఁ-ఃఅ-ఌఎ-ఐఒ-నప-ళవ-హఽ-ౄె-ైొ-్ౕౖౘౙౠ-ౣ౦-౯ಂಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೞೠ-ೣ೦-೯ೱೲംഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൎൗൠ-ൣ൦-൯ൺ-ൿංඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟෲෳก-ฺเ-๎๐-๙ກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟༀ༘༙༠-༩༹༵༷༾-ཇཉ-ཬཱ-྄྆-ྗྙ-ྼ࿆က-၉ၐ-ႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፟ᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-᜔ᜠ-᜴ᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-៓ៗៜ៝០-៩᠋-᠍᠐-᠙ᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤜᤠ-ᤫᤰ-᤻᥆-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉ᧐-᧙ᨀ-ᨛᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙ᪧᬀ-ᭋ᭐-᭙᭫-᭳ᮀ-᯳ᰀ-᰷᱀-᱉ᱍ-ᱽ᳐-᳔᳒-ᳶᴀ-ᷦ᷼-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ‌‍‿⁀⁔ⁱⁿₐ-ₜ⃐-⃥⃜⃡-⃰ℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯ⵿-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〯〱-〵〸-〼ぁ-ゖ゙゚ゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘫꙀ-꙯ꙴ-꙽ꙿ-ꚗꚟ-꛱ꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠧꡀ-ꡳꢀ-꣄꣐-꣙꣠-ꣷꣻ꤀-꤭ꤰ-꥓ꥠ-ꥼꦀ-꧀ꧏ-꧙ꨀ-ꨶꩀ-ꩍ꩐-꩙ꩠ-ꩶꩺꩻꪀ-ꫂꫛ-ꫝꫠ-ꫯꫲ-꫶ꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯪ꯬꯭꯰-꯹가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻ︀-️︠-︦︳︴﹍-﹏ﹰ-ﹴﹶ-ﻼ０-９Ａ-Ｚ＿ａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]\")},ae={name:\"SyntaxTree\",processComment:function(t){var e,n;if(!(t.type===ne.Program&&t.body.length>0)){for(me.trailingComments.length>0?me.trailingComments[0].range[0]>=t.range[1]?(n=me.trailingComments,me.trailingComments=[]):me.trailingComments.length=0:me.bottomRightStack.length>0&&me.bottomRightStack[me.bottomRightStack.length-1].trailingComments&&me.bottomRightStack[me.bottomRightStack.length-1].trailingComments[0].range[0]>=t.range[1]&&(n=me.bottomRightStack[me.bottomRightStack.length-1].trailingComments,delete me.bottomRightStack[me.bottomRightStack.length-1].trailingComments);me.bottomRightStack.length>0&&me.bottomRightStack[me.bottomRightStack.length-1].range[0]>=t.range[0];)e=me.bottomRightStack.pop();e?e.leadingComments&&e.leadingComments[e.leadingComments.length-1].range[1]<=t.range[0]&&(t.leadingComments=e.leadingComments,delete e.leadingComments):me.leadingComments.length>0&&me.leadingComments[me.leadingComments.length-1].range[1]<=t.range[0]&&(t.leadingComments=me.leadingComments,me.leadingComments=[]),n&&(t.trailingComments=n),me.bottomRightStack.push(t)}},markEnd:function(t,e){return me.range&&(t.range=[e.start,le]),me.loc&&(t.loc=new D(void 0===e.startLineNumber?e.lineNumber:e.startLineNumber,e.start-(void 0===e.startLineStart?e.lineStart:e.startLineStart),ce,le-fe),this.postProcess(t)),me.attachComment&&this.processComment(t),t},postProcess:function(t){return me.source&&(t.loc.source=me.source),t},createArrayExpression:function(t){return{type:ne.ArrayExpression,elements:t}},createAssignmentExpression:function(t,e,n){return{type:ne.AssignmentExpression,operator:t,left:e,right:n}},createBinaryExpression:function(t,e,n){var r=\"||\"===t||\"&&\"===t?ne.LogicalExpression:ne.BinaryExpression;return{type:r,operator:t,left:e,right:n}},createBlockStatement:function(t){return{type:ne.BlockStatement,body:t}},createBreakStatement:function(t){return{type:ne.BreakStatement,label:t}},createCallExpression:function(t,e){return{type:ne.CallExpression,callee:t,arguments:e}},createCatchClause:function(t,e){return{type:ne.CatchClause,param:t,body:e}},createConditionalExpression:function(t,e,n){return{type:ne.ConditionalExpression,test:t,consequent:e,alternate:n}},createContinueStatement:function(t){return{type:ne.ContinueStatement,label:t}},createDebuggerStatement:function(){return{type:ne.DebuggerStatement}},createDoWhileStatement:function(t,e){return{type:ne.DoWhileStatement,body:t,test:e}},createEmptyStatement:function(){return{type:ne.EmptyStatement}},createExpressionStatement:function(t){return{type:ne.ExpressionStatement,expression:t}},createForStatement:function(t,e,n,r){return{type:ne.ForStatement,init:t,test:e,update:n,body:r}},createForInStatement:function(t,e,n){return{type:ne.ForInStatement,left:t,right:e,body:n,each:!1}},createFunctionDeclaration:function(t,e,n,r){return{type:ne.FunctionDeclaration,id:t,params:e,defaults:n,body:r,rest:null,generator:!1,expression:!1}},createFunctionExpression:function(t,e,n,r){return{type:ne.FunctionExpression,id:t,params:e,defaults:n,body:r,rest:null,generator:!1,expression:!1}},createIdentifier:function(t){return{type:ne.Identifier,name:t}},createIfStatement:function(t,e,n){return{type:ne.IfStatement,test:t,consequent:e,alternate:n}},createLabeledStatement:function(t,e){return{type:ne.LabeledStatement,label:t,body:e}},createLiteral:function(t){return{type:ne.Literal,value:t.value,raw:se.slice(t.start,t.end)}},createMemberExpression:function(t,e,n){return{type:ne.MemberExpression,computed:\"[\"===t,object:e,property:n}},createNewExpression:function(t,e){return{type:ne.NewExpression,callee:t,arguments:e}},createObjectExpression:function(t){return{type:ne.ObjectExpression,properties:t}},createPostfixExpression:function(t,e){return{type:ne.UpdateExpression,operator:t,argument:e,prefix:!1}},createProgram:function(t){return{type:ne.Program,body:t}},createProperty:function(t,e,n){return{type:ne.Property,key:e,value:n,kind:t}},createReturnStatement:function(t){return{type:ne.ReturnStatement,argument:t}},createSequenceExpression:function(t){return{type:ne.SequenceExpression,expressions:t}},createSwitchCase:function(t,e){return{type:ne.SwitchCase,test:t,consequent:e}},createSwitchStatement:function(t,e){return{type:ne.SwitchStatement,discriminant:t,cases:e}},createThisExpression:function(){return{type:ne.ThisExpression}},createThrowStatement:function(t){return{type:ne.ThrowStatement,argument:t}},createTryStatement:function(t,e,n,r){return{type:ne.TryStatement,block:t,guardedHandlers:e,handlers:n,finalizer:r}},createUnaryExpression:function(t,e){return\"++\"===t||\"--\"===t?{type:ne.UpdateExpression,operator:t,argument:e,prefix:!0}:{type:ne.UnaryExpression,operator:t,argument:e,prefix:!0}},createVariableDeclaration:function(t,e){return{type:ne.VariableDeclaration,declarations:t,kind:e}},createVariableDeclarator:function(t,e){return{type:ne.VariableDeclarator,id:t,init:e}},createWhileStatement:function(t,e){return{type:ne.WhileStatement,test:t,body:e}},createWithStatement:function(t,e){return{type:ne.WithStatement,object:t,body:e}}},t.version=\"1.2.5\",t.tokenize=Zt,t.parse=Qt,t.Syntax=function(){var t,e={};\"function\"==typeof Object.create&&(e=Object.create(null));for(t in ne)ne.hasOwnProperty(t)&&(e[t]=ne[t]);return\"function\"==typeof Object.freeze&&Object.freeze(e),e}()})},function(t,e){e.read=function(t,e,n,r,o){var i,a,s=8*o-r-1,u=(1<<s)-1,l=u>>1,c=-7,f=n?o-1:0,p=n?-1:1,h=t[e+f];for(f+=p,i=h&(1<<-c)-1,h>>=-c,c+=s;c>0;i=256*i+t[e+f],f+=p,c-=8);for(a=i&(1<<-c)-1,i>>=-c,c+=r;c>0;a=256*a+t[e+f],f+=p,c-=8);if(0===i)i=1-l;else{if(i===u)return a?NaN:(h?-1:1)*(1/0);a+=Math.pow(2,r),i-=l}return(h?-1:1)*a*Math.pow(2,i-r)},e.write=function(t,e,n,r,o,i){var a,s,u,l=8*i-o-1,c=(1<<l)-1,f=c>>1,p=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:i-1,d=r?1:-1,v=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,a=c):(a=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-a))<1&&(a--,u*=2),e+=a+f>=1?p/u:p*Math.pow(2,1-f),e*u>=2&&(a++,u/=2),a+f>=c?(s=0,a=c):a+f>=1?(s=(e*u-1)*Math.pow(2,o),a+=f):(s=e*Math.pow(2,f-1)*Math.pow(2,o),a=0));o>=8;t[n+h]=255&s,h+=d,s/=256,o-=8);for(a=a<<o|s,l+=o;l>0;t[n+h]=255&a,h+=d,a/=256,l-=8);t[n+h-d]|=128*v}},function(t,e,n){\"use strict\";function r(t){for(var e=new Array(t),n=0;n<t;++n)e[n]=n;return e}t.exports=r},function(t,e){function n(t){return!!t.constructor&&\"function\"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}function r(t){return\"function\"==typeof t.readFloatLE&&\"function\"==typeof t.slice&&n(t.slice(0,0))}t.exports=function(t){return null!=t&&(n(t)||r(t)||!!t._isBuffer)}},function(t,e,n){var r=n(48),o=n(29),i=r(o,\"DataView\");t.exports=i},function(t,e,n){function r(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}var o=n(521),i=n(522),a=n(523),s=n(524),u=n(525);r.prototype.clear=o,r.prototype.delete=i,r.prototype.get=a,r.prototype.has=s,r.prototype.set=u,t.exports=r},function(t,e,n){var r=n(48),o=n(29),i=r(o,\"Promise\");t.exports=i},function(t,e,n){var r=n(48),o=n(29),i=r(o,\"Set\");t.exports=i},function(t,e,n){function r(t){var e=-1,n=null==t?0:t.length;for(this.__data__=new o;++e<n;)this.add(t[e])}var o=n(120),i=n(546),a=n(547);r.prototype.add=r.prototype.push=i,r.prototype.has=a,t.exports=r},function(t,e,n){var r=n(29),o=r.Uint8Array;t.exports=o},function(t,e,n){var r=n(48),o=n(29),i=r(o,\"WeakMap\");t.exports=i},function(t,e){function n(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}t.exports=n},function(t,e){function n(t,e){for(var n=-1,r=null==t?0:t.length;++n<r;)if(!e(t[n],n,t))return!1;return!0}t.exports=n},function(t,e){function n(t,e){for(var n=-1,r=null==t?0:t.length,o=0,i=[];++n<r;){var a=t[n];e(a,n,t)&&(i[o++]=a)}return i}t.exports=n},function(t,e,n){function r(t,e){var n=a(t),r=!n&&i(t),c=!n&&!r&&s(t),p=!n&&!r&&!c&&l(t),h=n||r||c||p,d=h?o(t.length,String):[],v=d.length;for(var m in t)!e&&!f.call(t,m)||h&&(\"length\"==m||c&&(\"offset\"==m||\"parent\"==m)||p&&(\"buffer\"==m||\"byteLength\"==m||\"byteOffset\"==m)||u(m,v))||d.push(m);return d}var o=n(495),i=n(126),a=n(30),s=n(185),u=n(85),l=n(187),c=Object.prototype,f=c.hasOwnProperty;t.exports=r},function(t,e){function n(t,e,n,r){var o=-1,i=null==t?0:t.length;for(r&&i&&(n=t[++o]);++o<i;)n=e(n,t[o],o,t);return n}t.exports=n},function(t,e){function n(t,e){for(var n=-1,r=null==t?0:t.length;++n<r;)if(e(t[n],n,t))return!0;return!1}t.exports=n},function(t,e){function n(t){return t.split(\"\")}t.exports=n},function(t,e){function n(t){return t.match(r)||[]}var r=/[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;t.exports=n},function(t,e,n){function r(t,e,n){var r=t[e];s.call(t,e)&&i(r,n)&&(void 0!==n||e in t)||o(t,e,n)}var o=n(170),i=n(87),a=Object.prototype,s=a.hasOwnProperty;t.exports=r},function(t,e,n){var r=n(172),o=n(503),i=o(r);t.exports=i},function(t,e,n){function r(t,e){var n=!0;return o(t,function(t,r,o){return n=!!e(t,r,o)}),n}var o=n(471);t.exports=r},function(t,e){function n(t,e,n,r){for(var o=t.length,i=n+(r?1:-1);r?i--:++i<o;)if(e(t[i],i,t))return i;return-1}t.exports=n},function(t,e,n){var r=n(504),o=r();t.exports=o},function(t,e,n){function r(t,e,n){var r=e(t);return i(t)?r:o(r,n(t))}var o=n(169),i=n(30);t.exports=r},function(t,e){function n(t,e){return null!=t&&e in Object(t)}t.exports=n},function(t,e,n){function r(t){return i(t)&&o(t)==a}var o=n(62),i=n(64),a=\"[object Arguments]\";t.exports=r},function(t,e,n){function r(t,e,n,r,m,g){var y=l(t),b=l(e),w=y?d:u(t),x=b?d:u(e);w=w==h?v:w,x=x==h?v:x;var E=w==v,T=x==v,O=w==x;if(O&&c(t)){if(!c(e))return!1;y=!0,E=!1}if(O&&!E)return g||(g=new o),y||f(t)?i(t,e,n,r,m,g):a(t,e,w,n,r,m,g);if(!(n&p)){var S=E&&_.call(t,\"__wrapped__\"),P=T&&_.call(e,\"__wrapped__\");if(S||P){var M=S?t.value():t,j=P?e.value():e;return g||(g=new o),m(M,j,n,r,g)}}return!!O&&(g||(g=new o),s(t,e,n,r,m,g))}var o=n(168),i=n(174),a=n(511),s=n(512),u=n(176),l=n(30),c=n(185),f=n(187),p=1,h=\"[object Arguments]\",d=\"[object Array]\",v=\"[object Object]\",m=Object.prototype,_=m.hasOwnProperty;t.exports=r},function(t,e,n){function r(t,e,n,r){var u=n.length,l=u,c=!r;if(null==t)return!l;for(t=Object(t);u--;){var f=n[u];if(c&&f[2]?f[1]!==t[f[0]]:!(f[0]in t))return!1}for(;++u<l;){f=n[u];var p=f[0],h=t[p],d=f[1];if(c&&f[2]){if(void 0===h&&!(p in t))return!1}else{var v=new o;if(r)var m=r(h,d,p,t,e,v);if(!(void 0===m?i(d,h,a|s,r,v):m))return!1}}return!0}var o=n(168),i=n(123),a=1,s=2;t.exports=r},function(t,e,n){function r(t){if(!a(t)||i(t))return!1;var e=o(t)?d:l;return e.test(s(t))}var o=n(186),i=n(528),a=n(55),s=n(182),u=/[\\\\^$.*+?()[\\]{}|]/g,l=/^\\[object .+?Constructor\\]$/,c=Function.prototype,f=Object.prototype,p=c.toString,h=f.hasOwnProperty,d=RegExp(\"^\"+p.call(h).replace(u,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\");t.exports=r},function(t,e,n){function r(t){return a(t)&&i(t.length)&&!!C[o(t)]}var o=n(62),i=n(128),a=n(64),s=\"[object Arguments]\",u=\"[object Array]\",l=\"[object Boolean]\",c=\"[object Date]\",f=\"[object Error]\",p=\"[object Function]\",h=\"[object Map]\",d=\"[object Number]\",v=\"[object Object]\",m=\"[object RegExp]\",_=\"[object Set]\",g=\"[object String]\",y=\"[object WeakMap]\",b=\"[object ArrayBuffer]\",w=\"[object DataView]\",x=\"[object Float32Array]\",E=\"[object Float64Array]\",T=\"[object Int8Array]\",O=\"[object Int16Array]\",S=\"[object Int32Array]\",P=\"[object Uint8Array]\",M=\"[object Uint8ClampedArray]\",j=\"[object Uint16Array]\",A=\"[object Uint32Array]\",C={};C[x]=C[E]=C[T]=C[O]=C[S]=C[P]=C[M]=C[j]=C[A]=!0,C[s]=C[u]=C[b]=C[l]=C[w]=C[c]=C[f]=C[p]=C[h]=C[d]=C[v]=C[m]=C[_]=C[g]=C[y]=!1,t.exports=r},function(t,e,n){function r(t){if(!o(t))return i(t);var e=[];for(var n in Object(t))s.call(t,n)&&\"constructor\"!=n&&e.push(n);return e}var o=n(529),i=n(541),a=Object.prototype,s=a.hasOwnProperty;t.exports=r},function(t,e,n){function r(t){var e=i(t);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(n){return n===t||o(n,t,e)}}var o=n(479),i=n(515),a=n(181);t.exports=r},function(t,e,n){function r(t,e){return s(t)&&u(e)?l(c(t),e):function(n){var r=i(n,t);return void 0===r&&r===e?a(n,t):o(e,r,f|p)}}var o=n(123),i=n(569),a=n(184),s=n(124),u=n(179),l=n(181),c=n(63),f=1,p=2;t.exports=r},function(t,e,n){function r(t,e){return o(t,e,function(e,n){return i(t,n)})}var o=n(486),i=n(184);t.exports=r},function(t,e,n){function r(t,e,n){for(var r=-1,s=e.length,u={};++r<s;){var l=e[r],c=o(t,l);n(c,l)&&i(u,a(l,t),c)}return u}var o=n(122),i=n(491),a=n(83);t.exports=r},function(t,e){function n(t){return function(e){return null==e?void 0:e[t]}}t.exports=n},function(t,e,n){function r(t){return function(e){return o(e,t)}}var o=n(122);t.exports=r},function(t,e){function n(t){return function(e){return null==t?void 0:t[e]}}t.exports=n},function(t,e){function n(t,e,n,i){for(var a=-1,s=o(r((e-t)/(n||1)),0),u=Array(s);s--;)u[i?s:++a]=t,t+=n;return u}var r=Math.ceil,o=Math.max;t.exports=n},function(t,e,n){function r(t,e,n,r){if(!s(t))return t;e=i(e,t);for(var l=-1,c=e.length,f=c-1,p=t;null!=p&&++l<c;){var h=u(e[l]),d=n;if(l!=f){var v=p[h];d=r?r(v,h,p):void 0,void 0===d&&(d=s(v)?v:a(e[l+1])?[]:{})}o(p,h,d),p=p[h]}return t}var o=n(470),i=n(83),a=n(85),s=n(55),u=n(63);t.exports=r},function(t,e,n){var r=n(563),o=n(173),i=n(125),a=o?function(t,e){return o(t,\"toString\",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:i;t.exports=a},function(t,e){function n(t,e,n){var r=-1,o=t.length;e<0&&(e=-e>o?0:o+e),n=n>o?o:n,n<0&&(n+=o),o=e>n?0:n-e>>>0,e>>>=0;for(var i=Array(o);++r<o;)i[r]=t[r+e];return i}t.exports=n},function(t,e){function n(t,e){for(var n,r=-1,o=t.length;++r<o;){var i=e(t[r]);void 0!==i&&(n=void 0===n?i:n+i)}return n}t.exports=n},function(t,e){function n(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r}t.exports=n},function(t,e,n){function r(t,e){return o(e,function(e){return[e,t[e]]})}var o=n(121);t.exports=r},function(t,e,n){function r(t){if(\"string\"==typeof t)return t;if(a(t))return i(t,r)+\"\";if(s(t))return c?c.call(t):\"\";var e=t+\"\";return\"0\"==e&&1/t==-u?\"-0\":e}var o=n(61),i=n(121),a=n(30),s=n(89),u=1/0,l=o?o.prototype:void 0,c=l?l.toString:void 0;t.exports=r},function(t,e){function n(t){return function(e){return t(e)}}t.exports=n},function(t,e,n){function r(t,e){return o(e,function(e){return t[e]})}var o=n(121);t.exports=r},function(t,e){function n(t,e){return t.has(e)}t.exports=n},function(t,e,n){function r(t,e,n){var r=t.length;return n=void 0===n?r:n,!e&&n>=r?t:o(t,e,n)}var o=n(493);t.exports=r},function(t,e,n){var r=n(29),o=r[\"__core-js_shared__\"];t.exports=o},function(t,e,n){function r(t,e){return function(n,r){if(null==n)return n;if(!o(n))return t(n,r);for(var i=n.length,a=e?i:-1,s=Object(n);(e?a--:++a<i)&&r(s[a],a,s)!==!1;);return n}}var o=n(88);t.exports=r},function(t,e){function n(t){return function(e,n,r){for(var o=-1,i=Object(e),a=r(e),s=a.length;s--;){var u=a[t?s:++o];if(n(i[u],u,i)===!1)break}return e}}t.exports=n},function(t,e,n){function r(t){return function(e){e=s(e);var n=i(e)?a(e):void 0,r=n?n[0]:e.charAt(0),u=n?o(n,1).join(\"\"):e.slice(1);return r[t]()+u}}var o=n(501),i=n(177),a=n(557),s=n(65);t.exports=r},function(t,e,n){function r(t){return function(e){return o(a(i(e).replace(u,\"\")),t,\"\")}}var o=n(466),i=n(564),a=n(582),s=\"['’]\",u=RegExp(s,\"g\");t.exports=r},function(t,e,n){function r(t){return function(e,n,r){var s=Object(e);if(!i(e)){var u=o(n,3);e=a(e),n=function(t){return u(s[t],t,s)}}var l=t(e,n,r);return l>-1?s[u?e[l]:l]:void 0}}var o=n(82),i=n(88),a=n(49);t.exports=r},function(t,e,n){function r(t){return function(e,n,r){return r&&\"number\"!=typeof r&&i(e,n,r)&&(n=r=void 0),e=a(e),void 0===n?(n=e,e=0):n=a(n),r=void 0===r?e<n?1:-1:a(r),o(e,n,r,t)}}var o=n(490),i=n(178),a=n(189);t.exports=r},function(t,e,n){function r(t){return function(e){var n=i(e);return n==u?a(e):n==l?s(e):o(e,t(e))}}var o=n(496),i=n(176),a=n(180),s=n(549),u=\"[object Map]\",l=\"[object Set]\";t.exports=r},function(t,e,n){var r=n(489),o={\"À\":\"A\",\"Á\":\"A\",\"Â\":\"A\",\"Ã\":\"A\",\"Ä\":\"A\",\"Å\":\"A\",\"à\":\"a\",\"á\":\"a\",\"â\":\"a\",\"ã\":\"a\",\"ä\":\"a\",\"å\":\"a\",\"Ç\":\"C\",\"ç\":\"c\",\"Ð\":\"D\",\"ð\":\"d\",\"È\":\"E\",\"É\":\"E\",\"Ê\":\"E\",\"Ë\":\"E\",\"è\":\"e\",\"é\":\"e\",\"ê\":\"e\",\"ë\":\"e\",\"Ì\":\"I\",\"Í\":\"I\",\"Î\":\"I\",\"Ï\":\"I\",\"ì\":\"i\",\"í\":\"i\",\"î\":\"i\",\"ï\":\"i\",\"Ñ\":\"N\",\"ñ\":\"n\",\"Ò\":\"O\",\"Ó\":\"O\",\"Ô\":\"O\",\"Õ\":\"O\",\"Ö\":\"O\",\"Ø\":\"O\",\"ò\":\"o\",\"ó\":\"o\",\"ô\":\"o\",\"õ\":\"o\",\"ö\":\"o\",\"ø\":\"o\",\"Ù\":\"U\",\"Ú\":\"U\",\"Û\":\"U\",\"Ü\":\"U\",\"ù\":\"u\",\"ú\":\"u\",\"û\":\"u\",\"ü\":\"u\",\"Ý\":\"Y\",\"ý\":\"y\",\"ÿ\":\"y\",\"Æ\":\"Ae\",\"æ\":\"ae\",\"Þ\":\"Th\",\"þ\":\"th\",\"ß\":\"ss\",\"Ā\":\"A\",\"Ă\":\"A\",\"Ą\":\"A\",\"ā\":\"a\",\"ă\":\"a\",\"ą\":\"a\",\"Ć\":\"C\",\"Ĉ\":\"C\",\"Ċ\":\"C\",\"Č\":\"C\",\"ć\":\"c\",\"ĉ\":\"c\",\"ċ\":\"c\",\"č\":\"c\",\"Ď\":\"D\",\"Đ\":\"D\",\"ď\":\"d\",\"đ\":\"d\",\"Ē\":\"E\",\"Ĕ\":\"E\",\"Ė\":\"E\",\"Ę\":\"E\",\"Ě\":\"E\",\"ē\":\"e\",\"ĕ\":\"e\",\"ė\":\"e\",\"ę\":\"e\",\"ě\":\"e\",\"Ĝ\":\"G\",\"Ğ\":\"G\",\"Ġ\":\"G\",\"Ģ\":\"G\",\"ĝ\":\"g\",\"ğ\":\"g\",\"ġ\":\"g\",\"ģ\":\"g\",\"Ĥ\":\"H\",\"Ħ\":\"H\",\"ĥ\":\"h\",\"ħ\":\"h\",\"Ĩ\":\"I\",\"Ī\":\"I\",\"Ĭ\":\"I\",\"Į\":\"I\",\"İ\":\"I\",\"ĩ\":\"i\",\"ī\":\"i\",\"ĭ\":\"i\",\"į\":\"i\",\n\"ı\":\"i\",\"Ĵ\":\"J\",\"ĵ\":\"j\",\"Ķ\":\"K\",\"ķ\":\"k\",\"ĸ\":\"k\",\"Ĺ\":\"L\",\"Ļ\":\"L\",\"Ľ\":\"L\",\"Ŀ\":\"L\",\"Ł\":\"L\",\"ĺ\":\"l\",\"ļ\":\"l\",\"ľ\":\"l\",\"ŀ\":\"l\",\"ł\":\"l\",\"Ń\":\"N\",\"Ņ\":\"N\",\"Ň\":\"N\",\"Ŋ\":\"N\",\"ń\":\"n\",\"ņ\":\"n\",\"ň\":\"n\",\"ŋ\":\"n\",\"Ō\":\"O\",\"Ŏ\":\"O\",\"Ő\":\"O\",\"ō\":\"o\",\"ŏ\":\"o\",\"ő\":\"o\",\"Ŕ\":\"R\",\"Ŗ\":\"R\",\"Ř\":\"R\",\"ŕ\":\"r\",\"ŗ\":\"r\",\"ř\":\"r\",\"Ś\":\"S\",\"Ŝ\":\"S\",\"Ş\":\"S\",\"Š\":\"S\",\"ś\":\"s\",\"ŝ\":\"s\",\"ş\":\"s\",\"š\":\"s\",\"Ţ\":\"T\",\"Ť\":\"T\",\"Ŧ\":\"T\",\"ţ\":\"t\",\"ť\":\"t\",\"ŧ\":\"t\",\"Ũ\":\"U\",\"Ū\":\"U\",\"Ŭ\":\"U\",\"Ů\":\"U\",\"Ű\":\"U\",\"Ų\":\"U\",\"ũ\":\"u\",\"ū\":\"u\",\"ŭ\":\"u\",\"ů\":\"u\",\"ű\":\"u\",\"ų\":\"u\",\"Ŵ\":\"W\",\"ŵ\":\"w\",\"Ŷ\":\"Y\",\"ŷ\":\"y\",\"Ÿ\":\"Y\",\"Ź\":\"Z\",\"Ż\":\"Z\",\"Ž\":\"Z\",\"ź\":\"z\",\"ż\":\"z\",\"ž\":\"z\",\"Ĳ\":\"IJ\",\"ĳ\":\"ij\",\"Œ\":\"Oe\",\"œ\":\"oe\",\"ŉ\":\"'n\",\"ſ\":\"s\"},i=r(o);t.exports=i},function(t,e,n){function r(t,e,n,r,o,E,O){switch(n){case x:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case w:return!(t.byteLength!=e.byteLength||!E(new i(t),new i(e)));case p:case h:case m:return a(+t,+e);case d:return t.name==e.name&&t.message==e.message;case _:case y:return t==e+\"\";case v:var S=u;case g:var P=r&c;if(S||(S=l),t.size!=e.size&&!P)return!1;var M=O.get(t);if(M)return M==e;r|=f,O.set(t,e);var j=s(S(t),S(e),r,o,E,O);return O.delete(t),j;case b:if(T)return T.call(t)==T.call(e)}return!1}var o=n(61),i=n(460),a=n(87),s=n(174),u=n(180),l=n(548),c=1,f=2,p=\"[object Boolean]\",h=\"[object Date]\",d=\"[object Error]\",v=\"[object Map]\",m=\"[object Number]\",_=\"[object RegExp]\",g=\"[object Set]\",y=\"[object String]\",b=\"[object Symbol]\",w=\"[object ArrayBuffer]\",x=\"[object DataView]\",E=o?o.prototype:void 0,T=E?E.valueOf:void 0;t.exports=r},function(t,e,n){function r(t,e,n,r,a,u){var l=n&i,c=o(t),f=c.length,p=o(e),h=p.length;if(f!=h&&!l)return!1;for(var d=f;d--;){var v=c[d];if(!(l?v in e:s.call(e,v)))return!1}var m=u.get(t);if(m&&u.get(e))return m==e;var _=!0;u.set(t,e),u.set(e,t);for(var g=l;++d<f;){v=c[d];var y=t[v],b=e[v];if(r)var w=l?r(b,y,v,e,t,u):r(y,b,v,t,e,u);if(!(void 0===w?y===b||a(y,b,n,r,u):w)){_=!1;break}g||(g=\"constructor\"==v)}if(_&&!g){var x=t.constructor,E=e.constructor;x!=E&&\"constructor\"in t&&\"constructor\"in e&&!(\"function\"==typeof x&&x instanceof x&&\"function\"==typeof E&&E instanceof E)&&(_=!1)}return u.delete(t),u.delete(e),_}var o=n(514),i=1,a=Object.prototype,s=a.hasOwnProperty;t.exports=r},function(t,e,n){function r(t){return a(i(t,void 0,o),t+\"\")}var o=n(568),i=n(545),a=n(550);t.exports=r},function(t,e,n){function r(t){return o(t,a,i)}var o=n(475),i=n(517),a=n(49);t.exports=r},function(t,e,n){function r(t){for(var e=i(t),n=e.length;n--;){var r=e[n],a=t[r];e[n]=[r,a,o(a)]}return e}var o=n(179),i=n(49);t.exports=r},function(t,e,n){function r(t){var e=a.call(t,u),n=t[u];try{t[u]=void 0;var r=!0}catch(t){}var o=s.call(t);return r&&(e?t[u]=n:delete t[u]),o}var o=n(61),i=Object.prototype,a=i.hasOwnProperty,s=i.toString,u=o?o.toStringTag:void 0;t.exports=r},function(t,e,n){var r=n(464),o=n(575),i=Object.prototype,a=i.propertyIsEnumerable,s=Object.getOwnPropertySymbols,u=s?function(t){return null==t?[]:(t=Object(t),r(s(t),function(e){return a.call(t,e)}))}:o;t.exports=u},function(t,e){function n(t,e){return null==t?void 0:t[e]}t.exports=n},function(t,e,n){function r(t,e,n){e=o(e,t);for(var r=-1,c=e.length,f=!1;++r<c;){var p=l(e[r]);if(!(f=null!=t&&n(t,p)))break;t=t[p]}return f||++r!=c?f:(c=null==t?0:t.length,!!c&&u(c)&&s(p,c)&&(a(t)||i(t)))}var o=n(83),i=n(126),a=n(30),s=n(85),u=n(128),l=n(63);t.exports=r},function(t,e){function n(t){return r.test(t)}var r=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;t.exports=n},function(t,e,n){function r(){this.__data__=o?o(null):{},this.size=0}var o=n(86);t.exports=r},function(t,e){function n(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e}t.exports=n},function(t,e,n){function r(t){var e=this.__data__;if(o){var n=e[t];return n===i?void 0:n}return s.call(e,t)?e[t]:void 0}var o=n(86),i=\"__lodash_hash_undefined__\",a=Object.prototype,s=a.hasOwnProperty;t.exports=r},function(t,e,n){function r(t){var e=this.__data__;return o?void 0!==e[t]:a.call(e,t)}var o=n(86),i=Object.prototype,a=i.hasOwnProperty;t.exports=r},function(t,e,n){function r(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=o&&void 0===e?i:e,this}var o=n(86),i=\"__lodash_hash_undefined__\";t.exports=r},function(t,e,n){function r(t){return a(t)||i(t)||!!(s&&t&&t[s])}var o=n(61),i=n(126),a=n(30),s=o?o.isConcatSpreadable:void 0;t.exports=r},function(t,e){function n(t){var e=typeof t;return\"string\"==e||\"number\"==e||\"symbol\"==e||\"boolean\"==e?\"__proto__\"!==t:null===t}t.exports=n},function(t,e,n){function r(t){return!!i&&i in t}var o=n(502),i=function(){var t=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||\"\");return t?\"Symbol(src)_1.\"+t:\"\"}();t.exports=r},function(t,e){function n(t){var e=t&&t.constructor,n=\"function\"==typeof e&&e.prototype||r;return t===n}var r=Object.prototype;t.exports=n},function(t,e){function n(){this.__data__=[],this.size=0}t.exports=n},function(t,e,n){function r(t){var e=this.__data__,n=o(e,t);if(n<0)return!1;var r=e.length-1;return n==r?e.pop():a.call(e,n,1),--this.size,!0}var o=n(81),i=Array.prototype,a=i.splice;t.exports=r},function(t,e,n){function r(t){var e=this.__data__,n=o(e,t);return n<0?void 0:e[n][1]}var o=n(81);t.exports=r},function(t,e,n){function r(t){return o(this.__data__,t)>-1}var o=n(81);t.exports=r},function(t,e,n){function r(t,e){var n=this.__data__,r=o(n,t);return r<0?(++this.size,n.push([t,e])):n[r][1]=e,this}var o=n(81);t.exports=r},function(t,e,n){function r(){this.size=0,this.__data__={hash:new o,map:new(a||i),string:new o}}var o=n(456),i=n(80),a=n(119);t.exports=r},function(t,e,n){function r(t){var e=o(this,t).delete(t);return this.size-=e?1:0,e}var o=n(84);t.exports=r},function(t,e,n){function r(t){return o(this,t).get(t)}var o=n(84);t.exports=r},function(t,e,n){function r(t){return o(this,t).has(t)}var o=n(84);t.exports=r},function(t,e,n){function r(t,e){var n=o(this,t),r=n.size;return n.set(t,e),this.size+=n.size==r?0:1,this}var o=n(84);t.exports=r},function(t,e,n){function r(t){var e=o(t,function(t){return n.size===i&&n.clear(),t}),n=e.cache;return e}var o=n(572),i=500;t.exports=r},function(t,e,n){var r=n(544),o=r(Object.keys,Object);t.exports=o},function(t,e,n){(function(t){var r=n(175),o=\"object\"==typeof e&&e&&!e.nodeType&&e,i=o&&\"object\"==typeof t&&t&&!t.nodeType&&t,a=i&&i.exports===o,s=a&&r.process,u=function(){try{return s&&s.binding&&s.binding(\"util\")}catch(t){}}();t.exports=u}).call(e,n(92)(t))},function(t,e){function n(t){return o.call(t)}var r=Object.prototype,o=r.toString;t.exports=n},function(t,e){function n(t,e){return function(n){return t(e(n))}}t.exports=n},function(t,e,n){function r(t,e,n){return e=i(void 0===e?t.length-1:e,0),function(){for(var r=arguments,a=-1,s=i(r.length-e,0),u=Array(s);++a<s;)u[a]=r[e+a];a=-1;for(var l=Array(e+1);++a<e;)l[a]=r[a];return l[e]=n(u),o(t,this,l)}}var o=n(462),i=Math.max;t.exports=r},function(t,e){function n(t){return this.__data__.set(t,r),this}var r=\"__lodash_hash_undefined__\";t.exports=n},function(t,e){function n(t){return this.__data__.has(t)}t.exports=n},function(t,e){function n(t){var e=-1,n=Array(t.size);return t.forEach(function(t){n[++e]=t}),n}t.exports=n},function(t,e){function n(t){var e=-1,n=Array(t.size);return t.forEach(function(t){n[++e]=[t,t]}),n}t.exports=n},function(t,e,n){var r=n(492),o=n(551),i=o(r);t.exports=i},function(t,e){function n(t){var e=0,n=0;return function(){var a=i(),s=o-(a-n);if(n=a,s>0){if(++e>=r)return arguments[0]}else e=0;return t.apply(void 0,arguments)}}var r=800,o=16,i=Date.now;t.exports=n},function(t,e,n){function r(){this.__data__=new o,this.size=0}var o=n(80);t.exports=r},function(t,e){function n(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n}t.exports=n},function(t,e){function n(t){return this.__data__.get(t)}t.exports=n},function(t,e){function n(t){return this.__data__.has(t)}t.exports=n},function(t,e,n){function r(t,e){var n=this.__data__;if(n instanceof o){var r=n.__data__;if(!i||r.length<s-1)return r.push([t,e]),this.size=++n.size,this;n=this.__data__=new a(r)}return n.set(t,e),this.size=n.size,this}var o=n(80),i=n(119),a=n(120),s=200;t.exports=r},function(t,e,n){function r(t){return i(t)?a(t):o(t)}var o=n(468),i=n(177),a=n(559);t.exports=r},function(t,e,n){var r=n(540),o=/^\\./,i=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,a=/\\\\(\\\\)?/g,s=r(function(t){var e=[];return o.test(t)&&e.push(\"\"),t.replace(i,function(t,n,r,o){e.push(r?o.replace(a,\"$1\"):n||t)}),e});t.exports=s},function(t,e){function n(t){return t.match(x)||[]}var r=\"\\\\ud800-\\\\udfff\",o=\"\\\\u0300-\\\\u036f\",i=\"\\\\ufe20-\\\\ufe2f\",a=\"\\\\u20d0-\\\\u20ff\",s=o+i+a,u=\"\\\\ufe0e\\\\ufe0f\",l=\"[\"+r+\"]\",c=\"[\"+s+\"]\",f=\"\\\\ud83c[\\\\udffb-\\\\udfff]\",p=\"(?:\"+c+\"|\"+f+\")\",h=\"[^\"+r+\"]\",d=\"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\",v=\"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\",m=\"\\\\u200d\",_=p+\"?\",g=\"[\"+u+\"]?\",y=\"(?:\"+m+\"(?:\"+[h,d,v].join(\"|\")+\")\"+g+_+\")*\",b=g+_+y,w=\"(?:\"+[h+c+\"?\",c,d,v,l].join(\"|\")+\")\",x=RegExp(f+\"(?=\"+f+\")|\"+w+b,\"g\");t.exports=n},function(t,e){function n(t){return t.match(W)||[]}var r=\"\\\\ud800-\\\\udfff\",o=\"\\\\u0300-\\\\u036f\",i=\"\\\\ufe20-\\\\ufe2f\",a=\"\\\\u20d0-\\\\u20ff\",s=o+i+a,u=\"\\\\u2700-\\\\u27bf\",l=\"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\",c=\"\\\\xac\\\\xb1\\\\xd7\\\\xf7\",f=\"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\",p=\"\\\\u2000-\\\\u206f\",h=\" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\",d=\"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\",v=\"\\\\ufe0e\\\\ufe0f\",m=c+f+p+h,_=\"['’]\",g=\"[\"+m+\"]\",y=\"[\"+s+\"]\",b=\"\\\\d+\",w=\"[\"+u+\"]\",x=\"[\"+l+\"]\",E=\"[^\"+r+m+b+u+l+d+\"]\",T=\"\\\\ud83c[\\\\udffb-\\\\udfff]\",O=\"(?:\"+y+\"|\"+T+\")\",S=\"[^\"+r+\"]\",P=\"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\",M=\"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\",j=\"[\"+d+\"]\",A=\"\\\\u200d\",C=\"(?:\"+x+\"|\"+E+\")\",k=\"(?:\"+j+\"|\"+E+\")\",R=\"(?:\"+_+\"(?:d|ll|m|re|s|t|ve))?\",I=\"(?:\"+_+\"(?:D|LL|M|RE|S|T|VE))?\",N=O+\"?\",U=\"[\"+v+\"]?\",F=\"(?:\"+A+\"(?:\"+[S,P,M].join(\"|\")+\")\"+U+N+\")*\",L=\"\\\\d*(?:(?:1st|2nd|3rd|(?![123])\\\\dth)\\\\b)\",D=\"\\\\d*(?:(?:1ST|2ND|3RD|(?![123])\\\\dTH)\\\\b)\",B=U+N+F,V=\"(?:\"+[w,P,M].join(\"|\")+\")\"+B,W=RegExp([j+\"?\"+x+\"+\"+R+\"(?=\"+[g,j,\"$\"].join(\"|\")+\")\",k+\"+\"+I+\"(?=\"+[g,j+C,\"$\"].join(\"|\")+\")\",j+\"?\"+C+\"+\"+R,j+\"+\"+I,D,L,b,V].join(\"|\"),\"g\");t.exports=n},function(t,e,n){var r=n(562),o=n(506),i=o(function(t,e,n){return e=e.toLowerCase(),t+(n?r(e):e)});t.exports=i},function(t,e,n){function r(t){return i(o(t).toLowerCase())}var o=n(65),i=n(580);t.exports=r},function(t,e){function n(t){return function(){return t}}t.exports=n},function(t,e,n){function r(t){return t=i(t),t&&t.replace(a,o).replace(p,\"\")}var o=n(510),i=n(65),a=/[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g,s=\"\\\\u0300-\\\\u036f\",u=\"\\\\ufe20-\\\\ufe2f\",l=\"\\\\u20d0-\\\\u20ff\",c=s+u+l,f=\"[\"+c+\"]\",p=RegExp(f,\"g\");t.exports=r},function(t,e,n){function r(t,e,n){var r=s(t)?o:i;return n&&u(t,e,n)&&(e=void 0),r(t,a(e,3))}var o=n(463),i=n(472),a=n(82),s=n(30),u=n(178);t.exports=r},function(t,e,n){var r=n(507),o=n(567),i=r(o);t.exports=i},function(t,e,n){function r(t,e,n){var r=null==t?0:t.length;if(!r)return-1;var u=null==n?0:a(n);return u<0&&(u=s(r+u,0)),o(t,i(e,3),u)}var o=n(473),i=n(82),a=n(577),s=Math.max;t.exports=r},function(t,e,n){function r(t){var e=null==t?0:t.length;return e?o(t,1):[]}var o=n(171);t.exports=r},function(t,e,n){function r(t,e,n){var r=null==t?void 0:o(t,e);return void 0===r?n:r}var o=n(122);t.exports=r},function(t,e,n){function r(t){return\"number\"==typeof t&&i(t)}var o=n(29),i=o.isFinite;t.exports=r},function(t,e,n){function r(t,e){var n={};return e=a(e,3),i(t,function(t,r,i){o(n,e(t,r,i),t)}),n}var o=n(170),i=n(172),a=n(82);t.exports=r},function(t,e,n){function r(t,e){if(\"function\"!=typeof t||null!=e&&\"function\"!=typeof e)throw new TypeError(i);var n=function(){var r=arguments,o=e?e.apply(this,r):r[0],i=n.cache;if(i.has(o))return i.get(o);var a=t.apply(this,r);return n.cache=i.set(o,a)||i,a};return n.cache=new(r.Cache||o),n}var o=n(120),i=\"Expected a function\";r.Cache=o,t.exports=r},function(t,e,n){var r=n(485),o=n(513),i=o(function(t,e){return null==t?{}:r(t,e)});t.exports=i},function(t,e,n){function r(t){return a(t)?o(s(t)):i(t)}var o=n(487),i=n(488),a=n(124),s=n(63);t.exports=r},function(t,e){function n(){return[]}t.exports=n},function(t,e){function n(){return!1}t.exports=n},function(t,e,n){function r(t){var e=o(t),n=e%1;return e===e?n?e-n:e:0}var o=n(189);t.exports=r},function(t,e,n){function r(t){if(\"number\"==typeof t)return t;if(i(t))return a;if(o(t)){var e=\"function\"==typeof t.valueOf?t.valueOf():t;t=o(e)?e+\"\":e}if(\"string\"!=typeof t)return 0===t?t:+t;t=t.replace(s,\"\");var n=l.test(t);return n||c.test(t)?f(t.slice(2),n?2:8):u.test(t)?a:+t}var o=n(55),i=n(89),a=NaN,s=/^\\s+|\\s+$/g,u=/^[-+]0x[0-9a-f]+$/i,l=/^0b[01]+$/i,c=/^0o[0-7]+$/i,f=parseInt;t.exports=r},function(t,e,n){var r=n(509),o=n(49),i=r(o);t.exports=i},function(t,e,n){var r=n(505),o=r(\"toUpperCase\");t.exports=o},function(t,e,n){function r(t){return null==t?[]:o(t,i(t))}var o=n(499),i=n(49);t.exports=r},function(t,e,n){function r(t,e,n){return t=a(t),e=n?void 0:e,void 0===e?i(t)?s(t):o(t):t.match(e)||[]}var o=n(469),i=n(520),a=n(65),s=n(560);t.exports=r},function(t,e,n){\"use strict\";t.exports=function(t){var e,n=t.data,r=t.stride[0],o=t.offset,i=0;for(e=t.shape[0]-1;e>=0;e--,o+=r)i+=Math.abs(n[o]);return i}},function(t,e,n){\"use strict\";t.exports=function(t,e,n){var r,o=e.data,i=n.data,a=e.stride[0],s=n.stride[0],u=e.offset,l=n.offset;for(r=e.shape[0]-1;r>=0;r--,u+=a,l+=s)i[l]+=t*o[u]}},function(t,e,n){\"use strict\";t.exports=function(t,e){var n,r=t.data,o=e.data,i=t.stride[0],a=e.stride[0],s=t.offset,u=e.offset;for(n=t.shape[0]-1;n>=0;n--,s+=i,u+=a)o[u]=r[s]}},function(t,e,n){\"use strict\";t.exports=function(t,e,n){var r,o=e.data,i=n.data,a=e.stride[0],s=n.stride[0],u=e.offset,l=n.offset;for(r=e.shape[0]-1;r>=0;r--,u+=a,l+=s)i[l]=t*o[u]}},function(t,e,n){\"use strict\";t.exports=function(t,e){var n,r,o=t.data,i=t.stride[0],a=t.offset,s=0;if(t===e)for(n=t.shape[0]-1;n>=0;n--,a+=i)r=o[a],s+=r*r;else{var u=e.data,l=e.stride[0],c=e.offset;for(n=t.shape[0]-1;n>=0;n--,a+=i,c+=l)s+=u[c]*o[a]}return s}},function(t,e,n){\"use strict\";t.exports=function(t){var e,n,r,o=-(1/0),i=t.data,a=t.stride[0],s=t.offset,u=t.shape[0];for(e=0;e<u;e++,s+=a)n=Math.abs(i[s]),n>o&&(o=n,r=e);return r}},function(t,e,n){\"use strict\";var r=function(t,e){if(0===t&&0===e)return 0;var n=Math.abs(t),r=Math.abs(e),o=Math.min(n,r),i=Math.max(n,r);return o/=i,i*Math.sqrt(1+o*o)};t.exports=function(t){var e,n,o=t.data,i=t.stride[0],a=t.offset,s=0;for(e=t.shape[0]-1;e>=0;e--,a+=i)n=o[a],s=r(s,n);return s}},function(t,e,n){\"use strict\";Math.sign=Math.sign||function(t){return t=+t,0===t||isNaN(t)?t:t>0?1:-1},t.exports=function(t,e,n){var r=0,o=0,i=0,a=0,s=0;return 0===e?(r=Math.sign(t),o=0,i=Math.abs(t)):0===t?(r=0,o=Math.sign(e),i=Math.abs(e)):Math.abs(t)>Math.abs(e)?(a=e/t,s=Math.sign(t)*Math.sqrt(1+a*a),r=1/s,o=a*r,i=t*s):(a=t/e,s=Math.sign(t)*Math.sqrt(1+a*a),o=1/s,r=a*o,i=e*s),void 0!==n&&n.length>2?(n[0]=r,n[1]=o,n[2]=i,void 0):[r,o,i]}},function(t,e,n){\"use strict\";t.exports=function(t,e){var n,r=e.data,o=e.stride[0],i=e.offset;for(n=e.shape[0]-1;n>=0;n--,i+=o)r[i]*=t}},function(t,e,n){\"use strict\";t.exports=function(t,e){var n,r,o=t.data,i=e.data,a=t.stride[0],s=e.stride[0],u=t.offset,l=e.offset;for(n=t.shape[0]-1;n>=0;n--,u+=a,l+=s)r=o[u],o[u]=i[l],i[l]=r}},function(t,e,n){\"use strict\";function r(t,e,n,r,o,i,a){for(var s=0,u=0,l=0,c=0,f=0,p=t.shape[0],h=t.shape[1],d=Math.min(e,p-1),v=Math.min(n,h-1),m=void 0===i?1:i,_=void 0===a?0:a;s<=d;){c=0;var g=Math.min(s+v,h-1);for(l=0;l<=g;l++)c+=t.get(s,l)*r.get(l);o.set(s,c*m+_*o.get(s)),s++}if(s<p)for(u=0;s+v<h;){for(c=0,l=0;l<=d+v;l++)f=u+l+1,c+=t.get(s,f)*r.get(f);if(o.set(s,c*m+_*o.get(s)),s++,u++,s===p)break}if(s<p)for(u++;s-d<h;){for(c=0,l=u;l<h;l++)c+=t.get(s,l)*r.get(l);if(o.set(s,c*m+_*o.get(s)),s++,u++,s===p)break}return!0}t.exports=r},function(t,e,n){\"use strict\";function r(t,e,n,r,i){for(var a=o.dot,s=e.shape[0]-1;s>=0;s--)i.set(s,i.get(s)*r+t*a(e.pick(s,null),n));return!0}var o=n(90);t.exports=r},function(t,e,n){\"use strict\";function r(){console.error(\"GER (rank 1 operation A := alpha*x*y' + A) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";function r(){console.error(\"SBMV (symmetric banded matrix vector multiply) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";(function(t){function e(){console.error(\"SPMV (symmetric packed matrix vector multiply) not yet implemented\")}t.exporst=e}).call(e,n(92)(t))},function(t,e,n){\"use strict\";function r(){console.error(\"SPR (symmetric packed rank 1 operation A := alpha*x*y' + A) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";function r(){console.error(\"SPR (symmetric packed rank 2 operation A := alpha*x*y' + alpha*y*x' + A) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";function r(t,e,n,r,i,a){var s=t.shape[0],u=r||!0,l=void 0===i?1:i,c=void 0===a?0:a,f=0,p=0,h=0,d=0;if(0===c)for(f=0;f<n.shape[0];++f)n.set(f,0);else 1!==c&&o.scal(c,n);if(0===l)return!0;if(1===l)if(u)for(p=0;p<s;++p){for(h=e.get(p),d=0,n.set(p,n.get(p)+h*t.get(p,p)),f=p+1;f<s;++f)n.set(f,n.get(f)+h*t.get(f,p)),d+=t.get(f,p)*e.get(f);n.set(p,n.get(p)+d)}else for(p=0;p<s;++p){for(h=e.get(p),d=0,f=0;f<=p-1;++f)n.set(f,n.get(f)+h*t.get(f,p)),d+=t.get(f,p)*e.get(f);n.set(p,n.get(p)+h*t.get(p,p)+d)}else if(u)for(p=0;p<s;++p){for(h=l*e.get(p),d=0,n.set(p,n.get(p)+h*t.get(p,p)),f=p+1;f<s;++f)n.set(f,n.get(f)+h*t.get(f,p)),d+=t.get(f,p)*e.get(f);n.set(p,n.get(p)+l*d)}else for(p=0;p<s;++p){for(h=l*e.get(p),d=0,f=0;f<=p-1;++f)n.set(f,n.get(f)+h*t.get(f,p)),d+=t.get(f,p)*e.get(f);n.set(p,n.get(p)+h*t.get(p,p)+l*d)}return!0}var o=n(90);t.exports=r},function(t,e,n){\"use strict\";function r(){console.error(\"SYR (symmetric rank 1 operation A := alpha*x*y' + A) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";function r(){console.error(\"SYR (symmetric rank 2 operation A := alpha*x*y' + alpha*y*x' + A) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";function r(){console.error(\"TBMV (triangular banded matrix vector multiply) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";(function(t){function e(){console.error(\"TBSV (triangular banded matrix solver) not yet implemented\")}t.exporst=e}).call(e,n(92)(t))},function(t,e,n){\"use strict\";function r(){console.error(\"TPSV (triangular packed matrix solver) not yet implemented\")}t.exports=r},function(t,e,n){\"use strict\";function r(t,e,n){var r=o.dot,i=t.shape[1],a=0;if(n)for(a=i-1;a>=0;a--)e.set(a,r(t.pick(a,null).hi(a+1),e.hi(a+1)));else for(a=0;a<i;a++)e.set(a,r(t.pick(a,null).lo(a),e.lo(a)));return!0}var o=n(90);t.exports=r},function(t,e,n){\"use strict\";function r(t,e,n){var r=o.dot,i=t.shape[1],a=0;if(n)for(e.set(0,e.get(0)/t.get(0,0)),a=1;a<i;a++)e.set(a,(e.get(a)-r(t.pick(a,null).hi(a),e.hi(a)))/t.get(a,a));else for(e.set(i-1,e.get(i-1)/t.get(i-1,i-1)),a=i-2;a>=0;a--)e.set(a,(e.get(a)-r(t.pick(a,null).lo(a+1),e.lo(a+1)))/t.get(a,a));return!0}var o=n(90);t.exports=r},function(t,e,n){\"use strict\";function r(){var t,e,n,r,u,l,c,f,p,h;if(r=o({},s),0===arguments.length)throw new Error(\"Array of ndarrays to concatenate must not be empty\");if(Array.isArray(arguments[0])?(n=arguments[0],o(r,arguments[1]||{})):2===arguments.length&&(n=arguments[1],t=arguments[0],o(r,arguments[2]||{})),0===n.length)throw new Error(\"Array of ndarrays to concatenate must not be empty\");for(u=0;u<n.length;u++)if(c){if(n[u].dimension!==c.length)throw new Error(\"all arrays must have the same dimensionality\");for(l=1;l<n[u].shape.length;l++)if(n[u].shape[l]!==c[l])throw new Error(\"last n-1 dimensions of concatenated rows must have the same size\");c[0]+=n[u].shape[0]}else c=n[u].shape.slice(0);if(t){if(c[0]!==t.shape[0])throw new Error(\"first dimension of output array must match the total number of concatenated rows\")}else t=a.zeros(c,r.dtype);for(l=0,f=0;l<n.length;l++)e=n[l],p=e.shape[0],h=t.lo(f).hi(p),i.assign(h,e),f+=p;return t}t.exports=r;var o=n(623),i=n(3),a=n(190),s={dtype:\"double\"}},function(t,e,n){\"use strict\";function r(t,e){return\"native\"===e[1]?[t,\"d0=\",t,\".length,\",t,\"d1=\",t,\"[0].length,\"].join(\"\"):[t,\"d0=\",t,\".shape[0],\",t,\"d1=\",t,\".shape[1],\",t,\"s0=\",t,\".stride[0],\",t,\"s1=\",t,\".stride[1],\",t,\"o=\",t,\".offset,\",t,\"d=\",t,\".data,\"].join(\"\")}function o(t,e,n,r,o,i){var a=[];return\"native\"===n[1]?t[0]&&(r?a.push(\"var \",e,\"p=\",e,\"[\",r,\"];\"):a.push(\"var \",e,\"p=\",e,\"[0];\")):r&&o?i?a.push(\"var \",e,\"t0=\",e,\"s\",t[0],\",\",e,\"t1=\",e,\"s\",t[1],\"-\",e,\"s\",t[0],\"*\",i,\",\",e,\"p=\",e,\"o+\",r,\"*\",e,\"s0+\",o,\"*\",e,\"s1;\"):a.push(\"var \",e,\"t0=\",e,\"s\",t[0],\",\",e,\"p=\",e,\"o+\",r,\"*\",e,\"s0+\",o,\"*\",e,\"s1;\"):r?a.push(\"var \",e,\"t0=\",e,\"s\",t[0],\",\",e,\"p=\",e,\"o+\",r,\"*\",e,\"s0;\"):o?a.push(\"var \",e,\"t0=\",e,\"s\",t[0],\",\",e,\"p=\",e,\"o+\",o,\"*\",e,\"s1;\"):a.push(\"var \",e,\"t0=\",e,\"s\",t[0],\",\",e,\"t1=\",e,\"s\",t[1],\"-\",e,\"s\",t[0],\"*\",e,\"d\",t[0],\",\",e,\"p=\",e,\"o;\"),a}function i(t,e,n,r,o){var i=[];return\"native\"===n[1]?t[0]&&1===r&&i.push(e,\"p=\",e,\"[\",o,\"+1]\"):i.push(e,\"p+=\",e,\"t\",r,\";\"),i}function a(t,e,n,r,o,i){var a=[];return\"native\"===n[1]?t[0]?a.push(e,\"p[\",o,\"]=\",i,\";\"):a.push(e,\"[\",r,\"][\",o,\"]=\",i,\";\"):\"generic\"===n[1]?a.push(e,\"d.set(\",e,\"p,\",i,\");\"):a.push(e,\"d[\",e,\"p]=\",i,\";\"),a}function s(t,e,n,r,o){var i=[];return\"native\"===n[1]?t[0]?i.push(e,\"p[\",o,\"]\"):i.push(e,\"[\",r,\"][\",o,\"]\"):\"generic\"===n[1]?i.push(e,\"d.get(\",e,\"p)\"):i.push(e,\"d[\",e,\"p]\"),i.join(\"\")}function u(t,e,n,r,u){var l=[],c=\"r\"===t[0]?[1,0]:[0,1],f=[1,0],p=[0,1],h=[\"i\",\"j\"];return l.push.apply(l,o(c,\"o\",t)),c[1]?(l.push(\"for(j=0;j<od1;++j){\"),l.push(\"for(i=0;i<od0;++i){\")):(l.push(\"for(i=0;i<od0;++i){\"),l.push(\"for(j=0;j<od1;++j){\")),l.push.apply(l,o(f,\"a\",e,\"i\")),l.push.apply(l,o(p,\"b\",n,void 0,\"j\")),l.push(\"var r=0.0;\",\"for(k=0;k<ad1;++k){\",\"r+=\",s(f,\"a\",e,\"i\",\"k\"),\"*\",s(p,\"b\",n,\"k\",\"j\"),\";\"),l.push.apply(l,i(f,\"a\",e,0,\"k\")),l.push.apply(l,i(p,\"b\",n,0,\"k\")),l.push(\"}\"),r&&l.push(\"r*=A;\"),u&&l.push(\"r+=B*\",s(c,\"o\",t,\"i\",\"j\"),\";\"),l.push.apply(l,a(c,\"o\",t,\"i\",\"j\",\"r\")),l.push.apply(l,i(c,\"o\",t,0,h[1])),l.push(\"}\"),l.push.apply(l,i(c,\"o\",t,1,h[0])),l.push(\"}\"),l}function l(t,e){var n,r=[],u=\"r\"===t[0]?[1,0]:[0,1];return e&&r.push(\"if(B!==1.0){\"),r.push.apply(r,o(u,\"o\",t)),u[0]?(r.push(\"for(i=0;i<od0;++i){for(j=0;j<od1;++j){\"),n=[\"i\",\"j\"]):(r.push(\"for(j=0;j<od1;++j){for(i=0;i<od0;++i){\"),n=[\"j\",\"i\"]),e?r.push.apply(r,a(u,\"o\",t,\"i\",\"j\",\"B*\"+s(u,\"o\",t,\"i\",\"j\"))):r.push.apply(r,a(u,\"o\",t,\"i\",\"j\",\"0\")),r.push.apply(r,i(u,\"o\",t,0,n[1])),r.push(\"}\"),r.push.apply(r,i(u,\"o\",t,1,n[0])),r.push(\"}\"),e&&r.push(\"}\"),r}function c(t,e,n,r,u){var c=[],f=[\"od0\",\"od1\",\"ad1\"],h=[1,0],d=[1,0],v=[0,1];c.push.apply(c,l(t,u));for(var m=0;m<3;++m)c.push(\"for(var i\",m,\"=\",f[m],\";i\",m,\">0;){\",\"var w\",m,\"=\",p,\";\",\"if(i\",m,\"<\",p,\"){\",\"w\",m,\"=i\",m,\";\",\"i\",m,\"=0;\",\"}else{\",\"i\",m,\"-=\",p,\";\",\"}\");c.push.apply(c,o(h,\"o\",t,\"i0\",\"i1\",\"w1\")),c.push(\"for(i=0;i<w0;++i){for(j=0;j<w1;++j){var r=0.0;\"),c.push.apply(c,o(d,\"a\",e,\"(i0+i)\",\"i2\")),c.push.apply(c,o(v,\"b\",n,\"i2\",\"(i1+j)\")),c.push(\"for(k=0;k<w2;++k){\"),c.push(\"r+=\",s(d,\"a\",e,\"(i0+i)\",\"(i2+k)\"),\"*\",s(v,\"b\",n,\"(i2+k)\",\"(i1+j)\"),\";\"),c.push.apply(c,i(d,\"a\",e,0,\"(i2+k)\")),c.push.apply(c,i(v,\"b\",n,0,\"(i2+k)\")),c.push(\"}\");var _=\"r\";return r&&(_=\"A*r\"),c.push.apply(c,a(h,\"o\",t,\"(i0+i)\",\"(i1+j)\",_+\"+\"+s(h,\"o\",t,\"(i0+i)\",\"(i1+j)\"))),c.push.apply(c,i(h,\"o\",t,0,\"(i1+j)\")),c.push(\"}\"),c.push.apply(c,i(h,\"o\",t,1,\"(i0+i)\")),c.push(\"}}}}\"),c}function f(t,e,n,o,i){var a=[\"gemm\",t[0],t[1],\"a\",e[0],e[1],\"b\",n[0],n[1],o?\"alpha\":\"\",i?\"beta\":\"\"].join(\"\"),s=[\"function \",a,\"(o,a,b,A,B){\",\"var \",r(\"o\",t),r(\"a\",e),r(\"b\",n),\"i,j,k;\"];\"r\"===e[0]&&\"c\"===n[0]?s.push.apply(s,u(t,e,n,o,i)):s.push.apply(s,c(t,e,n,o,i)),s.push(\"}return \",a);var l=new Function(s.join(\"\"));return l()}t.exports=f;var p=32},function(t,e,n){\"use strict\";function r(){var t,e,n,r;if(2===arguments.length?(e=arguments[0],r=arguments[1]):3===arguments.length&&(n=arguments[0],e=arguments[1],r=arguments[2]),!Array.isArray(r))throw new Error(\"second argument of tile must be an array of repetition counts for each dimension\");var a=e.shape.slice(0),s=a.slice(0),u=Math.max(s.length,r.length);for(t=0;t<u;t++)if(a[t]=void 0===a[t]?1:a[t],r[t]=void 0===r[t]?1:r[t],s[t]=(void 0===s[t]?1:s[t])*r[t],0===s[t])throw new Error(\"Number of tiles must be greater than zero\");n||(n=o.zeros(s,e.dtype));var l=1;for(t=0;t<r.length;t++)l*=r[t];var c=new Array(r.length);for(t=0;t<r.length;t++)c[t]=0;var f=s.slice(0);for(h=0;h<s.length;h++)f[h]=h<e.dimension?null:0;for(t=0;t<l;t++){for(h=e.dimension;h<s.length;h++)f[h]=c[h];var p=n.pick.apply(n,f);if(p=p.lo.apply(p,c),p=p.hi.apply(p,e.shape),i.assign(p,e),t===l-1)break;for(var h=u-1;h>=0&&(c[h]+=a[h],c[h]===s[h]);)c[h]=0,h--}return n}var o=n(190),i=n(3);t.exports=r},function(t,e){t.exports='// 2D convolution fragment shader - based on im2col + gemm implementation\\n// The input texture, X, is already configured as column matrix, after\\n// input_transform.glsl is run on it if necessary. The output texture is in column\\n// matrix configuration, and will need to be reshaped or transformed prior to the\\n// next layer.\\n\\n// The following code is adapted from weblas, specifically the sgemm parts.\\n// https://github.com/waylonflinn/weblas\\n//\\n// The MIT License (MIT)\\n//\\n// Copyright (c) 2015 Waylon Flinn\\n// Modified by Leon Chen, 2017\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D X;\\nuniform sampler2D W;\\nuniform sampler2D b;\\nuniform int inputCols;\\nuniform int outputCols;\\nuniform int inputColPad;\\nuniform int outputColPad;\\nuniform int relu;\\n\\n// sum of products between elements in row i (from X) x col j (from B)\\n//\\n// Calculate the dot product between the row (from X) and column (from B)\\n// identified by the passed indeces (output texture coordinate space).\\n// We loop over elements in the row and column and sum the product\\n// using the glsl `dot` function to process four elements at a time.\\n// This four element optimization requires that the matrix B be\\n// transposed before texel packing and that both matrices be padded\\n// (with zeros) to a multiple of four (4) in their shared dimension.\\nfloat dot_rowcol (float y, float x, sampler2D X, sampler2D W, int K) {\\n  float delta_t = 1. / float(K); // space (on texture) between elements\\n  float sum = 0.; // sum for this row/column pair\\n  float z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\\n\\n  for (int l = 0; l < 4096; ++l) {\\n    if (l >= K / 4) break; // stop when we finish the row/column\\n    // l is in pixel space, so we divide by four\\n\\n    // retrieve next four elements from each texture\\n    vec4 a_ik = texture2D(X, vec2(z, y));\\n    vec4 b_kj = texture2D(W, vec2(z, x));\\n\\n    // use `dot` to process four elements at a time\\n    sum += dot(a_ik, b_kj);\\n    z += (4.0 * delta_t); // (z + 0.5)*delta\\n  }\\n  return sum;\\n}\\n\\nvoid main(void) {\\n\\n  // get the implied row and column from .y and .x of passed (output)\\n  // texture coordinate. These map directly to input texture space when\\n  // the relevant dimensions are the same.\\n  float row_t = outTex.y;\\n  float col_t = outTex.x;\\n  vec4 b_v = texture2D(b, vec2(col_t, 0.5));\\n\\n  vec4 sum_v = vec4(0.0, 0.0, 0.0, 0.0);\\n  float col = (col_t * float(outputCols + outputColPad) - 2.0); // index of first element in pixel (matrix space)\\n  sum_v.r = dot_rowcol(row_t, (col + 0.5) / float(outputCols), X, W, inputCols + inputColPad);\\n  // in the padding region?\\n  if (outputColPad > 0 && (col + 4.0) > float(outputCols)) {\\n    // pad\\n    if (outputColPad < 3) {\\n      sum_v.g = dot_rowcol(row_t, (col + 1.5) / float(outputCols), X, W, inputCols + inputColPad);\\n    }\\n    if (outputColPad < 2) {\\n      sum_v.b = dot_rowcol(row_t, (col + 2.5) / float(outputCols), X, W, inputCols + inputColPad);\\n    }\\n  } else {\\n    sum_v.g = dot_rowcol(row_t, (col + 1.5) / float(outputCols), X, W, inputCols + inputColPad);\\n    sum_v.b = dot_rowcol(row_t, (col + 2.5) / float(outputCols), X, W, inputCols + inputColPad);\\n    sum_v.a = dot_rowcol(row_t, (col + 3.5) / float(outputCols), X, W, inputCols + inputColPad);\\n  }\\n\\n  if (relu == 1) {\\n    gl_FragColor = max(sum_v + b_v, 0.0);\\n  } else {\\n    gl_FragColor = sum_v + b_v;\\n  }\\n}\\n'},function(t,e){t.exports=\"// Transform input matrix X based on index mappings, indexMappingRow and indexMappingCol.\\n// This is an extension of weblas.\\n// https://github.com/waylonflinn/weblas\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D X;\\nuniform sampler2D indexMappingRow;\\nuniform sampler2D indexMappingCol;\\nuniform int inputRows;\\nuniform int inputCols;\\nuniform int outputCols;\\nuniform int inputColPad;\\nuniform int outputColPad;\\n\\nfloat select_index(vec4 v, int index) {\\n  float val = 0.0;\\n  if (index == 0) {\\n    val = v.r;\\n  } else if (index == 1) {\\n    val = v.g;\\n  } else if (index == 2) {\\n    val = v.b;\\n  } else if (index == 3) {\\n    val = v.a;\\n  }\\n  return val;\\n}\\n\\nvoid fix_pad(inout vec4 v, int pad) {\\n  v.a = 0.0;\\n  if (pad == 2) {\\n    v.b = 0.0;\\n  } else if (pad == 3) {\\n    v.b = 0.0;\\n    v.g = 0.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  // index of first element in pixel (matrix space)\\n  float col = floor(outTex.x * float(outputCols + outputColPad) - 1.5);\\n\\n  vec4 rowIndices = texture2D(indexMappingRow, vec2(outTex.x, outTex.y));\\n  vec4 colIndices = texture2D(indexMappingCol, vec2(outTex.x, outTex.y));\\n\\n  float rowIndex;\\n  float colIndex;\\n  float inputCoordX;\\n  float inputCoordY;\\n  vec2 inputCoords;\\n  int inputChannel;\\n  vec4 mappedValues = vec4(0.0, 0.0, 0.0, 0.0);\\n  for (int i = 0; i < 4; i++) {\\n    rowIndex = select_index(rowIndices, i);\\n    colIndex = select_index(colIndices, i);\\n\\n    if (rowIndex != -1.0 && colIndex != -1.0) {\\n      inputCoordX = (float(colIndex) + 0.5) / float(inputCols + inputColPad);\\n      inputCoordY = (float(rowIndex) + 0.5) / float(inputRows);\\n      inputCoords = vec2(inputCoordX, inputCoordY);\\n      inputChannel = int(mod(colIndex, 4.0));\\n      if (i == 0) {\\n        mappedValues.r = select_index(texture2D(X, inputCoords), inputChannel);\\n      } else if (i == 1) {\\n        mappedValues.g = select_index(texture2D(X, inputCoords), inputChannel);\\n      } else if (i == 2) {\\n        mappedValues.b = select_index(texture2D(X, inputCoords), inputChannel);\\n      } else if (i == 3) {\\n        mappedValues.a = select_index(texture2D(X, inputCoords), inputChannel);\\n      }\\n    }\\n\\n    // set pad values to 0.0, if in padded region of output texture\\n    if (outputColPad > 0 && col + 4.0 > float(outputCols)) {\\n      fix_pad(mappedValues, outputColPad);\\n    }\\n  }\\n\\n  gl_FragColor = mappedValues;\\n}\\n\"},function(t,e){t.exports=\"// Merge op.\\n// Modes: 'sum', 'mul', 'ave', 'max'\\n// This is an extension of weblas.\\n// https://github.com/waylonflinn/weblas\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D inputs[8]; // array length must be fixed\\nuniform int numInputs;\\nuniform int modeCode;\\nuniform int outputCols;\\nuniform int outputColPad;\\n\\nvoid fix_pad(inout vec4 v, int pad) {\\n  v.a = 0.0;\\n  if (pad == 2) {\\n    v.b = 0.0;\\n  } else if (pad == 3) {\\n    v.b = 0.0;\\n    v.g = 0.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  // index of first element in pixel (matrix space)\\n  float col = floor(outTex.x * float(outputCols + outputColPad) - 1.5);\\n\\n  vec4 mergeValues = vec4(0.0, 0.0, 0.0, 0.0);\\n  if (modeCode == 1) {\\n    // mul\\n    mergeValues = vec4(1.0, 1.0, 1.0, 1.0);\\n  } else if (modeCode == 4) {\\n    // max\\n    const float min = -1.0e+08;\\n    mergeValues = vec4(min, min, min, min);\\n  }\\n\\n  for (int i = 0; i < 8; i += 1) {\\n    if (i >= numInputs) {\\n      break;\\n    }\\n\\n    if (modeCode == 0 || modeCode == 3) {\\n      // sum\\n      // ave\\n      mergeValues = mergeValues + texture2D(inputs[i], vec2(outTex.x, outTex.y));\\n    } else if (modeCode == 1) {\\n      // mul\\n      mergeValues = mergeValues * texture2D(inputs[i], vec2(outTex.x, outTex.y));\\n    } else if (modeCode == 4) {\\n      // max\\n      mergeValues = max(mergeValues, texture2D(inputs[i], vec2(outTex.x, outTex.y)));\\n    }\\n  }\\n\\n  if (modeCode == 3) {\\n    // ave\\n    mergeValues = mergeValues / float(numInputs);\\n  }\\n\\n  // set pad values to 0.0, if in padded region of output texture\\n  if (outputColPad > 0 && col + 4.0 > float(outputCols)) {\\n    fix_pad(mergeValues, outputColPad);\\n  }\\n\\n  gl_FragColor = mergeValues;\\n}\\n\";\n},function(t,e){t.exports=\"// Merge op.\\n// Modes: 'concat'\\n// This is an extension of weblas.\\n// https://github.com/waylonflinn/weblas\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D inputs[8]; // array length must be fixed\\nuniform int numInputs;\\nuniform int inputChannelStartIndices[8];\\nuniform int outputRows;\\nuniform int outputCols;\\nuniform int outputColPad;\\n\\nvoid fix_pad(inout vec4 v, int pad) {\\n  v.a = 0.0;\\n  if (pad == 2) {\\n    v.b = 0.0;\\n  } else if (pad == 3) {\\n    v.b = 0.0;\\n    v.g = 0.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  // index of first element in pixel (matrix space)\\n  float col = floor(outTex.x * float(outputCols + outputColPad) - 0.5);\\n\\n  vec4 outValues = vec4(0.0, 0.0, 0.0, 0.0);\\n  int row = int(floor(outTex.y * float(outputRows)));\\n  float inputCoordY;\\n  for (int i = 0; i < 8; i += 1) {\\n    if (i >= numInputs) {\\n      break;\\n    }\\n\\n    if (i == numInputs - 1) {\\n      inputCoordY = (0.5 + floor(outTex.y * float(outputRows)) - float(inputChannelStartIndices[i])) / float(outputRows - inputChannelStartIndices[i]);\\n      outValues = texture2D(inputs[i], vec2(outTex.x, inputCoordY));\\n      break;\\n    } else if (row >= inputChannelStartIndices[i] && row < inputChannelStartIndices[i + 1]) {\\n      inputCoordY = (0.5 + floor(outTex.y * float(outputRows)) - float(inputChannelStartIndices[i])) / float(inputChannelStartIndices[i + 1] - inputChannelStartIndices[i]);\\n      outValues = texture2D(inputs[i], vec2(outTex.x, inputCoordY));\\n      break;\\n    }\\n  }\\n\\n  // set pad values to 0.0, if in padded region of output texture\\n  if (outputColPad > 0 && col + 4.0 > float(outputCols)) {\\n    fix_pad(outValues, outputColPad);\\n  }\\n\\n  gl_FragColor = outValues;\\n}\\n\"},function(t,e){t.exports=\"// Batch normalization op.\\n// This is an extension of weblas.\\n// https://github.com/waylonflinn/weblas\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D X;\\nuniform sampler2D gamma;\\nuniform sampler2D beta;\\nuniform sampler2D mean;\\nuniform sampler2D std;\\nuniform float epsilon;\\nuniform int outputCols;\\nuniform int outputColPad;\\n\\nvoid fix_pad(inout vec4 v, int pad) {\\n  v.a = 0.0;\\n  if (pad == 2) {\\n    v.b = 0.0;\\n  } else if (pad == 3) {\\n    v.b = 0.0;\\n    v.g = 0.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  // index of first element in pixel (matrix space)\\n  float col = floor(outTex.x * float(outputCols + outputColPad) - 1.5);\\n\\n  vec4 _x = texture2D(X, vec2(outTex.x, outTex.y));\\n  vec4 _mean = texture2D(mean, vec2(outTex.x, 0.5));\\n  vec4 _std = texture2D(std, vec2(outTex.x, 0.5));\\n  vec4 _gamma = texture2D(gamma, vec2(outTex.x, 0.5));\\n  vec4 _beta = texture2D(beta, vec2(outTex.x, 0.5));\\n  vec4 sumValues = _beta + _gamma * (_x - _mean) / sqrt(_std + epsilon);\\n\\n  // set pad values to 0.0, if in padded region of output texture\\n  if (outputColPad > 0 && col + 4.0 > float(outputCols)) {\\n    fix_pad(sumValues, outputColPad);\\n  }\\n\\n  gl_FragColor = sumValues;\\n}\\n\"},function(t,e){t.exports=\"// 2D Average Pooling op.\\n// This is an extension of weblas.\\n// https://github.com/waylonflinn/weblas\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D X;\\nuniform sampler2D poolIndexMapping;\\nuniform int inputRows;\\nuniform int channels;\\nuniform int channelsPad;\\nuniform int poolElements;\\nuniform int poolElementsPad;\\n\\nfloat select_index(vec4 v, int index) {\\n  float val = 0.0;\\n  if (index == 0) {\\n    val = v.r;\\n  } else if (index == 1) {\\n    val = v.g;\\n  } else if (index == 2) {\\n    val = v.b;\\n  } else if (index == 3) {\\n    val = v.a;\\n  }\\n  return val;\\n}\\n\\nvoid fix_pad(inout vec4 v, int pad) {\\n  v.a = 0.0;\\n  if (pad == 2) {\\n    v.b = 0.0;\\n  } else if (pad == 3) {\\n    v.b = 0.0;\\n    v.g = 0.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  // index of first element in pixel (matrix space)\\n  float col = floor(outTex.x * float(channels + channelsPad) - 1.5);\\n\\n  float poolIndexCoordX;\\n  vec4 poolIndices;\\n  int poolIndexRGBA;\\n  float poolIndex;\\n  vec4 mappedValues;\\n  float inputCoordY;\\n  vec4 currentSum = vec4(0.0, 0.0, 0.0, 0.0);\\n  int poolElementsEffective = poolElements;\\n  for (int i = 0; i < 100; i += 1) {\\n    if (i >= poolElements) {\\n      break;\\n    }\\n\\n    poolIndexCoordX = (float(i) + 0.5) / float(poolElements + poolElementsPad);\\n    poolIndices = texture2D(poolIndexMapping, vec2(poolIndexCoordX, outTex.y));\\n    poolIndexRGBA = int(mod(float(i), 4.0));\\n    poolIndex = select_index(poolIndices, poolIndexRGBA);\\n\\n    if (poolIndex != -1.0) {\\n      inputCoordY = (poolIndex + 0.5) / float(inputRows);\\n      mappedValues = texture2D(X, vec2(outTex.x, inputCoordY));\\n      currentSum = currentSum + mappedValues;\\n    } else {\\n      poolElementsEffective = poolElementsEffective - 1;\\n    }\\n  }\\n\\n  currentSum = currentSum / float(poolElementsEffective);\\n\\n  // set pad values to 0.0, if in padded region of output texture\\n  if (channelsPad > 0 && col + 4.0 > float(channels)) {\\n    fix_pad(mappedValues, channelsPad);\\n  }\\n\\n  gl_FragColor = currentSum;\\n}\\n\"},function(t,e){t.exports=\"// 2D Max Pooling op.\\n// This is an extension of weblas.\\n// https://github.com/waylonflinn/weblas\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D X;\\nuniform sampler2D poolIndexMapping;\\nuniform int inputRows;\\nuniform int channels;\\nuniform int channelsPad;\\nuniform int poolElements;\\nuniform int poolElementsPad;\\n\\nfloat select_index(vec4 v, int index) {\\n  float val = 0.0;\\n  if (index == 0) {\\n    val = v.r;\\n  } else if (index == 1) {\\n    val = v.g;\\n  } else if (index == 2) {\\n    val = v.b;\\n  } else if (index == 3) {\\n    val = v.a;\\n  }\\n  return val;\\n}\\n\\nvoid fix_pad(inout vec4 v, int pad) {\\n  v.a = 0.0;\\n  if (pad == 2) {\\n    v.b = 0.0;\\n  } else if (pad == 3) {\\n    v.b = 0.0;\\n    v.g = 0.0;\\n  }\\n}\\n\\nvoid main(void) {\\n  // index of first element in pixel (matrix space)\\n  float col = floor(outTex.x * float(channels + channelsPad) - 1.5);\\n\\n  float poolIndexCoordX;\\n  vec4 poolIndices;\\n  int poolIndexRGBA;\\n  float poolIndex;\\n  vec4 mappedValues;\\n  float inputCoordY;\\n  const float min = -1.0e+08;\\n  vec4 currentMax = vec4(min, min, min, min);\\n  for (int i = 0; i < 100; i += 1) {\\n    if (i >= poolElements) {\\n      break;\\n    }\\n\\n    poolIndexCoordX = (float(i) + 0.5) / float(poolElements + poolElementsPad);\\n    poolIndices = texture2D(poolIndexMapping, vec2(poolIndexCoordX, outTex.y));\\n    poolIndexRGBA = int(mod(float(i), 4.0));\\n    poolIndex = select_index(poolIndices, poolIndexRGBA);\\n\\n    if (poolIndex != -1.0) {\\n      inputCoordY = (poolIndex + 0.5) / float(inputRows);\\n      mappedValues = texture2D(X, vec2(outTex.x, inputCoordY));\\n    }\\n\\n    currentMax = max(currentMax, mappedValues);\\n  }\\n\\n  // set pad values to 0.0, if in padded region of output texture\\n  if (channelsPad > 0 && col + 4.0 > float(channels)) {\\n    fix_pad(mappedValues, channelsPad);\\n  }\\n\\n  gl_FragColor = currentMax;\\n}\\n\"},function(t,e){t.exports=\"// Copy texture\\n// This is an extension of weblas.\\n// https://github.com/waylonflinn/weblas\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2 outTex;\\nuniform sampler2D source;\\n\\nvoid main(void) {\\n  gl_FragColor = texture2D(source, vec2(outTex.x, outTex.y));\\n}\\n\"},function(t,e,n){(function(e,n){!function(e){\"use strict\";function r(t,e,n,r){var o=e&&e.prototype instanceof i?e:i,a=Object.create(o.prototype),s=new h(r||[]);return a._invoke=c(t,n,s),a}function o(t,e,n){try{return{type:\"normal\",arg:t.call(e,n)}}catch(t){return{type:\"throw\",arg:t}}}function i(){}function a(){}function s(){}function u(t){[\"next\",\"throw\",\"return\"].forEach(function(e){t[e]=function(t){return this._invoke(e,t)}})}function l(t){function e(n,r,i,a){var s=o(t[n],t,r);if(\"throw\"!==s.type){var u=s.arg,l=u.value;return l&&\"object\"==typeof l&&g.call(l,\"__await\")?Promise.resolve(l.__await).then(function(t){e(\"next\",t,i,a)},function(t){e(\"throw\",t,i,a)}):Promise.resolve(l).then(function(t){u.value=t,i(u)},a)}a(s.arg)}function r(t,n){function r(){return new Promise(function(r,o){e(t,n,r,o)})}return i=i?i.then(r,r):r()}\"object\"==typeof n&&n.domain&&(e=n.domain.bind(e));var i;this._invoke=r}function c(t,e,n){var r=T;return function(i,a){if(r===S)throw new Error(\"Generator is already running\");if(r===P){if(\"throw\"===i)throw a;return v()}for(;;){var s=n.delegate;if(s){if(\"return\"===i||\"throw\"===i&&s.iterator[i]===m){n.delegate=null;var u=s.iterator.return;if(u){var l=o(u,s.iterator,a);if(\"throw\"===l.type){i=\"throw\",a=l.arg;continue}}if(\"return\"===i)continue}var l=o(s.iterator[i],s.iterator,a);if(\"throw\"===l.type){n.delegate=null,i=\"throw\",a=l.arg;continue}i=\"next\",a=m;var c=l.arg;if(!c.done)return r=O,c;n[s.resultName]=c.value,n.next=s.nextLoc,n.delegate=null}if(\"next\"===i)n.sent=n._sent=a;else if(\"throw\"===i){if(r===T)throw r=P,a;n.dispatchException(a)&&(i=\"next\",a=m)}else\"return\"===i&&n.abrupt(\"return\",a);r=S;var l=o(t,e,n);if(\"normal\"===l.type){r=n.done?P:O;var c={value:l.arg,done:n.done};if(l.arg!==M)return c;n.delegate&&\"next\"===i&&(a=m)}else\"throw\"===l.type&&(r=P,i=\"throw\",a=l.arg)}}}function f(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function p(t){var e=t.completion||{};e.type=\"normal\",delete e.arg,t.completion=e}function h(t){this.tryEntries=[{tryLoc:\"root\"}],t.forEach(f,this),this.reset(!0)}function d(t){if(t){var e=t[b];if(e)return e.call(t);if(\"function\"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,r=function e(){for(;++n<t.length;)if(g.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=m,e.done=!0,e};return r.next=r}}return{next:v}}function v(){return{value:m,done:!0}}var m,_=Object.prototype,g=_.hasOwnProperty,y=\"function\"==typeof Symbol?Symbol:{},b=y.iterator||\"@@iterator\",w=y.toStringTag||\"@@toStringTag\",x=\"object\"==typeof t,E=e.regeneratorRuntime;if(E)return void(x&&(t.exports=E));E=e.regeneratorRuntime=x?t.exports:{},E.wrap=r;var T=\"suspendedStart\",O=\"suspendedYield\",S=\"executing\",P=\"completed\",M={},j={};j[b]=function(){return this};var A=Object.getPrototypeOf,C=A&&A(A(d([])));C&&C!==_&&g.call(C,b)&&(j=C);var k=s.prototype=i.prototype=Object.create(j);a.prototype=k.constructor=s,s.constructor=a,s[w]=a.displayName=\"GeneratorFunction\",E.isGeneratorFunction=function(t){var e=\"function\"==typeof t&&t.constructor;return!!e&&(e===a||\"GeneratorFunction\"===(e.displayName||e.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,s):(t.__proto__=s,w in t||(t[w]=\"GeneratorFunction\")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},u(l.prototype),E.AsyncIterator=l,E.async=function(t,e,n,o){var i=new l(r(t,e,n,o));return E.isGeneratorFunction(e)?i:i.next().then(function(t){return t.done?t.value:i.next()})},u(k),k[w]=\"Generator\",k.toString=function(){return\"[object Generator]\"},E.keys=function(t){var e=[];for(var n in t)e.push(n);return e.reverse(),function n(){for(;e.length;){var r=e.pop();if(r in t)return n.value=r,n.done=!1,n}return n.done=!0,n}},E.values=d,h.prototype={constructor:h,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=m,this.done=!1,this.delegate=null,this.tryEntries.forEach(p),!t)for(var e in this)\"t\"===e.charAt(0)&&g.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=m)},stop:function(){this.done=!0;var t=this.tryEntries[0],e=t.completion;if(\"throw\"===e.type)throw e.arg;return this.rval},dispatchException:function(t){function e(e,r){return i.type=\"throw\",i.arg=t,n.next=e,!!r}if(this.done)throw t;for(var n=this,r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r],i=o.completion;if(\"root\"===o.tryLoc)return e(\"end\");if(o.tryLoc<=this.prev){var a=g.call(o,\"catchLoc\"),s=g.call(o,\"finallyLoc\");if(a&&s){if(this.prev<o.catchLoc)return e(o.catchLoc,!0);if(this.prev<o.finallyLoc)return e(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return e(o.catchLoc,!0)}else{if(!s)throw new Error(\"try statement without catch or finally\");if(this.prev<o.finallyLoc)return e(o.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc<=this.prev&&g.call(r,\"finallyLoc\")&&this.prev<r.finallyLoc){var o=r;break}}o&&(\"break\"===t||\"continue\"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=t,i.arg=e,o?this.next=o.finallyLoc:this.complete(i),M},complete:function(t,e){if(\"throw\"===t.type)throw t.arg;\"break\"===t.type||\"continue\"===t.type?this.next=t.arg:\"return\"===t.type?(this.rval=t.arg,this.next=\"end\"):\"normal\"===t.type&&e&&(this.next=e)},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.finallyLoc===t)return this.complete(n.completion,n.afterLoc),p(n),M}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.tryLoc===t){var r=n.completion;if(\"throw\"===r.type){var o=r.arg;p(n)}return o}}throw new Error(\"illegal catch attempt\")},delegateYield:function(t,e,n){return this.delegate={iterator:d(t),resultName:e,nextLoc:n},M}}}(\"object\"==typeof e?e:\"object\"==typeof window?window:\"object\"==typeof self?self:this)}).call(e,n(38),n(131))},function(t,e,n){(function(t,e){!function(t,n){\"use strict\";function r(t){\"function\"!=typeof t&&(t=new Function(\"\"+t));for(var e=new Array(arguments.length-1),n=0;n<e.length;n++)e[n]=arguments[n+1];var r={callback:t,args:e};return v[d]=r,h(d),d++}function o(t){delete v[t]}function i(t){var e=t.callback,r=t.args;switch(r.length){case 0:e();break;case 1:e(r[0]);break;case 2:e(r[0],r[1]);break;case 3:e(r[0],r[1],r[2]);break;default:e.apply(n,r)}}function a(t){if(m)setTimeout(a,0,t);else{var e=v[t];if(e){m=!0;try{i(e)}finally{o(t),m=!1}}}}function s(){h=function(t){e.nextTick(function(){a(t)})}}function u(){if(t.postMessage&&!t.importScripts){var e=!0,n=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage(\"\",\"*\"),t.onmessage=n,e}}function l(){var e=\"setImmediate$\"+Math.random()+\"$\",n=function(n){n.source===t&&\"string\"==typeof n.data&&0===n.data.indexOf(e)&&a(+n.data.slice(e.length))};t.addEventListener?t.addEventListener(\"message\",n,!1):t.attachEvent(\"onmessage\",n),h=function(n){t.postMessage(e+n,\"*\")}}function c(){var t=new MessageChannel;t.port1.onmessage=function(t){var e=t.data;a(e)},h=function(e){t.port2.postMessage(e)}}function f(){var t=_.documentElement;h=function(e){var n=_.createElement(\"script\");n.onreadystatechange=function(){a(e),n.onreadystatechange=null,t.removeChild(n),n=null},t.appendChild(n)}}function p(){h=function(t){setTimeout(a,0,t)}}if(!t.setImmediate){var h,d=1,v={},m=!1,_=t.document,g=Object.getPrototypeOf&&Object.getPrototypeOf(t);g=g&&g.setTimeout?g:t,\"[object process]\"==={}.toString.call(t.process)?s():u()?l():t.MessageChannel?c():_&&\"onreadystatechange\"in _.createElement(\"script\")?f():p(),g.setImmediate=r,g.clearImmediate=o}}(\"undefined\"==typeof self?\"undefined\"==typeof t?this:t:self)}).call(e,n(38),n(131))},function(t,e,n){function r(t,e){this._id=t,this._clearFn=e}var o=Function.prototype.apply;e.setTimeout=function(){return new r(o.call(setTimeout,window,arguments),clearTimeout)},e.setInterval=function(){return new r(o.call(setInterval,window,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close()},r.prototype.unref=r.prototype.ref=function(){},r.prototype.close=function(){this._clearFn.call(window,this._id)},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout(function(){t._onTimeout&&t._onTimeout()},e))},n(620),e.setImmediate=setImmediate,e.clearImmediate=clearImmediate},function(t,e,n){\"use strict\";(function(t,r){function o(t){if(t){var e=t.length||t.byteLength,n=g.log2(e);x[n].push(t)}}function i(t){o(t.buffer)}function a(t){var t=g.nextPow2(t),e=g.log2(t),n=x[e];return n.length>0?n.pop():new ArrayBuffer(t)}function s(t){return new Uint8Array(a(t),0,t)}function u(t){return new Uint16Array(a(2*t),0,t)}function l(t){return new Uint32Array(a(4*t),0,t)}function c(t){return new Int8Array(a(t),0,t)}function f(t){return new Int16Array(a(2*t),0,t)}function p(t){return new Int32Array(a(4*t),0,t)}function h(t){return new Float32Array(a(4*t),0,t)}function d(t){return new Float64Array(a(8*t),0,t)}function v(t){return b?new Uint8ClampedArray(a(t),0,t):s(t)}function m(t){return new DataView(a(t),0,t)}function _(t){t=g.nextPow2(t);var e=g.log2(t),n=E[e];return n.length>0?n.pop():new r(t)}var g=n(263),y=n(167);t.__TYPEDARRAY_POOL||(t.__TYPEDARRAY_POOL={UINT8:y([32,0]),UINT16:y([32,0]),UINT32:y([32,0]),INT8:y([32,0]),INT16:y([32,0]),INT32:y([32,0]),FLOAT:y([32,0]),DOUBLE:y([32,0]),DATA:y([32,0]),UINT8C:y([32,0]),BUFFER:y([32,0])});var b=\"undefined\"!=typeof Uint8ClampedArray,w=t.__TYPEDARRAY_POOL;w.UINT8C||(w.UINT8C=y([32,0])),w.BUFFER||(w.BUFFER=y([32,0]));var x=w.DATA,E=w.BUFFER;e.free=function(t){if(r.isBuffer(t))E[g.log2(t.length)].push(t);else{if(\"[object ArrayBuffer]\"!==Object.prototype.toString.call(t)&&(t=t.buffer),!t)return;var e=t.length||t.byteLength,n=0|g.log2(e);x[n].push(t)}},e.freeUint8=e.freeUint16=e.freeUint32=e.freeInt8=e.freeInt16=e.freeInt32=e.freeFloat32=e.freeFloat=e.freeFloat64=e.freeDouble=e.freeUint8Clamped=e.freeDataView=i,e.freeArrayBuffer=o,e.freeBuffer=function(t){E[g.log2(t.length)].push(t)},e.malloc=function(t,e){if(void 0===e||\"arraybuffer\"===e)return a(t);switch(e){case\"uint8\":return s(t);case\"uint16\":return u(t);case\"uint32\":return l(t);case\"int8\":return c(t);case\"int16\":return f(t);case\"int32\":return p(t);case\"float\":case\"float32\":return h(t);case\"double\":case\"float64\":return d(t);case\"uint8_clamped\":return v(t);case\"buffer\":return _(t);case\"data\":case\"dataview\":return m(t);default:return null}return null},e.mallocArrayBuffer=a,e.mallocUint8=s,e.mallocUint16=u,e.mallocUint32=l,e.mallocInt8=c,e.mallocInt16=f,e.mallocInt32=p,e.mallocFloat32=e.mallocFloat=h,e.mallocFloat64=e.mallocDouble=d,e.mallocUint8Clamped=v,e.mallocDataView=m,e.mallocBuffer=_,e.clearCache=function(){for(var t=0;t<32;++t)w.UINT8[t].length=0,w.UINT16[t].length=0,w.UINT32[t].length=0,w.INT8[t].length=0,w.INT16[t].length=0,w.INT32[t].length=0,w.FLOAT[t].length=0,w.DOUBLE[t].length=0,w.UINT8C[t].length=0,x[t].length=0,E[t].length=0}}).call(e,n(38),n(265).Buffer)},function(t,e){function n(t,e){if(!e||\"object\"!=typeof e)return t;for(var n=Object.keys(e),r=n.length;r--;)t[n[r]]=e[n[r]];return t}t.exports=n},function(t,e,n){var r,r;!function(e){t.exports=e()}(function(){return function t(e,n,o){function i(s,u){if(!n[s]){if(!e[s]){var l=\"function\"==typeof r&&r;if(!u&&l)return r(s,!0);if(a)return a(s,!0);var c=new Error(\"Cannot find module '\"+s+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}var f=n[s]={exports:{}};e[s][0].call(f.exports,function(t){var n=e[s][1][t];return i(n?n:t)},f,f.exports,t,e,n,o)}return n[s].exports}for(var a=\"function\"==typeof r&&r,s=0;s<o.length;s++)i(o[s]);return i}({1:[function(t,e,n){function r(t){function e(e,n,r,o,i,a,s,u){if(null!=u&&u.length!=n)throw new Error(\"Only vector C with length matching rows in A is currently supported.\");var l,c=i,f=u;l=v(r,n,a);var p=t.createDataTexture(e,r,c),h=t.createDataTexture(n,r,l),d=null;null!=f&&(d=t.createDataTexture(1,n,f));var _=t.createOutputTexture(e,n);return m.calculate(e,n,r,o,p,h,s,d,_),rawBuffer=t.readData(e,n),t.context.deleteTexture(p),t.context.deleteTexture(h),null!=d&&t.context.deleteTexture(d),t.context.deleteTexture(_),new Float32Array(rawBuffer)}function n(e,n,o,i){var a,s,u=o;r(i)?s=i:(s=new Float32Array(e),s.fill(i));var l=t.createDataTexture(1,e,u),c=t.createDataTexture(1,e,s),f=t.createOutputTexture(1,e);return _.calculate(e,n,l,c,f),a=t.readData(1,e),t.context.deleteTexture(l),t.context.deleteTexture(c),t.context.deleteTexture(f),new Float32Array(a)}function r(t){return\"[object Float32Array]\"===Object.prototype.toString.call(t)}function o(e,n,r,o,i){var a,s=i,u=t.createDataTexture(e,n,s),l=t.createOutputTexture(e,n);return g.calculate(e,n,r,o,u,l),a=t.readData(e,n),t.context.deleteTexture(u),t.context.deleteTexture(l),new Float32Array(a)}function f(e,n,r,o,i){var a,s=i,u=t.createDataTexture(e,n,s),l=t.createOutputTexture(e,n);return g.calculate(e,n,1/o,-1*r/o,u,l),a=t.readData(e,n),t.context.deleteTexture(u),t.context.deleteTexture(l),new Float32Array(a)}function p(e,n,r,o,i,a){var s=t.createDataTexture(e,n*r,a),u=Math.floor((n-o)/i)+1,l=Math.floor((e-o)/i)+1,c=t.createOutputTexture(l,u*r);return y.calculate(e,n,r,o,i,s,c),rawBuffer=t.readData(l,u*r),t.context.deleteTexture(s),t.context.deleteTexture(c),new Float32Array(rawBuffer)}function h(e,n,r,o,i){r=null!=r?r:Number.MIN_VALUE,o=null!=o?o:Number.MAX_VALUE;var a,s=i,u=t.createDataTexture(e,n,s),l=t.createOutputTexture(e,n);return b.calculate(e,n,r,o,u,l),a=t.readData(e,n),t.context.deleteTexture(u),t.context.deleteTexture(l),new Float32Array(a)}function d(t,e,n){var r,o,i=[];n?(i[1]=t.length,i[0]=t[0].length):(i[0]=t.length,i[1]=t[0].length),o=i[1],e=e||Float32Array,r=new e(i[0]*i[1]);for(var a=0;a<i[0];++a)for(var s=0;s<i[1];++s)n?r[a*o+s]=t[s][a]:r[a*o+s]=t[a][s];return r}function v(t,e,n){for(var r=new n.constructor(t*e),o=0;t>o;o++)for(var i=0;e>i;i++)r[i*t+o]=n[o*e+i];return r}var m=new a(t),_=new s(t),g=new u(t),y=new l(t),b=new c(t);return{saxpy:n,sscal:o,sgemm:e,sstd:f,sdwns:p,sclmp:h,pipeline:i,gpu:{gl:t,sgemm:i.sgemmcalculator.calculate.bind(i.sgemmcalculator),sscal:i.sscalcalculator.calculate.bind(i.sscalcalculator),sclmp:i.sclmpcalculator.calculate.bind(i.sclmpcalculator),sdwns:i.sdwnscalculator.calculate.bind(i.sdwnscalculator),encode:t.encode.bind(t)},util:{fromArray:d,transpose:v}}}var o=t(\"./lib/globals\"),i=t(\"./lib/pipeline\"),a=t(\"./lib/sgemmcalculator\"),s=t(\"./lib/saxpycalculator\"),u=t(\"./lib/sscalcalculator\"),l=t(\"./lib/sdwnscalculator\"),c=t(\"./lib/sclmpcalculator\");o.gl?e.exports=r(o.gl):e.exports=null},{\"./lib/globals\":2,\"./lib/pipeline\":3,\"./lib/saxpycalculator\":4,\"./lib/sclmpcalculator\":5,\"./lib/sdwnscalculator\":6,\"./lib/sgemmcalculator\":7,\"./lib/sscalcalculator\":9}],2:[function(t,e,n){var r,o=t(\"./webgl\");try{r=new o}catch(t){r=null,console.log(\"No support for WebGL!\")}e.exports={gl:r}},{\"./webgl\":11}],3:[function(t,e,n){function r(t){function e(t,e,n){var r=n.shape[0],o=n.shape[1],i=new f([r,o],null);return v.calculate(r,o,t,e,n.texture,i.texture),i}function n(t,e,n,r,o){if(n.shape[1]!==e.shape[1])throw new Error(\"Second dimension must be of same size for input Tensors (second Tensor is transposed).\");var i,a=e.shape[0],s=n.shape[0],u=e.shape[1];i=o?o.texture:null;var l=new f([a,s],null);return h.calculate(a,s,u,t,e.texture,n.texture,r,i,l.texture),l}function r(t,e,n,r){if(r.shape[1]%t!==0)throw new Error(\"Second dimension of tensor must be a multiple of channels\");var o=r.shape[0],i=r.shape[1]/t,a=Math.floor((o-e)/n)+1,s=Math.floor((i-e)/n)+1,u=new f([a,s*t],null);return m.calculate(o,i,t,e,n,r.texture,u.texture),u}function o(t,e,n){t=null!=t?t:Number.MIN_VALUE,e=null!=e?e:Number.MAX_VALUE;var r=n.shape[0],o=n.shape[1],i=new f([r,o],null);return _.calculate(r,o,t,e,n.texture,i.texture),i}function p(t,e,n,r,o){if(o.shape[1]%t!==0)throw new Error(\"Second dimension of tensor must be a multiple of channels\");var i,a,s=o.shape[0],u=o.shape[1]/t;r?(i=Math.ceil((u+2*r-e)/n)+1,a=Math.ceil((s+2*r-e)/n)+1):(r=0,i=Math.ceil((u-e)/n)+1,a=Math.ceil((s-e)/n)+1);var l=e*e*t,c=a*i,p=l,h=new f([c,p],null);return g.calculate(s,u,t,c,p,i,e,n,r,o.texture,h.texture),h}var h=new i(t,!1),d=new a(t,!1),v=new s(t,!1),m=new u(t,!1),_=new l(t,!1),g=new c(t,!1);return{Tensor:f,sscal:e,sgemm:n,sdwns:r,sclmp:o,slokn:p,sgemmcalculator:h,saxpycalculator:d,sscalcalculator:v,sdwnscalculator:m,sclmpcalculator:_,slokncalculator:g}}var o=t(\"./globals\"),i=t(\"./sgemmcalculator\"),a=t(\"./saxpycalculator\"),s=t(\"./sscalcalculator\"),u=t(\"./sdwnscalculator\"),l=t(\"./sclmpcalculator\"),c=t(\"./slokncalculator\"),f=t(\"./tensor\");o.gl?e.exports=r(o.gl):e.exports=null},{\"./globals\":2,\"./saxpycalculator\":4,\"./sclmpcalculator\":5,\"./sdwnscalculator\":6,\"./sgemmcalculator\":7,\"./slokncalculator\":8,\"./sscalcalculator\":9,\"./tensor\":10}],4:[function(t,e,n){function r(t,e){this.webgl=t,this.standalone=e||!0;var n=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D X;\\t\\t// texture with data from padded A\\nuniform sampler2D Y;\\t\\t// texture with data from padded transpose of B\\nuniform int       N;\\nuniform float     a; \\t\\t// coefficient to multiplication\\n\\n// Render float to bytes according to IEEE 754 Floating Point\\nvec4 encode_float_1540259130(float val) {\\n\\n\\t// TODO: correctly handle denormal numbers\\n\\t// http://www.2ality.com/2012/04/number-encoding.html\\n\\tfloat a = abs(val);                           // encode absolute value + sign\\n\\tfloat exp = floor(log2(a));                 // number of powers of 2\\n\\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\\n\\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\\n\\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n\\tfloat mant3 = mod(mant,256.);               // third 8 bits\\n\\n\\thighp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n\\thighp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n\\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\\n\\thighp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n\\thighp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n\\treturn vec4(m3,m2,m1,e);\\n}\\n\\n// select an element from a vector based on index\\nfloat select_index_1604150559(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n \\tfloat row = outTex.y;\\n\\tfloat col = outTex.x;\\n\\n\\t// direct usage of col requires output be padded exactly like input\\n\\tvec4 x = texture2D( X, vec2(col, row));\\n\\tvec4 y = texture2D( Y, vec2(col, row));\\n\\tvec4 sum_v = (a * x) + y;\\n\\tint channel = int(mod(col * float(N), 4.0 ));\\n\\tfloat sum = select_index_1604150559(sum_v, channel);\\n\\n\\tif (sum == 0.) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n \\t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\tgl_FragColor = encode_float_1540259130(sum);\\n}\\n\";this.standalone?this.program=this.webgl.createProgram(n):this.program=this.webgl.createProgram(p)}t(\"./webgl\");e.exports=r,r.TEXTURE_UNIFORM_NAME_0=\"X\",r.TEXTURE_UNIFORM_NAME_1=\"Y\",r.LENGTH_UNIFORM_NAME=\"N\",r.COEFFICIENT_UNIFORM_NAME=\"a\",r.prototype.calculate=function(t,e,n,o,i){var a=this.webgl.context;this.webgl.selectProgram(this.program),this.bindInputTexture(n,a.TEXTURE0,r.TEXTURE_UNIFORM_NAME_0),this.bindInputTexture(o,a.TEXTURE1,r.TEXTURE_UNIFORM_NAME_1);var s=this.webgl.getPad(t);this.bindUniforms(t+s,e),this.webgl.bindOutputTexture(1,t+s,i),a.drawElements(a.TRIANGLES,6,a.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(a.TEXTURE0),this.webgl.unbindInputTexture(a.TEXTURE1)},r.prototype.bindInputTexture=function(t,e,n){var r=this.webgl.context,o=this.program;r.activeTexture(e),r.bindTexture(r.TEXTURE_2D,t);var i=r.getUniformLocation(o,n);r.uniform1i(i,e-r.TEXTURE0)},r.prototype.bindUniforms=function(t,e){var n=this.webgl.context,o=n.getUniformLocation(this.program,r.LENGTH_UNIFORM_NAME),i=n.getUniformLocation(this.program,r.COEFFICIENT_UNIFORM_NAME);n.uniform1i(o,t),n.uniform1f(i,e)}},{\"./webgl\":11}],5:[function(t,e,n){function r(t,e){this.webgl=t,this.standalone=null==e||e;var n=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D X;\\t\\t// texture with data from padded A\\nuniform int       N;\\t\\t// number of columns\\nuniform int       pad;\\t\\t// additional columns to nearest multiple of four\\nuniform float     a; \\t\\t// lower bound\\nuniform float     b; \\t\\t// upper bound\\n\\n// Render float to bytes according to IEEE 754 Floating Point\\nvec4 encode_float_1604150559(float val) {\\n\\n\\t// TODO: correctly handle denormal numbers\\n\\t// http://www.2ality.com/2012/04/number-encoding.html\\n\\tfloat a = abs(val);                           // encode absolute value + sign\\n\\tfloat exp = floor(log2(a));                 // number of powers of 2\\n\\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\\n\\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\\n\\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n\\tfloat mant3 = mod(mant,256.);               // third 8 bits\\n\\n\\thighp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n\\thighp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n\\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\\n\\thighp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n\\thighp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n\\treturn vec4(m3,m2,m1,e);\\n}\\n\\n// select an element from a vector based on index\\nfloat select_index_1540259130(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row = outTex.y;\\n\\tfloat col = outTex.x;\\n\\n\\t// return 0.0 if in padded region of output texture\\n\\tif(col * float(N + pad) > float(N) ) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n\\t// direct usage of col requires output be padded exactly like input\\n\\tvec4 x = texture2D( X, vec2(col, row));\\n\\tvec4 val = clamp(x, a, b);\\n\\n\\t// select and output channel (standalone version only)\\n\\tint channel = int(mod(col * float(N + pad), 4.0));\\n\\tfloat sum = select_index_1540259130(val, channel);\\n\\n\\tif (sum == 0.) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n\\t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\tgl_FragColor = encode_float_1604150559(sum);\\n}\\n\",r=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D X;\\t\\t// texture with data from padded A\\nuniform int       N;\\t\\t// number of columns\\nuniform int       pad;\\t\\t// additional columns to nearest multiple of four\\nuniform float     a; \\t\\t// lower bound\\nuniform float     b; \\t\\t// upper bound\\n\\n// set pad values to 0.0, if in padded region of output texture\\nvoid fix_pad_1540259130(inout vec4 v, int pad){\\n\\tv.a = 0.0;\\n\\tif(pad == 2){\\n\\t\\tv.b = 0.0;\\n\\t} else if(pad == 3){\\n\\t\\tv.b = 0.0;\\n\\t\\tv.g = 0.0;\\n\\t}\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\\n\\n\\t// direct usage of col requires output be padded exactly like input\\n\\tvec4 x = texture2D( X, vec2(col_t, row_t));\\n\\tvec4 val_v = clamp(x, a, b);\\n\\n\\t// is last element in pixel past row length?\\n\\tif(pad > 0 && (col + 4.0) > float(N) ) {\\n\\t\\t// fix elements in padded region\\n\\t\\tfix_pad_1540259130(val_v, pad);\\n\\t}\\n\\n\\tgl_FragColor = val_v;\\n}\\n\";\nthis.standalone?this.program=this.webgl.createProgram(n):this.program=this.webgl.createProgram(r)}t(\"./webgl\");e.exports=r,r.TEXTURE_UNIFORM_NAME_0=\"X\",r.LENGTH_UNIFORM_NAME=\"N\",r.LOWER_UNIFORM_NAME=\"a\",r.UPPER_UNIFORM_NAME=\"b\",r.prototype.calculate=function(t,e,n,o,i,a){n=null!=n?n:Number.MIN_VALUE,o=null!=o?o:Number.MAX_VALUE;var s=this.webgl.context;this.webgl.selectProgram(this.program),this.bindInputTexture(i,s.TEXTURE0,r.TEXTURE_UNIFORM_NAME_0);var u=this.webgl.getPad(e);this.bindUniforms(e,u,n,o),this.standalone?this.webgl.bindOutputTexture(t,e+u,a):this.webgl.bindOutputTexture(t,(e+u)/4,a),s.drawElements(s.TRIANGLES,6,s.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(s.TEXTURE0)},r.prototype.bindInputTexture=function(t,e,n){var r=this.webgl.context,o=this.program;r.activeTexture(e),r.bindTexture(r.TEXTURE_2D,t);var i=r.getUniformLocation(o,n);r.uniform1i(i,e-r.TEXTURE0)},r.prototype.bindUniforms=function(t,e,n,o){var i=this.webgl.context,a=i.getUniformLocation(this.program,r.LENGTH_UNIFORM_NAME),s=i.getUniformLocation(this.program,r.UPPER_UNIFORM_NAME),u=i.getUniformLocation(this.program,r.LOWER_UNIFORM_NAME),l=i.getUniformLocation(this.program,\"pad\");i.uniform1i(a,t),i.uniform1i(l,e),i.uniform1f(u,n),i.uniform1f(s,o)}},{\"./webgl\":11}],6:[function(t,e,n){function r(t,e){this.webgl=t,this.standalone=null==e||e;var n=\"// TODO: unroll loop for stride == factor and small values (2, 3)\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;  // texture coords of row/column to calculate\\nuniform sampler2D X;       // texture with data from padded A\\nuniform int       factor;  // width of image patch\\nuniform float     stride;  // width between image patches\\nuniform float     C;       // number of channels\\nuniform float     M;\\nuniform float     N;\\nuniform float     N_out;\\nuniform float     M_out;\\n\\n// Render float to bytes according to IEEE 754 Floating Point\\nvec4 encode_float_1540259130(float val) {\\n\\n\\t// TODO: correctly handle denormal numbers\\n\\t// http://www.2ality.com/2012/04/number-encoding.html\\n\\tfloat a = abs(val);                           // encode absolute value + sign\\n\\tfloat exp = floor(log2(a));                 // number of powers of 2\\n\\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\\n\\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\\n\\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n\\tfloat mant3 = mod(mant,256.);               // third 8 bits\\n\\n\\thighp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n\\thighp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n\\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\\n\\thighp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n\\thighp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n\\treturn vec4(m3,m2,m1,e);\\n}\\n\\n// select an element from a vector based on index\\nfloat select_index_1604150559(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate and translate to output pixel space.\\n\\tfloat row = floor(outTex.y * M_out);   // row on output texture (matrix space)\\n\\tfloat col = floor(outTex.x * N_out); // column on output texture (matrix space)\\n\\tfloat vcol = floor(col / C);   // virtual column on output texture (matrix space)\\n\\tfloat vchannel = floor(mod(col, C)); // virtual channel on output texture\\n\\n\\tconst float min = -1.0e+08;\\n\\tvec4 currentMax = vec4(min, min, min, min);\\n\\n\\tfloat deltaY = 1.0/M;\\n\\tfloat deltaX = 1.0/N;\\n\\tfloat y = ((row * stride) + 0.5)*deltaY; // texture position of input row\\n\\tfloat x;\\n\\tfloat z = vchannel * deltaX;\\n\\tfor (int i = 0; i < 100; i += 1) {\\n\\t\\tif (i >= factor) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tx = ((vcol * stride * C) + 0.5) * deltaX; // texture position of input column\\n\\n\\t\\tfor (int j = 0; j < 100; j += 1) {\\n\\t\\t\\tif (j >= factor) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec2 coords = vec2(x + z, y);\\n\\t\\t\\tvec4 x_v = texture2D(X, coords);\\n\\t\\t\\tcurrentMax = max(currentMax, x_v);\\n\\n\\t\\t\\tx += (deltaX * C);\\n\\t\\t}\\n\\t\\ty += deltaY;\\n\\t}\\n\\tint chan = int(mod(outTex.x * N_out, 4.0 ));\\n\\tfloat val = select_index_1604150559(currentMax, int(chan));\\n\\tif (val == 0.) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n\\tgl_FragColor = encode_float_1540259130(val);\\n}\\n\";p=\"// TODO: unroll loop for stride == factor and small values (2, 3)\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;  // texture coords of row/column to calculate\\nuniform sampler2D X;       // texture with data from padded A\\nuniform int       factor;  // width of image patch\\nuniform float     stride;  // width between image patches\\nuniform float     C;       // number of channels\\nuniform float     M;\\nuniform float     N;\\nuniform float     N_out;\\nuniform float     M_out;\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate and translate to output pixel space.\\n\\tfloat row = floor(outTex.y * M_out);   // row on output texture (pixel space)\\n\\tfloat col = floor(outTex.x * N_out); // column on output texture (matrix space)\\n\\tfloat vcol = floor(col / C);   // virtual column on output texture (matrix space)\\n\\tfloat vchannel = floor(mod(col, C)); // virtual channel on output texture\\n\\n\\tconst float min = -1.0e+08;\\n\\tvec4 currentMax = vec4(min, min, min, min);\\n\\n\\tfloat deltaY = 1.0/M;\\n\\tfloat deltaX = 1.0/N;\\n\\tfloat y = ((row * stride) + 0.5)*deltaY; // texture position of input row\\n\\tfloat x;\\n\\tfloat z = vchannel * deltaX;\\n\\tfor (int i = 0; i < 100; i += 1) {\\n\\t\\tif (i >= factor) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tx = ((vcol * stride * C) + 0.5) * deltaX; // texture position of input column\\n\\n\\t\\tfor (int j = 0; j < 100; j += 1) {\\n\\t\\t\\tif (j >= factor) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec2 coords = vec2(x + z, y);\\n\\t\\t\\tvec4 x_v = texture2D(X, coords);\\n\\t\\t\\tcurrentMax = max(currentMax, x_v);\\n\\n\\t\\t\\tx += (deltaX * C);\\n\\t\\t}\\n\\t\\ty += deltaY;\\n\\t}\\n\\n\\tgl_FragColor = currentMax;\\n}\\n\",this.standalone?this.program=this.webgl.createProgram(n):this.program=this.webgl.createProgram(p)}var o=t(\"./webgl\");e.exports=r,r.TEXTURE_UNIFORM_NAME_0=\"X\",r.INPUT_ROW_COUNT_UNIFORM_NAME=\"M\",r.INPUT_COLUMN_COUNT_UNIFORM_NAME=\"N\",r.OUTPUT_ROW_COUNT_UNIFORM_NAME=\"M_out\",r.OUTPUT_COLUMN_COUNT_UNIFORM_NAME=\"N_out\",r.FACTOR_UNIFORM_NAME=\"factor\",r.STRIDE_UNIFORM_NAME=\"stride\",r.CHANNEL_COUNT_UNIFORM_NAME=\"C\",r.prototype.calculate=function(t,e,n,i,a,s,u){if(n%o.COMPONENTS_PER_TEXEL!=0)throw new Error(\"Channel count must be a multiple of \"+o.COMPONENTS_PER_TEXEL);var l=this.webgl.context,c=(Math.floor((e-i)/a)+1)*n,f=Math.floor((t-i)/a)+1;this.webgl.selectProgram(this.program),this.bindInputTexture(s,l.TEXTURE0,r.TEXTURE_UNIFORM_NAME_0),this.bindUniforms(t,e*n,f,c,i,a,n),this.standalone?this.webgl.bindOutputTexture(f,c,u):this.webgl.bindOutputTexture(f,c/o.COMPONENTS_PER_TEXEL,u),l.drawElements(l.TRIANGLES,6,l.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(l.TEXTURE0)},r.prototype.bindInputTexture=function(t,e,n){var r=this.webgl.context,o=this.program;r.activeTexture(e),r.bindTexture(r.TEXTURE_2D,t);var i=r.getUniformLocation(o,n);r.uniform1i(i,e-r.TEXTURE0)},r.prototype.bindUniforms=function(t,e,n,o,i,a,s){var u=this.webgl.context,l=u.getUniformLocation(this.program,r.INPUT_ROW_COUNT_UNIFORM_NAME),c=u.getUniformLocation(this.program,r.INPUT_COLUMN_COUNT_UNIFORM_NAME),f=u.getUniformLocation(this.program,r.OUTPUT_ROW_COUNT_UNIFORM_NAME),p=u.getUniformLocation(this.program,r.OUTPUT_COLUMN_COUNT_UNIFORM_NAME),h=u.getUniformLocation(this.program,r.FACTOR_UNIFORM_NAME),d=u.getUniformLocation(this.program,r.STRIDE_UNIFORM_NAME),v=u.getUniformLocation(this.program,r.CHANNEL_COUNT_UNIFORM_NAME);u.uniform1f(l,t),u.uniform1f(c,e),u.uniform1f(f,n),u.uniform1f(p,o),u.uniform1i(h,i),u.uniform1f(d,a),u.uniform1f(v,s)}},{\"./webgl\":11}],7:[function(t,e,n){function r(t,e){this.webgl=t,this.standalone=null==e||e;var n=\"// fragment shader that calculates the matrix product and renders each\\n// element to the bytes representing a 32-bit IEEE754 floating point in\\n// the output RGBA canvas.\\n// readPixel is used to read the bytes.\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform sampler2D B_t;\\t\\t// texture with data from padded transpose of B\\nuniform int       K;\\t\\t// number of elements in shared dimension\\nuniform int       N;\\t\\t// number of columns in output\\nuniform int       pad;\\t\\t//\\nuniform float     alpha; \\t// coefficient to multiplication\\n\\n// sum of products between elements in row i (from A) x col j (from B)\\n\\n// Calculate the dot product between the row (from A) and column (from B)\\n// identified by the passed indeces (output texture coordinate space).\\n// We loop over elements in the row and column and sum the product\\n// using the glsl `dot` function to process four elements at a time.\\n// This four element optimization requires that the matrix B be\\n// transposed before texel packing and that both matrices be padded\\n// (with zeros) to a multiple of four (4) in their shared dimension.\\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\\n\\tfloat delta_t = 1./float(K);// space (on texture) between elements\\n\\tfloat sum = 0.;\\t\\t\\t// sum for this row/column pair\\n\\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\\n\\n\\tfor (int l=0 ; l<4096 ; ++l) {\\n\\t\\tif(l >= K / 4) break;    // stop when we finish the row/column\\n\\t\\t// l is in pixel space, so we divide by four\\n\\n\\t\\t// retrieve next four elements from each texture\\n\\t\\tvec4 a_ik = texture2D(  A, vec2(z, y));\\n\\t\\tvec4 b_kj = texture2D(B_t, vec2(z, x));\\n\\n\\t// use `dot` to process four elements at a time\\n\\t\\tsum +=  dot(a_ik, b_kj);\\n\\t\\tz += (4.0 * delta_t);      // (z + 0.5)*delta\\n\\t}\\n\\treturn sum;\\n}\\n\\n// Render float to bytes according to IEEE 754 Floating Point\\nvec4 encode_float_1604150559(float val) {\\n\\n\\t// TODO: correctly handle denormal numbers\\n\\t// http://www.2ality.com/2012/04/number-encoding.html\\n\\tfloat a = abs(val);                           // encode absolute value + sign\\n\\tfloat exp = floor(log2(a));                 // number of powers of 2\\n\\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\\n\\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\\n\\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n\\tfloat mant3 = mod(mant,256.);               // third 8 bits\\n\\n\\thighp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n\\thighp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n\\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\\n\\thighp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n\\thighp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n\\treturn vec4(m3,m2,m1,e);\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\n\\t// sum row x col for the passed pixel\\n\\tfloat sum = alpha * dot_rowcol_1540259130(row_t, col_t * float(N + pad)/float(N), A, B_t, K);\\n\\n\\tif (sum == 0.) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n\\t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\tgl_FragColor = encode_float_1604150559(sum);\\n}\\n\",r=\"// fragment shader that calculates the matrix product (with additive 'C' term)\\n// and renders each element to the bytes representing a 32-bit IEEE754 floating\\n// point in the output RGBA canvas.\\n// readPixel is used to read the bytes.\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform sampler2D B_t;\\t\\t// texture with data from padded transpose of B\\nuniform sampler2D C;\\t\\t// texture with data from C\\nuniform int       K;\\t\\t// number of elements in shared dimension\\nuniform int       N;\\t\\t// number of columns in output\\nuniform int       pad;\\t\\t//\\nuniform float     alpha; \\t// coefficient to multiplication\\nuniform float     beta; \\t// coefficient to additive term\\n\\n// sum of products between elements in row i (from A) x col j (from B)\\n\\n// Calculate the dot product between the row (from A) and column (from B)\\n// identified by the passed indeces (output texture coordinate space).\\n// We loop over elements in the row and column and sum the product\\n// using the glsl `dot` function to process four elements at a time.\\n// This four element optimization requires that the matrix B be\\n// transposed before texel packing and that both matrices be padded\\n// (with zeros) to a multiple of four (4) in their shared dimension.\\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\\n\\tfloat delta_t = 1./float(K);// space (on texture) between elements\\n\\tfloat sum = 0.;\\t\\t\\t// sum for this row/column pair\\n\\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\\n\\n\\tfor (int l=0 ; l<4096 ; ++l) {\\n\\t\\tif(l >= K / 4) break;    // stop when we finish the row/column\\n\\t\\t// l is in pixel space, so we divide by four\\n\\n\\t\\t// retrieve next four elements from each texture\\n\\t\\tvec4 a_ik = texture2D(  A, vec2(z, y));\\n\\t\\tvec4 b_kj = texture2D(B_t, vec2(z, x));\\n\\n\\t// use `dot` to process four elements at a time\\n\\t\\tsum +=  dot(a_ik, b_kj);\\n\\t\\tz += (4.0 * delta_t);      // (z + 0.5)*delta\\n\\t}\\n\\treturn sum;\\n}\\n\\n// Render float to bytes according to IEEE 754 Floating Point\\nvec4 encode_float_1117569599(float val) {\\n\\n\\t// TODO: correctly handle denormal numbers\\n\\t// http://www.2ality.com/2012/04/number-encoding.html\\n\\tfloat a = abs(val);                           // encode absolute value + sign\\n\\tfloat exp = floor(log2(a));                 // number of powers of 2\\n\\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\\n\\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\\n\\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n\\tfloat mant3 = mod(mant,256.);               // third 8 bits\\n\\n\\thighp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n\\thighp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n\\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\\n\\thighp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n\\thighp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n\\treturn vec4(m3,m2,m1,e);\\n}\\n\\n// select an element from a vector based on index\\nfloat select_index_1604150559(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\tvec4 c_vec = texture2D(C, vec2(col_t, 0.5));\\n\\n\\t// should be -0.5, but that subtly breaks at zero\\n\\tfloat col = col_t * float(N + pad); // index of first element in pixel (matrix space)\\n\\tint channel = int(mod(col, 4.0 ));\\n\\tfloat c = select_index_1604150559(c_vec, channel);\\n\\n\\t// sum row x col for the passed pixel\\n\\tfloat sum = alpha * dot_rowcol_1540259130(row_t, col_t * float(N + pad)/float(N), A, B_t, K);\\n\\tsum += beta * c;\\n\\n\\tif (sum == 0.) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n\\t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\tgl_FragColor = encode_float_1117569599(sum);\\n}\\n\",o=\"// fragment shader that calculates the matrix product and writes each\\n// element to a pixel component in a floating point texture.\\n// the output RGBA canvas.\\n// readPixel is used to read the bytes.\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform sampler2D B_t;\\t\\t// texture with data from padded transpose of B\\nuniform int       K;\\t\\t// number of elements in shared dimension\\nuniform int       N;\\t\\t// number of columns in output\\nuniform int       pad;\\t\\t//\\nuniform float     alpha; \\t// coefficient to multiplication\\n\\n// sum of products between elements in row i (from A) x col j (from B)\\n\\n// Calculate the dot product between the row (from A) and column (from B)\\n// identified by the passed indeces (output texture coordinate space).\\n// We loop over elements in the row and column and sum the product\\n// using the glsl `dot` function to process four elements at a time.\\n// This four element optimization requires that the matrix B be\\n// transposed before texel packing and that both matrices be padded\\n// (with zeros) to a multiple of four (4) in their shared dimension.\\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\\n\\tfloat delta_t = 1./float(K);// space (on texture) between elements\\n\\tfloat sum = 0.;\\t\\t\\t// sum for this row/column pair\\n\\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\\n\\n\\tfor (int l=0 ; l<4096 ; ++l) {\\n\\t\\tif(l >= K / 4) break;    // stop when we finish the row/column\\n\\t\\t// l is in pixel space, so we divide by four\\n\\n\\t\\t// retrieve next four elements from each texture\\n\\t\\tvec4 a_ik = texture2D(  A, vec2(z, y));\\n\\t\\tvec4 b_kj = texture2D(B_t, vec2(z, x));\\n\\n\\t// use `dot` to process four elements at a time\\n\\t\\tsum +=  dot(a_ik, b_kj);\\n\\t\\tz += (4.0 * delta_t);      // (z + 0.5)*delta\\n\\t}\\n\\treturn sum;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\n\\tvec4 sum_v = vec4(0.0, 0.0, 0.0, 0.0);\\n\\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\\n\\tsum_v.r = alpha * dot_rowcol_1540259130(row_t, (col + 0.5)/float(N), A, B_t, K);\\n\\t// is last element in pixel past row length?\\n\\tif(pad > 0 && (col + 4.0) > float(N) ) {\\n\\t\\t// compute elements in padded region\\n\\t\\tif(pad < 3){\\n\\t\\t\\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\\n\\t\\t}\\n\\t\\tif(pad < 2){\\n\\t\\t\\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\\n\\t\\t}\\n\\t} else {\\n\\t\\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\\n\\t\\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\\n\\t\\tsum_v.a = alpha * dot_rowcol_1540259130(row_t, (col + 3.5)/float(N), A, B_t, K);\\n\\t}\\n\\n\\tgl_FragColor = sum_v;\\n}\\n\",i=\"// fragment shader that calculates the matrix product and writes each\\n// element to a pixel component in a floating point texture.\\n// the output RGBA canvas.\\n// readPixel is used to read the bytes.\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform sampler2D B_t;\\t\\t// texture with data from padded transpose of B\\nuniform sampler2D C;\\t\\t// texture with data from C\\nuniform int       K;\\t\\t// number of elements in shared dimension\\nuniform int       N;\\t\\t// number of columns in output\\nuniform int       pad;\\t\\t//\\nuniform float     alpha; \\t// coefficient to multiplication\\nuniform float     beta; \\t// coefficient to addition\\n\\n// sum of products between elements in row i (from A) x col j (from B)\\n\\n// Calculate the dot product between the row (from A) and column (from B)\\n// identified by the passed indeces (output texture coordinate space).\\n// We loop over elements in the row and column and sum the product\\n// using the glsl `dot` function to process four elements at a time.\\n// This four element optimization requires that the matrix B be\\n// transposed before texel packing and that both matrices be padded\\n// (with zeros) to a multiple of four (4) in their shared dimension.\\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\\n\\tfloat delta_t = 1./float(K);// space (on texture) between elements\\n\\tfloat sum = 0.;\\t\\t\\t// sum for this row/column pair\\n\\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\\n\\n\\tfor (int l=0 ; l<4096 ; ++l) {\\n\\t\\tif(l >= K / 4) break;    // stop when we finish the row/column\\n\\t\\t// l is in pixel space, so we divide by four\\n\\n\\t\\t// retrieve next four elements from each texture\\n\\t\\tvec4 a_ik = texture2D(  A, vec2(z, y));\\n\\t\\tvec4 b_kj = texture2D(B_t, vec2(z, x));\\n\\n\\t// use `dot` to process four elements at a time\\n\\t\\tsum +=  dot(a_ik, b_kj);\\n\\t\\tz += (4.0 * delta_t);      // (z + 0.5)*delta\\n\\t}\\n\\treturn sum;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\tvec4 c_v = texture2D(C, vec2(col_t, 0.5));\\n\\n\\tvec4 sum_v = vec4(0.0, 0.0, 0.0, 0.0);\\n\\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\\n\\tsum_v.r = alpha * dot_rowcol_1540259130(row_t, (col + 0.5)/float(N), A, B_t, K);\\n\\t// in the padding region?\\n\\tif(pad > 0 && (col + 4.0) > float(N) ) {\\n\\t\\t// pad\\n\\t\\tif(pad < 3){\\n\\t\\t\\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\\n\\t\\t}\\n\\t\\tif(pad < 2){\\n\\t\\t\\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\\n\\t\\t}\\n\\t} else {\\n\\t\\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\\n\\t\\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\\n\\t\\tsum_v.a = alpha * dot_rowcol_1540259130(row_t, (col + 3.5)/float(N), A, B_t, K);\\n\\t}\\n\\n\\tgl_FragColor = sum_v + beta*c_v;\\n}\\n\";this.standalone?(this.program_=this.webgl.createProgram(n),this.program_c=this.webgl.createProgram(r)):(this.program_=this.webgl.createProgram(o),this.program_c=this.webgl.createProgram(i))}t(\"./webgl\");e.exports=r,r.TEXTURE_UNIFORM_NAME_0=\"A\",r.TEXTURE_UNIFORM_NAME_1=\"B_t\",r.TEXTURE_UNIFORM_NAME_2=\"C\",r.SHARED_LENGTH_UNIFORM_NAME=\"K\",r.COLUMN_COUNT_UNIFORM_NAME=\"N\",r.PAD_UNIFORM_NAME=\"pad\",r.ALPHA_UNIFORM_NAME=\"alpha\",r.BETA_UNIFORM_NAME=\"beta\",r.prototype.calculate=function(t,e,n,o,i,a,s,u,l){var c=this.webgl.context;null!=u?this.program=this.program_c:(s=null,this.program=this.program_),this.webgl.selectProgram(this.program),this.bindInputTexture(i,c.TEXTURE0,r.TEXTURE_UNIFORM_NAME_0),this.bindInputTexture(a,c.TEXTURE1,r.TEXTURE_UNIFORM_NAME_1),null!=u&&this.bindInputTexture(u,c.TEXTURE2,r.TEXTURE_UNIFORM_NAME_2);var f=this.webgl.getPad(n),p=this.webgl.getPad(e);this.bindUniforms(e,n+f,p,o,s),this.standalone?this.webgl.bindOutputTexture(t,e+p,l):this.webgl.bindOutputTexture(t,(e+p)/4,l),c.drawElements(c.TRIANGLES,6,c.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(c.TEXTURE0),this.webgl.unbindInputTexture(c.TEXTURE1),this.webgl.unbindInputTexture(c.TEXTURE2)},r.prototype.bindInputTexture=function(t,e,n){var r=this.webgl.context,o=this.program;r.activeTexture(e),r.bindTexture(r.TEXTURE_2D,t);var i=r.getUniformLocation(o,n);r.uniform1i(i,e-r.TEXTURE0)},r.prototype.bindUniforms=function(t,e,n,o,i){var a=this.webgl.context,s=a.getUniformLocation(this.program,r.SHARED_LENGTH_UNIFORM_NAME),u=a.getUniformLocation(this.program,r.ALPHA_UNIFORM_NAME),l=a.getUniformLocation(this.program,r.BETA_UNIFORM_NAME),c=a.getUniformLocation(this.program,r.COLUMN_COUNT_UNIFORM_NAME),f=f=a.getUniformLocation(this.program,r.PAD_UNIFORM_NAME);a.uniform1f(l,i),a.uniform1i(c,t),a.uniform1i(f,n),a.uniform1i(s,e),a.uniform1f(u,o)}},{\"./webgl\":11}],8:[function(t,e,n){function r(t,e){this.webgl=t,this.standalone=null==e||e;var n=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;  // texture coords of row/column to calculate\\nuniform sampler2D X;       // texture with data from padded A\\nuniform float     factor;  // width of image patch\\nuniform float     stride;  // width between image patches\\nuniform float     margin;\\nuniform float     N_p;     // patches across\\nuniform float     M;\\nuniform float     N;\\nuniform float     pad;\\nuniform float     M_in;\\nuniform float     N_in;\\nuniform float     C;       // number of channels in input\\nuniform float     pad_in;\\n\\n// select an element from a vector based on index\\nfloat select_index_1540259130(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\n// translate a linear index into x, y coordinates for a matrix\\nvec2 linear_index_coords_1604150559(float linear_index, float row_length){\\n\\tvec2 coords;\\n\\n\\tcoords.x = floor(mod(linear_index + 0.5, row_length)); // column\\n\\tcoords.y = floor((linear_index + 0.5) / row_length); // row\\n\\n\\treturn coords;\\n}\\n\\n// set pad values to 0.0, if in padded region of output texture\\nvoid fix_pad_1117569599(inout vec4 v, int pad){\\n\\tv.a = 0.0;\\n\\tif(pad == 2){\\n\\t\\tv.b = 0.0;\\n\\t} else if(pad == 3){\\n\\t\\tv.b = 0.0;\\n\\t\\tv.g = 0.0;\\n\\t}\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\n\\t// row corresponds to patch\\n\\tfloat row = floor(row_t * M) + 0.5;\\n\\t// column corresponds to placement in patch\\n\\tfloat col_0 = floor(col_t * (N + pad) - 1.5); // index of first element in output pixel (matrix space)\\n\\n\\t// N_p = patches across\\n\\tfloat col_patch = floor(mod(row, N_p)); // column index in grid of patches\\n\\tfloat row_patch = floor(row / N_p); // row index in grid of patches\\n\\tfloat col_in_0 = (col_patch * stride - margin) * C; // input column index of left element in patch\\n\\tfloat row_in_0 = row_patch * stride - margin; // input row index of top element in patch\\n\\n\\tvec4 pixel_in;\\n\\tvec4 result = vec4(0.0, 0.0, 0.0, 0.0);\\n\\tvec2 coords = linear_index_coords_1604150559(col_0, factor * C); // coords inside patch\\n\\tvec2 ncoords;\\n\\tint channel_in = int(mod(col_in_0 + coords.x, 4.0));\\n\\tvec2 scale_in = vec2(1.0/(N_in + pad_in), 1.0/M_in); // scale from matrix to input texture coords\\n\\tvec2 offset_in = vec2(col_in_0 + 2.0 - float(channel_in), row_in_0 + 0.5); // offset into patch (and pixel)\\n\\n\\tconst vec2 pixel_scale = vec2(1.0/4.0, 1.0); // scale from matrix to pixel coords\\n\\n\\tpixel_in = texture2D(X, (coords + offset_in) * scale_in);\\n\\n\\t// go through channels for current output pixel\\n\\tfor(int channel = 0; channel < 4; channel++){\\n\\n\\t\\t// are we on a new input pixel?\\n\\t\\tncoords = linear_index_coords_1604150559(col_0 + float(channel), factor * C);\\n\\n\\t\\t// are we in the margin or outside the input texture?\\n\\t\\tif((col_in_0 + ncoords.x + 0.5 < 0.0) || (row_in_0 + ncoords.y + 0.5 < 0.0) ||\\n\\t\\t   (col_in_0 + ncoords.x + 0.5) > (N_in) || row_in_0 + ncoords.y + 0.5 > M_in){\\n\\t\\t\\t// yes, create a virtual pixel\\n\\t\\t\\tpixel_in = vec4(0.0, 0.0, 0.0, 0.0);\\n\\t\\t} else if(floor(ncoords * pixel_scale) != floor(coords * pixel_scale)){\\n\\t\\t\\t// no, get the get the next real pixel\\n\\t\\t\\tcoords = ncoords;\\n\\t\\t\\toffset_in.x += float(channel_in);\\n\\t\\t\\tchannel_in = 0;\\n\\t\\t\\tpixel_in = texture2D(X, (coords + offset_in) * scale_in);\\n\\t\\t}\\n\\n\\t\\tif(channel == 0){\\n\\t\\t\\tresult.r = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t} else if(channel == 1){\\n\\t\\t\\tresult.g = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t} else if(channel == 2){\\n\\t\\t\\tresult.b = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t} else {\\n\\t\\t\\tresult.a = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t}\\n\\n\\t\\tchannel_in++;\\n\\t\\toffset_in.x -= 1.0;\\n\\t}\\n\\n\\t// fix padded region\\n\\tif(pad > 0.0 && col_0 + 4.0 > N ) {\\n\\t\\tfix_pad_1117569599(result, int(pad));\\n\\t}\\n\\n\\t//gl_FragColor = vec4(row_in_0, col_in_0, channel_in, N_p);\\n\\tgl_FragColor = result;\\n}\\n\";this.standalone?this.program=this.webgl.createProgram(s):this.program=this.webgl.createProgram(n)}t(\"./webgl\");e.exports=r,r.TEXTURE_UNIFORM_NAME_0=\"X\",r.STRIDE_UNIFORM_NAME=\"stride\",r.KERNEL_WIDTH_UNIFORM_NAME=\"factor\",r.prototype.calculate=function(t,e,n,o,i,a,s,u,l,c,f){var p=this.webgl.context,h=this.webgl.getPad(e*n),d=this.webgl.getPad(i);this.webgl.selectProgram(this.program),this.bindInputTexture(c,p.TEXTURE0,r.TEXTURE_UNIFORM_NAME_0),this.bindUniforms(o,i,d,t,e*n,n,h,a,s,u,l),this.standalone?this.webgl.bindOutputTexture(o,i+d,f):this.webgl.bindOutputTexture(o,(i+d)/4,f),p.drawElements(p.TRIANGLES,6,p.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(p.TEXTURE0)},r.prototype.bindInputTexture=function(t,e,n){var r=this.webgl.context,o=this.program;r.activeTexture(e),r.bindTexture(r.TEXTURE_2D,t);var i=r.getUniformLocation(o,n);r.uniform1i(i,e-r.TEXTURE0)},r.prototype.bindUniforms=function(t,e,n,o,i,a,s,u,l,c,f){var p=this.webgl.context,h=p.getUniformLocation(this.program,\"M\"),d=p.getUniformLocation(this.program,\"N\"),v=p.getUniformLocation(this.program,\"C\"),m=p.getUniformLocation(this.program,\"M_in\"),_=p.getUniformLocation(this.program,\"N_in\"),g=p.getUniformLocation(this.program,r.STRIDE_UNIFORM_NAME),y=p.getUniformLocation(this.program,r.KERNEL_WIDTH_UNIFORM_NAME),b=p.getUniformLocation(this.program,\"pad\"),w=p.getUniformLocation(this.program,\"pad_in\"),x=p.getUniformLocation(this.program,\"N_p\");margin_gl=p.getUniformLocation(this.program,\"margin\"),p.uniform1f(h,t),p.uniform1f(d,e),p.uniform1f(b,n),p.uniform1f(m,o),p.uniform1f(_,i),p.uniform1f(v,a),p.uniform1f(w,s),p.uniform1f(x,u),p.uniform1f(y,l),p.uniform1f(g,c),p.uniform1f(margin_gl,f)}},{\"./webgl\":11}],9:[function(t,e,n){function r(t,e){this.webgl=t,this.standalone=null==e||e;var n=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D X;\\t\\t// texture with data from padded X\\nuniform int       N;\\t\\t// number of columns\\nuniform int       pad;\\t\\t// additional columns to nearest multiple of four\\nuniform float     b; \\t\\t// additive term\\nuniform float     a; \\t\\t// multiplicative term\\n\\n// Render float to bytes according to IEEE 754 Floating Point\\nvec4 encode_float_1540259130(float val) {\\n\\n\\t// TODO: correctly handle denormal numbers\\n\\t// http://www.2ality.com/2012/04/number-encoding.html\\n\\tfloat a = abs(val);                           // encode absolute value + sign\\n\\tfloat exp = floor(log2(a));                 // number of powers of 2\\n\\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\\n\\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\\n\\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n\\tfloat mant3 = mod(mant,256.);               // third 8 bits\\n\\n\\thighp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n\\thighp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n\\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\\n\\thighp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n\\thighp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n\\treturn vec4(m3,m2,m1,e);\\n}\\n\\n// select an element from a vector based on index\\nfloat select_index_1604150559(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n \\tfloat row = outTex.y;\\n\\tfloat col = outTex.x;\\n\\n\\t// direct usage of col requires output be padded exactly like input\\n\\tvec4 x = texture2D( X, vec2(col, row));\\n\\tvec4 sum_v = (a * x) + b;\\n\\tint channel = int(mod(col * float(N + pad), 4.0 ));\\n\\tfloat sum = select_index_1604150559(sum_v, channel);\\n\\n\\tif (sum == 0.) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n \\t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\tgl_FragColor = encode_float_1540259130(sum);\\n}\\n\",r=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D X;\\t\\t// texture with data from padded X\\nuniform int       N;\\t\\t// number of columns\\nuniform int       pad;\\t\\t// additional columns to nearest multiple of four\\nuniform float     b; \\t\\t// additive term\\nuniform float     a; \\t\\t// multiplicative term\\n\\n// set pad values to 0.0, if in padded region of output texture\\nvoid fix_pad_1540259130(inout vec4 v, int pad){\\n\\tv.a = 0.0;\\n\\tif(pad == 2){\\n\\t\\tv.b = 0.0;\\n\\t} else if(pad == 3){\\n\\t\\tv.b = 0.0;\\n\\t\\tv.g = 0.0;\\n\\t}\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\\n\\n\\t// direct usage of col requires output be padded exactly like input\\n\\tvec4 x = texture2D( X, vec2(col_t, row_t));\\n\\tvec4 sum_v = (a * x) + b;\\n\\n\\t// fix padded region\\n\\tif(pad > 0 && col + 4.0 > float(N) ) {\\n\\t\\tfix_pad_1540259130(sum_v, pad);\\n\\t}\\n\\n\\tgl_FragColor = sum_v;\\n}\\n\";\nthis.standalone?this.program=this.webgl.createProgram(n):this.program=this.webgl.createProgram(r)}t(\"./webgl\");e.exports=r,r.TEXTURE_UNIFORM_NAME_0=\"X\",r.LENGTH_UNIFORM_NAME=\"N\",r.ADD_UNIFORM_NAME=\"b\",r.MUL_UNIFORM_NAME=\"a\",r.prototype.calculate=function(t,e,n,o,i,a){var s=this.webgl.context,u=this.webgl.getPad(e);this.webgl.selectProgram(this.program),this.bindInputTexture(i,s.TEXTURE0,r.TEXTURE_UNIFORM_NAME_0),this.bindUniforms(e,u,n,o),this.standalone?this.webgl.bindOutputTexture(t,e+u,a):this.webgl.bindOutputTexture(t,(e+u)/4,a),s.drawElements(s.TRIANGLES,6,s.UNSIGNED_SHORT,0),this.webgl.unbindInputTexture(s.TEXTURE0)},r.prototype.bindInputTexture=function(t,e,n){var r=this.webgl.context,o=this.program;r.activeTexture(e),r.bindTexture(r.TEXTURE_2D,t);var i=r.getUniformLocation(o,n);r.uniform1i(i,e-r.TEXTURE0)},r.prototype.bindUniforms=function(t,e,n,o){var i=this.webgl.context,a=i.getUniformLocation(this.program,r.LENGTH_UNIFORM_NAME),s=i.getUniformLocation(this.program,r.ADD_UNIFORM_NAME),u=i.getUniformLocation(this.program,r.MUL_UNIFORM_NAME),l=i.getUniformLocation(this.program,\"pad\");i.uniform1i(a,t),i.uniform1i(l,e),i.uniform1f(u,n),i.uniform1f(s,o)}},{\"./webgl\":11}],10:[function(t,e,n){function r(t,e){if(2!=t.length)throw new Error(\"Only Tensor of order two (matrix) is supported right now.\");var n=t[0],r=t[1];this.texture=i.createDataTexture(n,r,e),this.shape=[n,r],this[Symbol.toStringTag]=\"Tensor\"}var o=t(\"./globals\"),i=o.gl;e.exports=r,r.prototype.delete=function(){i.context.deleteTexture(this.texture),this.texture=null,this.shape=null},r.prototype.transfer=function(t){var e,n,r=this.shape[0],o=this.shape[1];return e=i.createOutputTexture(r,o),i.encode(r,o,this.texture,e),n=new Float32Array(i.readData(r,o)),i.context.deleteTexture(e),t||this.delete(),n},r.prototype.reshape=function(t,e){var n=this.shape[0],o=this.shape[1],a=t[0],s=t[1],u=new r(t,null);return i.reshape(n,o,a,s,this.texture,u.texture),e||this.delete(),u},r.prototype.transpose=function(t){var e=this.shape[0],n=this.shape[1],o=new r([n,e],null);return i.transpose(e,n,this.texture,o.texture),t||this.delete(),o},r.prototype.split=function(t,e){var n=this.shape[0],o=this.shape[1];if(o%2!==0)throw new Error(\"row count must be multiple of two.\");var a=new r([n,o/2],null),s=new r([n,o/2],null);return i.submatrix(o,n,o/2,t,0,this.texture,a.texture),i.submatrix(o,n,o/2,t,1,this.texture,s.texture),e||this.delete(),[a,s]},r.combine=function(t,e,n,o){var a=t.shape[0],s=t.shape[1];if(t.shape[1]!==e.shape[1]||t.shape[0]!==e.shape[0])throw new Error(\"row and column counts must be equal.\");if(n%4!==0)throw new Error(\"stride must be a multiple of four\");var u=new r([a,2*s],null);return i.combine(a,s,n,t.texture,e.texture,u.texture),o||(t.delete(),e.delete()),u}},{\"./globals\":2}],11:[function(t,e,n){function r(t){var e,n;if(t=t||{},\"undefined\"==typeof t.canvas?this.canvas=document.createElement(\"canvas\"):this.canvas=t.canvas,e={premultipliedAlpha:!1,preserveDrawingBuffer:!1},this.context=this.canvas.getContext(\"experimental-webgl\",e),null==this.context)throw new Error(\"No support for Webgl.\");try{n=this.context.getExtension(\"OES_texture_float\")}catch(t){}null==n?(console.log(\"No support for OES_texture_float extension!\"),this.hasFloat=!1):this.hasFloat=!0;var r=this.context.getShaderPrecisionFormat(this.context.FRAGMENT_SHADER,this.context.HIGH_FLOAT);this.hasHighPrecision=0!=r.precision,this.hasHighPrecision&&(this.highp=r);var o=\"// vertex shader for a single quad\\n// work is performed in the operation specific texture shader\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 pos;\\nattribute vec2 tex;\\nvarying vec2   outTex;\\nvoid main(void)\\n{\\n\\t// just pass the position and texture coords\\n\\tgl_Position = vec4(pos, 1.0);\\n\\toutTex = tex;\\n}\\n\";this.vertexShader=this.context.createShader(this.context.VERTEX_SHADER),this.context.shaderSource(this.vertexShader,o),this.context.compileShader(this.vertexShader);var i=\"\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform int       N;\\t\\t// number of columns in output\\nuniform int       pad;\\t\\t//\\n\\n// Render float to bytes according to IEEE 754 Floating Point\\nvec4 encode_float_1540259130(float val) {\\n\\n\\t// TODO: correctly handle denormal numbers\\n\\t// http://www.2ality.com/2012/04/number-encoding.html\\n\\tfloat a = abs(val);                           // encode absolute value + sign\\n\\tfloat exp = floor(log2(a));                 // number of powers of 2\\n\\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\\n\\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\\n\\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n\\tfloat mant3 = mod(mant,256.);               // third 8 bits\\n\\n\\thighp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n\\thighp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n\\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\\n\\thighp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n\\thighp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n\\treturn vec4(m3,m2,m1,e);\\n}\\n\\n// select an element from a vector based on index\\nfloat select_index_1604150559(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\n\\tvec4 val_v = texture2D(A, vec2(col_t * float(N)/float(N + pad), row_t));\\n\\tint channel = int(mod(col_t * float(N), 4.0 ));\\n\\tfloat val = select_index_1604150559(val_v, channel);\\n\\n\\tif (val == 0.) {\\n\\t\\tgl_FragColor = vec4(0.,0.,0.,0.);\\n\\t\\treturn;\\n\\t}\\n\\n \\t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\tgl_FragColor = encode_float_1540259130(val);\\n}\\n\",a=\"\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform int       M;\\t\\t// number of rows in output\\nuniform int       N;\\t\\t// number of columns in output\\nuniform int       mpad;\\t\\t//\\nuniform int       npad;\\t\\t//\\n\\n// select an element from a vector based on index\\nfloat select_index_1540259130(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\tfloat col = (col_t * float(N + npad) - 2.0); // index of first element in pixel (matrix space)\\n\\n\\t// get rows in the input, each containing one element in the output\\n\\tvec4 row_1 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 0.5)/float(N)));\\n\\tvec4 row_2 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 1.5)/float(N)));\\n\\tvec4 row_3 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 2.5)/float(N)));\\n\\tvec4 row_4 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 3.5)/float(N)));\\n\\n\\t// package into output vector\\n\\tint channel = int(mod(row_t * float(M), 4.0 ));\\n\\n\\tvec4 col_v = vec4(0.0, 0.0, 0.0, 0.0); // vec4 representing four elements in a column in the input\\n\\n\\t// extract relevent element from each input row\\n\\tcol_v.r = select_index_1540259130(row_1, channel);\\n\\tif(npad > 0 && (col + 4.0) > float(N) ) {\\n\\t\\t// compute elements in padded region\\n\\t\\tif(npad < 3){\\n\\t\\t\\tcol_v.g = select_index_1540259130(row_2, channel);\\n\\t\\t}\\n\\t\\tif(npad < 2){\\n\\t\\t\\tcol_v.b = select_index_1540259130(row_3, channel);\\n\\t\\t}\\n\\t} else {\\n\\t\\tcol_v.g = select_index_1540259130(row_2, channel);\\n\\t\\tcol_v.b = select_index_1540259130(row_3, channel);\\n\\t\\tcol_v.a = select_index_1540259130(row_4, channel);\\n\\t}\\n\\n\\tgl_FragColor = col_v;\\n}\\n\",s=\"\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform float     M;\\t\\t// number of rows in output\\nuniform float     N;\\t\\t// number of columns in output\\nuniform float     pad;\\t\\t// column padding in output\\nuniform float     M_in;\\t\\t// number of rows in input\\nuniform float     N_in;\\t\\t// number of columns in input\\nuniform float     pad_in;\\t// column padding in input\\n\\n/* number of input pixels\\n   origin index (channel) for each\\n   termination index (channel) for each\\n   destination origin index (channel) for each\\n */\\n// select an element from a vector based on index\\nfloat select_index_1540259130(vec4 v, int index){\\n\\tfloat val;\\n\\tif (index == 0) {\\n\\t\\tval = v.r;\\n\\t} else if(index == 1) {\\n\\t\\tval = v.g;\\n\\t} else if(index == 2) {\\n\\t\\tval = v.b;\\n\\t} else if(index == 3){\\n\\t\\tval = v.a;\\n\\t} else {\\n\\t\\t// should never be here\\n\\t\\tval = 0.0;\\n\\t}\\n\\n\\treturn val;\\n}\\n\\n// set pad values to 0.0, if in padded region of output texture\\nvoid fix_pad_1604150559(inout vec4 v, int pad){\\n\\tv.a = 0.0;\\n\\tif(pad == 2){\\n\\t\\tv.b = 0.0;\\n\\t} else if(pad == 3){\\n\\t\\tv.b = 0.0;\\n\\t\\tv.g = 0.0;\\n\\t}\\n}\\n\\n// translate a linear index into x, y coordinates for a matrix\\nvec2 linear_index_coords_1117569599(float linear_index, float row_length){\\n\\tvec2 coords;\\n\\n\\tcoords.x = floor(mod(linear_index + 0.5, row_length)); // column\\n\\tcoords.y = floor((linear_index + 0.5) / row_length); // row\\n\\n\\treturn coords;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\n\\tfloat row = floor(row_t * M);\\n\\tfloat col_0 = (col_t * (N + pad) - 2.0); // index of first element in pixel (matrix space)\\n\\t//float col_0 = floor(col_t * (N + pad)/4.0)*4.0; // index of first element in pixel (matrix space)\\n\\tfloat lin_index_0 = row * N + col_0; // linearized index of first element in pixel in output\\n\\n\\tvec4 pixel_in = vec4(0.0, 0.0, 0.0, 0.0);\\n\\tvec4 result = vec4(0.0, 0.0, 0.0, 0.0);\\n\\tvec2 coords = linear_index_coords_1117569599(lin_index_0, N_in);\\n\\tvec2 ncoords;\\n\\tint channel_in = int(mod(coords.x, 4.0));\\n\\n\\tvec2 scale_in = vec2(1.0/(N_in + pad_in), 1.0/M_in); // scale from matrix to input texture coords\\n\\tvec2 offset_in = vec2(0.5, 0.5); // move away from edge of pixel\\n\\tconst vec2 pixel_scale = vec2(1.0/4.0, 1.0); // scale from matrix to pixel coords\\n\\n\\tpixel_in = texture2D(A, (coords + offset_in) * scale_in);\\n\\n\\t// go through channels for current output pixel\\n\\tfor(int channel = 0; channel < 4; channel++){\\n\\n\\t\\t// are we on a new input pixel?\\n\\t\\tncoords = linear_index_coords_1117569599(lin_index_0 + float(channel), N_in);\\n\\t\\tif(floor(ncoords * pixel_scale) != floor(coords * pixel_scale)){\\n\\t\\t\\tcoords = ncoords;\\n\\t\\t\\tpixel_in = texture2D(A, (coords + offset_in) * scale_in);\\n\\t\\t\\tchannel_in = 0;\\n\\t\\t}\\n\\n\\t\\tif(channel == 0){\\n\\t\\t\\tresult.r = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t} else if(channel == 1){\\n\\t\\t\\tresult.g = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t} else if(channel == 2){\\n\\t\\t\\tresult.b = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t} else {\\n\\t\\t\\tresult.a = select_index_1540259130(pixel_in, channel_in);\\n\\t\\t}\\n\\n\\t\\tchannel_in++;\\n\\t}\\n\\n\\t// are we in the padded (output) region?\\n\\tif(pad > 0.0 && col_0 + 3.5 > N ) {\\n\\t\\tfix_pad_1604150559(result, int(pad));\\n\\t}\\n\\n\\tgl_FragColor = result;\\n}\\n\",u=\"\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform float     M;\\t\\t// number of rows in output\\nuniform float     N;\\t\\t// number of columns in output\\nuniform float     M_in;\\t\\t// number of rows in input\\nuniform float     N_in;\\t\\t// number of columns in input\\n\\n// translate a linear index into x, y coordinates for a matrix\\nvec2 linear_index_coords_1540259130(float linear_index, float row_length){\\n\\tvec2 coords;\\n\\n\\tcoords.x = floor(mod(linear_index + 0.5, row_length)); // column\\n\\tcoords.y = floor((linear_index + 0.5) / row_length); // row\\n\\n\\treturn coords;\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\n\\tfloat row = floor(row_t * M);\\n\\tfloat col_0 = floor(col_t * N - 1.5); // index of first element in pixel (matrix space)\\n\\tfloat lin_index_0 = row * N + col_0; // linearized index of first element in pixel in output\\n\\n\\tvec4 result;\\n\\tvec2 coords = linear_index_coords_1540259130(lin_index_0, N_in);\\n\\n\\tvec2 scale_in = vec2(1.0/N_in, 1.0/M_in); // scale from matrix to input texture coords\\n\\tvec2 offset_in = vec2(0.5, 0.5); // move away from edge of pixel\\n\\n\\tresult = texture2D(A, (coords + offset_in) * scale_in);\\n\\n\\tgl_FragColor = result;\\n}\\n\",l=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D X;\\t\\t// texture with data from padded X\\nuniform float     N;\\t\\t// number of columns\\nuniform float     pad;\\t\\t// additional columns to nearest multiple of four\\nuniform float     N_in;\\t\\t// number of columns (input)\\nuniform float     pad_in;\\t// additional columns to nearest multiple of four (input)\\nuniform float     stride;\\nuniform float     offset;   // zero or one\\n\\n// set pad values to 0.0, if in padded region of output texture\\nvoid fix_pad_1540259130(inout vec4 v, int pad){\\n\\tv.a = 0.0;\\n\\tif(pad == 2){\\n\\t\\tv.b = 0.0;\\n\\t} else if(pad == 3){\\n\\t\\tv.b = 0.0;\\n\\t\\tv.g = 0.0;\\n\\t}\\n}\\n\\n/* join parts of two pixels into one, selecting four continguous elements\\n  starting at channel.\\n*/\\nvoid join_pixels_1604150559(inout vec4 x, vec4 x0, vec4 x1, float channel){\\n\\tif(channel == 1.0){\\n\\t\\tx.rgb = x0.gba;\\n\\t\\tx.a = x1.r;\\n\\t} else if(channel == 2.0){\\n\\t\\tx.rg = x0.ba;\\n\\t\\tx.ba = x1.rg;\\n\\t} else if(channel == 3.0){\\n\\t\\tx.r = x0.a;\\n\\t\\tx.gba = x1.rgb;\\n\\t}\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\tfloat col = floor(col_t * (N + pad) - 1.5); // index of first element in pixel (output matrix space)\\n\\n\\tfloat stripe = floor(col / stride);\\n\\tfloat sub_col = floor(mod(col, stride));\\n\\n\\tfloat col_in = (offset + (2.0 * stripe)) * stride + sub_col;\\n\\n\\tvec4 x;\\n\\tfloat channel = mod(col_in, 4.0); // channel in the input of first element in output\\n\\n\\t// are we at the beggining of an input pixel?\\n\\tif(channel == 0.0){\\n\\t\\t// yes, select the whole thing\\n\\t\\tx = texture2D( X, vec2((col_in + 2.0 - channel) / (N_in + pad_in) , row_t));\\n\\t} else {\\n\\t\\t// no, select parts from two pixels\\n\\t\\tvec4 x0, x1;\\n\\t\\tx0 = texture2D( X, vec2((col_in + 2.0 - channel) / (N_in + pad_in) , row_t));\\n\\t\\tx1 = texture2D( X, vec2((col_in + 6.0 - channel) / (N_in + pad_in) , row_t));\\n\\n\\t\\tjoin_pixels_1604150559(x, x0, x1, channel);\\n\\n\\t}\\n\\n\\t// fix padded region\\n\\tif(pad > 0.0 && col + 4.0 > N ) {\\n\\t\\tfix_pad_1540259130(x, int(pad));\\n\\t}\\n\\n\\tgl_FragColor = x;\\n}\\n\",c=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec2      outTex;\\t// texture coords of row/column to calculate\\nuniform sampler2D A;\\t\\t// texture with data from padded A\\nuniform sampler2D B;\\t\\t// texture with data from padded B\\nuniform float     N_in;\\t\\t// number of columns\\nuniform float     pad_in;\\t// additional columns to nearest multiple of four\\nuniform float     stride;\\n\\n// set pad values to 0.0, if in padded region of output texture\\nvoid fix_pad_1540259130(inout vec4 v, int pad){\\n\\tv.a = 0.0;\\n\\tif(pad == 2){\\n\\t\\tv.b = 0.0;\\n\\t} else if(pad == 3){\\n\\t\\tv.b = 0.0;\\n\\t\\tv.g = 0.0;\\n\\t}\\n}\\n\\nvoid main(void) {\\n\\n\\t// get the implied row and column from .y and .x of passed (output)\\n\\t// texture coordinate. These map directly to input texture space when\\n\\t// the relevant dimensions are the same.\\n\\tfloat row_t = outTex.y;\\n\\tfloat col_t = outTex.x;\\n\\tfloat N = N_in * 2.0;\\n\\tfloat pad = mod(N, 4.0);\\n\\tfloat col = floor(col_t * (N + pad) - 1.5); // index of first element in pixel (output matrix space)\\n\\n\\tfloat stripe = floor(col / stride);\\n\\tfloat sub_col = floor(mod(col, stride));\\n\\n\\tfloat tex_select = mod(stripe, 2.0);\\n\\tfloat col_in = floor(stripe / 2.0) * stride + sub_col;\\n\\n\\tvec4 x;\\n\\tfloat channel = mod(col_in, 4.0); // channel in the input of first element in output\\n\\n\\t// which input texture are we getting this pixel from?\\n\\tif(tex_select == 0.0){\\n\\t\\tx = texture2D( A, vec2((col_in + 2.0) / (N_in + pad_in) , row_t));\\n\\t} else {\\n\\t\\tx = texture2D( B, vec2((col_in + 2.0) / (N_in + pad_in) , row_t));\\n\\t}\\n\\n\\t// fix padded region\\n\\tif(pad > 0.0 && col + 4.0 > N ) {\\n\\t\\tfix_pad_1540259130(x, int(pad));\\n\\t}\\n\\n\\tgl_FragColor = x;\\n}\\n\";this.encode_program=this.createProgram(i),this.transpose_program=this.createProgram(a),this.reshape_program=this.createProgram(s),this.reshape_simple_program=this.createProgram(u),this.submatrix_program=this.createProgram(l),this.combine_program=this.createProgram(c)}e.exports=r,r.COMPONENTS_PER_TEXEL=4,r.POSITION_UNIFORM_NAME=\"pos\",r.TEXTURE_UNIFORM_NAME=\"tex\",r.prototype.encode=function(t,e,n,r){this.program=this.encode_program,this.selectProgram(this.program);var o=this.getPad(e),i=this.context.getUniformLocation(this.program,\"N\"),a=this.context.getUniformLocation(this.program,\"pad\");this.context.uniform1i(i,e),this.context.uniform1i(a,o),this.bindInputTexture(n,this.context.TEXTURE0,\"A\"),this.bindOutputTexture(t,e,r),this.context.drawElements(this.context.TRIANGLES,6,this.context.UNSIGNED_SHORT,0),this.unbindInputTexture(this.context.TEXTURE0)},r.prototype.transpose=function(t,e,n,r){this.program=this.transpose_program,this.selectProgram(this.program);var o=this.getPad(e),i=this.getPad(t),a=this.context.getUniformLocation(this.program,\"N\"),s=this.context.getUniformLocation(this.program,\"npad\"),u=this.context.getUniformLocation(this.program,\"M\"),l=this.context.getUniformLocation(this.program,\"mpad\");this.context.uniform1i(a,t),this.context.uniform1i(s,i),this.context.uniform1i(u,e),this.context.uniform1i(l,o),this.bindInputTexture(n,this.context.TEXTURE0,\"A\"),this.bindOutputTexture(e,(t+i)/4,r),this.context.drawElements(this.context.TRIANGLES,6,this.context.UNSIGNED_SHORT,0),this.unbindInputTexture(this.context.TEXTURE0)},r.prototype.reshape=function(t,e,n,r,o,i){var a=this.getPad(e),s=this.getPad(r);0==a&&0==s?this.program=this.reshape_simple_program:(this.program=this.reshape_program,console.log(\"# WARNING: using slow reshape shader.\")),this.selectProgram(this.program);var u=this.context.getUniformLocation(this.program,\"M\"),l=this.context.getUniformLocation(this.program,\"N\"),c=this.context.getUniformLocation(this.program,\"pad\"),f=this.context.getUniformLocation(this.program,\"M_in\"),p=this.context.getUniformLocation(this.program,\"N_in\"),h=this.context.getUniformLocation(this.program,\"pad_in\");this.context.uniform1f(u,n),this.context.uniform1f(l,r),this.context.uniform1f(c,s),this.context.uniform1f(f,t),this.context.uniform1f(p,e),this.context.uniform1f(h,a),this.bindInputTexture(o,this.context.TEXTURE0,\"A\"),this.bindOutputTexture(n,(r+s)/4,i),this.context.drawElements(this.context.TRIANGLES,6,this.context.UNSIGNED_SHORT,0),this.unbindInputTexture(this.context.TEXTURE0)},r.prototype.submatrix=function(t,e,n,r,o,i,a){this.program=this.submatrix_program,this.selectProgram(this.program);var s=this.getPad(t),u=this.getPad(n),l=this.context.getUniformLocation(this.program,\"N\"),c=this.context.getUniformLocation(this.program,\"pad\"),f=this.context.getUniformLocation(this.program,\"N_in\"),p=this.context.getUniformLocation(this.program,\"pad_in\"),h=this.context.getUniformLocation(this.program,\"offset\");stride_gl=this.context.getUniformLocation(this.program,\"stride\"),this.context.uniform1f(l,n),this.context.uniform1f(c,u),this.context.uniform1f(f,t),this.context.uniform1f(p,s),this.context.uniform1f(stride_gl,r),this.context.uniform1f(h,o),this.bindInputTexture(i,this.context.TEXTURE0,\"X\"),this.bindOutputTexture(e,(n+u)/4,a),this.context.drawElements(this.context.TRIANGLES,6,this.context.UNSIGNED_SHORT,0),this.unbindInputTexture(this.context.TEXTURE0)},r.prototype.combine=function(t,e,n,r,o,i){this.program=this.combine_program,this.selectProgram(this.program);var a=2*e,s=this.getPad(e),u=this.getPad(a),l=this.context.getUniformLocation(this.program,\"N_in\"),c=this.context.getUniformLocation(this.program,\"pad_in\"),f=this.context.getUniformLocation(this.program,\"stride\");this.context.uniform1f(l,e),this.context.uniform1f(c,s),this.context.uniform1f(f,n),this.bindInputTexture(r,this.context.TEXTURE0,\"A\"),this.bindInputTexture(o,this.context.TEXTURE1,\"B\"),this.bindOutputTexture(t,(a+u)/4,i),this.context.drawElements(this.context.TRIANGLES,6,this.context.UNSIGNED_SHORT,0),this.unbindInputTexture(this.context.TEXTURE0)},r.prototype.bindInputTexture=function(t,e,n){var r=this.context,o=this.program;r.activeTexture(e),r.bindTexture(r.TEXTURE_2D,t);var i=r.getUniformLocation(o,n);r.uniform1i(i,e-r.TEXTURE0)},r.prototype.createProgram=function(t){var e,n=this.context;if(e=n.createShader(n.FRAGMENT_SHADER),n.shaderSource(e,t),n.compileShader(e),0==n.getShaderParameter(e,n.COMPILE_STATUS))throw new Error(n.getShaderInfoLog(e));var r=n.createProgram();return n.attachShader(r,this.vertexShader),n.attachShader(r,e),n.linkProgram(r),r},r.prototype.selectProgram=function(t){var e=this.context;e.useProgram(t),this.bindVertices(t)},r.prototype.bindVertices=function(t){var e=this.context,n=t,o=e.getAttribLocation(n,r.POSITION_UNIFORM_NAME),i=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,i);var a=[-1,-1,0,1,-1,0,1,1,0,-1,1,0];e.bufferData(e.ARRAY_BUFFER,new Float32Array(a),e.STATIC_DRAW),e.vertexAttribPointer(o,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(o);var s=e.getAttribLocation(n,r.TEXTURE_UNIFORM_NAME),u=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,u);var l=[0,0,1,0,1,1,0,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(l),e.STATIC_DRAW),e.vertexAttribPointer(s,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(s);var c=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,c);var f=[0,1,2,0,2,3];e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(f),e.STATIC_DRAW)},r.prototype.createDataTexture=function(t,e,n){var o=this.context,i=[0,0,0,0],a=e%r.COMPONENTS_PER_TEXEL,s=0==a?0:r.COMPONENTS_PER_TEXEL-a,u=o.createTexture();if(o.bindTexture(o.TEXTURE_2D,u),0==s||null==n||\"undefined\"==typeof n)o.texImage2D(o.TEXTURE_2D,0,o.RGBA,(e+s)/r.COMPONENTS_PER_TEXEL,t,0,o.RGBA,o.FLOAT,n);else{o.texImage2D(o.TEXTURE_2D,0,o.RGBA,(e+s)/r.COMPONENTS_PER_TEXEL,t,0,o.RGBA,o.FLOAT,null);for(var l,c,f=e-a,p=f/r.COMPONENTS_PER_TEXEL,h=0,d=new Float32Array(i),v=0;t>v;v++)h=v*e,full_texel_row_end=h+f,l=new Float32Array(n.buffer,h*n.BYTES_PER_ELEMENT,f),f>0&&o.texSubImage2D(o.TEXTURE_2D,0,0,v,p,1,o.RGBA,o.FLOAT,l),c=new Float32Array(n.buffer,full_texel_row_end*n.BYTES_PER_ELEMENT,a),d.set(c),o.texSubImage2D(o.TEXTURE_2D,0,p,v,1,1,o.RGBA,o.FLOAT,d)}return o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.NEAREST),o.bindTexture(o.TEXTURE_2D,null),u},r.prototype.createOutputTexture=function(t,e){var n=this.context,r=this.getPad(e),o=n.createTexture();return n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e+r,t,0,n.RGBA,n.UNSIGNED_BYTE,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.bindTexture(n.TEXTURE_2D,null),o},r.prototype.bindOutputTexture=function(t,e,n){var r=this.context;if(this.canvas.height=t,this.canvas.width=e,r.viewport(0,0,e,t),this.framebuffer=this.framebuffer||r.createFramebuffer(),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0),r.checkFramebufferStatus(r.FRAMEBUFFER)!=r.FRAMEBUFFER_COMPLETE)throw new Error(\"Bound framebuffer is not complete.\");return this.framebuffer},r.prototype.unbindInputTexture=function(t){var e=this.context;e.activeTexture(t),e.bindTexture(e.TEXTURE_2D,null)},r.prototype.readData=function(t,e){var n=this.context;return rawbuffer=new ArrayBuffer(t*e*Float32Array.BYTES_PER_ELEMENT),prod=new Uint8Array(rawbuffer),n.readPixels(0,0,e,t,n.RGBA,n.UNSIGNED_BYTE,prod),rawbuffer},r.prototype.getPad=function(t){var e=t%r.COMPONENTS_PER_TEXEL,n=0==e?0:r.COMPONENTS_PER_TEXEL-e;return n}},{}]},{},[1])(1)})},function(t,e,n){n(195),t.exports=n(194)}])});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../~/timers-browserify/main.js */ 1).setImmediate, __webpack_require__(/*! ./../../~/timers-browserify/main.js */ 1).clearImmediate))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9rZXJhcy5qcz82NzRiIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuS2VyYXNKUz1lKCk6dC5LZXJhc0pTPWUoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgbz1uW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxlKSxvLmw9ITAsby5leHBvcnRzfXZhciBuPXt9O3JldHVybiBlLm09dCxlLmM9bixlLmk9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGUuZD1mdW5jdGlvbih0LG4scil7ZS5vKHQsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpyfSl9LGUubj1mdW5jdGlvbih0KXt2YXIgbj10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gZS5kKG4sXCJhXCIsbiksbn0sZS5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxlLnA9XCJcIixlKGUucz02MjUpfShbZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNSksbz1uKDMxKSxpPW4oMTUpLGE9bigxNikscz1uKDMyKSx1PVwicHJvdG90eXBlXCIsbD1mdW5jdGlvbih0LGUsbil7dmFyIGMsZixwLGgsZD10JmwuRix2PXQmbC5HLG09dCZsLlMsXz10JmwuUCxnPXQmbC5CLHk9dj9yOm0/cltlXXx8KHJbZV09e30pOihyW2VdfHx7fSlbdV0sYj12P286b1tlXXx8KG9bZV09e30pLHc9Ylt1XXx8KGJbdV09e30pO3YmJihuPWUpO2ZvcihjIGluIG4pZj0hZCYmeSYmdm9pZCAwIT09eVtjXSxwPShmP3k6bilbY10saD1nJiZmP3MocCxyKTpfJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBwP3MoRnVuY3Rpb24uY2FsbCxwKTpwLHkmJmEoeSxjLHAsdCZsLlUpLGJbY10hPXAmJmkoYixjLGgpLF8mJndbY10hPXAmJih3W2NdPXApfTtyLmNvcmU9byxsLkY9MSxsLkc9MixsLlM9NCxsLlA9OCxsLkI9MTYsbC5XPTMyLGwuVT02NCxsLlI9MTI4LHQuZXhwb3J0cz1sfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZihBcnJheS5pc0FycmF5KHQpKXtmb3IodmFyIGU9MCxuPUFycmF5KHQubGVuZ3RoKTtlPHQubGVuZ3RoO2UrKyluW2VdPXRbZV07cmV0dXJuIG59cmV0dXJuIEFycmF5LmZyb20odCl9ZnVuY3Rpb24gaSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxzPW4oMiksdT1yKHMpLGw9bigzKSxjPXIobCksZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aSh0aGlzLHQpLHRoaXMubGF5ZXJDbGFzcz1cIkxheWVyXCIsdGhpcy5uYW1lPWUubmFtZSx0aGlzLnBhcmFtcz1bXSx0aGlzLndlaWdodHM9e30sdGhpcy5ncHU9ZS5ncHUsdGhpcy5waXBlbGluZT1lLnBpcGVsaW5lLHRoaXMuX3VzZVdlYmxhcz0hMSx0aGlzLl9waXBlbGluZUVuYWJsZWQ9ITF9cmV0dXJuIGEodCxbe2tleTpcInNldFdlaWdodHNcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMucGFyYW1zLmZvckVhY2goZnVuY3Rpb24obixyKXtlLndlaWdodHNbbl09dFtyXX0pfX0se2tleTpcInRvZ2dsZUdwdVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPVwidW5kZWZpbmVkXCI9PXR5cGVvZiB0PyF0aGlzLl91c2VXZWJsYXM6dDtlJiZ3ZWJsYXM/dGhpcy5fdXNlV2VibGFzPSEwOnRoaXMuX3VzZVdlYmxhcz0hMX19LHtrZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHR9fSx7a2V5OlwidHJhbnNmZXJGcm9tUGlwZWxpbmVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdC53ZWJsYXNUZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgcGFzc2VkIGluIGRvZXMgbm90IGNvbnRhaW4gd2VibGFzIHRlbnNvci5cIik7aWYoIXQuX2Zyb21QaXBlbGluZSl0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSBwYXNzZWQgaW4gZG9lcyBub3QgY29udGFpbiBfZnJvbVBpcGVsaW5lLlwiKTtpZighdC5fYWN0dWFsU2hhcGUpdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgcGFzc2VkIGluIGRvZXMgbm90IGNvbnRhaW4gX2FjdHVhbFNoYXBlLlwiKTt2YXIgZT10LndlYmxhc1RlbnNvci5zaGFwZVsxXSxuPXQuX2FjdHVhbFNoYXBlLnNsaWNlKDAsLTEpLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9LDEpLHI9bmV3IHUuZGVmYXVsdChbXSx0LndlYmxhc1RlbnNvci5zaGFwZSk7ci50ZW5zb3IuZGF0YT10LndlYmxhc1RlbnNvci50cmFuc2ZlcigpO2Zvcih2YXIgaT1uZXcgdS5kZWZhdWx0KFtdLHQuX2FjdHVhbFNoYXBlKSxhPW5ldyB1LmRlZmF1bHQoW10sW25dKSxzPW5ldyB1LmRlZmF1bHQoW10sdC5fYWN0dWFsU2hhcGUuc2xpY2UoMCwtMSkpLGw9MDtsPGU7bCsrKXt2YXIgZjtjLmRlZmF1bHQuYXNzaWduKGEudGVuc29yLHIudGVuc29yLnBpY2sobnVsbCxsKSkscy5yZXBsYWNlVGVuc29yRGF0YShhLnRlbnNvci5kYXRhKTt2YXIgcD1BcnJheSh0Ll9hY3R1YWxTaGFwZS5sZW5ndGgtMSkuZmlsbChudWxsKTtjLmRlZmF1bHQuYXNzaWduKChmPWkudGVuc29yKS5waWNrLmFwcGx5KGYsbyhwKS5jb25jYXQoW2xdKSkscy50ZW5zb3IpfXJldHVybiBpLl9mcm9tUGlwZWxpbmU9ITEsaS5fYWN0dWFsU2hhcGUmJmRlbGV0ZSBpLl9hY3R1YWxTaGFwZSxpfX1dKSx0fSgpO2UuZGVmYXVsdD1mfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEscz10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9cy5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXshciYmcy5yZXR1cm4mJnMucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufXJldHVybiBmdW5jdGlvbihlLG4pe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGU7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlyZXR1cm4gdChlLG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCkscz1uKDkxKSx1PXIocyksbD1uKDE5MSksYz0ocihsKSxuKDE5NykpLGY9ZnVuY3Rpb24odCxlKXtpZih0Lmxlbmd0aCYmZS5sZW5ndGgmJnQubGVuZ3RoIT09ZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSwxKSl0aHJvdyBuZXcgRXJyb3IoXCJTcGVjaWZpZWQgc2hhcGUgaW5jb21wYXRpYmxlIHdpdGggZGF0YS5cIil9LHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsbil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O28odGhpcyx0KSx0aGlzLl90eXBlPXIudHlwZXx8RmxvYXQzMkFycmF5LGUmJmUubGVuZ3RoJiYoZSBpbnN0YW5jZW9mIHRoaXMuX3R5cGV8fGUgaW5zdGFuY2VvZiBBcnJheSk/KGYoZSxuKSx0aGlzLnRlbnNvcj0oMCx1LmRlZmF1bHQpKGUsbiksdGhpcy50ZW5zb3I9KDAsdS5kZWZhdWx0KShuZXcgdGhpcy5fdHlwZShlKSxuKSk6IWUubGVuZ3RoJiZuLmxlbmd0aD90aGlzLnRlbnNvcj0oMCx1LmRlZmF1bHQpKG5ldyB0aGlzLl90eXBlKG4ucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0sMSkpLG4pOnRoaXMudGVuc29yPSgwLHUuZGVmYXVsdCkobmV3IHRoaXMuX3R5cGUoW10pLFtdKX1yZXR1cm4gYSh0LFt7a2V5OlwicmVwbGFjZVRlbnNvckRhdGFcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0JiZ0Lmxlbmd0aCYmdCBpbnN0YW5jZW9mIHRoaXMuX3R5cGUpdGhpcy50ZW5zb3IuZGF0YT10O2Vsc2V7aWYoISh0JiZ0Lmxlbmd0aCYmdCBpbnN0YW5jZW9mIEFycmF5KSl0aHJvdyBuZXcgRXJyb3IoXCJbVGVuc29yXSBpbnZhbGlkIGlucHV0IGZvciByZXBsYWNlVGVuc29yRGF0YSBtZXRob2QuXCIpO3RoaXMudGVuc29yLmRhdGE9bmV3IHRoaXMuX3R5cGUodCl9fX0se2tleTpcImNyZWF0ZVdlYmxhc1RlbnNvclwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy53ZWJsYXNUZW5zb3ImJnRoaXMud2VibGFzVGVuc29yLmRlbGV0ZSgpLDE9PT10aGlzLnRlbnNvci5zaGFwZS5sZW5ndGgpe3ZhciB0PXRoaXMudGVuc29yLnNoYXBlWzBdO2lmKHQ+Yy5NQVhfVEVYVFVSRV9TSVpFKXRoaXMuX2dwdU1heFNpemVFeGNlZWRlZD0hMDtlbHNle3ZhciBlPVsxLHRdO3RoaXMud2VibGFzVGVuc29yPW5ldyB3ZWJsYXMucGlwZWxpbmUuVGVuc29yKGUsdGhpcy50ZW5zb3IuZGF0YSl9fWVsc2V7aWYoMiE9PXRoaXMudGVuc29yLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJbVGVuc29yXSBjYW4gb25seSBjcmVhdGUgd2VibGFzIFRlbnNvciBmb3IgMS1EIG9yIDItRCBvbmx5XCIpO2lmKHRoaXMudGVuc29yLnNoYXBlLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQ+Yy5NQVhfVEVYVFVSRV9TSVpFfSkpdGhpcy5fZ3B1TWF4U2l6ZUV4Y2VlZGVkPSEwO2Vsc2V7dmFyIG49dGhpcy50ZW5zb3Iuc2hhcGU7dGhpcy53ZWJsYXNUZW5zb3I9bmV3IHdlYmxhcy5waXBlbGluZS5UZW5zb3Iobix0aGlzLnRlbnNvci5kYXRhKX19fX0se2tleTpcImRlbGV0ZVdlYmxhc1RlbnNvclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy53ZWJsYXNUZW5zb3ImJih0aGlzLndlYmxhc1RlbnNvci5kZWxldGUoKSxkZWxldGUgdGhpcy53ZWJsYXNUZW5zb3IpfX0se2tleTpcImNvcHlGcm9tV2VibGFzVGVuc29yXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9d2VibGFzLmdwdS5nbCxyPWUuY29udGV4dCxvPWUuY3JlYXRlUHJvZ3JhbShuKDYxOCkpO3RoaXMud2VibGFzVGVuc29yPW5ldyB3ZWJsYXMucGlwZWxpbmUuVGVuc29yKHQuc2hhcGUsbnVsbCksZS5zZWxlY3RQcm9ncmFtKG8pLHIuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwKSxyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0LnRleHR1cmUpO3ZhciBhPXIuZ2V0VW5pZm9ybUxvY2F0aW9uKG8sXCJzb3VyY2VcIik7ci51bmlmb3JtMWkoYSwwKTt2YXIgcz1pKHRoaXMud2VibGFzVGVuc29yLnNoYXBlLDIpLHU9c1swXSxsPXNbMV0sYz1lLmdldFBhZChsKTtlLmJpbmRPdXRwdXRUZXh0dXJlKHUsKGwrYykvNCx0aGlzLndlYmxhc1RlbnNvci50ZXh0dXJlKSxyLmRyYXdFbGVtZW50cyhyLlRSSUFOR0xFUyw2LHIuVU5TSUdORURfU0hPUlQsMCksZS51bmJpbmRJbnB1dFRleHR1cmUoci5URVhUVVJFMCl9fV0pLHR9KCk7ZS5kZWZhdWx0PXB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe2lmKCF0KXJldHVybiBzO2Zvcih2YXIgZT0wO2U8dC5hcmdzLmxlbmd0aDsrK2Upe3ZhciBuPXQuYXJnc1tlXTswPT09ZT90LmFyZ3NbZV09e25hbWU6bixsdmFsdWU6ITAscnZhbHVlOiEhdC5ydmFsdWUsY291bnQ6dC5jb3VudHx8MX06dC5hcmdzW2VdPXtuYW1lOm4sbHZhbHVlOiExLHJ2YWx1ZTohMCxjb3VudDoxfX1yZXR1cm4gdC50aGlzVmFyc3x8KHQudGhpc1ZhcnM9W10pLHQubG9jYWxWYXJzfHwodC5sb2NhbFZhcnM9W10pLHR9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gYSh7YXJnczp0LmFyZ3MscHJlOnIodC5wcmUpLGJvZHk6cih0LmJvZHkpLHBvc3Q6cih0LnByb2MpLGZ1bmNOYW1lOnQuZnVuY05hbWV9KX1mdW5jdGlvbiBpKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0LmFyZ3MubGVuZ3RoOysrbillLnB1c2goXCJhXCIrbik7dmFyIHI9bmV3IEZ1bmN0aW9uKFwiUFwiLFtcInJldHVybiBmdW5jdGlvbiBcIix0LmZ1bmNOYW1lLFwiX25kYXJyYXlvcHMoXCIsZS5qb2luKFwiLFwiKSxcIikge1AoXCIsZS5qb2luKFwiLFwiKSxcIik7cmV0dXJuIGEwfVwiXS5qb2luKFwiXCIpKTtyZXR1cm4gcihvKHQpKX12YXIgYT1uKDE2Nikscz17Ym9keTpcIlwiLGFyZ3M6W10sdGhpc1ZhcnM6W10sbG9jYWxWYXJzOltdfSx1PXthZGQ6XCIrXCIsc3ViOlwiLVwiLG11bDpcIipcIixkaXY6XCIvXCIsbW9kOlwiJVwiLGJhbmQ6XCImXCIsYm9yOlwifFwiLGJ4b3I6XCJeXCIsbHNoaWZ0OlwiPDxcIixyc2hpZnQ6XCI+PlwiLHJyc2hpZnQ6XCI+Pj5cIn07IWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHUpe3ZhciBuPXVbdF07ZVt0XT1pKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLGJvZHk6XCJhPWJcIituK1wiY1wifSxmdW5jTmFtZTp0fSksZVt0K1wiZXFcIl09aSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIl0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCJdLGJvZHk6XCJhXCIrbitcIj1iXCJ9LHJ2YWx1ZTohMCxmdW5jTmFtZTp0K1wiZXFcIn0pLGVbdCtcInNcIl09aSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIixcInNjYWxhclwiXSxib2R5OnthcmdzOltcImFcIixcImJcIixcInNcIl0sYm9keTpcImE9YlwiK24rXCJzXCJ9LGZ1bmNOYW1lOnQrXCJzXCJ9KSxlW3QrXCJzZXFcIl09aSh7YXJnczpbXCJhcnJheVwiLFwic2NhbGFyXCJdLGJvZHk6e2FyZ3M6W1wiYVwiLFwic1wiXSxib2R5OlwiYVwiK24rXCI9c1wifSxydmFsdWU6ITAsZnVuY05hbWU6dCtcInNlcVwifSl9fSgpO3ZhciBsPXtub3Q6XCIhXCIsYm5vdDpcIn5cIixuZWc6XCItXCIscmVjaXA6XCIxLjAvXCJ9OyFmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiBsKXt2YXIgbj1sW3RdO2VbdF09aSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIl0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCJdLGJvZHk6XCJhPVwiK24rXCJiXCJ9LGZ1bmNOYW1lOnR9KSxlW3QrXCJlcVwiXT1pKHthcmdzOltcImFycmF5XCJdLGJvZHk6e2FyZ3M6W1wiYVwiXSxib2R5OlwiYT1cIituK1wiYVwifSxydmFsdWU6ITAsY291bnQ6MixmdW5jTmFtZTp0K1wiZXFcIn0pfX0oKTt2YXIgYz17YW5kOlwiJiZcIixvcjpcInx8XCIsZXE6XCI9PT1cIixuZXE6XCIhPT1cIixsdDpcIjxcIixndDpcIj5cIixsZXE6XCI8PVwiLGdlcTpcIj49XCJ9OyFmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiBjKXt2YXIgbj1jW3RdO2VbdF09aSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLGJvZHk6e2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSxib2R5OlwiYT1iXCIrbitcImNcIn0sZnVuY05hbWU6dH0pLGVbdCtcInNcIl09aSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIixcInNjYWxhclwiXSxib2R5OnthcmdzOltcImFcIixcImJcIixcInNcIl0sYm9keTpcImE9YlwiK24rXCJzXCJ9LGZ1bmNOYW1lOnQrXCJzXCJ9KSxlW3QrXCJlcVwiXT1pKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiXSxib2R5OnthcmdzOltcImFcIixcImJcIl0sYm9keTpcImE9YVwiK24rXCJiXCJ9LHJ2YWx1ZTohMCxjb3VudDoyLGZ1bmNOYW1lOnQrXCJlcVwifSksZVt0K1wic2VxXCJdPWkoe2FyZ3M6W1wiYXJyYXlcIixcInNjYWxhclwiXSxib2R5OnthcmdzOltcImFcIixcInNcIl0sYm9keTpcImE9YVwiK24rXCJzXCJ9LHJ2YWx1ZTohMCxjb3VudDoyLGZ1bmNOYW1lOnQrXCJzZXFcIn0pfX0oKTt2YXIgZj1bXCJhYnNcIixcImFjb3NcIixcImFzaW5cIixcImF0YW5cIixcImNlaWxcIixcImNvc1wiLFwiZXhwXCIsXCJmbG9vclwiLFwibG9nXCIsXCJyb3VuZFwiLFwic2luXCIsXCJzcXJ0XCIsXCJ0YW5cIl07IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxmLmxlbmd0aDsrK3Qpe3ZhciBuPWZbdF07ZVtuXT1pKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiXSxwcmU6e2FyZ3M6W10sYm9keTpcInRoaXNfZj1NYXRoLlwiK24sdGhpc1ZhcnM6W1widGhpc19mXCJdfSxib2R5OnthcmdzOltcImFcIixcImJcIl0sYm9keTpcImE9dGhpc19mKGIpXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxmdW5jTmFtZTpufSksZVtuK1wiZXFcIl09aSh7YXJnczpbXCJhcnJheVwiXSxwcmU6e2FyZ3M6W10sYm9keTpcInRoaXNfZj1NYXRoLlwiK24sdGhpc1ZhcnM6W1widGhpc19mXCJdfSxib2R5OnthcmdzOltcImFcIl0sYm9keTpcImE9dGhpc19mKGEpXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxydmFsdWU6ITAsY291bnQ6MixmdW5jTmFtZTpuK1wiZXFcIn0pfX0oKTt2YXIgcD1bXCJtYXhcIixcIm1pblwiLFwiYXRhbjJcIixcInBvd1wiXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHAubGVuZ3RoOysrdCl7dmFyIG49cFt0XTtlW25dPWkoe2FyZ3M6W1wiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiXSxwcmU6e2FyZ3M6W10sYm9keTpcInRoaXNfZj1NYXRoLlwiK24sdGhpc1ZhcnM6W1widGhpc19mXCJdfSxib2R5OnthcmdzOltcImFcIixcImJcIixcImNcIl0sYm9keTpcImE9dGhpc19mKGIsYylcIix0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LGZ1bmNOYW1lOm59KSxlW24rXCJzXCJdPWkoe2FyZ3M6W1wiYXJyYXlcIixcImFycmF5XCIsXCJzY2FsYXJcIl0scHJlOnthcmdzOltdLGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIituLHRoaXNWYXJzOltcInRoaXNfZlwiXX0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLGJvZHk6XCJhPXRoaXNfZihiLGMpXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxmdW5jTmFtZTpuK1wic1wifSksZVtuK1wiZXFcIl09aSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIl0scHJlOnthcmdzOltdLGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIituLHRoaXNWYXJzOltcInRoaXNfZlwiXX0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCJdLGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxydmFsdWU6ITAsY291bnQ6MixmdW5jTmFtZTpuK1wiZXFcIn0pLGVbbitcInNlcVwiXT1pKHthcmdzOltcImFycmF5XCIsXCJzY2FsYXJcIl0scHJlOnthcmdzOltdLGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIituLHRoaXNWYXJzOltcInRoaXNfZlwiXX0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCJdLGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxydmFsdWU6ITAsY291bnQ6MixmdW5jTmFtZTpuK1wic2VxXCJ9KX19KCk7dmFyIGg9W1wiYXRhbjJcIixcInBvd1wiXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PGgubGVuZ3RoOysrdCl7dmFyIG49aFt0XTtlW24rXCJvcFwiXT1pKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0scHJlOnthcmdzOltdLGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIituLHRoaXNWYXJzOltcInRoaXNfZlwiXX0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLGJvZHk6XCJhPXRoaXNfZihjLGIpXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxmdW5jTmFtZTpuK1wib3BcIn0pLGVbbitcIm9wc1wiXT1pKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwic2NhbGFyXCJdLHByZTp7YXJnczpbXSxib2R5OlwidGhpc19mPU1hdGguXCIrbix0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LGJvZHk6e2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSxib2R5OlwiYT10aGlzX2YoYyxiKVwiLHRoaXNWYXJzOltcInRoaXNfZlwiXX0sZnVuY05hbWU6bitcIm9wc1wifSksZVtuK1wib3BlcVwiXT1pKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiXSxwcmU6e2FyZ3M6W10sYm9keTpcInRoaXNfZj1NYXRoLlwiK24sdGhpc1ZhcnM6W1widGhpc19mXCJdfSxib2R5OnthcmdzOltcImFcIixcImJcIl0sYm9keTpcImE9dGhpc19mKGIsYSlcIix0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LHJ2YWx1ZTohMCxjb3VudDoyLGZ1bmNOYW1lOm4rXCJvcGVxXCJ9KSxlW24rXCJvcHNlcVwiXT1pKHthcmdzOltcImFycmF5XCIsXCJzY2FsYXJcIl0scHJlOnthcmdzOltdLGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIituLHRoaXNWYXJzOltcInRoaXNfZlwiXX0sYm9keTp7YXJnczpbXCJhXCIsXCJiXCJdLGJvZHk6XCJhPXRoaXNfZihiLGEpXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxydmFsdWU6ITAsY291bnQ6MixmdW5jTmFtZTpuK1wib3BzZXFcIn0pfX0oKSxlLmFueT1hKHthcmdzOltcImFycmF5XCJdLHByZTpzLGJvZHk6e2FyZ3M6W3tuYW1lOlwiYVwiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6MX1dLGJvZHk6XCJpZihhKXtyZXR1cm4gdHJ1ZX1cIixsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W119LHBvc3Q6e2FyZ3M6W10sbG9jYWxWYXJzOltdLHRoaXNWYXJzOltdLGJvZHk6XCJyZXR1cm4gZmFsc2VcIn0sZnVuY05hbWU6XCJhbnlcIn0pLGUuYWxsPWEoe2FyZ3M6W1wiYXJyYXlcIl0scHJlOnMsYm9keTp7YXJnczpbe25hbWU6XCJ4XCIsbHZhbHVlOiExLHJ2YWx1ZTohMCxjb3VudDoxfV0sYm9keTpcImlmKCF4KXtyZXR1cm4gZmFsc2V9XCIsbG9jYWxWYXJzOltdLHRoaXNWYXJzOltdfSxwb3N0OnthcmdzOltdLGxvY2FsVmFyczpbXSx0aGlzVmFyczpbXSxib2R5OlwicmV0dXJuIHRydWVcIn0sZnVuY05hbWU6XCJhbGxcIn0pLGUuc3VtPWEoe2FyZ3M6W1wiYXJyYXlcIl0scHJlOnthcmdzOltdLGxvY2FsVmFyczpbXSx0aGlzVmFyczpbXCJ0aGlzX3NcIl0sYm9keTpcInRoaXNfcz0wXCJ9LGJvZHk6e2FyZ3M6W3tuYW1lOlwiYVwiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6MX1dLGJvZHk6XCJ0aGlzX3MrPWFcIixsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W1widGhpc19zXCJdfSxwb3N0OnthcmdzOltdLGxvY2FsVmFyczpbXSx0aGlzVmFyczpbXCJ0aGlzX3NcIl0sYm9keTpcInJldHVybiB0aGlzX3NcIn0sZnVuY05hbWU6XCJzdW1cIn0pLGUucHJvZD1hKHthcmdzOltcImFycmF5XCJdLHByZTp7YXJnczpbXSxsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W1widGhpc19zXCJdLGJvZHk6XCJ0aGlzX3M9MVwifSxib2R5OnthcmdzOlt7bmFtZTpcImFcIixsdmFsdWU6ITEscnZhbHVlOiEwLGNvdW50OjF9XSxib2R5OlwidGhpc19zKj1hXCIsbG9jYWxWYXJzOltdLHRoaXNWYXJzOltcInRoaXNfc1wiXX0scG9zdDp7YXJnczpbXSxsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W1widGhpc19zXCJdLGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LGZ1bmNOYW1lOlwicHJvZFwifSksZS5ub3JtMnNxdWFyZWQ9YSh7YXJnczpbXCJhcnJheVwiXSxwcmU6e2FyZ3M6W10sbG9jYWxWYXJzOltdLHRoaXNWYXJzOltcInRoaXNfc1wiXSxib2R5OlwidGhpc19zPTBcIn0sYm9keTp7YXJnczpbe25hbWU6XCJhXCIsbHZhbHVlOiExLHJ2YWx1ZTohMCxjb3VudDoyfV0sYm9keTpcInRoaXNfcys9YSphXCIsbG9jYWxWYXJzOltdLHRoaXNWYXJzOltcInRoaXNfc1wiXX0scG9zdDp7YXJnczpbXSxsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W1widGhpc19zXCJdLGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LGZ1bmNOYW1lOlwibm9ybTJzcXVhcmVkXCJ9KSxlLm5vcm0yPWEoe2FyZ3M6W1wiYXJyYXlcIl0scHJlOnthcmdzOltdLGxvY2FsVmFyczpbXSx0aGlzVmFyczpbXCJ0aGlzX3NcIl0sYm9keTpcInRoaXNfcz0wXCJ9LGJvZHk6e2FyZ3M6W3tuYW1lOlwiYVwiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6Mn1dLGJvZHk6XCJ0aGlzX3MrPWEqYVwiLGxvY2FsVmFyczpbXSx0aGlzVmFyczpbXCJ0aGlzX3NcIl19LHBvc3Q6e2FyZ3M6W10sbG9jYWxWYXJzOltdLHRoaXNWYXJzOltcInRoaXNfc1wiXSxib2R5OlwicmV0dXJuIE1hdGguc3FydCh0aGlzX3MpXCJ9LGZ1bmNOYW1lOlwibm9ybTJcIn0pLGUubm9ybWluZj1hKHthcmdzOltcImFycmF5XCJdLHByZTp7YXJnczpbXSxsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W1widGhpc19zXCJdLGJvZHk6XCJ0aGlzX3M9MFwifSxib2R5OnthcmdzOlt7bmFtZTpcImFcIixsdmFsdWU6ITEscnZhbHVlOiEwLGNvdW50OjR9XSxib2R5OlwiaWYoLWE+dGhpc19zKXt0aGlzX3M9LWF9ZWxzZSBpZihhPnRoaXNfcyl7dGhpc19zPWF9XCIsbG9jYWxWYXJzOltdLHRoaXNWYXJzOltcInRoaXNfc1wiXX0scG9zdDp7YXJnczpbXSxsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W1widGhpc19zXCJdLGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LGZ1bmNOYW1lOlwibm9ybWluZlwifSksZS5ub3JtMT1hKHthcmdzOltcImFycmF5XCJdLHByZTp7YXJnczpbXSxsb2NhbFZhcnM6W10sdGhpc1ZhcnM6W1widGhpc19zXCJdLGJvZHk6XCJ0aGlzX3M9MFwifSxib2R5OnthcmdzOlt7bmFtZTpcImFcIixsdmFsdWU6ITEscnZhbHVlOiEwLGNvdW50OjN9XSxib2R5OlwidGhpc19zKz1hPDA/LWE6YVwiLGxvY2FsVmFyczpbXSx0aGlzVmFyczpbXCJ0aGlzX3NcIl19LHBvc3Q6e2FyZ3M6W10sbG9jYWxWYXJzOltdLHRoaXNWYXJzOltcInRoaXNfc1wiXSxib2R5OlwicmV0dXJuIHRoaXNfc1wifSxmdW5jTmFtZTpcIm5vcm0xXCJ9KSxlLnN1cD1hKHthcmdzOltcImFycmF5XCJdLHByZTp7Ym9keTpcInRoaXNfaD0tSW5maW5pdHlcIixhcmdzOltdLHRoaXNWYXJzOltcInRoaXNfaFwiXSxsb2NhbFZhcnM6W119LGJvZHk6e2JvZHk6XCJpZihfaW5saW5lXzFfYXJnMF8+dGhpc19oKXRoaXNfaD1faW5saW5lXzFfYXJnMF9cIixhcmdzOlt7bmFtZTpcIl9pbmxpbmVfMV9hcmcwX1wiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6Mn1dLHRoaXNWYXJzOltcInRoaXNfaFwiXSxsb2NhbFZhcnM6W119LHBvc3Q6e2JvZHk6XCJyZXR1cm4gdGhpc19oXCIsYXJnczpbXSx0aGlzVmFyczpbXCJ0aGlzX2hcIl0sbG9jYWxWYXJzOltdfX0pLGUuaW5mPWEoe2FyZ3M6W1wiYXJyYXlcIl0scHJlOntib2R5OlwidGhpc19oPUluZmluaXR5XCIsYXJnczpbXSx0aGlzVmFyczpbXCJ0aGlzX2hcIl0sbG9jYWxWYXJzOltdfSxib2R5Ontib2R5OlwiaWYoX2lubGluZV8xX2FyZzBfPHRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsYXJnczpbe25hbWU6XCJfaW5saW5lXzFfYXJnMF9cIixsdmFsdWU6ITEscnZhbHVlOiEwLGNvdW50OjJ9XSx0aGlzVmFyczpbXCJ0aGlzX2hcIl0sbG9jYWxWYXJzOltdfSxwb3N0Ontib2R5OlwicmV0dXJuIHRoaXNfaFwiLGFyZ3M6W10sdGhpc1ZhcnM6W1widGhpc19oXCJdLGxvY2FsVmFyczpbXX19KSxlLmFyZ21pbj1hKHthcmdzOltcImluZGV4XCIsXCJhcnJheVwiLFwic2hhcGVcIl0scHJlOntib2R5Olwie3RoaXNfdj1JbmZpbml0eTt0aGlzX2k9X2lubGluZV8wX2FyZzJfLnNsaWNlKDApfVwiLGFyZ3M6W3tuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOiExLHJ2YWx1ZTohMSxjb3VudDowfSx7bmFtZTpcIl9pbmxpbmVfMF9hcmcxX1wiLGx2YWx1ZTohMSxydmFsdWU6ITEsY291bnQ6MH0se25hbWU6XCJfaW5saW5lXzBfYXJnMl9cIixsdmFsdWU6ITEscnZhbHVlOiEwLGNvdW50OjF9XSx0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxsb2NhbFZhcnM6W119LGJvZHk6e2JvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPHRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixhcmdzOlt7bmFtZTpcIl9pbmxpbmVfMV9hcmcwX1wiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6Mn0se25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ITEscnZhbHVlOiEwLGNvdW50OjJ9XSx0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxsb2NhbFZhcnM6W1wiX2lubGluZV8xX2tcIl19LHBvc3Q6e2JvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixhcmdzOltdLHRoaXNWYXJzOltcInRoaXNfaVwiXSxsb2NhbFZhcnM6W119fSksZS5hcmdtYXg9YSh7YXJnczpbXCJpbmRleFwiLFwiYXJyYXlcIixcInNoYXBlXCJdLHByZTp7Ym9keTpcInt0aGlzX3Y9LUluZmluaXR5O3RoaXNfaT1faW5saW5lXzBfYXJnMl8uc2xpY2UoMCl9XCIsYXJnczpbe25hbWU6XCJfaW5saW5lXzBfYXJnMF9cIixsdmFsdWU6ITEscnZhbHVlOiExLGNvdW50OjB9LHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOiExLHJ2YWx1ZTohMSxjb3VudDowfSx7bmFtZTpcIl9pbmxpbmVfMF9hcmcyX1wiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6MX1dLHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLGxvY2FsVmFyczpbXX0sYm9keTp7Ym9keTpcIntpZihfaW5saW5lXzFfYXJnMV8+dGhpc192KXt0aGlzX3Y9X2lubGluZV8xX2FyZzFfO2Zvcih2YXIgX2lubGluZV8xX2s9MDtfaW5saW5lXzFfazxfaW5saW5lXzFfYXJnMF8ubGVuZ3RoOysrX2lubGluZV8xX2spe3RoaXNfaVtfaW5saW5lXzFfa109X2lubGluZV8xX2FyZzBfW19pbmxpbmVfMV9rXX19fVwiLGFyZ3M6W3tuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOiExLHJ2YWx1ZTohMCxjb3VudDoyfSx7bmFtZTpcIl9pbmxpbmVfMV9hcmcxX1wiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6Mn1dLHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0scG9zdDp7Ym9keTpcIntyZXR1cm4gdGhpc19pfVwiLGFyZ3M6W10sdGhpc1ZhcnM6W1widGhpc19pXCJdLGxvY2FsVmFyczpbXX19KSxlLnJhbmRvbT1pKHthcmdzOltcImFycmF5XCJdLHByZTp7YXJnczpbXSxib2R5OlwidGhpc19mPU1hdGgucmFuZG9tXCIsdGhpc1ZhcnM6W1widGhpc19mXCJdfSxib2R5OnthcmdzOltcImFcIl0sYm9keTpcImE9dGhpc19mKClcIix0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LGZ1bmNOYW1lOlwicmFuZG9tXCJ9KSxlLmFzc2lnbj1pKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiXSxib2R5OnthcmdzOltcImFcIixcImJcIl0sYm9keTpcImE9YlwifSxmdW5jTmFtZTpcImFzc2lnblwifSksZS5hc3NpZ25zPWkoe2FyZ3M6W1wiYXJyYXlcIixcInNjYWxhclwiXSxib2R5OnthcmdzOltcImFcIixcImJcIl0sYm9keTpcImE9YlwifSxmdW5jTmFtZTpcImFzc2lnbnNcIn0pLGUuZXF1YWxzPWEoe2FyZ3M6W1wiYXJyYXlcIixcImFycmF5XCJdLHByZTpzLGJvZHk6e2FyZ3M6W3tuYW1lOlwieFwiLGx2YWx1ZTohMSxydmFsdWU6ITAsY291bnQ6MX0se25hbWU6XCJ5XCIsbHZhbHVlOiExLHJ2YWx1ZTohMCxjb3VudDoxfV0sYm9keTpcImlmKHghPT15KXtyZXR1cm4gZmFsc2V9XCIsbG9jYWxWYXJzOltdLHRoaXNWYXJzOltdfSxwb3N0OnthcmdzOltdLGxvY2FsVmFyczpbXSx0aGlzVmFyczpbXSxib2R5OlwicmV0dXJuIHRydWVcIn0sZnVuY05hbWU6XCJlcXVhbHNcIn0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoIXIodCkpdGhyb3cgVHlwZUVycm9yKHQrXCIgaXMgbm90IGFuIG9iamVjdCFcIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUpe3ZhciBuPXQuZXhwb3J0cz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcIm51bWJlclwiPT10eXBlb2YgX19nJiYoX19nPW4pfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2godCl7cmV0dXJuITB9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/bnVsbCE9PXQ6XCJmdW5jdGlvblwiPT10eXBlb2YgdH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDc4KShcIndrc1wiKSxvPW4oNDcpLGk9big1KS5TeW1ib2wsYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpLHM9dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiByW3RdfHwoclt0XT1hJiZpW3RdfHwoYT9pOm8pKFwiU3ltYm9sLlwiK3QpKX07cy5zdG9yZT1yfSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPSFuKDYpKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0KSxvPW4oMTQ2KSxpPW4oMjgpLGE9T2JqZWN0LmRlZmluZVByb3BlcnR5O2UuZj1uKDkpP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbih0LGUsbil7aWYocih0KSxlPWkoZSwhMCkscihuKSxvKXRyeXtyZXR1cm4gYSh0LGUsbil9Y2F0Y2godCl7fWlmKFwiZ2V0XCJpbiBufHxcInNldFwiaW4gbil0aHJvdyBUeXBlRXJyb3IoXCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCFcIik7cmV0dXJuXCJ2YWx1ZVwiaW4gbiYmKHRbZV09bi52YWx1ZSksdH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDM3KSxvPU1hdGgubWluO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdD4wP28ocih0KSw5MDA3MTk5MjU0NzQwOTkxKTowfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjMpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KHIodCkpfX0sZnVuY3Rpb24odCxlKXt2YXIgbj17fS5oYXNPd25Qcm9wZXJ0eTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5jYWxsKHQsZSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIGZ1bmN0aW9uIVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEwKSxvPW4oMzYpO3QuZXhwb3J0cz1uKDkpP2Z1bmN0aW9uKHQsZSxuKXtyZXR1cm4gci5mKHQsZSxvKDEsbikpfTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRbZV09bix0fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNSksbz1uKDE1KSxpPW4oMTMpLGE9big0NykoXCJzcmNcIikscz1cInRvU3RyaW5nXCIsdT1GdW5jdGlvbltzXSxsPShcIlwiK3UpLnNwbGl0KHMpO24oMzEpLmluc3BlY3RTb3VyY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHUuY2FsbCh0KX0sKHQuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixzKXt2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuO3UmJihpKG4sXCJuYW1lXCIpfHxvKG4sXCJuYW1lXCIsZSkpLHRbZV0hPT1uJiYodSYmKGkobixhKXx8byhuLGEsdFtlXT9cIlwiK3RbZV06bC5qb2luKFN0cmluZyhlKSkpKSx0PT09cj90W2VdPW46cz90W2VdP3RbZV09bjpvKHQsZSxuKTooZGVsZXRlIHRbZV0sbyh0LGUsbikpKX0pKEZ1bmN0aW9uLnByb3RvdHlwZSxzLGZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcyYmdGhpc1thXXx8dS5jYWxsKHRoaXMpfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89big2KSxpPW4oMjMpLGE9L1wiL2cscz1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1TdHJpbmcoaSh0KSkscz1cIjxcIitlO3JldHVyblwiXCIhPT1uJiYocys9XCIgXCIrbisnPVwiJytTdHJpbmcocikucmVwbGFjZShhLFwiJnF1b3Q7XCIpKydcIicpLHMrXCI+XCIrbytcIjwvXCIrZStcIj5cIn07dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49e307blt0XT1lKHMpLHIoci5QK3IuRipvKGZ1bmN0aW9uKCl7dmFyIGU9XCJcIlt0XSgnXCInKTtyZXR1cm4gZSE9PWUudG9Mb3dlckNhc2UoKXx8ZS5zcGxpdCgnXCInKS5sZW5ndGg+M30pLFwiU3RyaW5nXCIsbil9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1OSksbz1uKDIzKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHIobyh0KSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZigxPT09dC50ZW5zb3Iuc2hhcGUubGVuZ3RoKXt2YXIgZT1oLmRlZmF1bHQuc3VwKHQudGVuc29yKTtoLmRlZmF1bHQuc3Vic2VxKHQudGVuc29yLGUpLGguZGVmYXVsdC5leHBlcSh0LnRlbnNvcik7dmFyIG49aC5kZWZhdWx0LnN1bSh0LnRlbnNvcik7aC5kZWZhdWx0LmRpdnNlcSh0LnRlbnNvcixuKX1lbHNle2lmKDIhPT10LnRlbnNvci5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiW2FjdGl2YXRpb25zLnNvZnRtYXhdIHRlbnNvciBzaGFwZSBcIit0LnRlbnNvci5zaGFwZStcIiBub3Qgc3VwcG9ydGVkLlwiKTtmb3IodmFyIHI9MDtyPHQudGVuc29yLnNoYXBlWzBdO3IrKyl7dmFyIG89aC5kZWZhdWx0LnN1cCh0LnRlbnNvci5waWNrKHIsbnVsbCkpO2guZGVmYXVsdC5zdWJzZXEodC50ZW5zb3IucGljayhyLG51bGwpLG8pLGguZGVmYXVsdC5leHBlcSh0LnRlbnNvci5waWNrKHIsbnVsbCkpO3ZhciBpPWguZGVmYXVsdC5zdW0odC50ZW5zb3IucGljayhyLG51bGwpKTtoLmRlZmF1bHQuZGl2c2VxKHQudGVuc29yLnBpY2socixudWxsKSxpKX19cmV0dXJuIHRoaXN9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gZyh0LnRlbnNvciksdGhpc31mdW5jdGlvbiBhKHQpe3JldHVybiB5KHQudGVuc29yKSx0aGlzfWZ1bmN0aW9uIHModCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49ZS5hbHBoYSxyPXZvaWQgMD09PW4/MDpuLG89ZS5tYXhWYWx1ZSxpPXZvaWQgMD09PW8/bnVsbDpvLGE9dm9pZCAwO3JldHVybiAwIT09ciYmKGE9bmV3IF8uZGVmYXVsdChbXSx0LnRlbnNvci5zaGFwZSksaC5kZWZhdWx0Lm1pbnMoYS50ZW5zb3IsdC50ZW5zb3IsMCksaC5kZWZhdWx0Lm11bHNlcShhLnRlbnNvcixyKSksaC5kZWZhdWx0Lm1heHNlcSh0LnRlbnNvciwwKSxpJiZoLmRlZmF1bHQubWluc2VxKHQudGVuc29yLGkpLGEmJmguZGVmYXVsdC5hZGRlcSh0LnRlbnNvcixhLnRlbnNvciksdGhpc31mdW5jdGlvbiB1KHQpe3JldHVybiBiKHQudGVuc29yKSx0aGlzfWZ1bmN0aW9uIGwodCl7cmV0dXJuIHcodC50ZW5zb3IpLHRoaXN9ZnVuY3Rpb24gYyh0KXtyZXR1cm4geCh0LnRlbnNvciksdGhpc31mdW5jdGlvbiBmKHQpe3JldHVybiB0aGlzfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc29mdG1heD1vLGUuc29mdHBsdXM9aSxlLnNvZnRzaWduPWEsZS5yZWx1PXMsZS50YW5oPXUsZS5zaWdtb2lkPWwsZS5oYXJkU2lnbW9pZD1jLGUubGluZWFyPWY7dmFyIHA9bigzKSxoPXIocCksZD1uKDI1KSx2PXIoZCksbT1uKDIpLF89cihtKSxnPSgwLHYuZGVmYXVsdCkoe2FyZ3M6W1wiYXJyYXlcIl0sYm9keTpmdW5jdGlvbih0KXt0PU1hdGgubG9nKE1hdGguZXhwKHQpKzEpfX0pLHk9KDAsdi5kZWZhdWx0KSh7YXJnczpbXCJhcnJheVwiXSxib2R5OmZ1bmN0aW9uKHQpe3QvPTErTWF0aC5hYnModCl9fSksYj0oMCx2LmRlZmF1bHQpKHthcmdzOltcImFycmF5XCJdLGJvZHk6ZnVuY3Rpb24odCl7dD1NYXRoLnRhbmgodCl9fSksdz0oMCx2LmRlZmF1bHQpKHthcmdzOltcImFycmF5XCJdLGJvZHk6ZnVuY3Rpb24odCl7dD0xLygxK01hdGguZXhwKC10KSl9fSkseD0oMCx2LmRlZmF1bHQpKHthcmdzOltcImFycmF5XCJdLGJvZHk6ZnVuY3Rpb24odCl7dD0uMip0Ky41LHQ8PTA/dD0wOnQ+PTEmJih0PTEpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big2MCksbz1uKDM2KSxpPW4oMTgpLGE9bigyOCkscz1uKDEzKSx1PW4oMTQ2KSxsPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPW4oOSk/bDpmdW5jdGlvbih0LGUpe2lmKHQ9aSh0KSxlPWEoZSwhMCksdSl0cnl7cmV0dXJuIGwodCxlKX1jYXRjaCh0KXt9aWYocyh0LGUpKXJldHVybiBvKCFyLmYuY2FsbCh0LGUpLHRbZV0pfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTMpLG89bigxMiksaT1uKDEwOCkoXCJJRV9QUk9UT1wiKSxhPU9iamVjdC5wcm90b3R5cGU7dC5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCl7cmV0dXJuIHQ9byh0KSxyKHQsaSk/dFtpXTpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmNvbnN0cnVjdG9yJiZ0IGluc3RhbmNlb2YgdC5jb25zdHJ1Y3Rvcj90LmNvbnN0cnVjdG9yLnByb3RvdHlwZTp0IGluc3RhbmNlb2YgT2JqZWN0P2E6bnVsbH19LGZ1bmN0aW9uKHQsZSl7dmFyIG49e30udG9TdHJpbmc7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBuLmNhbGwodCkuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih2b2lkIDA9PXQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISF0JiZyKGZ1bmN0aW9uKCl7ZT90LmNhbGwobnVsbCxmdW5jdGlvbigpe30sMSk6dC5jYWxsKG51bGwpfSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtmb3IodmFyIGUgaW4gdClhLmluZGV4T2YoZSk8MCYmcy5pbmRleE9mKGUpPDAmJmNvbnNvbGUud2FybihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50ICdcIitlK1wiJyBwYXNzZWQgdG8gZXhwcmVzc2lvbiBjb21waWxlclwiKTtmb3IodmFyIG49MDtuPGEubGVuZ3RoOysrbilpZighdFthW25dXSl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTWlzc2luZyBhcmd1bWVudDogXCIrYVtuXSk7cmV0dXJuIGkoe2FyZ3M6dC5hcmdzLHByZTpvKHQucHJlfHxmdW5jdGlvbigpe30pLGJvZHk6byh0LmJvZHkpLHBvc3Q6byh0LnBvc3R8fGZ1bmN0aW9uKCl7fSksZGVidWc6ISF0LnByaW50Q29kZSxmdW5jTmFtZTp0LmZ1bmNOYW1lfHx0LmJvZHkubmFtZXx8XCJjd2lzZVwiLGJsb2NrU2l6ZTp0LmJsb2NrU2l6ZXx8NjR9KX12YXIgbz1uKDQ1MCksaT1uKDE2NiksYT1bXCJhcmdzXCIsXCJib2R5XCJdLHM9W1wicHJlXCIsXCJwb3N0XCIsXCJwcmludENvZGVcIixcImZ1bmNOYW1lXCIsXCJibG9ja1NpemVcIl07dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDMyKSxvPW4oNTkpLGk9bigxMiksYT1uKDExKSxzPW4oMjY5KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgbj0xPT10LHU9Mj09dCxsPTM9PXQsYz00PT10LGY9Nj09dCxwPTU9PXR8fGYsaD1lfHxzO3JldHVybiBmdW5jdGlvbihlLHMsZCl7Zm9yKHZhciB2LG0sXz1pKGUpLGc9byhfKSx5PXIocyxkLDMpLGI9YShnLmxlbmd0aCksdz0wLHg9bj9oKGUsYik6dT9oKGUsMCk6dm9pZCAwO2I+dzt3KyspaWYoKHB8fHcgaW4gZykmJih2PWdbd10sbT15KHYsdyxfKSx0KSlpZihuKXhbd109bTtlbHNlIGlmKG0pc3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIHY7Y2FzZSA2OnJldHVybiB3O2Nhc2UgMjp4LnB1c2godil9ZWxzZSBpZihjKXJldHVybiExO3JldHVybiBmPy0xOmx8fGM/Yzp4fX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigzMSksaT1uKDYpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuPShvLk9iamVjdHx8e30pW3RdfHxPYmplY3RbdF0sYT17fTthW3RdPWUobikscihyLlMrci5GKmkoZnVuY3Rpb24oKXtuKDEpfSksXCJPYmplY3RcIixhKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKCFyKHQpKXJldHVybiB0O3ZhciBuLG87aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2Yobj10LnRvU3RyaW5nKSYmIXIobz1uLmNhbGwodCkpKXJldHVybiBvO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mKG49dC52YWx1ZU9mKSYmIXIobz1uLmNhbGwodCkpKXJldHVybiBvO2lmKCFlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihuPXQudG9TdHJpbmcpJiYhcihvPW4uY2FsbCh0KSkpcmV0dXJuIG87dGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTc1KSxvPVwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmJiZzZWxmLk9iamVjdD09PU9iamVjdCYmc2VsZixpPXJ8fG98fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTt0LmV4cG9ydHM9aX0sZnVuY3Rpb24odCxlKXt2YXIgbj1BcnJheS5pc0FycmF5O3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe3ZhciBuPXQuZXhwb3J0cz17dmVyc2lvbjpcIjIuNC4wXCJ9O1wibnVtYmVyXCI9PXR5cGVvZiBfX2UmJihfX2U9bil9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE0KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2lmKHIodCksdm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2gobil7Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gdC5jYWxsKGUsbil9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24obixyKXtyZXR1cm4gdC5jYWxsKGUsbixyKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQuY2FsbChlLG4scixvKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE2Miksbz1uKDApLGk9big3OCkoXCJtZXRhZGF0YVwiKSxhPWkuc3RvcmV8fChpLnN0b3JlPW5ldyhuKDE2NSkpKSxzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgbz1hLmdldCh0KTtpZighbyl7aWYoIW4pcmV0dXJuO2Euc2V0KHQsbz1uZXcgcil9dmFyIGk9by5nZXQoZSk7aWYoIWkpe2lmKCFuKXJldHVybjtvLnNldChlLGk9bmV3IHIpfXJldHVybiBpfSx1PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1zKGUsbiwhMSk7cmV0dXJuIHZvaWQgMCE9PXImJnIuaGFzKHQpfSxsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1zKGUsbiwhMSk7cmV0dXJuIHZvaWQgMD09PXI/dm9pZCAwOnIuZ2V0KHQpfSxjPWZ1bmN0aW9uKHQsZSxuLHIpe3MobixyLCEwKS5zZXQodCxlKX0sZj1mdW5jdGlvbih0LGUpe3ZhciBuPXModCxlLCExKSxyPVtdO3JldHVybiBuJiZuLmZvckVhY2goZnVuY3Rpb24odCxlKXtyLnB1c2goZSl9KSxyfSxwPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10fHxcInN5bWJvbFwiPT10eXBlb2YgdD90OlN0cmluZyh0KX0saD1mdW5jdGlvbih0KXtvKG8uUyxcIlJlZmxlY3RcIix0KX07dC5leHBvcnRzPXtzdG9yZTphLG1hcDpzLGhhczp1LGdldDpsLHNldDpjLGtleXM6ZixrZXk6cCxleHA6aH19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtpZihuKDkpKXt2YXIgcj1uKDQwKSxvPW4oNSksaT1uKDYpLGE9bigwKSxzPW4oNzkpLHU9bigxMTUpLGw9bigzMiksYz1uKDM5KSxmPW4oMzYpLHA9bigxNSksaD1uKDQ0KSxkPW4oMzcpLHY9bigxMSksbT1uKDQ2KSxfPW4oMjgpLGc9bigxMykseT1uKDE1OSksYj1uKDU4KSx3PW4oNykseD1uKDEyKSxFPW4oMTAwKSxUPW4oNDEpLE89bigyMSksUz1uKDQyKS5mLFA9bigxMTcpLE09big0Nyksaj1uKDgpLEE9bigyNiksQz1uKDY5KSxrPW4oMTA5KSxSPW4oMTE4KSxJPW4oNTIpLE49big3NSksVT1uKDQ1KSxGPW4oOTMpLEw9bigxMzkpLEQ9bigxMCksQj1uKDIwKSxWPUQuZixXPUIuZixYPW8uUmFuZ2VFcnJvcix6PW8uVHlwZUVycm9yLEc9by5VaW50OEFycmF5LHE9XCJBcnJheUJ1ZmZlclwiLEg9XCJTaGFyZWRcIitxLFk9XCJCWVRFU19QRVJfRUxFTUVOVFwiLEs9XCJwcm90b3R5cGVcIiwkPUFycmF5W0tdLFo9dS5BcnJheUJ1ZmZlcixRPXUuRGF0YVZpZXcsSj1BKDApLHR0PUEoMiksZXQ9QSgzKSxudD1BKDQpLHJ0PUEoNSksb3Q9QSg2KSxpdD1DKCEwKSxhdD1DKCExKSxzdD1SLnZhbHVlcyx1dD1SLmtleXMsbHQ9Ui5lbnRyaWVzLGN0PSQubGFzdEluZGV4T2YsZnQ9JC5yZWR1Y2UscHQ9JC5yZWR1Y2VSaWdodCxodD0kLmpvaW4sZHQ9JC5zb3J0LHZ0PSQuc2xpY2UsbXQ9JC50b1N0cmluZyxfdD0kLnRvTG9jYWxlU3RyaW5nLGd0PWooXCJpdGVyYXRvclwiKSx5dD1qKFwidG9TdHJpbmdUYWdcIiksYnQ9TShcInR5cGVkX2NvbnN0cnVjdG9yXCIpLHd0PU0oXCJkZWZfY29uc3RydWN0b3JcIikseHQ9cy5DT05TVFIsRXQ9cy5UWVBFRCxUdD1zLlZJRVcsT3Q9XCJXcm9uZyBsZW5ndGghXCIsU3Q9QSgxLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGt0KGsodCx0W3d0XSksZSl9KSxQdD1pKGZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1uZXcgRyhuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdfSksTXQ9ISFHJiYhIUdbS10uc2V0JiZpKGZ1bmN0aW9uKCl7bmV3IEcoMSkuc2V0KHt9KX0pLGp0PWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dCl0aHJvdyB6KE90KTt2YXIgbj0rdCxyPXYodCk7aWYoZSYmIXkobixyKSl0aHJvdyBYKE90KTtyZXR1cm4gcn0sQXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1kKHQpO2lmKG48MHx8biVlKXRocm93IFgoXCJXcm9uZyBvZmZzZXQhXCIpO3JldHVybiBufSxDdD1mdW5jdGlvbih0KXtpZih3KHQpJiZFdCBpbiB0KXJldHVybiB0O3Rocm93IHoodCtcIiBpcyBub3QgYSB0eXBlZCBhcnJheSFcIil9LGt0PWZ1bmN0aW9uKHQsZSl7aWYoISh3KHQpJiZidCBpbiB0KSl0aHJvdyB6KFwiSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhXCIpO3JldHVybiBuZXcgdChlKX0sUnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSXQoayh0LHRbd3RdKSxlKX0sSXQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxyPWUubGVuZ3RoLG89a3QodCxyKTtyPm47KW9bbl09ZVtuKytdO3JldHVybiBvfSxOdD1mdW5jdGlvbih0LGUsbil7Vih0LGUse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kW25dfX0pfSxVdD1mdW5jdGlvbih0KXt2YXIgZSxuLHIsbyxpLGEscz14KHQpLHU9YXJndW1lbnRzLmxlbmd0aCxjPXU+MT9hcmd1bWVudHNbMV06dm9pZCAwLGY9dm9pZCAwIT09YyxwPVAocyk7aWYodm9pZCAwIT1wJiYhRShwKSl7Zm9yKGE9cC5jYWxsKHMpLHI9W10sZT0wOyEoaT1hLm5leHQoKSkuZG9uZTtlKyspci5wdXNoKGkudmFsdWUpO3M9cn1mb3IoZiYmdT4yJiYoYz1sKGMsYXJndW1lbnRzWzJdLDIpKSxlPTAsbj12KHMubGVuZ3RoKSxvPWt0KHRoaXMsbik7bj5lO2UrKylvW2VdPWY/YyhzW2VdLGUpOnNbZV07cmV0dXJuIG99LEZ0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT1hcmd1bWVudHMubGVuZ3RoLG49a3QodGhpcyxlKTtlPnQ7KW5bdF09YXJndW1lbnRzW3QrK107cmV0dXJuIG59LEx0PSEhRyYmaShmdW5jdGlvbigpe190LmNhbGwobmV3IEcoMSkpfSksRHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX3QuYXBwbHkoTHQ/dnQuY2FsbChDdCh0aGlzKSk6Q3QodGhpcyksYXJndW1lbnRzKX0sQnQ9e2NvcHlXaXRoaW46ZnVuY3Rpb24odCxlKXtyZXR1cm4gTC5jYWxsKEN0KHRoaXMpLHQsZSxhcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMCl9LGV2ZXJ5OmZ1bmN0aW9uKHQpe3JldHVybiBudChDdCh0aGlzKSx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX0sZmlsbDpmdW5jdGlvbih0KXtyZXR1cm4gRi5hcHBseShDdCh0aGlzKSxhcmd1bWVudHMpfSxmaWx0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIFJ0KHRoaXMsdHQoQ3QodGhpcyksdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCkpfSxmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiBydChDdCh0aGlzKSx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX0sZmluZEluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiBvdChDdCh0aGlzKSx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX0sZm9yRWFjaDpmdW5jdGlvbih0KXtKKEN0KHRoaXMpLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfSxpbmRleE9mOmZ1bmN0aW9uKHQpe3JldHVybiBhdChDdCh0aGlzKSx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX0saW5jbHVkZXM6ZnVuY3Rpb24odCl7cmV0dXJuIGl0KEN0KHRoaXMpLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfSxqb2luOmZ1bmN0aW9uKHQpe3JldHVybiBodC5hcHBseShDdCh0aGlzKSxhcmd1bWVudHMpfSxsYXN0SW5kZXhPZjpmdW5jdGlvbih0KXtyZXR1cm4gY3QuYXBwbHkoQ3QodGhpcyksYXJndW1lbnRzKX0sbWFwOmZ1bmN0aW9uKHQpe3JldHVybiBTdChDdCh0aGlzKSx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX0scmVkdWNlOmZ1bmN0aW9uKHQpe3JldHVybiBmdC5hcHBseShDdCh0aGlzKSxhcmd1bWVudHMpfSxyZWR1Y2VSaWdodDpmdW5jdGlvbih0KXtyZXR1cm4gcHQuYXBwbHkoQ3QodGhpcyksYXJndW1lbnRzKX0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdCxlPXRoaXMsbj1DdChlKS5sZW5ndGgscj1NYXRoLmZsb29yKG4vMiksbz0wO288cjspdD1lW29dLGVbbysrXT1lWy0tbl0sZVtuXT10O3JldHVybiBlfSxzb21lOmZ1bmN0aW9uKHQpe3JldHVybiBldChDdCh0aGlzKSx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX0sc29ydDpmdW5jdGlvbih0KXtyZXR1cm4gZHQuY2FsbChDdCh0aGlzKSx0KX0sc3ViYXJyYXk6ZnVuY3Rpb24odCxlKXt2YXIgbj1DdCh0aGlzKSxyPW4ubGVuZ3RoLG89bSh0LHIpO3JldHVybiBuZXcoayhuLG5bd3RdKSkobi5idWZmZXIsbi5ieXRlT2Zmc2V0K28qbi5CWVRFU19QRVJfRUxFTUVOVCx2KCh2b2lkIDA9PT1lP3I6bShlLHIpKS1vKSl9fSxWdD1mdW5jdGlvbih0LGUpe3JldHVybiBSdCh0aGlzLHZ0LmNhbGwoQ3QodGhpcyksdCxlKSl9LFd0PWZ1bmN0aW9uKHQpe0N0KHRoaXMpO3ZhciBlPUF0KGFyZ3VtZW50c1sxXSwxKSxuPXRoaXMubGVuZ3RoLHI9eCh0KSxvPXYoci5sZW5ndGgpLGk9MDtpZihvK2U+bil0aHJvdyBYKE90KTtmb3IoO2k8bzspdGhpc1tlK2ldPXJbaSsrXX0sWHQ9e2VudHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gbHQuY2FsbChDdCh0aGlzKSl9LGtleXM6ZnVuY3Rpb24oKXtyZXR1cm4gdXQuY2FsbChDdCh0aGlzKSl9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiBzdC5jYWxsKEN0KHRoaXMpKX19LHp0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCkmJnRbRXRdJiZcInN5bWJvbFwiIT10eXBlb2YgZSYmZSBpbiB0JiZTdHJpbmcoK2UpPT1TdHJpbmcoZSl9LEd0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHp0KHQsZT1fKGUsITApKT9mKDIsdFtlXSk6Vyh0LGUpfSxxdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuISh6dCh0LGU9XyhlLCEwKSkmJncobikmJmcobixcInZhbHVlXCIpKXx8ZyhuLFwiZ2V0XCIpfHxnKG4sXCJzZXRcIil8fG4uY29uZmlndXJhYmxlfHxnKG4sXCJ3cml0YWJsZVwiKSYmIW4ud3JpdGFibGV8fGcobixcImVudW1lcmFibGVcIikmJiFuLmVudW1lcmFibGU/Vih0LGUsbik6KHRbZV09bi52YWx1ZSx0KX07eHR8fChCLmY9R3QsRC5mPXF0KSxhKGEuUythLkYqIXh0LFwiT2JqZWN0XCIse2dldE93blByb3BlcnR5RGVzY3JpcHRvcjpHdCxkZWZpbmVQcm9wZXJ0eTpxdH0pLGkoZnVuY3Rpb24oKXttdC5jYWxsKHt9KX0pJiYobXQ9X3Q9ZnVuY3Rpb24oKXtyZXR1cm4gaHQuY2FsbCh0aGlzKX0pO3ZhciBIdD1oKHt9LEJ0KTtoKEh0LFh0KSxwKEh0LGd0LFh0LnZhbHVlcyksaChIdCx7c2xpY2U6VnQsc2V0Old0LGNvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7fSx0b1N0cmluZzptdCx0b0xvY2FsZVN0cmluZzpEdH0pLE50KEh0LFwiYnVmZmVyXCIsXCJiXCIpLE50KEh0LFwiYnl0ZU9mZnNldFwiLFwib1wiKSxOdChIdCxcImJ5dGVMZW5ndGhcIixcImxcIiksTnQoSHQsXCJsZW5ndGhcIixcImVcIiksVihIdCx5dCx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbRXRdfX0pLHQuZXhwb3J0cz1mdW5jdGlvbih0LGUsbix1KXt1PSEhdTt2YXIgbD10Kyh1P1wiQ2xhbXBlZFwiOlwiXCIpK1wiQXJyYXlcIixmPVwiVWludDhBcnJheVwiIT1sLGg9XCJnZXRcIit0LGQ9XCJzZXRcIit0LG09b1tsXSxfPW18fHt9LGc9bSYmTyhtKSx5PSFtfHwhcy5BQlYseD17fSxFPW0mJm1bS10sUD1mdW5jdGlvbih0LG4pe3ZhciByPXQuX2Q7cmV0dXJuIHIudltoXShuKmUrci5vLFB0KX0sTT1mdW5jdGlvbih0LG4scil7dmFyIG89dC5fZDt1JiYocj0ocj1NYXRoLnJvdW5kKHIpKTwwPzA6cj4yNTU/MjU1OjI1NSZyKSxvLnZbZF0obiplK28ubyxyLFB0KX0saj1mdW5jdGlvbih0LGUpe1YodCxlLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUCh0aGlzLGUpfSxzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIE0odGhpcyxlLHQpfSxlbnVtZXJhYmxlOiEwfSl9O3k/KG09bihmdW5jdGlvbih0LG4scixvKXtjKHQsbSxsLFwiX2RcIik7dmFyIGksYSxzLHUsZj0wLGg9MDtpZih3KG4pKXtpZighKG4gaW5zdGFuY2VvZiBafHwodT1iKG4pKT09cXx8dT09SCkpcmV0dXJuIEV0IGluIG4/SXQobSxuKTpVdC5jYWxsKG0sbik7aT1uLGg9QXQocixlKTt2YXIgZD1uLmJ5dGVMZW5ndGg7aWYodm9pZCAwPT09byl7aWYoZCVlKXRocm93IFgoT3QpO2lmKGE9ZC1oLGE8MCl0aHJvdyBYKE90KX1lbHNlIGlmKGE9dihvKSplLGEraD5kKXRocm93IFgoT3QpO3M9YS9lfWVsc2Ugcz1qdChuLCEwKSxhPXMqZSxpPW5ldyBaKGEpO2ZvcihwKHQsXCJfZFwiLHtiOmksbzpoLGw6YSxlOnMsdjpuZXcgUShpKX0pO2Y8czspaih0LGYrKyl9KSxFPW1bS109VChIdCkscChFLFwiY29uc3RydWN0b3JcIixtKSk6TihmdW5jdGlvbih0KXtuZXcgbShudWxsKSxuZXcgbSh0KX0sITApfHwobT1uKGZ1bmN0aW9uKHQsbixyLG8pe2ModCxtLGwpO3ZhciBpO3JldHVybiB3KG4pP24gaW5zdGFuY2VvZiBafHwoaT1iKG4pKT09cXx8aT09SD92b2lkIDAhPT1vP25ldyBfKG4sQXQocixlKSxvKTp2b2lkIDAhPT1yP25ldyBfKG4sQXQocixlKSk6bmV3IF8obik6RXQgaW4gbj9JdChtLG4pOlV0LmNhbGwobSxuKTpuZXcgXyhqdChuLGYpKX0pLEooZyE9PUZ1bmN0aW9uLnByb3RvdHlwZT9TKF8pLmNvbmNhdChTKGcpKTpTKF8pLGZ1bmN0aW9uKHQpe3QgaW4gbXx8cChtLHQsX1t0XSl9KSxtW0tdPUUscnx8KEUuY29uc3RydWN0b3I9bSkpO3ZhciBBPUVbZ3RdLEM9ISFBJiYoXCJ2YWx1ZXNcIj09QS5uYW1lfHx2b2lkIDA9PUEubmFtZSksaz1YdC52YWx1ZXM7cChtLGJ0LCEwKSxwKEUsRXQsbCkscChFLFR0LCEwKSxwKEUsd3QsbSksKHU/bmV3IG0oMSlbeXRdPT1sOnl0IGluIEUpfHxWKEUseXQse2dldDpmdW5jdGlvbigpe3JldHVybiBsfX0pLHhbbF09bSxhKGEuRythLlcrYS5GKihtIT1fKSx4KSxhKGEuUyxsLHtCWVRFU19QRVJfRUxFTUVOVDplLGZyb206VXQsb2Y6RnR9KSxZIGluIEV8fHAoRSxZLGUpLGEoYS5QLGwsQnQpLFUobCksYShhLlArYS5GKk10LGwse3NldDpXdH0pLGEoYS5QK2EuRiohQyxsLFh0KSxhKGEuUCthLkYqKEUudG9TdHJpbmchPW10KSxsLHt0b1N0cmluZzptdH0pLGEoYS5QK2EuRippKGZ1bmN0aW9uKCl7bmV3IG0oMSkuc2xpY2UoKX0pLGwse3NsaWNlOlZ0fSksYShhLlArYS5GKihpKGZ1bmN0aW9uKCl7cmV0dXJuWzEsMl0udG9Mb2NhbGVTdHJpbmcoKSE9bmV3IG0oWzEsMl0pLnRvTG9jYWxlU3RyaW5nKCl9KXx8IWkoZnVuY3Rpb24oKXtFLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsMl0pfSkpLGwse3RvTG9jYWxlU3RyaW5nOkR0fSksSVtsXT1DP0E6ayxyfHxDfHxwKEUsZ3Qsayl9fWVsc2UgdC5leHBvcnRzPWZ1bmN0aW9uKCl7fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNDcpKFwibWV0YVwiKSxvPW4oNyksaT1uKDEzKSxhPW4oMTApLmYscz0wLHU9T2JqZWN0LmlzRXh0ZW5zaWJsZXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbD0hbig2KShmdW5jdGlvbigpe3JldHVybiB1KE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSksYz1mdW5jdGlvbih0KXthKHQscix7dmFsdWU6e2k6XCJPXCIrICsrcyx3Ont9fX0pfSxmPWZ1bmN0aW9uKHQsZSl7aWYoIW8odCkpcmV0dXJuXCJzeW1ib2xcIj09dHlwZW9mIHQ/dDooXCJzdHJpbmdcIj09dHlwZW9mIHQ/XCJTXCI6XCJQXCIpK3Q7aWYoIWkodCxyKSl7aWYoIXUodCkpcmV0dXJuXCJGXCI7aWYoIWUpcmV0dXJuXCJFXCI7Yyh0KX1yZXR1cm4gdFtyXS5pfSxwPWZ1bmN0aW9uKHQsZSl7aWYoIWkodCxyKSl7aWYoIXUodCkpcmV0dXJuITA7aWYoIWUpcmV0dXJuITE7Yyh0KX1yZXR1cm4gdFtyXS53fSxoPWZ1bmN0aW9uKHQpe3JldHVybiBsJiZkLk5FRUQmJnUodCkmJiFpKHQscikmJmModCksdH0sZD10LmV4cG9ydHM9e0tFWTpyLE5FRUQ6ITEsZmFzdEtleTpmLGdldFdlYWs6cCxvbkZyZWV6ZTpofX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19fSxmdW5jdGlvbih0LGUpe3ZhciBuPU1hdGguY2VpbCxyPU1hdGguZmxvb3I7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpc05hTih0PSt0KT8wOih0PjA/cjpuKSh0KX19LGZ1bmN0aW9uKHQsZSl7dmFyIG47bj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtuPW58fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKXx8KDAsZXZhbCkoXCJ0aGlzXCIpfWNhdGNoKHQpe1wib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJihuPXdpbmRvdyl9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKCEodCBpbnN0YW5jZW9mIGUpfHx2b2lkIDAhPT1yJiZyIGluIHQpdGhyb3cgVHlwZUVycm9yKG4rXCI6IGluY29ycmVjdCBpbnZvY2F0aW9uIVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPSExfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0KSxvPW4oMTUyKSxpPW4oOTYpLGE9bigxMDgpKFwiSUVfUFJPVE9cIikscz1mdW5jdGlvbigpe30sdT1cInByb3RvdHlwZVwiLGw9ZnVuY3Rpb24oKXt2YXIgdCxlPW4oOTUpKFwiaWZyYW1lXCIpLHI9aS5sZW5ndGgsbz1cIjxcIixhPVwiPlwiO2ZvcihlLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsbig5OCkuYXBwZW5kQ2hpbGQoZSksZS5zcmM9XCJqYXZhc2NyaXB0OlwiLHQ9ZS5jb250ZW50V2luZG93LmRvY3VtZW50LHQub3BlbigpLHQud3JpdGUobytcInNjcmlwdFwiK2ErXCJkb2N1bWVudC5GPU9iamVjdFwiK28rXCIvc2NyaXB0XCIrYSksdC5jbG9zZSgpLGw9dC5GO3ItLTspZGVsZXRlIGxbdV1baVtyXV07cmV0dXJuIGwoKX07dC5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIG51bGwhPT10PyhzW3VdPXIodCksbj1uZXcgcyxzW3VdPW51bGwsblthXT10KTpuPWwoKSx2b2lkIDA9PT1lP246byhuLGUpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTU0KSxvPW4oOTYpLmNvbmNhdChcImxlbmd0aFwiLFwicHJvdG90eXBlXCIpO2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc3x8ZnVuY3Rpb24odCl7cmV0dXJuIHIodCxvKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE1NCksbz1uKDk2KTt0LmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3JldHVybiByKHQsbyl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIG8gaW4gZSlyKHQsbyxlW29dLG4pO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNSksbz1uKDEwKSxpPW4oOSksYT1uKDgpKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9clt0XTtpJiZlJiYhZVthXSYmby5mKGUsYSx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzfX0pfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMzcpLG89TWF0aC5tYXgsaT1NYXRoLm1pbjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD1yKHQpLHQ8MD9vKHQrZSwwKTppKHQsZSl9fSxmdW5jdGlvbih0LGUpe3ZhciBuPTAscj1NYXRoLnJhbmRvbSgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIlN5bWJvbChcIi5jb25jYXQodm9pZCAwPT09dD9cIlwiOnQsXCIpX1wiLCgrK24rcikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dmFyIG49aSh0LGUpO3JldHVybiBvKG4pP246dm9pZCAwfXZhciBvPW4oNDgwKSxpPW4oNTE4KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGEodCk/byh0KTppKHQpfXZhciBvPW4oNDY1KSxpPW4oNDgyKSxhPW4oODgpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big4KShcInVuc2NvcGFibGVzXCIpLG89QXJyYXkucHJvdG90eXBlO3ZvaWQgMD09b1tyXSYmbigxNSkobyxyLHt9KSx0LmV4cG9ydHM9ZnVuY3Rpb24odCl7XG5vW3JdW3RdPSEwfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMzIpLG89bigxNDgpLGk9bigxMDApLGE9big0KSxzPW4oMTEpLHU9bigxMTcpLGw9e30sYz17fSxlPXQuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixmLHApe3ZhciBoLGQsdixtLF89cD9mdW5jdGlvbigpe3JldHVybiB0fTp1KHQpLGc9cihuLGYsZT8yOjEpLHk9MDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBfKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBpdGVyYWJsZSFcIik7aWYoaShfKSl7Zm9yKGg9cyh0Lmxlbmd0aCk7aD55O3krKylpZihtPWU/ZyhhKGQ9dFt5XSlbMF0sZFsxXSk6Zyh0W3ldKSxtPT09bHx8bT09PWMpcmV0dXJuIG19ZWxzZSBmb3Iodj1fLmNhbGwodCk7IShkPXYubmV4dCgpKS5kb25lOylpZihtPW8odixnLGQudmFsdWUsZSksbT09PWx8fG09PT1jKXJldHVybiBtfTtlLkJSRUFLPWwsZS5SRVRVUk49Y30sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9e319LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEwKS5mLG89bigxMyksaT1uKDgpKFwidG9TdHJpbmdUYWdcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt0JiYhbyh0PW4/dDp0LnByb3RvdHlwZSxpKSYmcih0LGkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTplfSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMjMpLGk9big2KSxhPW4oMTEzKSxzPVwiW1wiK2ErXCJdXCIsdT1cIuKAi8KFXCIsbD1SZWdFeHAoXCJeXCIrcytzK1wiKlwiKSxjPVJlZ0V4cChzK3MrXCIqJFwiKSxmPWZ1bmN0aW9uKHQsZSxuKXt2YXIgbz17fSxzPWkoZnVuY3Rpb24oKXtyZXR1cm4hIWFbdF0oKXx8dVt0XSgpIT11fSksbD1vW3RdPXM/ZShwKTphW3RdO24mJihvW25dPWwpLHIoci5QK3IuRipzLFwiU3RyaW5nXCIsbyl9LHA9Zi50cmltPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9U3RyaW5nKG8odCkpLDEmZSYmKHQ9dC5yZXBsYWNlKGwsXCJcIikpLDImZSYmKHQ9dC5yZXBsYWNlKGMsXCJcIikpLHR9O3QuZXhwb3J0cz1mfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7dmFyIGU9dHlwZW9mIHQ7cmV0dXJuIG51bGwhPXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzLmdlbXY9big1OTQpLHQuZXhwb3J0cy5nYm12PW4oNTkzKSx0LmV4cG9ydHMuc3ltdj1uKDYwMCksdC5leHBvcnRzLnNibXY9big1OTYpLHQuZXhwb3J0cy5zcG12PW4oNTk3KSx0LmV4cG9ydHMudHJtdj1uKDYwNiksdC5leHBvcnRzLnRibXY9big2MDMpLHQuZXhwb3J0cy50cnN2PW4oNjA3KSx0LmV4cG9ydHMudGJzdj1uKDYwNCksdC5leHBvcnRzLnRwc3Y9big2MDUpLHQuZXhwb3J0cy5nZXI9big1OTUpLHQuZXhwb3J0cy5zeXI9big2MDEpLHQuZXhwb3J0cy5zcHI9big1OTgpLHQuZXhwb3J0cy5zeXIyPW4oNjAyKSx0LmV4cG9ydHMuc3ByMj1uKDU5OSksdC5leHBvcnRzLnRybXZfbG93ZXI9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gY29uc29sZS53YXJuKFwidHJtdl9sb3dlciBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSAnaXNMb3dlcicgZmxhZyB3aXRoIHRybXYuXCIpLHQuZXhwb3J0cy50cm12KGUsbiwhMCl9LHQuZXhwb3J0cy50cnN2X2xvd2VyPWZ1bmN0aW9uKGUsbil7cmV0dXJuIGNvbnNvbGUud2FybihcInRyc3ZfbG93ZXIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgJ2lzTG93ZXInIGZsYWcgd2l0aCB0cnN2LlwiKSx0LmV4cG9ydHMudHJzdihlLG4sITApfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlKXtzd2l0Y2godCl7Y2FzZVwiQ29udm9sdXRpb24yRFwiOnJldHVybltcImxpbmVhclwiLFwicmVsdVwiXS5pbmRleE9mKGUuYWN0aXZhdGlvbik+LTE7Y2FzZVwiQmF0Y2hOb3JtYWxpemF0aW9uXCI6cmV0dXJuIDA9PT1lLm1vZGU7Y2FzZVwiTWF4UG9vbGluZzJEXCI6Y2FzZVwiQXZlcmFnZVBvb2xpbmcyRFwiOnJldHVybiEwO2Nhc2VcIk1lcmdlXCI6cmV0dXJuW1wiY29uY2F0XCIsXCJzdW1cIixcIm11bFwiLFwiYXZlXCIsXCJtYXhcIl0uaW5kZXhPZihlLm1vZGUpPi0xO2RlZmF1bHQ6cmV0dXJuITF9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyMiksbz1uKDgpKFwidG9TdHJpbmdUYWdcIiksaT1cIkFyZ3VtZW50c1wiPT1yKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSksYT1mdW5jdGlvbih0LGUpe3RyeXtyZXR1cm4gdFtlXX1jYXRjaCh0KXt9fTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGUsbixzO3JldHVybiB2b2lkIDA9PT10P1wiVW5kZWZpbmVkXCI6bnVsbD09PXQ/XCJOdWxsXCI6XCJzdHJpbmdcIj09dHlwZW9mKG49YShlPU9iamVjdCh0KSxvKSk/bjppP3IoZSk6XCJPYmplY3RcIj09KHM9cihlKSkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuY2FsbGVlP1wiQXJndW1lbnRzXCI6c319LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDIyKTt0LmV4cG9ydHM9T2JqZWN0KFwielwiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24odCl7cmV0dXJuXCJTdHJpbmdcIj09cih0KT90LnNwbGl0KFwiXCIpOk9iamVjdCh0KX19LGZ1bmN0aW9uKHQsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyOSksbz1yLlN5bWJvbDt0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIG51bGw9PXQ/dm9pZCAwPT09dD91OnM6bCYmbCBpbiBPYmplY3QodCk/aSh0KTphKHQpfXZhciBvPW4oNjEpLGk9big1MTYpLGE9big1NDMpLHM9XCJbb2JqZWN0IE51bGxdXCIsdT1cIltvYmplY3QgVW5kZWZpbmVkXVwiLGw9bz9vLnRvU3RyaW5nVGFnOnZvaWQgMDt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHR8fG8odCkpcmV0dXJuIHQ7dmFyIGU9dCtcIlwiO3JldHVyblwiMFwiPT1lJiYxL3Q9PS1pP1wiLTBcIjplfXZhciBvPW4oODkpLGk9MS8wO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIG51bGwhPXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gbnVsbD09dD9cIlwiOm8odCl9dmFyIG89big0OTcpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT9bdC5sZW5ndGgsdFswXS5sZW5ndGhdOnQuc2hhcGV9ZnVuY3Rpb24gbyh0LGUsbil7dmFyIG89cih0KSxpPXIoZSksYT1yKG4pO2lmKG9bMF0hPT1pWzBdfHxvWzFdIT09YVsxXXx8aVsxXSE9PWFbMF0pdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBhcnJheSBzaGFwZXMgZm9yIG1hdHJpeCBwcm9kdWN0XCIpfWZ1bmN0aW9uIGkodCl7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm5bXCJyXCIsXCJuYXRpdmVcIl19ZWxzZSBpZih0LnNoYXBlJiYyPT09dC5zaGFwZS5sZW5ndGgpcmV0dXJuIHQub3JkZXJbMF0/W1wiclwiLHQuZHR5cGVdOltcImNcIix0LmR0eXBlXTt0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGF0YSB0eXBlXCIpfWZ1bmN0aW9uIGEodCxlLG4scixhKXt2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1hJiYoYT0wKTt2YXIgbD0xIT09cixjPTAhPT1hLGY9aSh0KSxwPWkoZSksaD1pKG4pO28odCxlLG4pO3ZhciBkPVtmLHAsaCxsLGNdLmpvaW4oXCI6XCIpLHY9dVtkXTtyZXR1cm4gdnx8KHY9dVtkXT1zKGYscCxoLGwsYykpLHYodCxlLG4scixhKX10LmV4cG9ydHM9YTt2YXIgcz1uKDYwOSksdT17fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtyKHRoaXMsdCksdGhpcy5NQVhfTlVNX1RFWFRVUkVTPTgsdGhpcy53ZWJnbD13ZWJsYXMuZ3B1LmdsLHRoaXMubnVtVGV4dHVyZXM9OH1yZXR1cm4gbyh0LFt7a2V5OlwiX2JpbmRJbnB1dFRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz10aGlzLndlYmdsLmNvbnRleHQ7by5hY3RpdmVUZXh0dXJlKG4pLG8uYmluZFRleHR1cmUoby5URVhUVVJFXzJELGUpO3ZhciBpPW8uZ2V0VW5pZm9ybUxvY2F0aW9uKHQscik7by51bmlmb3JtMWkoaSxuLW8uVEVYVFVSRTApfX0se2tleTpcIl9jb21wdXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLndlYmdsLmNvbnRleHQ7dC5kcmF3RWxlbWVudHModC5UUklBTkdMRVMsNix0LlVOU0lHTkVEX1NIT1JULDApfX0se2tleTpcIl91bmJpbmRJbnB1dFRleHR1cmVzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy53ZWJnbC5jb250ZXh0LGU9MDtlPHRoaXMubnVtVGV4dHVyZXM7ZSsrKXRoaXMud2ViZ2wudW5iaW5kSW5wdXRUZXh0dXJlKHQuVEVYVFVSRTArZSl9fV0pLHR9KCk7ZS5kZWZhdWx0PWl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZS5kZWZhdWx0PXQsZX1mdW5jdGlvbiBpKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBhKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gcyh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHM9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXMubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7IXImJnMucmV0dXJuJiZzLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIHQoZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksbD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGM9ZnVuY3Rpb24gdChlLG4scil7bnVsbD09PWUmJihlPUZ1bmN0aW9uLnByb3RvdHlwZSk7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2lmKHZvaWQgMD09PW8pe3ZhciBpPU9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtyZXR1cm4gbnVsbD09PWk/dm9pZCAwOnQoaSxuLHIpfWlmKFwidmFsdWVcImluIG8pcmV0dXJuIG8udmFsdWU7dmFyIGE9by5nZXQ7aWYodm9pZCAwIT09YSlyZXR1cm4gYS5jYWxsKHIpfSxmPW4oMTkpLHA9byhmKSxoPW4oMiksZD1yKGgpLHY9bigxKSxtPXIodiksXz1uKDMpLGc9cihfKSx5PW4oNjYpLGI9cih5KSx3PW4oNTcpLHg9cih3KSxFPW4oMTk4KSxUPXIoRSksTz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O2kodGhpcyxlKTt2YXIgbj1hKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiQ29udm9sdXRpb24yRFwiO3ZhciByPXQubmJGaWx0ZXIsbz12b2lkIDA9PT1yPzE6cixzPXQubmJSb3csdT12b2lkIDA9PT1zPzM6cyxsPXQubmJDb2wsYz12b2lkIDA9PT1sPzM6bCxmPXQuYWN0aXZhdGlvbixoPXZvaWQgMD09PWY/XCJsaW5lYXJcIjpmLGQ9dC5ib3JkZXJNb2RlLHY9dm9pZCAwPT09ZD9cInZhbGlkXCI6ZCxtPXQuc3Vic2FtcGxlLF89dm9pZCAwPT09bT9bMSwxXTptLGc9dC5kaW1PcmRlcmluZyx5PXZvaWQgMD09PWc/XCJ0ZlwiOmcsYj10LmJpYXMsdz12b2lkIDA9PT1ifHxiO2lmKG4ua2VybmVsU2hhcGU9W28sdSxjXSxuLmFjdGl2YXRpb249aCxuLmFjdGl2YXRpb25GdW5jPXBbaF0sXCJ2YWxpZFwiIT09diYmXCJzYW1lXCIhPT12KXRocm93IG5ldyBFcnJvcihuLm5hbWUrXCIgW0NvbnZvbHV0aW9uMkQgbGF5ZXJdIEludmFsaWQgYm9yZGVyTW9kZS5cIik7aWYobi5ib3JkZXJNb2RlPXYsbi5zdWJzYW1wbGU9XyxcInRmXCIhPT15JiZcInRoXCIhPT15KXRocm93IG5ldyBFcnJvcihuLm5hbWUrXCIgW0NvbnZvbHV0aW9uMkQgbGF5ZXJdIE9ubHkgdGYgYW5kIHRoIGRpbSBvcmRlcmluZyBhcmUgYWxsb3dlZC5cIik7aWYobi5kaW1PcmRlcmluZz15LG4uYmlhcz13LG4ucGFyYW1zPW4uYmlhcz9bXCJXXCIsXCJiXCJdOltcIldcIl0sbi5ncHUmJndlYmxhcyYmKG4uX3VzZVdlYmxhcz0hMCxuLnBpcGVsaW5lKSl7dmFyIEU9KDAseC5kZWZhdWx0KShuLmxheWVyQ2xhc3MsdCk7RT8obi5fcGlwZWxpbmVFbmFibGVkPSEwLG4ud2ViZ2xDb252MkQ9bmV3IFQuZGVmYXVsdCk6bi5fcGlwZWxpbmVFbmFibGVkPSExfXJldHVybiBufXJldHVybiBzKGUsdCksbChlLFt7a2V5Olwic2V0V2VpZ2h0c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe1widGhcIj09PXRoaXMuZGltT3JkZXJpbmcmJih0WzBdLnRlbnNvcj10WzBdLnRlbnNvci50cmFuc3Bvc2UoMiwzLDEsMCkpLGMoZS5wcm90b3R5cGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wcm90b3R5cGUpLFwic2V0V2VpZ2h0c1wiLHRoaXMpLmNhbGwodGhpcyx0KSx0aGlzLl93MnJvdygpLHRoaXMuX3VzZVdlYmxhcyYmKHRoaXMuX3dSb3dzTWF0LmNyZWF0ZVdlYmxhc1RlbnNvcigpLHRoaXMuX3dSb3dzTWF0Ll9ncHVNYXhTaXplRXhjZWVkZWR8fCh0aGlzLl93Um93c01hdC53ZWJsYXNUZW5zb3I9dGhpcy5fd1Jvd3NNYXQud2VibGFzVGVuc29yLnRyYW5zcG9zZSgpKSx0aGlzLmJpYXM/dGhpcy53ZWlnaHRzLmIuY3JlYXRlV2VibGFzVGVuc29yKCk6KHRoaXMuX3plcm9zVmVjPW5ldyBkLmRlZmF1bHQoW10sW3RoaXMud2VpZ2h0cy5XLnRlbnNvci5zaGFwZVszXV0pLHRoaXMuX3plcm9zVmVjLmNyZWF0ZVdlYmxhc1RlbnNvcigpKSl9fSx7a2V5OlwiX2NhbGNPdXRwdXRTaGFwZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRbMF0sbj10WzFdLHI9dSh0aGlzLmtlcm5lbFNoYXBlLDMpLG89clswXSxpPXJbMV0sYT1yWzJdLHM9XCJzYW1lXCI9PT10aGlzLmJvcmRlck1vZGU/TWF0aC5mbG9vcigoZSt0aGlzLnN1YnNhbXBsZVswXS0xKS90aGlzLnN1YnNhbXBsZVswXSk6TWF0aC5mbG9vcigoZS1pK3RoaXMuc3Vic2FtcGxlWzBdKS90aGlzLnN1YnNhbXBsZVswXSksbD1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLmZsb29yKChuK3RoaXMuc3Vic2FtcGxlWzFdLTEpL3RoaXMuc3Vic2FtcGxlWzFdKTpNYXRoLmZsb29yKChuLWErdGhpcy5zdWJzYW1wbGVbMV0pL3RoaXMuc3Vic2FtcGxlWzFdKSxjPW8sZj1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLm1heCgwLE1hdGguZmxvb3IoKHMtMSkqdGhpcy5zdWJzYW1wbGVbMF0raS1lKSk6MCxwPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGgubWF4KDAsTWF0aC5mbG9vcigobC0xKSp0aGlzLnN1YnNhbXBsZVsxXSthLW4pKTowLGg9TWF0aC5mbG9vcihmLzIpLGQ9Zi1oLHY9TWF0aC5mbG9vcihwLzIpLG09cC12O3RoaXMub3V0cHV0U2hhcGU9W3MsbCxjXSx0aGlzLmlucHV0UGFkZGluZz1baCxkLHYsbV19fSx7a2V5OlwiX3BhZElucHV0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjA7aWYoXCJzYW1lXCI9PT10aGlzLmJvcmRlck1vZGUpe3ZhciBuPXUodC50ZW5zb3Iuc2hhcGUsMykscj1uWzBdLG89blsxXSxpPW5bMl0sYT11KHRoaXMuaW5wdXRQYWRkaW5nLDQpLHM9YVswXSxsPWFbMV0sYz1hWzJdLGY9YVszXSxwPXIrcytsLGg9bytjK2Ysdj1uZXcgZC5kZWZhdWx0KFtdLFtwLGgsaV0pOzAhPT1lJiZnLmRlZmF1bHQuYXNzaWducyh2LnRlbnNvcixlKSxnLmRlZmF1bHQuYXNzaWduKHYudGVuc29yLmhpKHIrcyxvK2MsaSkubG8ocyxjLDApLHQudGVuc29yKSx0LnRlbnNvcj12LnRlbnNvcn1yZXR1cm4gdH19LHtrZXk6XCJfaW0yY29sXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dSh0LnRlbnNvci5zaGFwZSwzKSxuPWVbMF0scj1lWzFdLG89ZVsyXSxpPXRoaXMua2VybmVsU2hhcGVbMV0sYT10aGlzLmtlcm5lbFNoYXBlWzJdLHM9dGhpcy5vdXRwdXRTaGFwZVswXSxsPXRoaXMub3V0cHV0U2hhcGVbMV0sYz1zKmwsZj1pKmEqbztpZih0aGlzLl9pbUNvbHNNYXR8fCh0aGlzLl9pbUNvbHNNYXQ9bmV3IGQuZGVmYXVsdChbXSxbYyxmXSkpLDE9PT1pJiYxPT09YSYmMT09PXRoaXMuc3Vic2FtcGxlWzBdJiYxPT09dGhpcy5zdWJzYW1wbGVbMV0pcmV0dXJuIHRoaXMuX2ltQ29sc01hdC5yZXBsYWNlVGVuc29yRGF0YSh0LnRlbnNvci5kYXRhKSx0aGlzLl91c2VXZWJsYXMmJnRoaXMuX2ltQ29sc01hdC5jcmVhdGVXZWJsYXNUZW5zb3IoKSx0aGlzLl9pbUNvbHNNYXQ7Zm9yKHZhciBwPW5ldyBkLmRlZmF1bHQoW10sW2ksYSxvXSksaD0wLHY9MCxtPW4taTt2PD1tO3YrPXRoaXMuc3Vic2FtcGxlWzBdKWZvcih2YXIgXz0wLHk9ci1hO188PXk7Xys9dGhpcy5zdWJzYW1wbGVbMV0pZy5kZWZhdWx0LmFzc2lnbihwLnRlbnNvcix0LnRlbnNvci5oaSh2K2ksXythLG8pLmxvKHYsXywwKSksdGhpcy5faW1Db2xzTWF0LnRlbnNvci5kYXRhLnNldChwLnRlbnNvci5kYXRhLGgpLGgrPWY7cmV0dXJuIHRoaXMuX3VzZVdlYmxhcyYmdGhpcy5faW1Db2xzTWF0LmNyZWF0ZVdlYmxhc1RlbnNvcigpLHRoaXMuX2ltQ29sc01hdH19LHtrZXk6XCJfdzJyb3dcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMud2VpZ2h0cy5XLnRlbnNvci5zaGFwZVsyXSxlPXUodGhpcy5rZXJuZWxTaGFwZSwzKSxuPWVbMF0scj1lWzFdLG89ZVsyXSxpPXIqbyp0O3RoaXMuX3dSb3dzTWF0PW5ldyBkLmRlZmF1bHQoW10sW2ksbl0pO2Zvcih2YXIgYT1uZXcgZC5kZWZhdWx0KFtdLFtyLG8sdF0pLHM9bmV3IGQuZGVmYXVsdChbXSxbaV0pLGw9MDtsPG47bCsrKWcuZGVmYXVsdC5hc3NpZ24oYS50ZW5zb3IsdGhpcy53ZWlnaHRzLlcudGVuc29yLnBpY2sobnVsbCxudWxsLG51bGwsbCkpLHMucmVwbGFjZVRlbnNvckRhdGEoYS50ZW5zb3IuZGF0YSksZy5kZWZhdWx0LmFzc2lnbih0aGlzLl93Um93c01hdC50ZW5zb3IucGljayhudWxsLGwpLHMudGVuc29yKTtyZXR1cm4gdGhpcy5fd1Jvd3NNYXR9fSx7a2V5OlwiX3RpbGVkSW5kZXhNYXBwaW5nXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoIXRoaXMuX3RpbGVkSW5kZXhNYXBwaW5nUm93fHwhdGhpcy5fdGlsZWRJbmRleE1hcHBpbmdDb2wpe2Zvcih2YXIgZT11KHQsMyksbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1uZXcgZC5kZWZhdWx0KFtdLHQpLGE9bmV3IGQuZGVmYXVsdChbXSx0KSxzPTA7czxuO3MrKylmb3IodmFyIGw9MDtsPHI7bCsrKWcuZGVmYXVsdC5hc3NpZ25zKGkudGVuc29yLnBpY2socyxsLG51bGwpLHMqcitsKTtmb3IodmFyIGM9MDtjPG87YysrKWcuZGVmYXVsdC5hc3NpZ25zKGEudGVuc29yLnBpY2sobnVsbCxudWxsLGMpLGMpO2lmKFwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlKXt2YXIgZj11KHRoaXMuaW5wdXRQYWRkaW5nLDQpLHA9ZlswXSxoPWZbMV0sdj1mWzJdLG09ZlszXTtuPW4rcCtoLHI9cit2K207dmFyIF89LTE7dGhpcy5fcGFkSW5wdXQoaSxfKSx0aGlzLl9wYWRJbnB1dChhLF8pfXZhciB5PXRoaXMua2VybmVsU2hhcGVbMV0sYj10aGlzLmtlcm5lbFNoYXBlWzJdLHc9dGhpcy5vdXRwdXRTaGFwZVswXSx4PXRoaXMub3V0cHV0U2hhcGVbMV0sRT13KngsVD15KmIqbzt0aGlzLl90aWxlZEluZGV4TWFwcGluZ1Jvdz1uZXcgZC5kZWZhdWx0KFtdLFtFLFRdKSx0aGlzLl90aWxlZEluZGV4TWFwcGluZ0NvbD1uZXcgZC5kZWZhdWx0KFtdLFtFLFRdKTtmb3IodmFyIE89bmV3IGQuZGVmYXVsdChbXSxbeSxiLG9dKSxTPW5ldyBkLmRlZmF1bHQoW10sW3ksYixvXSksUD0wLE09MCxqPW4teTtNPD1qO00rPXRoaXMuc3Vic2FtcGxlWzBdKWZvcih2YXIgQT0wLEM9ci1iO0E8PUM7QSs9dGhpcy5zdWJzYW1wbGVbMV0pZy5kZWZhdWx0LmFzc2lnbihPLnRlbnNvcixpLnRlbnNvci5oaShNK3ksQStiLG8pLmxvKE0sQSwwKSksZy5kZWZhdWx0LmFzc2lnbihTLnRlbnNvcixhLnRlbnNvci5oaShNK3ksQStiLG8pLmxvKE0sQSwwKSksdGhpcy5fdGlsZWRJbmRleE1hcHBpbmdSb3cudGVuc29yLmRhdGEuc2V0KE8udGVuc29yLmRhdGEsUCksdGhpcy5fdGlsZWRJbmRleE1hcHBpbmdDb2wudGVuc29yLmRhdGEuc2V0KFMudGVuc29yLmRhdGEsUCksUCs9VDt0aGlzLl90aWxlZEluZGV4TWFwcGluZ1Jvdy5jcmVhdGVXZWJsYXNUZW5zb3IoKSx0aGlzLl90aWxlZEluZGV4TWFwcGluZ0NvbC5jcmVhdGVXZWJsYXNUZW5zb3IoKX19fSx7a2V5OlwiX2NhbGxQaXBlbGluZU1vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdC53ZWJsYXNUZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgcGFzc2VkIGluIGRvZXMgbm90IGNvbnRhaW4gd2VibGFzIHRlbnNvci5cIik7dGhpcy5fdGlsZWRJbmRleE1hcHBpbmcodGhpcy5pbnB1dFNoYXBlKTt2YXIgZT10aGlzLmJpYXM/dGhpcy53ZWlnaHRzLmIud2VibGFzVGVuc29yOnRoaXMuX3plcm9zVmVjLndlYmxhc1RlbnNvcjtyZXR1cm4gdC53ZWJsYXNUZW5zb3I9dGhpcy53ZWJnbENvbnYyRC5jYWxsKHQud2VibGFzVGVuc29yLHRoaXMuX3dSb3dzTWF0LndlYmxhc1RlbnNvcixlLHRoaXMuYWN0aXZhdGlvbix0Ll9mcm9tUGlwZWxpbmU/dGhpcy5fdGlsZWRJbmRleE1hcHBpbmdSb3cud2VibGFzVGVuc29yOm51bGwsdC5fZnJvbVBpcGVsaW5lP3RoaXMuX3RpbGVkSW5kZXhNYXBwaW5nQ29sLndlYmxhc1RlbnNvcjpudWxsKSx0Ll9mcm9tUGlwZWxpbmU9ITAsdC5fYWN0dWFsU2hhcGU9dGhpcy5vdXRwdXRTaGFwZSx0fX0se2tleTpcIl9jYWxsUmVndWxhck1vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdC50ZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgcGFzc2VkIGluIGRvZXMgbm90IGNvbnRhaW4gdGVuc29yLlwiKTtcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDEsMiwwKSk7dmFyIGU9dGhpcy5rZXJuZWxTaGFwZVswXSxuPXRoaXMub3V0cHV0U2hhcGVbMF0scj10aGlzLm91dHB1dFNoYXBlWzFdLG89bipyLGk9bmV3IGQuZGVmYXVsdChbXSxbbyxlXSk7aWYoIXRoaXMuX3VzZVdlYmxhc3x8dGhpcy5faW1Db2xzTWF0Ll9ncHVNYXhTaXplRXhjZWVkZWR8fHRoaXMuX3dSb3dzTWF0Ll9ncHVNYXhTaXplRXhjZWVkZWQpe2lmKHRoaXMuYmlhcylmb3IodmFyIGE9MDthPGU7YSsrKWcuZGVmYXVsdC5hc3NpZ25zKGkudGVuc29yLnBpY2sobnVsbCxhKSx0aGlzLndlaWdodHMuYi50ZW5zb3IuZ2V0KGEpKTsoMCxiLmRlZmF1bHQpKGkudGVuc29yLHRoaXMuX2ltQ29sc01hdC50ZW5zb3IsdGhpcy5fd1Jvd3NNYXQudGVuc29yLDEsMSl9ZWxzZXt2YXIgcz10aGlzLmJpYXM/dGhpcy53ZWlnaHRzLmIud2VibGFzVGVuc29yOnRoaXMuX3plcm9zVmVjLndlYmxhc1RlbnNvcjtpLnRlbnNvci5kYXRhPXdlYmxhcy5waXBlbGluZS5zZ2VtbSgxLHRoaXMuX2ltQ29sc01hdC53ZWJsYXNUZW5zb3IsdGhpcy5fd1Jvd3NNYXQud2VibGFzVGVuc29yLDEscykudHJhbnNmZXIoKX1mb3IodmFyIHU9bmV3IGQuZGVmYXVsdChbXSx0aGlzLm91dHB1dFNoYXBlKSxsPW5ldyBkLmRlZmF1bHQoW10sW24qcl0pLGM9bmV3IGQuZGVmYXVsdChbXSxbbixyXSksZj0wO2Y8ZTtmKyspZy5kZWZhdWx0LmFzc2lnbihsLnRlbnNvcixpLnRlbnNvci5waWNrKG51bGwsZikpLGMucmVwbGFjZVRlbnNvckRhdGEobC50ZW5zb3IuZGF0YSksZy5kZWZhdWx0LmFzc2lnbih1LnRlbnNvci5waWNrKG51bGwsbnVsbCxmKSxjLnRlbnNvcik7cmV0dXJuIHQudGVuc29yPXUudGVuc29yLHRoaXMuYWN0aXZhdGlvbkZ1bmModCksXCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgyLDAsMSkpLHR9fSx7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHQuX2Zyb21QaXBlbGluZT90aGlzLmlucHV0U2hhcGU9dC5fYWN0dWFsU2hhcGU6dGhpcy5pbnB1dFNoYXBlPXQudGVuc29yLnNoYXBlLHRoaXMuX2NhbGNPdXRwdXRTaGFwZSh0aGlzLmlucHV0U2hhcGUpLHRoaXMuX3BpcGVsaW5lRW5hYmxlZCl7aWYoIXQuX2Zyb21QaXBlbGluZSl7aWYodGhpcy5fcGFkSW5wdXQodCksdGhpcy5faW0yY29sKHQpLHRoaXMuX2ltQ29sc01hdC5fZ3B1TWF4U2l6ZUV4Y2VlZGVkKXJldHVybiB0aGlzLl9jYWxsUmVndWxhck1vZGUodCk7dC53ZWJsYXNUZW5zb3I9dGhpcy5faW1Db2xzTWF0LndlYmxhc1RlbnNvcn1yZXR1cm4gdGhpcy5fY2FsbFBpcGVsaW5lTW9kZSh0KX1yZXR1cm4gdGhpcy5fcGFkSW5wdXQodCksdGhpcy5faW0yY29sKHQpLHRoaXMuX2NhbGxSZWd1bGFyTW9kZSh0KX19XSksZX0obS5kZWZhdWx0KTtlLmRlZmF1bHQ9T30sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTgpLG89bigxMSksaT1uKDQ2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbixhKXt2YXIgcyx1PXIoZSksbD1vKHUubGVuZ3RoKSxjPWkoYSxsKTtpZih0JiZuIT1uKXtmb3IoO2w+YzspaWYocz11W2MrK10scyE9cylyZXR1cm4hMH1lbHNlIGZvcig7bD5jO2MrKylpZigodHx8YyBpbiB1KSYmdVtjXT09PW4pcmV0dXJuIHR8fGN8fDA7cmV0dXJuIXQmJi0xfX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDUpLG89bigwKSxpPW4oMTYpLGE9big0NCkscz1uKDM1KSx1PW4oNTEpLGw9bigzOSksYz1uKDcpLGY9big2KSxwPW4oNzUpLGg9big1MyksZD1uKDk5KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4sdixtLF8pe3ZhciBnPXJbdF0seT1nLGI9bT9cInNldFwiOlwiYWRkXCIsdz15JiZ5LnByb3RvdHlwZSx4PXt9LEU9ZnVuY3Rpb24odCl7dmFyIGU9d1t0XTtpKHcsdCxcImRlbGV0ZVwiPT10P2Z1bmN0aW9uKHQpe3JldHVybiEoXyYmIWModCkpJiZlLmNhbGwodGhpcywwPT09dD8wOnQpfTpcImhhc1wiPT10P2Z1bmN0aW9uKHQpe3JldHVybiEoXyYmIWModCkpJiZlLmNhbGwodGhpcywwPT09dD8wOnQpfTpcImdldFwiPT10P2Z1bmN0aW9uKHQpe3JldHVybiBfJiYhYyh0KT92b2lkIDA6ZS5jYWxsKHRoaXMsMD09PXQ/MDp0KX06XCJhZGRcIj09dD9mdW5jdGlvbih0KXtyZXR1cm4gZS5jYWxsKHRoaXMsMD09PXQ/MDp0KSx0aGlzfTpmdW5jdGlvbih0LG4pe3JldHVybiBlLmNhbGwodGhpcywwPT09dD8wOnQsbiksdGhpc30pfTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB5JiYoX3x8dy5mb3JFYWNoJiYhZihmdW5jdGlvbigpeyhuZXcgeSkuZW50cmllcygpLm5leHQoKX0pKSl7dmFyIFQ9bmV3IHksTz1UW2JdKF8/e306LTAsMSkhPVQsUz1mKGZ1bmN0aW9uKCl7VC5oYXMoMSl9KSxQPXAoZnVuY3Rpb24odCl7bmV3IHkodCl9KSxNPSFfJiZmKGZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyB5LGU9NTtlLS07KXRbYl0oZSxlKTtyZXR1cm4hdC5oYXMoLTApfSk7UHx8KHk9ZShmdW5jdGlvbihlLG4pe2woZSx5LHQpO3ZhciByPWQobmV3IGcsZSx5KTtyZXR1cm4gdm9pZCAwIT1uJiZ1KG4sbSxyW2JdLHIpLHJ9KSx5LnByb3RvdHlwZT13LHcuY29uc3RydWN0b3I9eSksKFN8fE0pJiYoRShcImRlbGV0ZVwiKSxFKFwiaGFzXCIpLG0mJkUoXCJnZXRcIikpLChNfHxPKSYmRShiKSxfJiZ3LmNsZWFyJiZkZWxldGUgdy5jbGVhcn1lbHNlIHk9di5nZXRDb25zdHJ1Y3RvcihlLHQsbSxiKSxhKHkucHJvdG90eXBlLG4pLHMuTkVFRD0hMDtyZXR1cm4gaCh5LHQpLHhbdF09eSxvKG8uRytvLlcrby5GKih5IT1nKSx4KSxffHx2LnNldFN0cm9uZyh5LHQsbSkseX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDE1KSxvPW4oMTYpLGk9big2KSxhPW4oMjMpLHM9big4KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciB1PXModCksbD1uKGEsdSxcIlwiW3RdKSxjPWxbMF0sZj1sWzFdO2koZnVuY3Rpb24oKXt2YXIgZT17fTtyZXR1cm4gZVt1XT1mdW5jdGlvbigpe3JldHVybiA3fSw3IT1cIlwiW3RdKGUpfSkmJihvKFN0cmluZy5wcm90b3R5cGUsdCxjKSxyKFJlZ0V4cC5wcm90b3R5cGUsdSwyPT1lP2Z1bmN0aW9uKHQsZSl7cmV0dXJuIGYuY2FsbCh0LHRoaXMsZSl9OmZ1bmN0aW9uKHQpe3JldHVybiBmLmNhbGwodCx0aGlzKX0pKX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDQpO3QuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciB0PXIodGhpcyksZT1cIlwiO3JldHVybiB0Lmdsb2JhbCYmKGUrPVwiZ1wiKSx0Lmlnbm9yZUNhc2UmJihlKz1cImlcIiksdC5tdWx0aWxpbmUmJihlKz1cIm1cIiksdC51bmljb2RlJiYoZSs9XCJ1XCIpLHQuc3RpY2t5JiYoZSs9XCJ5XCIpLGV9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dmFyIHI9dm9pZCAwPT09bjtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gcj90KCk6dC5jYWxsKG4pO2Nhc2UgMTpyZXR1cm4gcj90KGVbMF0pOnQuY2FsbChuLGVbMF0pO2Nhc2UgMjpyZXR1cm4gcj90KGVbMF0sZVsxXSk6dC5jYWxsKG4sZVswXSxlWzFdKTtjYXNlIDM6cmV0dXJuIHI/dChlWzBdLGVbMV0sZVsyXSk6dC5jYWxsKG4sZVswXSxlWzFdLGVbMl0pO2Nhc2UgNDpyZXR1cm4gcj90KGVbMF0sZVsxXSxlWzJdLGVbM10pOnQuY2FsbChuLGVbMF0sZVsxXSxlWzJdLGVbM10pfXJldHVybiB0LmFwcGx5KG4sZSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3KSxvPW4oMjIpLGk9big4KShcIm1hdGNoXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gcih0KSYmKHZvaWQgMCE9PShlPXRbaV0pPyEhZTpcIlJlZ0V4cFwiPT1vKHQpKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDgpKFwiaXRlcmF0b3JcIiksbz0hMTt0cnl7dmFyIGk9WzddW3JdKCk7aS5yZXR1cm49ZnVuY3Rpb24oKXtvPSEwfSxBcnJheS5mcm9tKGksZnVuY3Rpb24oKXt0aHJvdyAyfSl9Y2F0Y2godCl7fXQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKCFlJiYhbylyZXR1cm4hMTt2YXIgbj0hMTt0cnl7dmFyIGk9WzddLGE9aVtyXSgpO2EubmV4dD1mdW5jdGlvbigpe3JldHVybntkb25lOm49ITB9fSxpW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGF9LHQoaSl9Y2F0Y2godCl7fXJldHVybiBufX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDQwKXx8IW4oNikoZnVuY3Rpb24oKXt2YXIgdD1NYXRoLnJhbmRvbSgpO19fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLHQsZnVuY3Rpb24oKXt9KSxkZWxldGUgbig1KVt0XX0pfSxmdW5jdGlvbih0LGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1KSxvPVwiX19jb3JlLWpzX3NoYXJlZF9fXCIsaT1yW29dfHwocltvXT17fSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpW3RdfHwoaVt0XT17fSl9fSxmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByLG89big1KSxpPW4oMTUpLGE9big0Nykscz1hKFwidHlwZWRfYXJyYXlcIiksdT1hKFwidmlld1wiKSxsPSEoIW8uQXJyYXlCdWZmZXJ8fCFvLkRhdGFWaWV3KSxjPWwsZj0wLHA9OSxoPVwiSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXlcIi5zcGxpdChcIixcIik7ZjxwOykocj1vW2hbZisrXV0pPyhpKHIucHJvdG90eXBlLHMsITApLGkoci5wcm90b3R5cGUsdSwhMCkpOmM9ITE7dC5leHBvcnRzPXtBQlY6bCxDT05TVFI6YyxUWVBFRDpzLFZJRVc6dX19LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPS0xLG49bnVsbD09dD8wOnQubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPG47KXt2YXIgcj10W2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fXZhciBvPW4oNTMwKSxpPW4oNTMxKSxhPW4oNTMyKSxzPW4oNTMzKSx1PW4oNTM0KTtyLnByb3RvdHlwZS5jbGVhcj1vLHIucHJvdG90eXBlLmRlbGV0ZT1pLHIucHJvdG90eXBlLmdldD1hLHIucHJvdG90eXBlLmhhcz1zLHIucHJvdG90eXBlLnNldD11LHQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe2Zvcih2YXIgbj10Lmxlbmd0aDtuLS07KWlmKG8odFtuXVswXSxlKSlyZXR1cm4gbjtyZXR1cm4tMX12YXIgbz1uKDg3KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90Om51bGw9PXQ/YTpcIm9iamVjdFwiPT10eXBlb2YgdD9zKHQpP2kodFswXSx0WzFdKTpvKHQpOnUodCl9dmFyIG89big0ODMpLGk9big0ODQpLGE9bigxMjUpLHM9bigzMCksdT1uKDU3NCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIG8odCk/dDppKHQsZSk/W3RdOmEocyh0KSl9dmFyIG89bigzMCksaT1uKDEyNCksYT1uKDU1OCkscz1uKDY1KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlKXt2YXIgbj10Ll9fZGF0YV9fO3JldHVybiBvKGUpP25bXCJzdHJpbmdcIj09dHlwZW9mIGU/XCJzdHJpbmdcIjpcImhhc2hcIl06bi5tYXB9dmFyIG89big1MjcpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZT1udWxsPT1lP3I6ZSwhIWUmJihcIm51bWJlclwiPT10eXBlb2YgdHx8by50ZXN0KHQpKSYmdD4tMSYmdCUxPT0wJiZ0PGV9dmFyIHI9OTAwNzE5OTI1NDc0MDk5MSxvPS9eKD86MHxbMS05XVxcZCopJC87dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQ4KSxvPXIoT2JqZWN0LFwiY3JlYXRlXCIpO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gdD09PWV8fHQhPT10JiZlIT09ZX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIG51bGwhPXQmJmkodC5sZW5ndGgpJiYhbyh0KX12YXIgbz1uKDE4NiksaT1uKDEyOCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0fHxpKHQpJiZvKHQpPT1hfXZhciBvPW4oNjIpLGk9big2NCksYT1cIltvYmplY3QgU3ltYm9sXVwiO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzLnN3YXA9big1OTIpLHQuZXhwb3J0cy5zY2FsPW4oNTkxKSx0LmV4cG9ydHMuY29weT1uKDU4NSksdC5leHBvcnRzLmF4cHk9big1ODQpLHQuZXhwb3J0cy5kb3Q9big1ODcpLHQuZXhwb3J0cy5jcHNjPW4oNTg2KSx0LmV4cG9ydHMubnJtMj1uKDU4OSksdC5leHBvcnRzLmFzdW09big1ODMpLHQuZXhwb3J0cy5pYW1heD1uKDU4OCksdC5leHBvcnRzLnJvdGc9big1OTApfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3JldHVybiB0WzBdLWVbMF19ZnVuY3Rpb24gbygpe3ZhciB0LGU9dGhpcy5zdHJpZGUsbj1uZXcgQXJyYXkoZS5sZW5ndGgpO2Zvcih0PTA7dDxuLmxlbmd0aDsrK3Qpblt0XT1bTWF0aC5hYnMoZVt0XSksdF07bi5zb3J0KHIpO3ZhciBvPW5ldyBBcnJheShuLmxlbmd0aCk7Zm9yKHQ9MDt0PG8ubGVuZ3RoOysrdClvW3RdPW5bdF1bMV07cmV0dXJuIG99ZnVuY3Rpb24gaSh0LGUpe3ZhciBuPVtcIlZpZXdcIixlLFwiZFwiLHRdLmpvaW4oXCJcIik7ZTwwJiYobj1cIlZpZXdfTmlsXCIrdCk7dmFyIHI9XCJnZW5lcmljXCI9PT10O2lmKGU9PT0tMSl7dmFyIGk9XCJmdW5jdGlvbiBcIituK1wiKGEpe3RoaXMuZGF0YT1hO307dmFyIHByb3RvPVwiK24rXCIucHJvdG90eXBlO3Byb3RvLmR0eXBlPSdcIit0K1wiJztwcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiAtMX07cHJvdG8uc2l6ZT0wO3Byb3RvLmRpbWVuc2lvbj0tMTtwcm90by5zaGFwZT1wcm90by5zdHJpZGU9cHJvdG8ub3JkZXI9W107cHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK24rXCIodGhpcy5kYXRhKTt9O3Byb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O3Byb3RvLnBpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07cmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIituK1wiKGEpe3JldHVybiBuZXcgXCIrbitcIihhKTt9XCIsYT1uZXcgRnVuY3Rpb24oaSk7cmV0dXJuIGEoKX1pZigwPT09ZSl7dmFyIGk9XCJmdW5jdGlvbiBcIituK1wiKGEsZCkge3RoaXMuZGF0YSA9IGE7dGhpcy5vZmZzZXQgPSBkfTt2YXIgcHJvdG89XCIrbitcIi5wcm90b3R5cGU7cHJvdG8uZHR5cGU9J1wiK3QrXCInO3Byb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtwcm90by5kaW1lbnNpb249MDtwcm90by5zaXplPTE7cHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO3Byb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPWZ1bmN0aW9uIFwiK24rXCJfY29weSgpIHtyZXR1cm4gbmV3IFwiK24rXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KX07cHJvdG8ucGljaz1mdW5jdGlvbiBcIituK1wiX3BpY2soKXtyZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7fTtwcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIituK1wiX2dldCgpe3JldHVybiBcIisocj9cInRoaXMuZGF0YS5nZXQodGhpcy5vZmZzZXQpXCI6XCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1wifTtwcm90by5zZXQ9ZnVuY3Rpb24gXCIrbitcIl9zZXQodil7cmV0dXJuIFwiKyhyP1widGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiOlwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XT12XCIpK1wifTtyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK24rXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIituK1wiKGEsZCl9XCIsYT1uZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIixpKTtyZXR1cm4gYShmW3RdWzBdKX12YXIgaT1bXCIndXNlIHN0cmljdCdcIl0scz11KGUpLGw9cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJpXCIrdH0pLGM9XCJ0aGlzLm9mZnNldCtcIitzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cInRoaXMuc3RyaWRlW1wiK3QrXCJdKmlcIit0fSkuam9pbihcIitcIikscD1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImJcIit0fSkuam9pbihcIixcIiksaD1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImNcIit0fSkuam9pbihcIixcIik7aS5wdXNoKFwiZnVuY3Rpb24gXCIrbitcIihhLFwiK3ArXCIsXCIraCtcIixkKXt0aGlzLmRhdGE9YVwiLFwidGhpcy5zaGFwZT1bXCIrcCtcIl1cIixcInRoaXMuc3RyaWRlPVtcIitoK1wiXVwiLFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFwidmFyIHByb3RvPVwiK24rXCIucHJvdG90eXBlXCIsXCJwcm90by5kdHlwZT0nXCIrdCtcIidcIixcInByb3RvLmRpbWVuc2lvbj1cIitlKSxpLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrbitcIl9zaXplKCl7cmV0dXJuIFwiK3MubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwidGhpcy5zaGFwZVtcIit0K1wiXVwifSkuam9pbihcIipcIiksXCJ9fSlcIiksMT09PWU/aS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpOihpLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ29yZGVyJyx7Z2V0OlwiKSxlPDQ/KGkucHVzaChcImZ1bmN0aW9uIFwiK24rXCJfb3JkZXIoKXtcIiksMj09PWU/aS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKTozPT09ZSYmaS5wdXNoKFwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO2lmKHMwPnMxKXtpZihzMT5zMil7cmV0dXJuIFsyLDEsMF07fWVsc2UgaWYoczA+czIpe3JldHVybiBbMSwyLDBdO31lbHNle3JldHVybiBbMSwwLDJdO319ZWxzZSBpZihzMD5zMil7cmV0dXJuIFsyLDAsMV07fWVsc2UgaWYoczI+czEpe3JldHVybiBbMCwxLDJdO31lbHNle3JldHVybiBbMCwyLDFdO319fSlcIikpOmkucHVzaChcIk9SREVSfSlcIikpLGkucHVzaChcInByb3RvLnNldD1mdW5jdGlvbiBcIituK1wiX3NldChcIitsLmpvaW4oXCIsXCIpK1wiLHYpe1wiKSxyP2kucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2MrXCIsdil9XCIpOmkucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIrYytcIl09dn1cIiksaS5wdXNoKFwicHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK24rXCJfZ2V0KFwiK2wuam9pbihcIixcIikrXCIpe1wiKSxyP2kucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2MrXCIpfVwiKTppLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2MrXCJdfVwiKSxpLnB1c2goXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIituK1wiX2luZGV4KFwiLGwuam9pbigpLFwiKXtyZXR1cm4gXCIrYytcIn1cIiksaS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrbitcIl9oaShcIitsLmpvaW4oXCIsXCIpK1wiKXtyZXR1cm4gbmV3IFwiK24rXCIodGhpcy5kYXRhLFwiK3MubWFwKGZ1bmN0aW9uKHQpe3JldHVybltcIih0eXBlb2YgaVwiLHQsXCIhPT0nbnVtYmVyJ3x8aVwiLHQsXCI8MCk/dGhpcy5zaGFwZVtcIix0LFwiXTppXCIsdCxcInwwXCJdLmpvaW4oXCJcIil9KS5qb2luKFwiLFwiKStcIixcIitzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cInRoaXMuc3RyaWRlW1wiK3QrXCJdXCJ9KS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpO3ZhciBkPXMubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiYVwiK3QrXCI9dGhpcy5zaGFwZVtcIit0K1wiXVwifSksdj1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImNcIit0K1wiPXRoaXMuc3RyaWRlW1wiK3QrXCJdXCJ9KTtpLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIituK1wiX2xvKFwiK2wuam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIitkLmpvaW4oXCIsXCIpK1wiLFwiK3Yuam9pbihcIixcIikpO2Zvcih2YXIgbT0wO208ZTsrK20paS5wdXNoKFwiaWYodHlwZW9mIGlcIittK1wiPT09J251bWJlcicmJmlcIittK1wiPj0wKXtkPWlcIittK1wifDA7Yis9Y1wiK20rXCIqZDthXCIrbStcIi09ZH1cIik7aS5wdXNoKFwicmV0dXJuIG5ldyBcIituK1wiKHRoaXMuZGF0YSxcIitzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImFcIit0fSkuam9pbihcIixcIikrXCIsXCIrcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJjXCIrdH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKSxpLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiK24rXCJfc3RlcChcIitsLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJhXCIrdCtcIj10aGlzLnNoYXBlW1wiK3QrXCJdXCJ9KS5qb2luKFwiLFwiKStcIixcIitzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImJcIit0K1wiPXRoaXMuc3RyaWRlW1wiK3QrXCJdXCJ9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKTtmb3IodmFyIG09MDttPGU7KyttKWkucHVzaChcImlmKHR5cGVvZiBpXCIrbStcIj09PSdudW1iZXInKXtkPWlcIittK1wifDA7aWYoZDwwKXtjKz1iXCIrbStcIiooYVwiK20rXCItMSk7YVwiK20rXCI9Y2VpbCgtYVwiK20rXCIvZCl9ZWxzZXthXCIrbStcIj1jZWlsKGFcIittK1wiL2QpfWJcIittK1wiKj1kfVwiKTtpLnB1c2goXCJyZXR1cm4gbmV3IFwiK24rXCIodGhpcy5kYXRhLFwiK3MubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiYVwiK3R9KS5qb2luKFwiLFwiKStcIixcIitzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImJcIit0fSkuam9pbihcIixcIikrXCIsYyl9XCIpO2Zvcih2YXIgXz1uZXcgQXJyYXkoZSksZz1uZXcgQXJyYXkoZSksbT0wO208ZTsrK20pX1ttXT1cImFbaVwiK20rXCJdXCIsZ1ttXT1cImJbaVwiK20rXCJdXCI7aS5wdXNoKFwicHJvdG8udHJhbnNwb3NlPWZ1bmN0aW9uIFwiK24rXCJfdHJhbnNwb3NlKFwiK2wrXCIpe1wiK2wubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrXCI9KFwiK3QrXCI9PT11bmRlZmluZWQ/XCIrZStcIjpcIit0K1wifDApXCJ9KS5qb2luKFwiO1wiKSxcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK24rXCIodGhpcy5kYXRhLFwiK18uam9pbihcIixcIikrXCIsXCIrZy5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpLGkucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrbitcIl9waWNrKFwiK2wrXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKTtmb3IodmFyIG09MDttPGU7KyttKWkucHVzaChcImlmKHR5cGVvZiBpXCIrbStcIj09PSdudW1iZXInJiZpXCIrbStcIj49MCl7Yz0oYyt0aGlzLnN0cmlkZVtcIittK1wiXSppXCIrbStcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiK20rXCJdKTtiLnB1c2godGhpcy5zdHJpZGVbXCIrbStcIl0pfVwiKTtpLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIiksaS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIituK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIituK1wiKGRhdGEsXCIrcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJzaGFwZVtcIit0K1wiXVwifSkuam9pbihcIixcIikrXCIsXCIrcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpZGVbXCIrdCtcIl1cIn0pLmpvaW4oXCIsXCIpK1wiLG9mZnNldCl9XCIpO3ZhciBhPW5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLFwiT1JERVJcIixpLmpvaW4oXCJcXG5cIikpO3JldHVybiBhKGZbdF0sbyl9ZnVuY3Rpb24gYSh0KXtpZihsKHQpKXJldHVyblwiYnVmZmVyXCI7aWYoYylzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKXtjYXNlXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpyZXR1cm5cImZsb2F0NjRcIjtjYXNlXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpyZXR1cm5cImZsb2F0MzJcIjtjYXNlXCJbb2JqZWN0IEludDhBcnJheV1cIjpyZXR1cm5cImludDhcIjtjYXNlXCJbb2JqZWN0IEludDE2QXJyYXldXCI6cmV0dXJuXCJpbnQxNlwiO2Nhc2VcIltvYmplY3QgSW50MzJBcnJheV1cIjpyZXR1cm5cImludDMyXCI7Y2FzZVwiW29iamVjdCBVaW50OEFycmF5XVwiOnJldHVyblwidWludDhcIjtjYXNlXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiOnJldHVyblwidWludDE2XCI7Y2FzZVwiW29iamVjdCBVaW50MzJBcnJheV1cIjpyZXR1cm5cInVpbnQzMlwiO2Nhc2VcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6cmV0dXJuXCJ1aW50OF9jbGFtcGVkXCJ9cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/XCJhcnJheVwiOlwiZ2VuZXJpY1wifWZ1bmN0aW9uIHModCxlLG4scil7aWYodm9pZCAwPT09dCl7dmFyIG89Zi5hcnJheVswXTtyZXR1cm4gbyhbXSl9XCJudW1iZXJcIj09dHlwZW9mIHQmJih0PVt0XSksdm9pZCAwPT09ZSYmKGU9W3QubGVuZ3RoXSk7dmFyIHM9ZS5sZW5ndGg7aWYodm9pZCAwPT09bil7bj1uZXcgQXJyYXkocyk7Zm9yKHZhciB1PXMtMSxsPTE7dT49MDstLXUpblt1XT1sLGwqPWVbdV19aWYodm9pZCAwPT09cil7cj0wO2Zvcih2YXIgdT0wO3U8czsrK3Upblt1XTwwJiYoci09KGVbdV0tMSkqblt1XSl9Zm9yKHZhciBjPWEodCkscD1mW2NdO3AubGVuZ3RoPD1zKzE7KXAucHVzaChpKGMscC5sZW5ndGgtMSkpO3ZhciBvPXBbcysxXTtyZXR1cm4gbyh0LGUsbixyKX12YXIgdT1uKDQ1MyksbD1uKDQ1NCksYz1cInVuZGVmaW5lZFwiIT10eXBlb2YgRmxvYXQ2NEFycmF5LGY9e2Zsb2F0MzI6W10sZmxvYXQ2NDpbXSxpbnQ4OltdLGludDE2OltdLGludDMyOltdLHVpbnQ4OltdLHVpbnQxNjpbXSx1aW50MzI6W10sYXJyYXk6W10sdWludDhfY2xhbXBlZDpbXSxidWZmZXI6W10sZ2VuZXJpYzpbXX07dC5leHBvcnRzPXN9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0LndlYnBhY2tQb2x5ZmlsbHx8KHQuZGVwcmVjYXRlPWZ1bmN0aW9uKCl7fSx0LnBhdGhzPVtdLHQuY2hpbGRyZW58fCh0LmNoaWxkcmVuPVtdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImxvYWRlZFwiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5sfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiaWRcIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuaX19KSx0LndlYnBhY2tQb2x5ZmlsbD0xKSx0fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMTIpLG89big0NiksaT1uKDExKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXIodGhpcyksbj1pKGUubGVuZ3RoKSxhPWFyZ3VtZW50cy5sZW5ndGgscz1vKGE+MT9hcmd1bWVudHNbMV06dm9pZCAwLG4pLHU9YT4yP2FyZ3VtZW50c1syXTp2b2lkIDAsbD12b2lkIDA9PT11P246byh1LG4pO2w+czspZVtzKytdPXQ7cmV0dXJuIGV9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMCksbz1uKDM2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2UgaW4gdD9yLmYodCxlLG8oMCxuKSk6dFtlXT1ufX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNyksbz1uKDUpLmRvY3VtZW50LGk9cihvKSYmcihvLmNyZWF0ZUVsZW1lbnQpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaT9vLmNyZWF0ZUVsZW1lbnQodCk6e319fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1cImNvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZlwiLnNwbGl0KFwiLFwiKX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oOCkoXCJtYXRjaFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9Ly4vO3RyeXtcIi8uL1wiW3RdKGUpfWNhdGNoKG4pe3RyeXtyZXR1cm4gZVtyXT0hMSwhXCIvLi9cIlt0XShlKX1jYXRjaCh0KXt9fXJldHVybiEwfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDUpLmRvY3VtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpLG89bigxMDcpLnNldDt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciBpLGE9ZS5jb25zdHJ1Y3RvcjtyZXR1cm4gYSE9PW4mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEmJihpPWEucHJvdG90eXBlKSE9PW4ucHJvdG90eXBlJiZyKGkpJiZvJiZvKHQsaSksdH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDUyKSxvPW4oOCkoXCJpdGVyYXRvclwiKSxpPUFycmF5LnByb3RvdHlwZTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQmJihyLkFycmF5PT09dHx8aVtvXT09PXQpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjIpO3QuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIkFycmF5XCI9PXIodCl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0MSksbz1uKDM2KSxpPW4oNTMpLGE9e307bigxNSkoYSxuKDgpKFwiaXRlcmF0b3JcIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHQuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dC5wcm90b3R5cGU9cihhLHtuZXh0Om8oMSxuKX0pLGkodCxlK1wiIEl0ZXJhdG9yXCIpfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNDApLG89bigwKSxpPW4oMTYpLGE9bigxNSkscz1uKDEzKSx1PW4oNTIpLGw9bigxMDIpLGM9big1MyksZj1uKDIxKSxwPW4oOCkoXCJpdGVyYXRvclwiKSxoPSEoW10ua2V5cyYmXCJuZXh0XCJpbltdLmtleXMoKSksZD1cIkBAaXRlcmF0b3JcIix2PVwia2V5c1wiLG09XCJ2YWx1ZXNcIixfPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixnLHksYix3KXtsKG4sZSxnKTt2YXIgeCxFLFQsTz1mdW5jdGlvbih0KXtpZighaCYmdCBpbiBqKXJldHVybiBqW3RdO3N3aXRjaCh0KXtjYXNlIHY6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuKHRoaXMsdCl9O2Nhc2UgbTpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG4odGhpcyx0KX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuKHRoaXMsdCl9fSxTPWUrXCIgSXRlcmF0b3JcIixQPXk9PW0sTT0hMSxqPXQucHJvdG90eXBlLEE9altwXXx8altkXXx8eSYmalt5XSxDPUF8fE8oeSksaz15P1A/TyhcImVudHJpZXNcIik6Qzp2b2lkIDAsUj1cIkFycmF5XCI9PWU/ai5lbnRyaWVzfHxBOkE7aWYoUiYmKFQ9ZihSLmNhbGwobmV3IHQpKSxUIT09T2JqZWN0LnByb3RvdHlwZSYmKGMoVCxTLCEwKSxyfHxzKFQscCl8fGEoVCxwLF8pKSksUCYmQSYmQS5uYW1lIT09bSYmKE09ITAsQz1mdW5jdGlvbigpe3JldHVybiBBLmNhbGwodGhpcyl9KSxyJiYhd3x8IWgmJiFNJiZqW3BdfHxhKGoscCxDKSx1W2VdPUMsdVtTXT1fLHkpaWYoeD17dmFsdWVzOlA/QzpPKG0pLGtleXM6Yj9DOk8odiksZW50cmllczprfSx3KWZvcihFIGluIHgpRSBpbiBqfHxpKGosRSx4W0VdKTtlbHNlIG8oby5QK28uRiooaHx8TSksZSx4KTtyZXR1cm4geH19LGZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5leHBtMTt0LmV4cG9ydHM9IW58fG4oMTApPjIyMDI1LjQ2NTc5NDgwNjcxOHx8bigxMCk8MjIwMjUuNDY1Nzk0ODA2NzE4fHxuKC0yZS0xNykhPS0yZS0xNz9mdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9K3QpP3Q6dD4tMWUtNiYmdDwxZS02P3QrdCp0LzI6TWF0aC5leHAodCktMX06bn0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9TWF0aC5zaWdufHxmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9K3QpfHx0IT10P3Q6dDwwPy0xOjF9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1KSxvPW4oMTE0KS5zZXQsaT1yLk11dGF0aW9uT2JzZXJ2ZXJ8fHIuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixhPXIucHJvY2VzcyxzPXIuUHJvbWlzZSx1PVwicHJvY2Vzc1wiPT1uKDIyKShhKTt0LmV4cG9ydHM9ZnVuY3Rpb24oKXt2YXIgdCxlLG4sbD1mdW5jdGlvbigpe3ZhciByLG87Zm9yKHUmJihyPWEuZG9tYWluKSYmci5leGl0KCk7dDspe289dC5mbix0PXQubmV4dDt0cnl7bygpfWNhdGNoKHIpe3Rocm93IHQ/bigpOmU9dm9pZCAwLHJ9fWU9dm9pZCAwLHImJnIuZW50ZXIoKX07aWYodSluPWZ1bmN0aW9uKCl7YS5uZXh0VGljayhsKX07ZWxzZSBpZihpKXt2YXIgYz0hMCxmPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO25ldyBpKGwpLm9ic2VydmUoZix7Y2hhcmFjdGVyRGF0YTohMH0pLG49ZnVuY3Rpb24oKXtmLmRhdGE9Yz0hY319ZWxzZSBpZihzJiZzLnJlc29sdmUpe3ZhciBwPXMucmVzb2x2ZSgpO249ZnVuY3Rpb24oKXtwLnRoZW4obCl9fWVsc2Ugbj1mdW5jdGlvbigpe28uY2FsbChyLGwpfTtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIG89e2ZuOnIsbmV4dDp2b2lkIDB9O2UmJihlLm5leHQ9byksdHx8KHQ9byxuKCkpLGU9b319fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3KSxvPW4oNCksaT1mdW5jdGlvbih0LGUpe2lmKG8odCksIXIoZSkmJm51bGwhPT1lKXRocm93IFR5cGVFcnJvcihlK1wiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKX07dC5leHBvcnRzPXtzZXQ6T2JqZWN0LnNldFByb3RvdHlwZU9mfHwoXCJfX3Byb3RvX19cImlue30/ZnVuY3Rpb24odCxlLHIpe3RyeXtyPW4oMzIpKEZ1bmN0aW9uLmNhbGwsbigyMCkuZihPYmplY3QucHJvdG90eXBlLFwiX19wcm90b19fXCIpLnNldCwyKSxyKHQsW10pLGU9ISh0IGluc3RhbmNlb2YgQXJyYXkpfWNhdGNoKHQpe2U9ITB9cmV0dXJuIGZ1bmN0aW9uKHQsbil7cmV0dXJuIGkodCxuKSxlP3QuX19wcm90b19fPW46cih0LG4pLHR9fSh7fSwhMSk6dm9pZCAwKSxjaGVjazppfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNzgpKFwia2V5c1wiKSxvPW4oNDcpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gclt0XXx8KHJbdF09byh0KSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0KSxvPW4oMTQpLGk9big4KShcInNwZWNpZXNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG4sYT1yKHQpLmNvbnN0cnVjdG9yO3JldHVybiB2b2lkIDA9PT1hfHx2b2lkIDA9PShuPXIoYSlbaV0pP2U6byhuKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDM3KSxvPW4oMjMpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXt2YXIgaSxhLHM9U3RyaW5nKG8oZSkpLHU9cihuKSxsPXMubGVuZ3RoO3JldHVybiB1PDB8fHU+PWw/dD9cIlwiOnZvaWQgMDooaT1zLmNoYXJDb2RlQXQodSksaTw1NTI5Nnx8aT41NjMxOXx8dSsxPT09bHx8KGE9cy5jaGFyQ29kZUF0KHUrMSkpPDU2MzIwfHxhPjU3MzQzP3Q/cy5jaGFyQXQodSk6aTp0P3Muc2xpY2UodSx1KzIpOihpLTU1Mjk2PDwxMCkrKGEtNTYzMjApKzY1NTM2KX19fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3NCksbz1uKDIzKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2lmKHIoZSkpdGhyb3cgVHlwZUVycm9yKFwiU3RyaW5nI1wiK24rXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO3JldHVybiBTdHJpbmcobyh0KSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigzNyksbz1uKDIzKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9U3RyaW5nKG8odGhpcykpLG49XCJcIixpPXIodCk7aWYoaTwwfHxpPT0xLzApdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO2Zvcig7aT4wOyhpPj4+PTEpJiYoZSs9ZSkpMSZpJiYobis9ZSk7cmV0dXJuIG59fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1cIlxcdFxcblxcdlxcZlxcciDCoOGagOGgjuKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFxcdTIwMjhcXHUyMDI5XFx1ZmVmZlwifSxmdW5jdGlvbih0LGUsbil7dmFyIHIsbyxpLGE9bigzMikscz1uKDczKSx1PW4oOTgpLGw9big5NSksYz1uKDUpLGY9Yy5wcm9jZXNzLHA9Yy5zZXRJbW1lZGlhdGUsaD1jLmNsZWFySW1tZWRpYXRlLGQ9Yy5NZXNzYWdlQ2hhbm5lbCx2PTAsbT17fSxfPVwib25yZWFkeXN0YXRlY2hhbmdlXCIsZz1mdW5jdGlvbigpe3ZhciB0PSt0aGlzO2lmKG0uaGFzT3duUHJvcGVydHkodCkpe3ZhciBlPW1bdF07ZGVsZXRlIG1bdF0sZSgpfX0seT1mdW5jdGlvbih0KXtnLmNhbGwodC5kYXRhKX07cCYmaHx8KHA9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MTthcmd1bWVudHMubGVuZ3RoPm47KWUucHVzaChhcmd1bWVudHNbbisrXSk7cmV0dXJuIG1bKyt2XT1mdW5jdGlvbigpe3MoXCJmdW5jdGlvblwiPT10eXBlb2YgdD90OkZ1bmN0aW9uKHQpLGUpfSxyKHYpLHZ9LGg9ZnVuY3Rpb24odCl7ZGVsZXRlIG1bdF19LFwicHJvY2Vzc1wiPT1uKDIyKShmKT9yPWZ1bmN0aW9uKHQpe2YubmV4dFRpY2soYShnLHQsMSkpfTpkPyhvPW5ldyBkLGk9by5wb3J0MixvLnBvcnQxLm9ubWVzc2FnZT15LHI9YShpLnBvc3RNZXNzYWdlLGksMSkpOmMuYWRkRXZlbnRMaXN0ZW5lciYmXCJmdW5jdGlvblwiPT10eXBlb2YgcG9zdE1lc3NhZ2UmJiFjLmltcG9ydFNjcmlwdHM/KHI9ZnVuY3Rpb24odCl7Yy5wb3N0TWVzc2FnZSh0K1wiXCIsXCIqXCIpfSxjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIseSwhMSkpOnI9XyBpbiBsKFwic2NyaXB0XCIpP2Z1bmN0aW9uKHQpe3UuYXBwZW5kQ2hpbGQobChcInNjcmlwdFwiKSlbX109ZnVuY3Rpb24oKXt1LnJlbW92ZUNoaWxkKHRoaXMpLGcuY2FsbCh0KX19OmZ1bmN0aW9uKHQpe3NldFRpbWVvdXQoYShnLHQsMSksMCl9KSx0LmV4cG9ydHM9e3NldDpwLGNsZWFyOmh9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big1KSxvPW4oOSksaT1uKDQwKSxhPW4oNzkpLHM9bigxNSksdT1uKDQ0KSxsPW4oNiksYz1uKDM5KSxmPW4oMzcpLHA9bigxMSksaD1uKDQyKS5mLGQ9bigxMCkuZix2PW4oOTMpLG09big1MyksXz1cIkFycmF5QnVmZmVyXCIsZz1cIkRhdGFWaWV3XCIseT1cInByb3RvdHlwZVwiLGI9XCJXcm9uZyBsZW5ndGghXCIsdz1cIldyb25nIGluZGV4IVwiLHg9cltfXSxFPXJbZ10sVD1yLk1hdGgsTz1yLlJhbmdlRXJyb3IsUz1yLkluZmluaXR5LFA9eCxNPVQuYWJzLGo9VC5wb3csQT1ULmZsb29yLEM9VC5sb2csaz1ULkxOMixSPVwiYnVmZmVyXCIsST1cImJ5dGVMZW5ndGhcIixOPVwiYnl0ZU9mZnNldFwiLFU9bz9cIl9iXCI6UixGPW8/XCJfbFwiOkksTD1vP1wiX29cIjpOLEQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG8saSxhPUFycmF5KG4pLHM9OCpuLWUtMSx1PSgxPDxzKS0xLGw9dT4+MSxjPTIzPT09ZT9qKDIsLTI0KS1qKDIsLTc3KTowLGY9MCxwPXQ8MHx8MD09PXQmJjEvdDwwPzE6MDtmb3IodD1NKHQpLHQhPXR8fHQ9PT1TPyhvPXQhPXQ/MTowLHI9dSk6KHI9QShDKHQpL2spLHQqKGk9aigyLC1yKSk8MSYmKHItLSxpKj0yKSx0Kz1yK2w+PTE/Yy9pOmMqaigyLDEtbCksdCppPj0yJiYocisrLGkvPTIpLHIrbD49dT8obz0wLHI9dSk6citsPj0xPyhvPSh0KmktMSkqaigyLGUpLHIrPWwpOihvPXQqaigyLGwtMSkqaigyLGUpLHI9MCkpO2U+PTg7YVtmKytdPTI1NSZvLG8vPTI1NixlLT04KTtmb3Iocj1yPDxlfG8scys9ZTtzPjA7YVtmKytdPTI1NSZyLHIvPTI1NixzLT04KTtyZXR1cm4gYVstLWZdfD0xMjgqcCxhfSxCPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPTgqbi1lLTEsaT0oMTw8byktMSxhPWk+PjEscz1vLTcsdT1uLTEsbD10W3UtLV0sYz0xMjcmbDtmb3IobD4+PTc7cz4wO2M9MjU2KmMrdFt1XSx1LS0scy09OCk7Zm9yKHI9YyYoMTw8LXMpLTEsYz4+PS1zLHMrPWU7cz4wO3I9MjU2KnIrdFt1XSx1LS0scy09OCk7aWYoMD09PWMpYz0xLWE7ZWxzZXtpZihjPT09aSlyZXR1cm4gcj9OYU46bD8tUzpTO3IrPWooMixlKSxjLT1hfXJldHVybihsPy0xOjEpKnIqaigyLGMtZSl9LFY9ZnVuY3Rpb24odCl7cmV0dXJuIHRbM108PDI0fHRbMl08PDE2fHRbMV08PDh8dFswXX0sVz1mdW5jdGlvbih0KXtyZXR1cm5bMjU1JnRdfSxYPWZ1bmN0aW9uKHQpe3JldHVyblsyNTUmdCx0Pj44JjI1NV19LHo9ZnVuY3Rpb24odCl7cmV0dXJuWzI1NSZ0LHQ+PjgmMjU1LHQ+PjE2JjI1NSx0Pj4yNCYyNTVdfSxHPWZ1bmN0aW9uKHQpe3JldHVybiBEKHQsNTIsOCl9LHE9ZnVuY3Rpb24odCl7cmV0dXJuIEQodCwyMyw0KX0sSD1mdW5jdGlvbih0LGUsbil7ZCh0W3ldLGUse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW25dfX0pfSxZPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPStuLGk9ZihvKTtpZihvIT1pfHxpPDB8fGkrZT50W0ZdKXRocm93IE8odyk7XG52YXIgYT10W1VdLl9iLHM9aSt0W0xdLHU9YS5zbGljZShzLHMrZSk7cmV0dXJuIHI/dTp1LnJldmVyc2UoKX0sSz1mdW5jdGlvbih0LGUsbixyLG8saSl7dmFyIGE9K24scz1mKGEpO2lmKGEhPXN8fHM8MHx8cytlPnRbRl0pdGhyb3cgTyh3KTtmb3IodmFyIHU9dFtVXS5fYixsPXMrdFtMXSxjPXIoK28pLHA9MDtwPGU7cCsrKXVbbCtwXT1jW2k/cDplLXAtMV19LCQ9ZnVuY3Rpb24odCxlKXtjKHQseCxfKTt2YXIgbj0rZSxyPXAobik7aWYobiE9cil0aHJvdyBPKGIpO3JldHVybiByfTtpZihhLkFCVil7aWYoIWwoZnVuY3Rpb24oKXtuZXcgeH0pfHwhbChmdW5jdGlvbigpe25ldyB4KC41KX0pKXt4PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUCgkKHRoaXMsdCkpfTtmb3IodmFyIFosUT14W3ldPVBbeV0sSj1oKFApLHR0PTA7Si5sZW5ndGg+dHQ7KShaPUpbdHQrK10paW4geHx8cyh4LFosUFtaXSk7aXx8KFEuY29uc3RydWN0b3I9eCl9dmFyIGV0PW5ldyBFKG5ldyB4KDIpKSxudD1FW3ldLnNldEludDg7ZXQuc2V0SW50OCgwLDIxNDc0ODM2NDgpLGV0LnNldEludDgoMSwyMTQ3NDgzNjQ5KSwhZXQuZ2V0SW50OCgwKSYmZXQuZ2V0SW50OCgxKXx8dShFW3ldLHtzZXRJbnQ4OmZ1bmN0aW9uKHQsZSl7bnQuY2FsbCh0aGlzLHQsZTw8MjQ+PjI0KX0sc2V0VWludDg6ZnVuY3Rpb24odCxlKXtudC5jYWxsKHRoaXMsdCxlPDwyND4+MjQpfX0sITApfWVsc2UgeD1mdW5jdGlvbih0KXt2YXIgZT0kKHRoaXMsdCk7dGhpcy5fYj12LmNhbGwoQXJyYXkoZSksMCksdGhpc1tGXT1lfSxFPWZ1bmN0aW9uKHQsZSxuKXtjKHRoaXMsRSxnKSxjKHQseCxnKTt2YXIgcj10W0ZdLG89ZihlKTtpZihvPDB8fG8+cil0aHJvdyBPKFwiV3Jvbmcgb2Zmc2V0IVwiKTtpZihuPXZvaWQgMD09PW4/ci1vOnAobiksbytuPnIpdGhyb3cgTyhiKTt0aGlzW1VdPXQsdGhpc1tMXT1vLHRoaXNbRl09bn0sbyYmKEgoeCxJLFwiX2xcIiksSChFLFIsXCJfYlwiKSxIKEUsSSxcIl9sXCIpLEgoRSxOLFwiX29cIikpLHUoRVt5XSx7Z2V0SW50ODpmdW5jdGlvbih0KXtyZXR1cm4gWSh0aGlzLDEsdClbMF08PDI0Pj4yNH0sZ2V0VWludDg6ZnVuY3Rpb24odCl7cmV0dXJuIFkodGhpcywxLHQpWzBdfSxnZXRJbnQxNjpmdW5jdGlvbih0KXt2YXIgZT1ZKHRoaXMsMix0LGFyZ3VtZW50c1sxXSk7cmV0dXJuKGVbMV08PDh8ZVswXSk8PDE2Pj4xNn0sZ2V0VWludDE2OmZ1bmN0aW9uKHQpe3ZhciBlPVkodGhpcywyLHQsYXJndW1lbnRzWzFdKTtyZXR1cm4gZVsxXTw8OHxlWzBdfSxnZXRJbnQzMjpmdW5jdGlvbih0KXtyZXR1cm4gVihZKHRoaXMsNCx0LGFyZ3VtZW50c1sxXSkpfSxnZXRVaW50MzI6ZnVuY3Rpb24odCl7cmV0dXJuIFYoWSh0aGlzLDQsdCxhcmd1bWVudHNbMV0pKT4+PjB9LGdldEZsb2F0MzI6ZnVuY3Rpb24odCl7cmV0dXJuIEIoWSh0aGlzLDQsdCxhcmd1bWVudHNbMV0pLDIzLDQpfSxnZXRGbG9hdDY0OmZ1bmN0aW9uKHQpe3JldHVybiBCKFkodGhpcyw4LHQsYXJndW1lbnRzWzFdKSw1Miw4KX0sc2V0SW50ODpmdW5jdGlvbih0LGUpe0sodGhpcywxLHQsVyxlKX0sc2V0VWludDg6ZnVuY3Rpb24odCxlKXtLKHRoaXMsMSx0LFcsZSl9LHNldEludDE2OmZ1bmN0aW9uKHQsZSl7Syh0aGlzLDIsdCxYLGUsYXJndW1lbnRzWzJdKX0sc2V0VWludDE2OmZ1bmN0aW9uKHQsZSl7Syh0aGlzLDIsdCxYLGUsYXJndW1lbnRzWzJdKX0sc2V0SW50MzI6ZnVuY3Rpb24odCxlKXtLKHRoaXMsNCx0LHosZSxhcmd1bWVudHNbMl0pfSxzZXRVaW50MzI6ZnVuY3Rpb24odCxlKXtLKHRoaXMsNCx0LHosZSxhcmd1bWVudHNbMl0pfSxzZXRGbG9hdDMyOmZ1bmN0aW9uKHQsZSl7Syh0aGlzLDQsdCxxLGUsYXJndW1lbnRzWzJdKX0sc2V0RmxvYXQ2NDpmdW5jdGlvbih0LGUpe0sodGhpcyw4LHQsRyxlLGFyZ3VtZW50c1syXSl9fSk7bSh4LF8pLG0oRSxnKSxzKEVbeV0sYS5WSUVXLCEwKSxlW19dPXgsZVtnXT1FfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1KSxvPW4oMzEpLGk9big0MCksYT1uKDE2MSkscz1uKDEwKS5mO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1vLlN5bWJvbHx8KG8uU3ltYm9sPWk/e306ci5TeW1ib2x8fHt9KTtcIl9cIj09dC5jaGFyQXQoMCl8fHQgaW4gZXx8cyhlLHQse3ZhbHVlOmEuZih0KX0pfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNTgpLG89big4KShcIml0ZXJhdG9yXCIpLGk9big1Mik7dC5leHBvcnRzPW4oMzEpLmdldEl0ZXJhdG9yTWV0aG9kPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9dClyZXR1cm4gdFtvXXx8dFtcIkBAaXRlcmF0b3JcIl18fGlbcih0KV19fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big1MCksbz1uKDE0OSksaT1uKDUyKSxhPW4oMTgpO3QuZXhwb3J0cz1uKDEwMykoQXJyYXksXCJBcnJheVwiLGZ1bmN0aW9uKHQsZSl7dGhpcy5fdD1hKHQpLHRoaXMuX2k9MCx0aGlzLl9rPWV9LGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fdCxlPXRoaXMuX2ssbj10aGlzLl9pKys7cmV0dXJuIXR8fG4+PXQubGVuZ3RoPyh0aGlzLl90PXZvaWQgMCxvKDEpKTpcImtleXNcIj09ZT9vKDAsbik6XCJ2YWx1ZXNcIj09ZT9vKDAsdFtuXSk6bygwLFtuLHRbbl1dKX0sXCJ2YWx1ZXNcIiksaS5Bcmd1bWVudHM9aS5BcnJheSxyKFwia2V5c1wiKSxyKFwidmFsdWVzXCIpLHIoXCJlbnRyaWVzXCIpfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0OCksbz1uKDI5KSxpPXIobyxcIk1hcFwiKTt0LmV4cG9ydHM9aX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9LTEsbj1udWxsPT10PzA6dC5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK2U8bjspe3ZhciByPXRbZV07dGhpcy5zZXQoclswXSxyWzFdKX19dmFyIG89big1MzUpLGk9big1MzYpLGE9big1MzcpLHM9big1MzgpLHU9big1MzkpO3IucHJvdG90eXBlLmNsZWFyPW8sci5wcm90b3R5cGUuZGVsZXRlPWksci5wcm90b3R5cGUuZ2V0PWEsci5wcm90b3R5cGUuaGFzPXMsci5wcm90b3R5cGUuc2V0PXUsdC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2Zvcih2YXIgbj0tMSxyPW51bGw9PXQ/MDp0Lmxlbmd0aCxvPUFycmF5KHIpOysrbjxyOylvW25dPWUodFtuXSxuLHQpO3JldHVybiBvfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe2U9byhlLHQpO2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGg7bnVsbCE9dCYmbjxyOyl0PXRbaShlW24rK10pXTtyZXR1cm4gbiYmbj09cj90OnZvaWQgMH12YXIgbz1uKDgzKSxpPW4oNjMpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbixhLHMpe3JldHVybiB0PT09ZXx8KG51bGw9PXR8fG51bGw9PWV8fCFpKHQpJiYhaShlKT90IT09dCYmZSE9PWU6byh0LGUsbixhLHIscykpfXZhciBvPW4oNDc4KSxpPW4oNjQpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe2lmKG8odCkpcmV0dXJuITE7dmFyIG49dHlwZW9mIHQ7cmV0dXJuIShcIm51bWJlclwiIT1uJiZcInN5bWJvbFwiIT1uJiZcImJvb2xlYW5cIiE9biYmbnVsbCE9dCYmIWkodCkpfHwocy50ZXN0KHQpfHwhYS50ZXN0KHQpfHxudWxsIT1lJiZ0IGluIE9iamVjdChlKSl9dmFyIG89bigzMCksaT1uKDg5KSxhPS9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8scz0vXlxcdyokLzt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiB0fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0NzcpLG89big2NCksaT1PYmplY3QucHJvdG90eXBlLGE9aS5oYXNPd25Qcm9wZXJ0eSxzPWkucHJvcGVydHlJc0VudW1lcmFibGUsdT1yKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSk/cjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0KSYmYS5jYWxsKHQsXCJjYWxsZWVcIikmJiFzLmNhbGwodCxcImNhbGxlZVwiKX07dC5leHBvcnRzPXV9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIG8odCxlKX12YXIgbz1uKDEyMyk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmdD4tMSYmdCUxPT0wJiZ0PD1yfXZhciByPTkwMDcxOTkyNTQ3NDA5OTE7dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Lmxlbmd0aD9vKHQsaSk6MH12YXIgbz1uKDQ5NCksaT1uKDEyNSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSl7dmFyIG4scjtpZih2b2lkIDAhPT1lJiYoIU51bWJlci5pc0Zpbml0ZShlKXx8ZSUxIT09ZSkpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBvZiBkaW1lbnNpb24gdG8gdW5zcXVlZXplIG11c3QgYmUgYW4gaW50ZWdlclwiKTtyZXR1cm4gZT12b2lkIDA9PT1lP3Quc2hhcGUubGVuZ3RoOmUsbj10LnNoYXBlLnNsaWNlKDApLHI9dC5zdHJpZGUuc2xpY2UoMCksbi5zcGxpY2UoZXx8MCwwLDEpLHIuc3BsaWNlKGV8fDAsMCwocltlXXx8MSkqKG5bZSsxXXx8MSkpLG8odC5kYXRhLG4scix0Lm9mZnNldCl9dmFyIG89big5MSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gcigpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBvKHQpe2lmKGM9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KHQsMCk7aWYoKGM9PT1ufHwhYykmJnNldFRpbWVvdXQpcmV0dXJuIGM9c2V0VGltZW91dCxzZXRUaW1lb3V0KHQsMCk7dHJ5e3JldHVybiBjKHQsMCl9Y2F0Y2goZSl7dHJ5e3JldHVybiBjLmNhbGwobnVsbCx0LDApfWNhdGNoKGUpe3JldHVybiBjLmNhbGwodGhpcyx0LDApfX19ZnVuY3Rpb24gaSh0KXtpZihmPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQodCk7aWYoKGY9PT1yfHwhZikmJmNsZWFyVGltZW91dClyZXR1cm4gZj1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHQpO3RyeXtyZXR1cm4gZih0KX1jYXRjaChlKXt0cnl7cmV0dXJuIGYuY2FsbChudWxsLHQpfWNhdGNoKGUpe3JldHVybiBmLmNhbGwodGhpcyx0KX19fWZ1bmN0aW9uIGEoKXt2JiZoJiYodj0hMSxoLmxlbmd0aD9kPWguY29uY2F0KGQpOm09LTEsZC5sZW5ndGgmJnMoKSl9ZnVuY3Rpb24gcygpe2lmKCF2KXt2YXIgdD1vKGEpO3Y9ITA7Zm9yKHZhciBlPWQubGVuZ3RoO2U7KXtmb3IoaD1kLGQ9W107KyttPGU7KWgmJmhbbV0ucnVuKCk7bT0tMSxlPWQubGVuZ3RofWg9bnVsbCx2PSExLGkodCl9fWZ1bmN0aW9uIHUodCxlKXt0aGlzLmZ1bj10LHRoaXMuYXJyYXk9ZX1mdW5jdGlvbiBsKCl7fXZhciBjLGYscD10LmV4cG9ydHM9e307IWZ1bmN0aW9uKCl7dHJ5e2M9XCJmdW5jdGlvblwiPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0Om59Y2F0Y2godCl7Yz1ufXRyeXtmPVwiZnVuY3Rpb25cIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6cn1jYXRjaCh0KXtmPXJ9fSgpO3ZhciBoLGQ9W10sdj0hMSxtPS0xO3AubmV4dFRpY2s9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspZVtuLTFdPWFyZ3VtZW50c1tuXTtkLnB1c2gobmV3IHUodCxlKSksMSE9PWQubGVuZ3RofHx2fHxvKHMpfSx1LnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSxwLnRpdGxlPVwiYnJvd3NlclwiLHAuYnJvd3Nlcj0hMCxwLmVudj17fSxwLmFyZ3Y9W10scC52ZXJzaW9uPVwiXCIscC52ZXJzaW9ucz17fSxwLm9uPWwscC5hZGRMaXN0ZW5lcj1sLHAub25jZT1sLHAub2ZmPWwscC5yZW1vdmVMaXN0ZW5lcj1sLHAucmVtb3ZlQWxsTGlzdGVuZXJzPWwscC5lbWl0PWwscC5iaW5kaW5nPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxwLmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifSxwLmNoZGlyPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX0scC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oNjcpLGw9cih1KSxjPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7byh0aGlzLGUpO3ZhciByPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzKSk7aWYoXCJtYXhcIj09PXQpci5wcm9ncmFtPXIud2ViZ2wuY3JlYXRlUHJvZ3JhbShuKDYxNykpO2Vsc2V7aWYoXCJhdmVyYWdlXCIhPT10KXRocm93IG5ldyBFcnJvcihcIltXZWJHTFBvb2xpbmcyRF0gcG9vbGluZyBmdW5jdGlvbiBtdXN0IGJlIG1heCBvciBhdmVyYWdlLlwiKTtyLnByb2dyYW09ci53ZWJnbC5jcmVhdGVQcm9ncmFtKG4oNjE2KSl9cmV0dXJuIHJ9cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJfYmluZElucHV0VGV4dHVyZXNcIix2YWx1ZTpmdW5jdGlvbih0LG4pe3ZhciByPXRoaXMud2ViZ2wuY29udGV4dDt0aGlzLm51bVRleHR1cmVzPTIsdGhpcy5fYmluZElucHV0VGV4dHVyZSh0aGlzLnByb2dyYW0sdC50ZXh0dXJlLHIuVEVYVFVSRTAsZS5JTlBVVF9URVhUVVJFX05BTUUpLHRoaXMuX2JpbmRJbnB1dFRleHR1cmUodGhpcy5wcm9ncmFtLG4udGV4dHVyZSxyLlRFWFRVUkUxLGUuUE9PTF9JTUFQX1RFWFRVUkVfTkFNRSl9fSx7a2V5OlwiX2JpbmRVbmlmb3Jtc1wiLHZhbHVlOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy53ZWJnbC5jb250ZXh0LG89dC5zaGFwZVswXSxpPXQuc2hhcGVbMV0sYT10aGlzLndlYmdsLmdldFBhZChpKSxzPW4uc2hhcGVbMV0sdT10aGlzLndlYmdsLmdldFBhZChzKTtyLnVuaWZvcm0xaShyLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sZS5JTlBVVF9ST1dTX1VOSUZPUk1fTkFNRSksbyksci51bmlmb3JtMWkoci5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLGUuQ0hBTk5FTFNfVU5JRk9STV9OQU1FKSxpKSxyLnVuaWZvcm0xaShyLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sZS5DSEFOTkVMU19QQURfVU5JRk9STV9OQU1FKSxhKSxyLnVuaWZvcm0xaShyLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sZS5QT09MX0VMRU1FTlRTX1VOSUZPUk1fTkFNRSkscyksci51bmlmb3JtMWkoci5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLGUuUE9PTF9FTEVNRU5UU19QQURfVU5JRk9STV9OQU1FKSx1KX19LHtrZXk6XCJfYmluZE91dHB1dFRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIHI9ZS5zaGFwZVswXSxvPXQuc2hhcGVbMV0saT10aGlzLndlYmdsLmdldFBhZChvKTt0aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKHIsKG8raSkvNCxuLnRleHR1cmUpfX0se2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3RoaXMud2ViZ2wuc2VsZWN0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO3ZhciBuPWUuc2hhcGVbMF0scj10LnNoYXBlWzFdLG89bmV3IHdlYmxhcy5waXBlbGluZS5UZW5zb3IoW24scl0sbnVsbCk7cmV0dXJuIHRoaXMuX2JpbmRJbnB1dFRleHR1cmVzKHQsZSksdGhpcy5fYmluZFVuaWZvcm1zKHQsZSksdGhpcy5fYmluZE91dHB1dFRleHR1cmUodCxlLG8pLHRoaXMuX2NvbXB1dGUoKSx0aGlzLl91bmJpbmRJbnB1dFRleHR1cmVzKCksb319XSksZX0obC5kZWZhdWx0KTtjLklOUFVUX1RFWFRVUkVfTkFNRT1cIlhcIixjLlBPT0xfSU1BUF9URVhUVVJFX05BTUU9XCJwb29sSW5kZXhNYXBwaW5nXCIsYy5JTlBVVF9ST1dTX1VOSUZPUk1fTkFNRT1cImlucHV0Um93c1wiLGMuQ0hBTk5FTFNfVU5JRk9STV9OQU1FPVwiY2hhbm5lbHNcIixjLkNIQU5ORUxTX1BBRF9VTklGT1JNX05BTUU9XCJjaGFubmVsc1BhZFwiLGMuUE9PTF9FTEVNRU5UU19VTklGT1JNX05BTUU9XCJwb29sRWxlbWVudHNcIixjLlBPT0xfRUxFTUVOVFNfUEFEX1VOSUZPUk1fTkFNRT1cInBvb2xFbGVtZW50c1BhZFwiLGUuZGVmYXVsdD1jfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5JbnB1dExheWVyPXZvaWQgMDt2YXIgbz1uKDIwOCk7T2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJlwiX19lc01vZHVsZVwiIT09dCYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb1t0XX19KX0pO3ZhciBpPW4oMjM2KTtPYmplY3Qua2V5cyhpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe1wiZGVmYXVsdFwiIT09dCYmXCJfX2VzTW9kdWxlXCIhPT10JiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBpW3RdfX0pfSk7dmFyIGE9bigyMjMpO09iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24odCl7XCJkZWZhdWx0XCIhPT10JiZcIl9fZXNNb2R1bGVcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGFbdF19fSl9KTt2YXIgcz1uKDI1NCk7T2JqZWN0LmtleXMocykuZm9yRWFjaChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJlwiX19lc01vZHVsZVwiIT09dCYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gc1t0XX19KX0pO3ZhciB1PW4oMjQzKTtPYmplY3Qua2V5cyh1KS5mb3JFYWNoKGZ1bmN0aW9uKHQpe1wiZGVmYXVsdFwiIT09dCYmXCJfX2VzTW9kdWxlXCIhPT10JiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1W3RdfX0pfSk7dmFyIGw9bigyMzgpO09iamVjdC5rZXlzKGwpLmZvckVhY2goZnVuY3Rpb24odCl7XCJkZWZhdWx0XCIhPT10JiZcIl9fZXNNb2R1bGVcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGxbdF19fSl9KTt2YXIgYz1uKDI0MSk7T2JqZWN0LmtleXMoYykuZm9yRWFjaChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJlwiX19lc01vZHVsZVwiIT09dCYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY1t0XX19KX0pO3ZhciBmPW4oMTM3KTtPYmplY3Qua2V5cyhmKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe1wiZGVmYXVsdFwiIT09dCYmXCJfX2VzTW9kdWxlXCIhPT10JiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBmW3RdfX0pfSk7dmFyIHA9bigyNjApO09iamVjdC5rZXlzKHApLmZvckVhY2goZnVuY3Rpb24odCl7XCJkZWZhdWx0XCIhPT10JiZcIl9fZXNNb2R1bGVcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHBbdF19fSl9KTt2YXIgaD1uKDIwMSksZD1yKGgpO2UuSW5wdXRMYXllcj1kLmRlZmF1bHR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMiksZj1yKGMpLHA9bigzKSxoPXIocCksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiX1Bvb2xpbmcxRFwiO3ZhciByPXQucG9vbExlbmd0aCxhPXZvaWQgMD09PXI/MjpyLHM9dC5zdHJpZGUsdT12b2lkIDA9PT1zP251bGw6cyxsPXQuYm9yZGVyTW9kZSxjPXZvaWQgMD09PWw/XCJ2YWxpZFwiOmw7cmV0dXJuIG4ucG9vbExlbmd0aD1hLG4uc3RyaWRlPW51bGw9PT11P2E6dSxuLmJvcmRlck1vZGU9YyxuLnBvb2xpbmdGdW5jPVwibWF4XCIsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtpZihcIm1heFwiIT09dGhpcy5wb29saW5nRnVuYyYmXCJhdmVyYWdlXCIhPT10aGlzLnBvb2xpbmdGdW5jKXRocm93IG5ldyBFcnJvcihcIltwb29saW5nLl9Qb29saW5nMURdIHBvb2xpbmcgZnVuY3Rpb24gbXVzdCBiZSBtYXggb3IgYXZlcmFnZS5cIik7Zm9yKHZhciBlPVwidmFsaWRcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLmZsb29yKCh0LnRlbnNvci5zaGFwZVswXS10aGlzLnBvb2xMZW5ndGgrdGhpcy5zdHJpZGUpL3RoaXMuc3RyaWRlKTpNYXRoLmZsb29yKCh0LnRlbnNvci5zaGFwZVswXSt0aGlzLnN0cmlkZS0xKS90aGlzLnN0cmlkZSksbj1uZXcgZi5kZWZhdWx0KFtdLFtlLHQudGVuc29yLnNoYXBlWzFdXSkscj1uZXcgZi5kZWZhdWx0KFtdLFt0LnRlbnNvci5zaGFwZVsxXV0pLG89XCJ2YWxpZFwiPT09dGhpcy5ib3JkZXJNb2RlPzA6TWF0aC5taW4oMCxNYXRoLmNlaWwoKHQudGVuc29yLnNoYXBlWzBdLShlLTEpKnRoaXMuc3RyaWRlLXRoaXMucG9vbExlbmd0aCkvMikpLGk9MDtpPGU7aSsrKXt2YXIgYT1NYXRoLm1heCgwLG8pLHM9dGhpcy5wb29sTGVuZ3RoK01hdGgubWluKDAsbyk7aC5kZWZhdWx0LmFzc2lnbihyLnRlbnNvcix0LnRlbnNvci5waWNrKGEsbnVsbCkpO2Zvcih2YXIgdT0xLGw9MTtsPHMmJiEoYStsPnQudGVuc29yLnNoYXBlWzBdLTEpO2wrKylcIm1heFwiPT09dGhpcy5wb29saW5nRnVuYz9oLmRlZmF1bHQubWF4ZXEoci50ZW5zb3IsdC50ZW5zb3IucGljayhhK2wsbnVsbCkpOlwiYXZlcmFnZVwiPT09dGhpcy5wb29saW5nRnVuYyYmaC5kZWZhdWx0LmFkZGVxKHIudGVuc29yLHQudGVuc29yLnBpY2soYStsLG51bGwpKSx1Kz0xO1wiYXZlcmFnZVwiPT09dGhpcy5wb29saW5nRnVuYyYmaC5kZWZhdWx0LmRpdnNlcShyLnRlbnNvcix1KSxoLmRlZmF1bHQuYXNzaWduKG4udGVuc29yLnBpY2soaSxudWxsKSxyLnRlbnNvciksbys9dGhpcy5zdHJpZGV9cmV0dXJuIHQudGVuc29yPW4udGVuc29yLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PWR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHM9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXMubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7IXImJnMucmV0dXJuJiZzLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIHQoZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGw9bigxKSxjPXIobCksZj1uKDIpLHA9cihmKSxoPW4oMyksZD1yKGgpLHY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIl9Qb29saW5nMkRcIjt2YXIgcj10LnBvb2xTaXplLGE9dm9pZCAwPT09cj9bMiwyXTpyLHM9dC5zdHJpZGVzLHU9dm9pZCAwPT09cz9udWxsOnMsbD10LmJvcmRlck1vZGUsYz12b2lkIDA9PT1sP1widmFsaWRcIjpsLGY9dC5kaW1PcmRlcmluZyxwPXZvaWQgMD09PWY/XCJ0ZlwiOmY7cmV0dXJuIG4ucG9vbFNpemU9YSxuLnN0cmlkZXM9bnVsbD09PXU/YTp1LG4uYm9yZGVyTW9kZT1jLG4uZGltT3JkZXJpbmc9cCxuLnBvb2xpbmdGdW5jPVwibWF4XCIsbn1yZXR1cm4gYShlLHQpLHUoZSxbe2tleTpcIl9jYWxjT3V0cHV0U2hhcGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT1zKHQsMyksbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1zKHRoaXMucG9vbFNpemUsMiksYT1pWzBdLHU9aVsxXSxsPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGguZmxvb3IoKG4rdGhpcy5zdHJpZGVzWzBdLTEpL3RoaXMuc3RyaWRlc1swXSk6TWF0aC5mbG9vcigobi1hK3RoaXMuc3RyaWRlc1swXSkvdGhpcy5zdHJpZGVzWzBdKSxjPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGguZmxvb3IoKHIrdGhpcy5zdHJpZGVzWzFdLTEpL3RoaXMuc3RyaWRlc1sxXSk6TWF0aC5mbG9vcigoci11K3RoaXMuc3RyaWRlc1sxXSkvdGhpcy5zdHJpZGVzWzFdKSxmPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGgubWF4KDAsTWF0aC5mbG9vcigobC0xKSp0aGlzLnN0cmlkZXNbMF0rYS1uKSk6MCxwPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGgubWF4KDAsTWF0aC5mbG9vcigoYy0xKSp0aGlzLnN0cmlkZXNbMV0rdS1yKSk6MCxoPU1hdGguZmxvb3IoZi8yKSxkPWYtaCx2PU1hdGguZmxvb3IocC8yKSxtPXAtdjt0aGlzLm91dHB1dFNoYXBlPVtsLGMsb10sdGhpcy5pbnB1dFBhZGRpbmc9W2gsZCx2LG1dfX0se2tleTpcIl9wYWRJbnB1dFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKFwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlKXt2YXIgZT1zKHQudGVuc29yLnNoYXBlLDMpLG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9cyh0aGlzLmlucHV0UGFkZGluZyw0KSxhPWlbMF0sdT1pWzFdLGw9aVsyXSxjPWlbM10sZj1uK2ErdSxoPXIrbCtjLHY9bmV3IHAuZGVmYXVsdChbXSxbZixoLG9dKTtcIm1heFwiPT09dGhpcy5wb29saW5nRnVuYyYmZC5kZWZhdWx0LmFzc2lnbnModi50ZW5zb3IsTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSxkLmRlZmF1bHQuYXNzaWduKHYudGVuc29yLmhpKG4rYSxyK2wsbykubG8oYSxsLDApLHQudGVuc29yKSx0LnRlbnNvcj12LnRlbnNvcn1yZXR1cm4gdH19LHtrZXk6XCJfcG9vbEluZGV4TWFwcGluZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLl9wb29sSW5kaWNlc1BlckNoYW5uZWwpe2Zvcih2YXIgZT10WzBdLG49dFsxXSxyPW5ldyBwLmRlZmF1bHQoW10sW2Usbl0pLG89MCxpPTA7aTxlO2krKylmb3IodmFyIGE9MDthPG47YSsrKXIudGVuc29yLnNldChpLGEsbyksbys9MTtpZihcInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZSl7dmFyIHU9cyh0aGlzLmlucHV0UGFkZGluZyw0KSxsPXVbMF0sYz11WzFdLGY9dVsyXSxoPXVbM107ZT1lK2wrYyxuPW4rZitoO3ZhciB2PW5ldyBwLmRlZmF1bHQoW10sW2Usbl0pO2QuZGVmYXVsdC5hc3NpZ25zKHYudGVuc29yLC0xKSxkLmRlZmF1bHQuYXNzaWduKHYudGVuc29yLmhpKHRbMF0rbCx0WzFdK2YpLmxvKGwsZiksci50ZW5zb3IpLHIudGVuc29yPXYudGVuc29yfXZhciBtPXModGhpcy5wb29sU2l6ZSwyKSxfPW1bMF0sZz1tWzFdLHk9dGhpcy5vdXRwdXRTaGFwZVswXSxiPXRoaXMub3V0cHV0U2hhcGVbMV07dGhpcy5fcG9vbEluZGljZXNQZXJDaGFubmVsPW5ldyBwLmRlZmF1bHQoW10sW3kqYixfKmddKTtmb3IodmFyIHc9bmV3IHAuZGVmYXVsdChbXSxbXyxnXSkseD0wLEU9MCxUPWUtXztFPD1UO0UrPXRoaXMuc3RyaWRlc1swXSlmb3IodmFyIE89MCxTPW4tZztPPD1TO08rPXRoaXMuc3RyaWRlc1sxXSlkLmRlZmF1bHQuYXNzaWduKHcudGVuc29yLHIudGVuc29yLmhpKEUrXyxPK2cpLmxvKEUsTykpLHRoaXMuX3Bvb2xJbmRpY2VzUGVyQ2hhbm5lbC50ZW5zb3IuZGF0YS5zZXQody50ZW5zb3IuZGF0YSx4KSx4Kz1fKmc7dGhpcy5fcG9vbEluZGljZXNQZXJDaGFubmVsLmNyZWF0ZVdlYmxhc1RlbnNvcigpfX19LHtrZXk6XCJfY2FsbFBpcGVsaW5lTW9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCF0LndlYmxhc1RlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSBwYXNzZWQgaW4gZG9lcyBub3QgY29udGFpbiB3ZWJsYXMgdGVuc29yLlwiKTtyZXR1cm4gdGhpcy5fY2FsY091dHB1dFNoYXBlKHQuX2FjdHVhbFNoYXBlKSx0aGlzLl9wb29sSW5kZXhNYXBwaW5nKHQuX2FjdHVhbFNoYXBlKSx0LndlYmxhc1RlbnNvcj10aGlzLndlYmdsUG9vbGluZzJELmNhbGwodC53ZWJsYXNUZW5zb3IsdGhpcy5fcG9vbEluZGljZXNQZXJDaGFubmVsLndlYmxhc1RlbnNvciksdC5fZnJvbVBpcGVsaW5lPSEwLHQuX2FjdHVhbFNoYXBlPXRoaXMub3V0cHV0U2hhcGUsdH19LHtrZXk6XCJfY2FsbFJlZ3VsYXJNb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoIXQudGVuc29yKXRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIHBhc3NlZCBpbiBkb2VzIG5vdCBjb250YWluIHRlbnNvci5cIik7XCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgxLDIsMCkpLHRoaXMuX2NhbGNPdXRwdXRTaGFwZSh0LnRlbnNvci5zaGFwZSksdGhpcy5fcGFkSW5wdXQodCk7Zm9yKHZhciBlPXModC50ZW5zb3Iuc2hhcGUsMyksbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1zKHRoaXMucG9vbFNpemUsMiksYT1pWzBdLHU9aVsxXSxsPW5ldyBwLmRlZmF1bHQoW10sdGhpcy5vdXRwdXRTaGFwZSksYz1uZXcgcC5kZWZhdWx0KFtdLFthLHUsb10pLGY9cyh0aGlzLmlucHV0UGFkZGluZyw0KSxoPWZbMF0sdj1mWzFdLG09ZlsyXSxfPWZbM10sZz0wLHk9MDtnPD1uLWE7Zys9dGhpcy5zdHJpZGVzWzBdLHkrKyl7dmFyIGI9MDtnPGg/Yj1oLWc6ZythPm4tdiYmKGI9ZythLShuLXYpKTtmb3IodmFyIHc9MCx4PTA7dzw9ci11O3crPXRoaXMuc3RyaWRlc1sxXSx4Kyspe3ZhciBFPTA7dzxtP0U9bS13OncrdT5yLV8mJihFPXcrdS0oci1fKSksZC5kZWZhdWx0LmFzc2lnbihjLnRlbnNvcix0LnRlbnNvci5oaShnK2Esdyt1LG8pLmxvKGcsdywwKSk7Zm9yKHZhciBUPTA7VDxvO1QrKylpZihcIm1heFwiPT09dGhpcy5wb29saW5nRnVuYylsLnRlbnNvci5zZXQoeSx4LFQsZC5kZWZhdWx0LnN1cChjLnRlbnNvci5waWNrKG51bGwsbnVsbCxUKSkpO2Vsc2UgaWYoXCJhdmVyYWdlXCI9PT10aGlzLnBvb2xpbmdGdW5jKXt2YXIgTz0oYS1iKSoodS1FKTtsLnRlbnNvci5zZXQoeSx4LFQsZC5kZWZhdWx0LnN1bShjLnRlbnNvci5waWNrKG51bGwsbnVsbCxUKSkvTyl9fX1yZXR1cm4gdC50ZW5zb3I9bC50ZW5zb3IsXCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgyLDAsMSkpLHR9fSx7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9waXBlbGluZUVuYWJsZWQmJnQuX2Zyb21QaXBlbGluZT90aGlzLl9jYWxsUGlwZWxpbmVNb2RlKHQpOnRoaXMuX2NhbGxSZWd1bGFyTW9kZSh0KX19XSksZX0oYy5kZWZhdWx0KTtlLmRlZmF1bHQ9dn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEscz10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9cy5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXshciYmcy5yZXR1cm4mJnMucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufXJldHVybiBmdW5jdGlvbihlLG4pe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGU7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlyZXR1cm4gdChlLG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSx1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksbD1uKDEpLGM9cihsKSxmPW4oMikscD1yKGYpLGg9bigzKSxkPXIoaCksdj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiX1Bvb2xpbmczRFwiO3ZhciByPXQucG9vbFNpemUsYT12b2lkIDA9PT1yP1syLDIsMl06cixzPXQuc3RyaWRlcyx1PXZvaWQgMD09PXM/bnVsbDpzLGw9dC5ib3JkZXJNb2RlLGM9dm9pZCAwPT09bD9cInZhbGlkXCI6bCxmPXQuZGltT3JkZXJpbmcscD12b2lkIDA9PT1mP1widGZcIjpmO3JldHVybiBuLnBvb2xTaXplPWEsbi5zdHJpZGVzPW51bGw9PT11P2E6dSxuLmJvcmRlck1vZGU9YyxuLmRpbU9yZGVyaW5nPXAsbi5wb29saW5nRnVuYz1cIm1heFwiLG59cmV0dXJuIGEoZSx0KSx1KGUsW3trZXk6XCJfY2FsY091dHB1dFNoYXBlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9cyh0LnRlbnNvci5zaGFwZSw0KSxuPWVbMF0scj1lWzFdLG89ZVsyXSxpPWVbM10sYT1zKHRoaXMucG9vbFNpemUsMyksdT1hWzBdLGw9YVsxXSxjPWFbMl0sZj1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLmZsb29yKChuK3RoaXMuc3RyaWRlc1swXS0xKS90aGlzLnN0cmlkZXNbMF0pOk1hdGguZmxvb3IoKG4tdSt0aGlzLnN0cmlkZXNbMF0pL3RoaXMuc3RyaWRlc1swXSkscD1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLmZsb29yKChyK3RoaXMuc3RyaWRlc1sxXS0xKS90aGlzLnN0cmlkZXNbMV0pOk1hdGguZmxvb3IoKHItbCt0aGlzLnN0cmlkZXNbMV0pL3RoaXMuc3RyaWRlc1sxXSksaD1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLmZsb29yKChvK3RoaXMuc3RyaWRlc1syXS0xKS90aGlzLnN0cmlkZXNbMl0pOk1hdGguZmxvb3IoKG8tYyt0aGlzLnN0cmlkZXNbMl0pL3RoaXMuc3RyaWRlc1syXSksZD1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLm1heCgwLE1hdGguZmxvb3IoKGYtMSkqdGhpcy5zdHJpZGVzWzBdK3UtbikpOjAsdj1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLm1heCgwLE1hdGguZmxvb3IoKHAtMSkqdGhpcy5zdHJpZGVzWzFdK2wtcikpOjAsbT1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLm1heCgwLE1hdGguZmxvb3IoKGgtMSkqdGhpcy5zdHJpZGVzWzJdK2MtbykpOjAsXz1NYXRoLmZsb29yKGQvMiksZz1kLV8seT1NYXRoLmZsb29yKHYvMiksYj12LXksdz1NYXRoLmZsb29yKG0vMikseD1tLXc7dGhpcy5vdXRwdXRTaGFwZT1bZixwLGgsaV0sdGhpcy5pbnB1dFBhZGRpbmc9W18sZyx5LGIsdyx4XX19LHtrZXk6XCJfcGFkSW5wdXRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZihcInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZSl7dmFyIGU9cyh0LnRlbnNvci5zaGFwZSw0KSxuPWVbMF0scj1lWzFdLG89ZVsyXSxpPWVbM10sYT1zKHRoaXMuaW5wdXRQYWRkaW5nLDYpLHU9YVswXSxsPWFbMV0sYz1hWzJdLGY9YVszXSxoPWFbNF0sdj1hWzVdLG09bit1K2wsXz1yK2MrZixnPW8raCt2LHk9bmV3IHAuZGVmYXVsdChbXSxbbSxfLGcsaV0pO1wibWF4XCI9PT10aGlzLnBvb2xpbmdGdW5jJiZkLmRlZmF1bHQuYXNzaWducyh5LnRlbnNvcixOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLGQuZGVmYXVsdC5hc3NpZ24oeS50ZW5zb3IuaGkobit1LHIrYyxvK2gsaSkubG8odSxjLGgsMCksdC50ZW5zb3IpLHQudGVuc29yPXkudGVuc29yfXJldHVybiB0fX0se2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtpZihcIm1heFwiIT09dGhpcy5wb29saW5nRnVuYyYmXCJhdmVyYWdlXCIhPT10aGlzLnBvb2xpbmdGdW5jKXRocm93IG5ldyBFcnJvcihcIltwb29saW5nLl9Qb29saW5nM0RdIHBvb2xpbmcgZnVuY3Rpb24gbXVzdCBiZSBtYXggb3IgYXZlcmFnZS5cIik7XCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgxLDIsMywwKSksdGhpcy5fY2FsY091dHB1dFNoYXBlKHQpLHRoaXMuX3BhZElucHV0KHQpO2Zvcih2YXIgZT1zKHQudGVuc29yLnNoYXBlLDQpLG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9ZVszXSxhPXModGhpcy5wb29sU2l6ZSwzKSx1PWFbMF0sbD1hWzFdLGM9YVsyXSxmPW5ldyBwLmRlZmF1bHQoW10sdGhpcy5vdXRwdXRTaGFwZSksaD1uZXcgcC5kZWZhdWx0KFtdLFt1LGwsYyxpXSksdj1zKHRoaXMuaW5wdXRQYWRkaW5nLDYpLG09dlswXSxfPXZbMV0sZz12WzJdLHk9dlszXSxiPXZbNF0sdz12WzVdLHg9MCxFPTA7eDw9bi11O3grPXRoaXMuc3RyaWRlc1swXSxFKyspe3ZhciBUPTA7eDxtP1Q9bS14OngrdT5uLV8mJihUPXgrdS0obi1fKSk7Zm9yKHZhciBPPTAsUz0wO088PXItbDtPKz10aGlzLnN0cmlkZXNbMV0sUysrKXt2YXIgUD0wO088Zz9QPWctTzpPK2w+ci15JiYoUD1PK2wtKHIteSkpO2Zvcih2YXIgTT0wLGo9MDtNPD1vLWM7TSs9dGhpcy5zdHJpZGVzWzJdLGorKyl7dmFyIEE9MDtNPGI/QT1iLU06TStjPm8tdyYmKEE9TStjLShvLXcpKSxkLmRlZmF1bHQuYXNzaWduKGgudGVuc29yLHQudGVuc29yLmhpKHgrdSxPK2wsTStjLGkpLmxvKHgsTyxNLDApKTtmb3IodmFyIEM9MDtDPGk7QysrKWlmKFwibWF4XCI9PT10aGlzLnBvb2xpbmdGdW5jKWYudGVuc29yLnNldChFLFMsaixDLGQuZGVmYXVsdC5zdXAoaC50ZW5zb3IucGljayhudWxsLG51bGwsbnVsbCxDKSkpO2Vsc2UgaWYoXCJhdmVyYWdlXCI9PT10aGlzLnBvb2xpbmdGdW5jKXt2YXIgaz0odS1UKSoobC1QKSooYy1BKTtmLnRlbnNvci5zZXQoRSxTLGosQyxkLmRlZmF1bHQuc3VtKGgudGVuc29yLnBpY2sobnVsbCxudWxsLG51bGwsQykpL2spfX19fXJldHVybiB0LnRlbnNvcj1mLnRlbnNvcixcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDMsMCwxLDIpKSx0fX1dKSxlfShjLmRlZmF1bHQpO2UuZGVmYXVsdD12fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5HUlU9ZS5MU1RNPWUuU2ltcGxlUk5OPXZvaWQgMDt2YXIgbz1uKDI1NyksaT1yKG8pLGE9bigyNTYpLHM9cihhKSx1PW4oMjU1KSxsPXIodSk7ZS5TaW1wbGVSTk49aS5kZWZhdWx0LGUuTFNUTT1zLmRlZmF1bHQsZS5HUlU9bC5kZWZhdWx0fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigyMik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQmJlwiTnVtYmVyXCIhPXIodCkpdGhyb3cgVHlwZUVycm9yKGUpO3JldHVybit0fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMTIpLG89big0NiksaT1uKDExKTt0LmV4cG9ydHM9W10uY29weVdpdGhpbnx8ZnVuY3Rpb24odCxlKXt2YXIgbj1yKHRoaXMpLGE9aShuLmxlbmd0aCkscz1vKHQsYSksdT1vKGUsYSksbD1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMCxjPU1hdGgubWluKCh2b2lkIDA9PT1sP2E6byhsLGEpKS11LGEtcyksZj0xO2Zvcih1PHMmJnM8dStjJiYoZj0tMSx1Kz1jLTEscys9Yy0xKTtjLS0gPjA7KXUgaW4gbj9uW3NdPW5bdV06ZGVsZXRlIG5bc10scys9Zix1Kz1mO3JldHVybiBufX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNTEpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuPVtdO3JldHVybiByKHQsITEsbi5wdXNoLG4sZSksbn19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE0KSxvPW4oMTIpLGk9big1OSksYT1uKDExKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4scyx1KXtyKGUpO3ZhciBsPW8odCksYz1pKGwpLGY9YShsLmxlbmd0aCkscD11P2YtMTowLGg9dT8tMToxO2lmKG48Milmb3IoOzspe2lmKHAgaW4gYyl7cz1jW3BdLHArPWg7YnJlYWt9aWYocCs9aCx1P3A8MDpmPD1wKXRocm93IFR5cGVFcnJvcihcIlJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIil9Zm9yKDt1P3A+PTA6Zj5wO3ArPWgpcCBpbiBjJiYocz1lKHMsY1twXSxwLGwpKTtyZXR1cm4gc319LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDE0KSxvPW4oNyksaT1uKDczKSxhPVtdLnNsaWNlLHM9e30sdT1mdW5jdGlvbih0LGUsbil7aWYoIShlIGluIHMpKXtmb3IodmFyIHI9W10sbz0wO288ZTtvKyspcltvXT1cImFbXCIrbytcIl1cIjtzW2VdPUZ1bmN0aW9uKFwiRixhXCIsXCJyZXR1cm4gbmV3IEYoXCIrci5qb2luKFwiLFwiKStcIilcIil9cmV0dXJuIHNbZV0odCxuKX07dC5leHBvcnRzPUZ1bmN0aW9uLmJpbmR8fGZ1bmN0aW9uKHQpe3ZhciBlPXIodGhpcyksbj1hLmNhbGwoYXJndW1lbnRzLDEpLHM9ZnVuY3Rpb24oKXt2YXIgcj1uLmNvbmNhdChhLmNhbGwoYXJndW1lbnRzKSk7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBzP3UoZSxyLmxlbmd0aCxyKTppKGUscix0KX07cmV0dXJuIG8oZS5wcm90b3R5cGUpJiYocy5wcm90b3R5cGU9ZS5wcm90b3R5cGUpLHN9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMCkuZixvPW4oNDEpLGk9big0NCksYT1uKDMyKSxzPW4oMzkpLHU9bigyMyksbD1uKDUxKSxjPW4oMTAzKSxmPW4oMTQ5KSxwPW4oNDUpLGg9big5KSxkPW4oMzUpLmZhc3RLZXksdj1oP1wiX3NcIjpcInNpemVcIixtPWZ1bmN0aW9uKHQsZSl7dmFyIG4scj1kKGUpO2lmKFwiRlwiIT09cilyZXR1cm4gdC5faVtyXTtmb3Iobj10Ll9mO247bj1uLm4paWYobi5rPT1lKXJldHVybiBufTt0LmV4cG9ydHM9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKHQsZSxuLGMpe3ZhciBmPXQoZnVuY3Rpb24odCxyKXtzKHQsZixlLFwiX2lcIiksdC5faT1vKG51bGwpLHQuX2Y9dm9pZCAwLHQuX2w9dm9pZCAwLHRbdl09MCx2b2lkIDAhPXImJmwocixuLHRbY10sdCl9KTtyZXR1cm4gaShmLnByb3RvdHlwZSx7Y2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcyxlPXQuX2ksbj10Ll9mO247bj1uLm4pbi5yPSEwLG4ucCYmKG4ucD1uLnAubj12b2lkIDApLGRlbGV0ZSBlW24uaV07dC5fZj10Ll9sPXZvaWQgMCx0W3ZdPTB9LGRlbGV0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49bShlLHQpO2lmKG4pe3ZhciByPW4ubixvPW4ucDtkZWxldGUgZS5faVtuLmldLG4ucj0hMCxvJiYoby5uPXIpLHImJihyLnA9byksZS5fZj09biYmKGUuX2Y9ciksZS5fbD09biYmKGUuX2w9byksZVt2XS0tfXJldHVybiEhbn0sZm9yRWFjaDpmdW5jdGlvbih0KXtzKHRoaXMsZixcImZvckVhY2hcIik7Zm9yKHZhciBlLG49YSh0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLDMpO2U9ZT9lLm46dGhpcy5fZjspZm9yKG4oZS52LGUuayx0aGlzKTtlJiZlLnI7KWU9ZS5wfSxoYXM6ZnVuY3Rpb24odCl7cmV0dXJuISFtKHRoaXMsdCl9fSksaCYmcihmLnByb3RvdHlwZSxcInNpemVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUodGhpc1t2XSl9fSksZn0sZGVmOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvLGk9bSh0LGUpO3JldHVybiBpP2kudj1uOih0Ll9sPWk9e2k6bz1kKGUsITApLGs6ZSx2Om4scDpyPXQuX2wsbjp2b2lkIDAscjohMX0sdC5fZnx8KHQuX2Y9aSksciYmKHIubj1pKSx0W3ZdKyssXCJGXCIhPT1vJiYodC5faVtvXT1pKSksdH0sZ2V0RW50cnk6bSxzZXRTdHJvbmc6ZnVuY3Rpb24odCxlLG4pe2ModCxlLGZ1bmN0aW9uKHQsZSl7dGhpcy5fdD10LHRoaXMuX2s9ZSx0aGlzLl9sPXZvaWQgMH0sZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcyxlPXQuX2ssbj10Ll9sO24mJm4ucjspbj1uLnA7cmV0dXJuIHQuX3QmJih0Ll9sPW49bj9uLm46dC5fdC5fZik/XCJrZXlzXCI9PWU/ZigwLG4uayk6XCJ2YWx1ZXNcIj09ZT9mKDAsbi52KTpmKDAsW24uayxuLnZdKToodC5fdD12b2lkIDAsZigxKSl9LG4/XCJlbnRyaWVzXCI6XCJ2YWx1ZXNcIiwhbiwhMCkscChlKX19fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1OCksbz1uKDE0MCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe2lmKHIodGhpcykhPXQpdGhyb3cgVHlwZUVycm9yKHQrXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7cmV0dXJuIG8odGhpcyl9fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNDQpLG89bigzNSkuZ2V0V2VhayxpPW4oNCksYT1uKDcpLHM9bigzOSksdT1uKDUxKSxsPW4oMjYpLGM9bigxMyksZj1sKDUpLHA9bCg2KSxoPTAsZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5fbHx8KHQuX2w9bmV3IHYpfSx2PWZ1bmN0aW9uKCl7dGhpcy5hPVtdfSxtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGYodC5hLGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPT09ZX0pfTt2LnByb3RvdHlwZT17Z2V0OmZ1bmN0aW9uKHQpe3ZhciBlPW0odGhpcyx0KTtpZihlKXJldHVybiBlWzFdfSxoYXM6ZnVuY3Rpb24odCl7cmV0dXJuISFtKHRoaXMsdCl9LHNldDpmdW5jdGlvbih0LGUpe3ZhciBuPW0odGhpcyx0KTtuP25bMV09ZTp0aGlzLmEucHVzaChbdCxlXSl9LGRlbGV0ZTpmdW5jdGlvbih0KXt2YXIgZT1wKHRoaXMuYSxmdW5jdGlvbihlKXtyZXR1cm4gZVswXT09PXR9KTtyZXR1cm5+ZSYmdGhpcy5hLnNwbGljZShlLDEpLCEhfmV9fSx0LmV4cG9ydHM9e2dldENvbnN0cnVjdG9yOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciBsPXQoZnVuY3Rpb24odCxyKXtzKHQsbCxlLFwiX2lcIiksdC5faT1oKyssdC5fbD12b2lkIDAsdm9pZCAwIT1yJiZ1KHIsbix0W2ldLHQpfSk7cmV0dXJuIHIobC5wcm90b3R5cGUse2RlbGV0ZTpmdW5jdGlvbih0KXtpZighYSh0KSlyZXR1cm4hMTt2YXIgZT1vKHQpO3JldHVybiBlPT09ITA/ZCh0aGlzKS5kZWxldGUodCk6ZSYmYyhlLHRoaXMuX2kpJiZkZWxldGUgZVt0aGlzLl9pXX0saGFzOmZ1bmN0aW9uKHQpe2lmKCFhKHQpKXJldHVybiExO3ZhciBlPW8odCk7cmV0dXJuIGU9PT0hMD9kKHRoaXMpLmhhcyh0KTplJiZjKGUsdGhpcy5faSl9fSksbH0sZGVmOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1vKGkoZSksITApO3JldHVybiByPT09ITA/ZCh0KS5zZXQoZSxuKTpyW3QuX2ldPW4sdH0sdWZzdG9yZTpkfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz0hbig5KSYmIW4oNikoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4oOTUpKFwiZGl2XCIpLFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpLG89TWF0aC5mbG9vcjt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIXIodCkmJmlzRmluaXRlKHQpJiZvKHQpPT09dH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixvKXt0cnl7cmV0dXJuIG8/ZShyKG4pWzBdLG5bMV0pOmUobil9Y2F0Y2goZSl7dmFyIGk9dC5yZXR1cm47dGhyb3cgdm9pZCAwIT09aSYmcihpLmNhbGwodCkpLGV9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57dmFsdWU6ZSxkb25lOiEhdH19fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1NYXRoLmxvZzFwfHxmdW5jdGlvbih0KXtyZXR1cm4odD0rdCk+LTFlLTgmJnQ8MWUtOD90LXQqdC8yOk1hdGgubG9nKDErdCl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big0Myksbz1uKDc3KSxpPW4oNjApLGE9bigxMikscz1uKDU5KSx1PU9iamVjdC5hc3NpZ247dC5leHBvcnRzPSF1fHxuKDYpKGZ1bmN0aW9uKCl7dmFyIHQ9e30sZT17fSxuPVN5bWJvbCgpLHI9XCJhYmNkZWZnaGlqa2xtbm9wcXJzdFwiO3JldHVybiB0W25dPTcsci5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2VbdF09dH0pLDchPXUoe30sdClbbl18fE9iamVjdC5rZXlzKHUoe30sZSkpLmpvaW4oXCJcIikhPXJ9KT9mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1hKHQpLHU9YXJndW1lbnRzLmxlbmd0aCxsPTEsYz1vLmYsZj1pLmY7dT5sOylmb3IodmFyIHAsaD1zKGFyZ3VtZW50c1tsKytdKSxkPWM/cihoKS5jb25jYXQoYyhoKSk6cihoKSx2PWQubGVuZ3RoLG09MDt2Pm07KWYuY2FsbChoLHA9ZFttKytdKSYmKG5bcF09aFtwXSk7cmV0dXJuIG59OnV9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEwKSxvPW4oNCksaT1uKDQzKTt0LmV4cG9ydHM9big5KT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbih0LGUpe28odCk7Zm9yKHZhciBuLGE9aShlKSxzPWEubGVuZ3RoLHU9MDtzPnU7KXIuZih0LG49YVt1KytdLGVbbl0pO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTgpLG89big0MikuZixpPXt9LnRvU3RyaW5nLGE9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdLHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiBvKHQpfWNhdGNoKHQpe3JldHVybiBhLnNsaWNlKCl9fTt0LmV4cG9ydHMuZj1mdW5jdGlvbih0KXtyZXR1cm4gYSYmXCJbb2JqZWN0IFdpbmRvd11cIj09aS5jYWxsKHQpP3ModCk6byhyKHQpKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDEzKSxvPW4oMTgpLGk9big2OSkoITEpLGE9bigxMDgpKFwiSUVfUFJPVE9cIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scz1vKHQpLHU9MCxsPVtdO2ZvcihuIGluIHMpbiE9YSYmcihzLG4pJiZsLnB1c2gobik7Zm9yKDtlLmxlbmd0aD51OylyKHMsbj1lW3UrK10pJiYofmkobCxuKXx8bC5wdXNoKG4pKTtyZXR1cm4gbH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQzKSxvPW4oMTgpLGk9big2MCkuZjt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgbixhPW8oZSkscz1yKGEpLHU9cy5sZW5ndGgsbD0wLGM9W107dT5sOylpLmNhbGwoYSxuPXNbbCsrXSkmJmMucHVzaCh0P1tuLGFbbl1dOmFbbl0pO3JldHVybiBjfX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQyKSxvPW4oNzcpLGk9big0KSxhPW4oNSkuUmVmbGVjdDt0LmV4cG9ydHM9YSYmYS5vd25LZXlzfHxmdW5jdGlvbih0KXt2YXIgZT1yLmYoaSh0KSksbj1vLmY7cmV0dXJuIG4/ZS5jb25jYXQobih0KSk6ZX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDUpLnBhcnNlRmxvYXQsbz1uKDU0KS50cmltO3QuZXhwb3J0cz0xL3IobigxMTMpK1wiLTBcIikhPT0tKDEvMCk/ZnVuY3Rpb24odCl7dmFyIGU9byhTdHJpbmcodCksMyksbj1yKGUpO3JldHVybiAwPT09biYmXCItXCI9PWUuY2hhckF0KDApPy0wOm59OnJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDUpLnBhcnNlSW50LG89big1NCkudHJpbSxpPW4oMTEzKSxhPS9eW1xcLStdPzBbeFhdLzt0LmV4cG9ydHM9OCE9PXIoaStcIjA4XCIpfHwyMiE9PXIoaStcIjB4MTZcIik/ZnVuY3Rpb24odCxlKXt2YXIgbj1vKFN0cmluZyh0KSwzKTtyZXR1cm4gcihuLGU+Pj4wfHwoYS50ZXN0KG4pPzE2OjEwKSl9OnJ9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPU9iamVjdC5pc3x8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWU/MCE9PXR8fDEvdD09PTEvZTp0IT10JiZlIT1lfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTEpLG89bigxMTIpLGk9bigyMyk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLGEpe3ZhciBzPVN0cmluZyhpKHQpKSx1PXMubGVuZ3RoLGw9dm9pZCAwPT09bj9cIiBcIjpTdHJpbmcobiksYz1yKGUpO2lmKGM8PXV8fFwiXCI9PWwpcmV0dXJuIHM7dmFyIGY9Yy11LHA9by5jYWxsKGwsTWF0aC5jZWlsKGYvbC5sZW5ndGgpKTtyZXR1cm4gcC5sZW5ndGg+ZiYmKHA9cC5zbGljZSgwLGYpKSxhP3ArczpzK3B9fSxmdW5jdGlvbih0LGUsbil7ZS5mPW4oOCl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDE0Myk7dC5leHBvcnRzPW4oNzApKFwiTWFwXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7Z2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXIuZ2V0RW50cnkodGhpcyx0KTtyZXR1cm4gZSYmZS52fSxzZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5kZWYodGhpcywwPT09dD8wOnQsZSl9fSxyLCEwKX0sZnVuY3Rpb24odCxlLG4pe24oOSkmJlwiZ1wiIT0vLi9nLmZsYWdzJiZuKDEwKS5mKFJlZ0V4cC5wcm90b3R5cGUsXCJmbGFnc1wiLHtjb25maWd1cmFibGU6ITAsZ2V0Om4oNzIpfSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDE0Myk7dC5leHBvcnRzPW4oNzApKFwiU2V0XCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCl9fSx7YWRkOmZ1bmN0aW9uKHQpe3JldHVybiByLmRlZih0aGlzLHQ9MD09PXQ/MDp0LHQpfX0scil9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcixvPW4oMjYpKDApLGk9bigxNiksYT1uKDM1KSxzPW4oMTUxKSx1PW4oMTQ1KSxsPW4oNyksYz1hLmdldFdlYWssZj1PYmplY3QuaXNFeHRlbnNpYmxlLHA9dS51ZnN0b3JlLGg9e30sZD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHY9e2dldDpmdW5jdGlvbih0KXtpZihsKHQpKXt2YXIgZT1jKHQpO3JldHVybiBlPT09ITA/cCh0aGlzKS5nZXQodCk6ZT9lW3RoaXMuX2ldOnZvaWQgMH19LHNldDpmdW5jdGlvbih0LGUpe3JldHVybiB1LmRlZih0aGlzLHQsZSl9fSxtPXQuZXhwb3J0cz1uKDcwKShcIldlYWtNYXBcIixkLHYsdSwhMCwhMCk7NyE9KG5ldyBtKS5zZXQoKE9iamVjdC5mcmVlemV8fE9iamVjdCkoaCksNykuZ2V0KGgpJiYocj11LmdldENvbnN0cnVjdG9yKGQpLHMoci5wcm90b3R5cGUsdiksYS5ORUVEPSEwLG8oW1wiZGVsZXRlXCIsXCJoYXNcIixcImdldFwiLFwic2V0XCJdLGZ1bmN0aW9uKHQpe3ZhciBlPW0ucHJvdG90eXBlLG49ZVt0XTtpKGUsdCxmdW5jdGlvbihlLG8pe2lmKGwoZSkmJiFmKGUpKXt0aGlzLl9mfHwodGhpcy5fZj1uZXcgcik7dmFyIGk9dGhpcy5fZlt0XShlLG8pO3JldHVyblwic2V0XCI9PXQ/dGhpczppfXJldHVybiBuLmNhbGwodGhpcyxlLG8pfSl9KSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7dGhpcy5hcmdUeXBlcz1bXSx0aGlzLnNoaW1BcmdzPVtdLHRoaXMuYXJyYXlBcmdzPVtdLHRoaXMuYXJyYXlCbG9ja0luZGljZXM9W10sdGhpcy5zY2FsYXJBcmdzPVtdLHRoaXMub2Zmc2V0QXJncz1bXSx0aGlzLm9mZnNldEFyZ0luZGV4PVtdLHRoaXMuaW5kZXhBcmdzPVtdLHRoaXMuc2hhcGVBcmdzPVtdLHRoaXMuZnVuY05hbWU9XCJcIix0aGlzLnByZT1udWxsLHRoaXMuYm9keT1udWxsLHRoaXMucG9zdD1udWxsLHRoaXMuZGVidWc9ITF9ZnVuY3Rpb24gbyh0KXt2YXIgZT1uZXcgcjtlLnByZT10LnByZSxlLmJvZHk9dC5ib2R5LGUucG9zdD10LnBvc3Q7dmFyIG49dC5hcmdzLnNsaWNlKDApO2UuYXJnVHlwZXM9bjtmb3IodmFyIG89MDtvPG4ubGVuZ3RoOysrbyl7dmFyIGE9bltvXTtpZihcImFycmF5XCI9PT1hfHxcIm9iamVjdFwiPT10eXBlb2YgYSYmYS5ibG9ja0luZGljZXMpe2lmKGUuYXJnVHlwZXNbb109XCJhcnJheVwiLGUuYXJyYXlBcmdzLnB1c2gobyksZS5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGEuYmxvY2tJbmRpY2VzP2EuYmxvY2tJbmRpY2VzOjApLGUuc2hpbUFyZ3MucHVzaChcImFycmF5XCIrbyksbzxlLnByZS5hcmdzLmxlbmd0aCYmZS5wcmUuYXJnc1tvXS5jb3VudD4wKXRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpO2lmKG88ZS5wb3N0LmFyZ3MubGVuZ3RoJiZlLnBvc3QuYXJnc1tvXS5jb3VudD4wKXRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgYXJnc1wiKX1lbHNlIGlmKFwic2NhbGFyXCI9PT1hKWUuc2NhbGFyQXJncy5wdXNoKG8pLGUuc2hpbUFyZ3MucHVzaChcInNjYWxhclwiK28pO2Vsc2UgaWYoXCJpbmRleFwiPT09YSl7aWYoZS5pbmRleEFyZ3MucHVzaChvKSxvPGUucHJlLmFyZ3MubGVuZ3RoJiZlLnByZS5hcmdzW29dLmNvdW50PjApdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpO2lmKG88ZS5ib2R5LmFyZ3MubGVuZ3RoJiZlLmJvZHkuYXJnc1tvXS5sdmFsdWUpdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IGJvZHkoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IGluZGV4XCIpO2lmKG88ZS5wb3N0LmFyZ3MubGVuZ3RoJiZlLnBvc3QuYXJnc1tvXS5jb3VudD4wKXRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIik7XG59ZWxzZSBpZihcInNoYXBlXCI9PT1hKXtpZihlLnNoYXBlQXJncy5wdXNoKG8pLG88ZS5wcmUuYXJncy5sZW5ndGgmJmUucHJlLmFyZ3Nbb10ubHZhbHVlKXRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpO2lmKG88ZS5ib2R5LmFyZ3MubGVuZ3RoJiZlLmJvZHkuYXJnc1tvXS5sdmFsdWUpdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IGJvZHkoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpO2lmKG88ZS5wb3N0LmFyZ3MubGVuZ3RoJiZlLnBvc3QuYXJnc1tvXS5sdmFsdWUpdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpfWVsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGF8fCFhLm9mZnNldCl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiK25bb10pO2UuYXJnVHlwZXNbb109XCJvZmZzZXRcIixlLm9mZnNldEFyZ3MucHVzaCh7YXJyYXk6YS5hcnJheSxvZmZzZXQ6YS5vZmZzZXR9KSxlLm9mZnNldEFyZ0luZGV4LnB1c2gobyl9fWlmKGUuYXJyYXlBcmdzLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKTtpZihlLnByZS5hcmdzLmxlbmd0aD5uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpO2lmKGUuYm9keS5hcmdzLmxlbmd0aD5uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKTtpZihlLnBvc3QuYXJncy5sZW5ndGg+bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwb3N0KCkgYmxvY2tcIik7cmV0dXJuIGUuZGVidWc9ISF0LnByaW50Q29kZXx8ISF0LmRlYnVnLGUuZnVuY05hbWU9dC5mdW5jTmFtZXx8XCJjd2lzZVwiLGUuYmxvY2tTaXplPXQuYmxvY2tTaXplfHw2NCxpKGUpfXZhciBpPW4oNDQ5KTt0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlLG4pe3ZhciBvPTB8dFtuXTtpZihvPD0wKXJldHVybltdO3ZhciBpLGE9bmV3IEFycmF5KG8pO2lmKG49PT10Lmxlbmd0aC0xKWZvcihpPTA7aTxvOysraSlhW2ldPWU7ZWxzZSBmb3IoaT0wO2k8bzsrK2kpYVtpXT1yKHQsZSxuKzEpO3JldHVybiBhfWZ1bmN0aW9uIG8odCxlKXt2YXIgbixyO2ZvcihuPW5ldyBBcnJheSh0KSxyPTA7cjx0OysrciluW3JdPWU7cmV0dXJuIG59ZnVuY3Rpb24gaSh0LGUpe3N3aXRjaChcInVuZGVmaW5lZFwiPT10eXBlb2YgZSYmKGU9MCksdHlwZW9mIHQpe2Nhc2VcIm51bWJlclwiOmlmKHQ+MClyZXR1cm4gbygwfHQsZSk7YnJlYWs7Y2FzZVwib2JqZWN0XCI6aWYoXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXJldHVybiByKHQsZSwwKX1yZXR1cm5bXX10LmV4cG9ydHM9aX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcy5fX2RhdGFfXz1uZXcgbyh0KTt0aGlzLnNpemU9ZS5zaXplfXZhciBvPW4oODApLGk9big1NTIpLGE9big1NTMpLHM9big1NTQpLHU9big1NTUpLGw9big1NTYpO3IucHJvdG90eXBlLmNsZWFyPWksci5wcm90b3R5cGUuZGVsZXRlPWEsci5wcm90b3R5cGUuZ2V0PXMsci5wcm90b3R5cGUuaGFzPXUsci5wcm90b3R5cGUuc2V0PWwsdC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2Zvcih2YXIgbj0tMSxyPWUubGVuZ3RoLG89dC5sZW5ndGg7KytuPHI7KXRbbytuXT1lW25dO3JldHVybiB0fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7XCJfX3Byb3RvX19cIj09ZSYmbz9vKHQsZSx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6bix3cml0YWJsZTohMH0pOnRbZV09bn12YXIgbz1uKDE3Myk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuLGEscyl7dmFyIHU9LTEsbD10Lmxlbmd0aDtmb3Iobnx8KG49aSksc3x8KHM9W10pOysrdTxsOyl7dmFyIGM9dFt1XTtlPjAmJm4oYyk/ZT4xP3IoYyxlLTEsbixhLHMpOm8ocyxjKTphfHwoc1tzLmxlbmd0aF09Yyl9cmV0dXJuIHN9dmFyIG89bigxNjkpLGk9big1MjYpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3JldHVybiB0JiZvKHQsZSxpKX12YXIgbz1uKDQ3NCksaT1uKDQ5KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNDgpLG89ZnVuY3Rpb24oKXt0cnl7dmFyIHQ9cihPYmplY3QsXCJkZWZpbmVQcm9wZXJ0eVwiKTtyZXR1cm4gdCh7fSxcIlwiLHt9KSx0fWNhdGNoKHQpe319KCk7dC5leHBvcnRzPW99LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuLHIsbCxjKXt2YXIgZj1uJnMscD10Lmxlbmd0aCxoPWUubGVuZ3RoO2lmKHAhPWgmJiEoZiYmaD5wKSlyZXR1cm4hMTt2YXIgZD1jLmdldCh0KTtpZihkJiZjLmdldChlKSlyZXR1cm4gZD09ZTt2YXIgdj0tMSxtPSEwLF89biZ1P25ldyBvOnZvaWQgMDtmb3IoYy5zZXQodCxlKSxjLnNldChlLHQpOysrdjxwOyl7dmFyIGc9dFt2XSx5PWVbdl07aWYocil2YXIgYj1mP3IoeSxnLHYsZSx0LGMpOnIoZyx5LHYsdCxlLGMpO2lmKHZvaWQgMCE9PWIpe2lmKGIpY29udGludWU7bT0hMTticmVha31pZihfKXtpZighaShlLGZ1bmN0aW9uKHQsZSl7aWYoIWEoXyxlKSYmKGc9PT10fHxsKGcsdCxuLHIsYykpKXJldHVybiBfLnB1c2goZSl9KSl7bT0hMTticmVha319ZWxzZSBpZihnIT09eSYmIWwoZyx5LG4scixjKSl7bT0hMTticmVha319cmV0dXJuIGMuZGVsZXRlKHQpLGMuZGVsZXRlKGUpLG19dmFyIG89big0NTkpLGk9big0NjcpLGE9big1MDApLHM9MSx1PTI7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXsoZnVuY3Rpb24oZSl7dmFyIG49XCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuT2JqZWN0PT09T2JqZWN0JiZlO3QuZXhwb3J0cz1ufSkuY2FsbChlLG4oMzgpKX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNDU1KSxvPW4oMTE5KSxpPW4oNDU3KSxhPW4oNDU4KSxzPW4oNDYxKSx1PW4oNjIpLGw9bigxODIpLGM9XCJbb2JqZWN0IE1hcF1cIixmPVwiW29iamVjdCBPYmplY3RdXCIscD1cIltvYmplY3QgUHJvbWlzZV1cIixoPVwiW29iamVjdCBTZXRdXCIsZD1cIltvYmplY3QgV2Vha01hcF1cIix2PVwiW29iamVjdCBEYXRhVmlld11cIixtPWwociksXz1sKG8pLGc9bChpKSx5PWwoYSksYj1sKHMpLHc9dTsociYmdyhuZXcgcihuZXcgQXJyYXlCdWZmZXIoMSkpKSE9dnx8byYmdyhuZXcgbykhPWN8fGkmJncoaS5yZXNvbHZlKCkpIT1wfHxhJiZ3KG5ldyBhKSE9aHx8cyYmdyhuZXcgcykhPWQpJiYodz1mdW5jdGlvbih0KXt2YXIgZT11KHQpLG49ZT09Zj90LmNvbnN0cnVjdG9yOnZvaWQgMCxyPW4/bChuKTpcIlwiO2lmKHIpc3dpdGNoKHIpe2Nhc2UgbTpyZXR1cm4gdjtjYXNlIF86cmV0dXJuIGM7Y2FzZSBnOnJldHVybiBwO2Nhc2UgeTpyZXR1cm4gaDtjYXNlIGI6cmV0dXJuIGR9cmV0dXJuIGV9KSx0LmV4cG9ydHM9d30sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiBjLnRlc3QodCl9dmFyIHI9XCJcXFxcdWQ4MDAtXFxcXHVkZmZmXCIsbz1cIlxcXFx1MDMwMC1cXFxcdTAzNmZcIixpPVwiXFxcXHVmZTIwLVxcXFx1ZmUyZlwiLGE9XCJcXFxcdTIwZDAtXFxcXHUyMGZmXCIscz1vK2krYSx1PVwiXFxcXHVmZTBlXFxcXHVmZTBmXCIsbD1cIlxcXFx1MjAwZFwiLGM9UmVnRXhwKFwiW1wiK2wrcitzK3UrXCJdXCIpO3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7aWYoIXMobikpcmV0dXJuITE7dmFyIHI9dHlwZW9mIGU7cmV0dXJuISEoXCJudW1iZXJcIj09cj9pKG4pJiZhKGUsbi5sZW5ndGgpOlwic3RyaW5nXCI9PXImJmUgaW4gbikmJm8obltlXSx0KX12YXIgbz1uKDg3KSxpPW4oODgpLGE9big4NSkscz1uKDU1KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQ9PT10JiYhbyh0KX12YXIgbz1uKDU1KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3ZhciBlPS0xLG49QXJyYXkodC5zaXplKTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQscil7blsrK2VdPVtyLHRdfSksbn10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiBudWxsIT1uJiYoblt0XT09PWUmJih2b2lkIDAhPT1lfHx0IGluIE9iamVjdChuKSkpfX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe2lmKG51bGwhPXQpe3RyeXtyZXR1cm4gby5jYWxsKHQpfWNhdGNoKHQpe310cnl7cmV0dXJuIHQrXCJcIn1jYXRjaCh0KXt9fXJldHVyblwiXCJ9dmFyIHI9RnVuY3Rpb24ucHJvdG90eXBlLG89ci50b1N0cmluZzt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9bnVsbD09dD8wOnQubGVuZ3RoO3JldHVybiBlP28odCxpKTpbXX12YXIgbz1uKDE3MSksaT0xLzA7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIG51bGwhPXQmJmkodCxlLG8pfXZhciBvPW4oNDc2KSxpPW4oNTE5KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4peyhmdW5jdGlvbih0KXt2YXIgcj1uKDI5KSxvPW4oNTc2KSxpPVwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiYhZS5ub2RlVHlwZSYmZSxhPWkmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiYhdC5ub2RlVHlwZSYmdCxzPWEmJmEuZXhwb3J0cz09PWksdT1zP3IuQnVmZmVyOnZvaWQgMCxsPXU/dS5pc0J1ZmZlcjp2b2lkIDAsYz1sfHxvO3QuZXhwb3J0cz1jfSkuY2FsbChlLG4oOTIpKHQpKX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7aWYoIWkodCkpcmV0dXJuITE7dmFyIGU9byh0KTtyZXR1cm4gZT09c3x8ZT09dXx8ZT09YXx8ZT09bH12YXIgbz1uKDYyKSxpPW4oNTUpLGE9XCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIscz1cIltvYmplY3QgRnVuY3Rpb25dXCIsdT1cIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIsbD1cIltvYmplY3QgUHJveHldXCI7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQ4MSksbz1uKDQ5OCksaT1uKDU0MiksYT1pJiZpLmlzVHlwZWRBcnJheSxzPWE/byhhKTpyO3QuZXhwb3J0cz1zfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1MDgpLG89cigpO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtpZighdClyZXR1cm4gMD09PXQ/dDowO2lmKHQ9byh0KSx0PT09aXx8dD09PS1pKXt2YXIgZT10PDA/LTE6MTtyZXR1cm4gZSphfXJldHVybiB0PT09dD90OjB9dmFyIG89big1NzgpLGk9MS8wLGE9MS43OTc2OTMxMzQ4NjIzMTU3ZTMwODt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7dmFyIGU9dC5kdHlwZTtcImdlbmVyaWNcIiE9PWUmJlwiYXJyYXlcIiE9PWV8fChlPVwiZG91YmxlXCIpO3ZhciBuPWYubWFsbG9jKHQuc2l6ZSxlKSxyPWwobix0LnNoYXBlKTtyZXR1cm4gYy5hc3NpZ24ocix0KSxyfWZ1bmN0aW9uIG8odCxlKXtlfHwoZT1cImRvdWJsZVwiKTtmb3IodmFyIG49MSxyPW5ldyBBcnJheSh0Lmxlbmd0aCksbz10Lmxlbmd0aC0xO28+PTA7LS1vKXJbb109bixuKj10W29dO3JldHVybiBsKGYubWFsbG9jKG4sZSksdCxyLDApfWZ1bmN0aW9uIGkodCl7XCJnZW5lcmljXCIhPT10LmR0eXBlJiZcImFycmF5XCIhPT10LmR0eXBlJiZmLmZyZWUodC5kYXRhKX1mdW5jdGlvbiBhKHQsZSl7ZXx8KGU9XCJkb3VibGVcIik7Zm9yKHZhciBuPTEscj1uZXcgQXJyYXkodC5sZW5ndGgpLG89dC5sZW5ndGgtMTtvPj0wOy0tbylyW29dPW4sbio9dFtvXTtmb3IodmFyIGk9Zi5tYWxsb2MobixlKSxvPTA7bzxuOysrbylpW29dPTA7cmV0dXJuIGwoaSx0LHIsMCl9ZnVuY3Rpb24gcyh0LGUpe2V8fChlPVwiZG91YmxlXCIpO2Zvcih2YXIgbj0xLHI9bmV3IEFycmF5KHQubGVuZ3RoKSxvPXQubGVuZ3RoLTE7bz49MDstLW8pcltvXT1uLG4qPXRbb107Zm9yKHZhciBpPWYubWFsbG9jKG4sZSksbz0wO288bjsrK28paVtvXT0xO3JldHVybiBsKGksdCxyLDApfWZ1bmN0aW9uIHUodCxlKXt2YXIgbixyO2V8fChlPVwiZG91YmxlXCIpO3ZhciBvPTEsaT1uZXcgQXJyYXkodC5sZW5ndGgpO2ZvcihuPXQubGVuZ3RoLTE7bj49MDstLW4paVtuXT1vLG8qPXRbbl07dmFyIGE9Zi5tYWxsb2MobyxlKTtmb3Iobj0wO248bzsrK24pYVtuXT0wO3ZhciBzPTEvMCx1PTA7Zm9yKG49dC5sZW5ndGgtMTtuPj0wO24tLSl1Kz1pW25dLHM9TWF0aC5taW4ocyx0W25dKTtmb3Iobj0wLHI9MDtuPHM7bisrLHIrPXUpYVtyXT0xO3JldHVybiBsKGEsdCxpLDApfXZhciBsPW4oOTEpLGM9bigzKSxmPW4oNjIyKTtlLmNsb25lPXIsZS5tYWxsb2M9byxlLmZyZWU9aSxlLnplcm9zPWEsZS5vbmVzPXMsZS5leWU9dX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlKXt2YXIgbixyPVtdLGk9W107aWYodm9pZCAwIT09ZSYmIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBtdXN0IGJlIGFuIEFycmF5IGxpc3Qgb2YgZGltZW5zaW9ucyB0byBzcXVlZXplXCIpO2ZvcihuPTA7bjx0LnNoYXBlLmxlbmd0aDtuKyspKDEhPT10LnNoYXBlW25dfHx2b2lkIDAhPT1lJiZlLmluZGV4T2Yobik9PT0tMSkmJihyLnB1c2godC5zaGFwZVtuXSksaS5wdXNoKHQuc3RyaWRlW25dKSk7cmV0dXJuIG8odC5kYXRhLHIsaSx0Lm9mZnNldCl9dmFyIG89big5MSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDE2Nyksbz1uKDI1KSxpPW8oe2FyZ3M6W1wiYXJyYXlcIixcInNjYWxhclwiLFwiaW5kZXhcIl0sYm9keTpmdW5jdGlvbih0LGUsbil7dmFyIHIsbz1lO2ZvcihyPTA7cjxuLmxlbmd0aC0xOysrcilvPW9bbltyXV07b1tuW24ubGVuZ3RoLTFdXT10fX0pO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1yKHQuc2hhcGUpO3JldHVybiBpKHQsZSksZX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSl7Zm9yKHZhciBuPTEscj10Lmxlbmd0aCxvPXRbMF0saT10WzBdLGE9MTthPHI7KythKWlmKGk9byxvPXRbYV0sZShvLGkpKXtpZihhPT09bil7bisrO2NvbnRpbnVlfXRbbisrXT1vfXJldHVybiB0Lmxlbmd0aD1uLHR9ZnVuY3Rpb24gbyh0KXtmb3IodmFyIGU9MSxuPXQubGVuZ3RoLHI9dFswXSxvPXRbMF0saT0xO2k8bjsrK2ksbz1yKWlmKG89cixyPXRbaV0sciE9PW8pe2lmKGk9PT1lKXtlKys7Y29udGludWV9dFtlKytdPXJ9cmV0dXJuIHQubGVuZ3RoPWUsdH1mdW5jdGlvbiBpKHQsZSxuKXtyZXR1cm4gMD09PXQubGVuZ3RoP3Q6ZT8obnx8dC5zb3J0KGUpLHIodCxlKSk6KG58fHQuc29ydCgpLG8odCkpfXQuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGU9e307aWYobnVsbCE9dClmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGUuZGVmYXVsdD10LGV9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS50ZXN0VXRpbHM9ZS5sYXllcnM9ZS5hY3RpdmF0aW9ucz1lLlRlbnNvcj1lLk1vZGVsPXZvaWQgMDt2YXIgaT1uKDYyNCksYT1vKGkpLHM9bigxOTYpLHU9byhzKSxsPW4oMiksYz1vKGwpLGY9bigxOSkscD1yKGYpLGg9bigxMzMpLGQ9cihoKSx2PW4oMjYxKSxtPXIodik7d2luZG93LndlYmxhcz1hLmRlZmF1bHQsZS5Nb2RlbD11LmRlZmF1bHQsZS5UZW5zb3I9Yy5kZWZhdWx0LGUuYWN0aXZhdGlvbnM9cCxlLmxheWVycz1kLGUudGVzdFV0aWxzPW19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsbil7dFtlXXx8T2JqZWN0W3JdKHQsZSx7d3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwLHZhbHVlOm59KX1pZihuKDQ0Nyksbig2MTkpLG4oMjY3KSx0Ll9iYWJlbFBvbHlmaWxsKXRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7dC5fYmFiZWxQb2x5ZmlsbD0hMDt2YXIgcj1cImRlZmluZVByb3BlcnR5XCI7ZShTdHJpbmcucHJvdG90eXBlLFwicGFkTGVmdFwiLFwiXCIucGFkU3RhcnQpLGUoU3RyaW5nLnByb3RvdHlwZSxcInBhZFJpZ2h0XCIsXCJcIi5wYWRFbmQpLFwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24odCl7W11bdF0mJmUoQXJyYXksdCxGdW5jdGlvbi5jYWxsLmJpbmQoW11bdF0pKX0pfSkuY2FsbChlLG4oMzgpKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlLmRlZmF1bHQ9dCxlfWZ1bmN0aW9uIG8odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIGkodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPW4oMjY0KSxzPW8oYSksdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSxsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHM9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXMubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7IXImJnMucmV0dXJuJiZzLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIHQoZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGY9big1NzkpLHA9byhmKSxoPW4oNTcxKSxkPW8oaCksdj1uKDU2MSksbT1vKHYpLF89big1NjYpLGc9byhfKSx5PW4oNDkpLGI9byh5KSx3PW4oNTgxKSx4PW8odyksRT1uKDEyOSksVD1vKEUpLE89bigxMjcpLFM9byhPKSxQPW4oNTY1KSxNPW8oUCksaj1uKDEzMyksQT1yKGopLEM9bigyKSxrPW8oQyksUj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aSh0aGlzLHQpO3ZhciBuPWUuZmlsZXBhdGhzLHI9dm9pZCAwPT09bj97fTpuLG89ZS5oZWFkZXJzLGE9dm9pZCAwPT09bz97fTpvLHM9ZS5ncHUsdT12b2lkIDAhPT1zJiZzLGw9ZS5waXBlbGluZSxjPXZvaWQgMCE9PWwmJmwsZj1lLmxheWVyQ2FsbFBhdXNlcyxwPXZvaWQgMCE9PWYmJmY7aWYoIXIubW9kZWx8fCFyLndlaWdodHN8fCFyLm1ldGFkYXRhKXRocm93IG5ldyBFcnJvcihcIkZpbGUgcGF0aHMgbXVzdCBiZSBkZWNsYXJlZCBmb3IgbW9kZWwsIHdlaWdodHMsIGFuZCBtZXRhZGF0YS5cIik7dGhpcy5maWxlcGF0aHM9cix0aGlzLmZpbGV0eXBlcz17bW9kZWw6XCJqc29uXCIsd2VpZ2h0czpcImFycmF5YnVmZmVyXCIsbWV0YWRhdGE6XCJqc29uXCJ9LHRoaXMuaGVhZGVycz1hLHRoaXMuZ3B1PXUsdGhpcy5waXBlbGluZT1jLHRoaXMubGF5ZXJDYWxsUGF1c2VzPXAsdGhpcy5kYXRhPXttb2RlbDp7fSx3ZWlnaHRzOm51bGwsbWV0YWRhdGE6W119LHRoaXMueGhycz17bW9kZWw6bnVsbCx3ZWlnaHRzOm51bGwsbWV0YWRhdGE6bnVsbH0sdGhpcy54aHJQcm9ncmVzcz17bW9kZWw6MCx3ZWlnaHRzOjAsbWV0YWRhdGE6MH0sdGhpcy5tb2RlbExheWVyc01hcD1uZXcgTWFwLHRoaXMubGF5ZXJzV2l0aFJlc3VsdHM9W10sdGhpcy5tb2RlbERBRz17fSx0aGlzLmlucHV0VGVuc29ycz17fSx0aGlzLl9yZWFkeT10aGlzLl9pbml0aWFsaXplKCksdGhpcy5pc1J1bm5pbmc9ITF9cmV0dXJuIGModCxbe2tleTpcInJlYWR5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZHl9fSx7a2V5OlwiX2ludGVycnVwdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPVtcIm1vZGVsXCIsXCJ3ZWlnaHRzXCIsXCJtZXRkYXRhXCJdO2UuZm9yRWFjaChmdW5jdGlvbihlKXt0LnhocnNbZV0mJih0LnhocnNbZV0uYWJvcnQoKSx0LnhocnNbZV09bnVsbCl9KX19LHtrZXk6XCJfaW5pdGlhbGl6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPVtcIm1vZGVsXCIsXCJ3ZWlnaHRzXCIsXCJtZXRhZGF0YVwiXTtyZXR1cm4gcy5kZWZhdWx0LmFsbChlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdC5fZGF0YVJlcXVlc3QoZSx0LmhlYWRlcnMpfSkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5fY3JlYXRlTGF5ZXJzKCkscy5kZWZhdWx0LnJlc29sdmUoKX0pLmNhdGNoKGZ1bmN0aW9uKGUpe2NvbnNvbGUubG9nKGUpLHQuX2ludGVycnVwdCgpfSl9fSx7a2V5OlwiX2RhdGFSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm4gbmV3IHMuZGVmYXVsdChmdW5jdGlvbihyLG8pe3ZhciBpPW5ldyBYTUxIdHRwUmVxdWVzdDtpLm9wZW4oXCJHRVRcIixlLmZpbGVwYXRoc1t0XSwhMCksaS5yZXNwb25zZVR5cGU9ZS5maWxldHlwZXNbdF07dmFyIGE9ITAscz0hMSx1PXZvaWQgMDt0cnl7Zm9yKHZhciBjLGY9KDAscC5kZWZhdWx0KShuKVtTeW1ib2wuaXRlcmF0b3JdKCk7IShhPShjPWYubmV4dCgpKS5kb25lKTthPSEwKXt2YXIgaD1sKGMudmFsdWUsMiksZD1oWzBdLHY9aFsxXTtpLnNldFJlcXVlc3RIZWFkZXIoZCx2KX19Y2F0Y2godCl7cz0hMCx1PXR9ZmluYWxseXt0cnl7IWEmJmYucmV0dXJuJiZmLnJldHVybigpfWZpbmFsbHl7aWYocyl0aHJvdyB1fX1pLm9ubG9hZD1mdW5jdGlvbihuKXtlLmRhdGFbdF09aS5yZXNwb25zZSxlLnhocnNbdF09bnVsbCxlLnhoclByb2dyZXNzW3RdPTEwMCxyKCl9LGkub25wcm9ncmVzcz1mdW5jdGlvbihuKXtpZihuLmxlbmd0aENvbXB1dGFibGUpe3ZhciByPU1hdGgucm91bmQoMTAwKm4ubG9hZGVkL24udG90YWwpO2UueGhyUHJvZ3Jlc3NbdF09cn19LGkub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gbyh0KX0saS5zZW5kKG51bGwpLGUueGhyc1t0XT1pfSl9fSx7a2V5OlwiZ2V0TG9hZGluZ1Byb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD0oMCx4LmRlZmF1bHQpKHRoaXMueGhyUHJvZ3Jlc3MpO3JldHVybiBNYXRoLnJvdW5kKCgwLFQuZGVmYXVsdCkodCkvdC5sZW5ndGgpfX0se2tleTpcInRvZ2dsZUdwdVwiLHZhbHVlOmZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCI9PXR5cGVvZiB0P3RoaXMuZ3B1PSF0aGlzLmdwdTp0aGlzLmdwdT10O3ZhciBlPSEwLG49ITEscj12b2lkIDA7dHJ5e2Zvcih2YXIgbyxpPXRoaXMubW9kZWxMYXllcnNNYXAudmFsdWVzKClbU3ltYm9sLml0ZXJhdG9yXSgpOyEoZT0obz1pLm5leHQoKSkuZG9uZSk7ZT0hMCl7dmFyIGE9by52YWx1ZTthLnRvZ2dsZUdwdSh0aGlzLmdwdSl9fWNhdGNoKHQpe249ITAscj10fWZpbmFsbHl7dHJ5eyFlJiZpLnJldHVybiYmaS5yZXR1cm4oKX1maW5hbGx5e2lmKG4pdGhyb3cgcn19fX0se2tleTpcIl9jcmVhdGVMYXllcnNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLmRhdGEubW9kZWwuY2xhc3NfbmFtZSxuPVtdO1wiU2VxdWVudGlhbFwiPT09ZT9uPXRoaXMuZGF0YS5tb2RlbC5jb25maWc6XCJNb2RlbFwiPT09ZSYmKG49dGhpcy5kYXRhLm1vZGVsLmNvbmZpZy5sYXllcnMpLG4uZm9yRWFjaChmdW5jdGlvbihyLG8pe3ZhciBpPXIuY2xhc3NfbmFtZSxhPXIuY29uZmlnO2lmKCEoaSBpbiBBKSl0aHJvdyBuZXcgRXJyb3IoXCJMYXllciBcIitpK1wiIHNwZWNpZmllZCBpbiBtb2RlbCBjb25maWd1cmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCFcIik7aWYoXCJTZXF1ZW50aWFsXCI9PT1lJiYwPT09byl7dmFyIHM9XCJpbnB1dFwiLHU9YS5iYXRjaF9pbnB1dF9zaGFwZS5zbGljZSgxKSxsPW5ldyBBLklucHV0TGF5ZXIoe25hbWU6cyxzaGFwZTp1fSk7dC5tb2RlbExheWVyc01hcC5zZXQocyxsKSx0Lm1vZGVsREFHW3NdPXtsYXllckNsYXNzOlwiSW5wdXRMYXllclwiLG5hbWU6cyxpbmJvdW5kOltdLG91dGJvdW5kOltdfSx0LmlucHV0VGVuc29yc1tzXT1uZXcgay5kZWZhdWx0KFtdLHUpfWVsc2UgaWYoXCJNb2RlbFwiPT09ZSYmXCJJbnB1dExheWVyXCI9PT1pKXt2YXIgYz1hLmJhdGNoX2lucHV0X3NoYXBlLnNsaWNlKDEpO3QuaW5wdXRUZW5zb3JzW2EubmFtZV09bmV3IGsuZGVmYXVsdChbXSxjKX12YXIgZj12b2lkIDA7aWYoXCJCaWRpcmVjdGlvbmFsXCI9PT1pfHxcIlRpbWVEaXN0cmlidXRlZFwiPT09aSl7dmFyIHA9KDAsZC5kZWZhdWx0KShhLGZ1bmN0aW9uKHQsZSl7cmV0dXJuKDAsbS5kZWZhdWx0KShlKX0pLGg9YS5sYXllci5jb25maWcsdj1hLmxheWVyLmNsYXNzX25hbWUsXz0oMCxkLmRlZmF1bHQpKGgsZnVuY3Rpb24odCxlKXtyZXR1cm4oMCxtLmRlZmF1bHQpKGUpfSk7XCJhY3RpdmF0aW9uXCJpbiBfJiYoXy5hY3RpdmF0aW9uPSgwLG0uZGVmYXVsdCkoXy5hY3RpdmF0aW9uKSksXCJpbm5lckFjdGl2YXRpb25cImluIF8mJihfLmlubmVyQWN0aXZhdGlvbj0oMCxtLmRlZmF1bHQpKF8uaW5uZXJBY3RpdmF0aW9uKSksXy5ncHU9dC5ncHUsZj1uZXcgQVtpXShPYmplY3QuYXNzaWduKHAse2xheWVyOm5ldyBBW3ZdKF8pfSkpfWVsc2V7dmFyIHk9KDAsZC5kZWZhdWx0KShhLGZ1bmN0aW9uKHQsZSl7cmV0dXJuKDAsbS5kZWZhdWx0KShlKX0pO1wiYWN0aXZhdGlvblwiaW4geSYmKHkuYWN0aXZhdGlvbj0oMCxtLmRlZmF1bHQpKHkuYWN0aXZhdGlvbikpLFwiaW5uZXJBY3RpdmF0aW9uXCJpbiB5JiYoeS5pbm5lckFjdGl2YXRpb249KDAsbS5kZWZhdWx0KSh5LmlubmVyQWN0aXZhdGlvbikpLHkuZ3B1PXQuZ3B1LHkucGlwZWxpbmU9dC5waXBlbGluZSxmPW5ldyBBW2ldKHkpfXZhciBiPVtdO2lmKFwiQmlkaXJlY3Rpb25hbFwiPT09aT8hZnVuY3Rpb24oKXt2YXIgdD1hLmxheWVyLmNvbmZpZy5uYW1lLGU9dC5yZXBsYWNlKC9mb3J3YXJkLyxcImJhY2t3YXJkXCIpLG49Zi5mb3J3YXJkTGF5ZXIucGFyYW1zLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdCtcIl9cIitlfSkscj1mLmJhY2t3YXJkTGF5ZXIucGFyYW1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZStcIl9cIit0fSk7Yj1uLmNvbmNhdChyKX0oKTpiPVwiVGltZURpc3RyaWJ1dGVkXCI9PT1pP2YubGF5ZXIucGFyYW1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gYS5sYXllci5jb25maWcubmFtZStcIl9cIit0fSk6Zi5wYXJhbXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBhLm5hbWUrXCJfXCIrdH0pLGImJmIubGVuZ3RoKXt2YXIgdz1iLm1hcChmdW5jdGlvbihlKXt2YXIgbj0oMCxnLmRlZmF1bHQpKHQuZGF0YS5tZXRhZGF0YSxmdW5jdGlvbih0KXt2YXIgbj1uZXcgUmVnRXhwKFwiXlwiK2UpO3JldHVybiB0LmxheWVyX25hbWU9PT1hLm5hbWUmJm4udGVzdCh0LndlaWdodF9uYW1lKX0pO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIltNb2RlbF0gZXJyb3IgbG9hZGluZyB3ZWlnaHRzLlwiKTt2YXIgcj1uLm9mZnNldCxvPW4ubGVuZ3RoLGk9bi5zaGFwZTtyZXR1cm4gbmV3IGsuZGVmYXVsdChuZXcgRmxvYXQzMkFycmF5KHQuZGF0YS53ZWlnaHRzLHIsbyksaSl9KTtmLnNldFdlaWdodHModyl9aWYodC5tb2RlbExheWVyc01hcC5zZXQoYS5uYW1lLGYpLHQubW9kZWxEQUdbYS5uYW1lXT17bGF5ZXJDbGFzczppLG5hbWU6YS5uYW1lLGluYm91bmQ6W10sb3V0Ym91bmQ6W119LFwiU2VxdWVudGlhbFwiPT09ZSlpZigwPT09byl7dmFyIHg9XCJpbnB1dFwiO3QubW9kZWxEQUdbeF0ub3V0Ym91bmQucHVzaChhLm5hbWUpLHQubW9kZWxEQUdbYS5uYW1lXS5pbmJvdW5kLnB1c2goeCl9ZWxzZXt2YXIgRT1uW28tMV0uY29uZmlnO3QubW9kZWxEQUdbYS5uYW1lXS5pbmJvdW5kLnB1c2goRS5uYW1lKSx0Lm1vZGVsREFHW0UubmFtZV0ub3V0Ym91bmQucHVzaChhLm5hbWUpfWVsc2VcIk1vZGVsXCI9PT1lJiZyLmluYm91bmRfbm9kZXMmJnIuaW5ib3VuZF9ub2Rlcy5sZW5ndGgmJnIuaW5ib3VuZF9ub2Rlc1swXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF07dC5tb2RlbERBR1thLm5hbWVdLmluYm91bmQucHVzaChuKSx0Lm1vZGVsREFHW25dLm91dGJvdW5kLnB1c2goYS5uYW1lKX0pfSl9fSx7a2V5OlwiX21lcmdlTGF5ZXJDYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc3VsdH0pLG89ci5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdC5fZnJvbVBpcGVsaW5lfSk7cmV0dXJuIG8mJnQuX3BpcGVsaW5lRW5hYmxlZD9uJiYocj1yLm1hcChmdW5jdGlvbih0KXt2YXIgZT1uZXcgay5kZWZhdWx0KFtdLHQudGVuc29yLnNoYXBlKTtyZXR1cm4gZS5jb3B5RnJvbVdlYmxhc1RlbnNvcih0LndlYmxhc1RlbnNvciksZS5fZnJvbVBpcGVsaW5lPSEwLGUuX2FjdHVhbFNoYXBlPXQuX2FjdHVhbFNoYXBlLnNsaWNlKCksZX0pKTpyPXIubWFwKGZ1bmN0aW9uKHQscil7cmV0dXJuIHQuX2Zyb21QaXBlbGluZT9lW3JdLnRyYW5zZmVyRnJvbVBpcGVsaW5lKHQpOm4/bmV3IGsuZGVmYXVsdCh0LnRlbnNvci5kYXRhLHQudGVuc29yLnNoYXBlKTp0fSksdC5jYWxsKHIpfX0se2tleTpcIl9yZWd1bGFyTGF5ZXJDYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWUucmVzdWx0O2lmKHIuX2Zyb21QaXBlbGluZSYmdC5fcGlwZWxpbmVFbmFibGVkKXtpZihuKXt2YXIgbz1uZXcgay5kZWZhdWx0KFtdLHIudGVuc29yLnNoYXBlKTtvLmNvcHlGcm9tV2VibGFzVGVuc29yKHIud2VibGFzVGVuc29yKSxvLl9mcm9tUGlwZWxpbmU9ITAsby5fYWN0dWFsU2hhcGU9ci5fYWN0dWFsU2hhcGUuc2xpY2UoKSxyPW99fWVsc2Ugci5fZnJvbVBpcGVsaW5lP3I9ZS50cmFuc2ZlckZyb21QaXBlbGluZShyKTpuJiYocj1uZXcgay5kZWZhdWx0KHIudGVuc29yLmRhdGEsci50ZW5zb3Iuc2hhcGUpKTtyZXR1cm4gdC5jYWxsKHIpfX0se2tleTpcIl90cmF2ZXJzZURBR1wiLHZhbHVlOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGU9KDAsYS5jb3JvdXRpbmUpKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIHQoZSl7dmFyIG4scixvLGksYSx1LGwsYyxmLHA9dGhpcztyZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6aWYoMCE9PWUubGVuZ3RoKXt0Lm5leHQ9NDticmVha31yZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIiwhMCk7Y2FzZSA0OmlmKDEhPT1lLmxlbmd0aCl7dC5uZXh0PTMwO2JyZWFrfWlmKG49ZVswXSxyPXRoaXMubW9kZWxEQUdbbl0sbz1yLmxheWVyQ2xhc3MsaT1yLmluYm91bmQsYT1yLm91dGJvdW5kLFwiSW5wdXRMYXllclwiPT09byl7dC5uZXh0PTI2O2JyZWFrfWlmKHU9dGhpcy5tb2RlbExheWVyc01hcC5nZXQobiksIXUudmlzaXRlZCl7dC5uZXh0PTE0O2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLCExKTtjYXNlIDE0OmlmKGw9aS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHAubW9kZWxMYXllcnNNYXAuZ2V0KHQpfSksKDAsTS5kZWZhdWx0KShsLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5oYXNSZXN1bHR9KSkpe3QubmV4dD0xNzticmVha31yZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIiwhMSk7Y2FzZSAxNzppZihjPWkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBwLm1vZGVsREFHW3RdLm91dGJvdW5kfSkucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZS5sZW5ndGh9LDApLGY9Yz49MSx1LnJlc3VsdD1cIk1lcmdlXCI9PT1vP3RoaXMuX21lcmdlTGF5ZXJDYWxsKHUsbCxmKTp0aGlzLl9yZWd1bGFyTGF5ZXJDYWxsKHUsbFswXSxmKSx1Lmhhc1Jlc3VsdD0hMCx1LnZpc2l0ZWQ9ITAsdGhpcy5sYXllcnNXaXRoUmVzdWx0cy5wdXNoKHUubmFtZSksIXRoaXMubGF5ZXJDYWxsUGF1c2VzKXt0Lm5leHQ9MjY7YnJlYWt9cmV0dXJuIHQubmV4dD0yNixzLmRlZmF1bHQuZGVsYXkoMCk7Y2FzZSAyNjpyZXR1cm4gdC5uZXh0PTI4LHRoaXMuX3RyYXZlcnNlREFHKGEpO2Nhc2UgMjg6dC5uZXh0PTMyO2JyZWFrO2Nhc2UgMzA6cmV0dXJuIHQubmV4dD0zMixzLmRlZmF1bHQuYWxsKGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBwLl90cmF2ZXJzZURBRyhbdF0pfSkpO2Nhc2UgMzI6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0sdCx0aGlzKX0pKTtyZXR1cm4gdH0oKX0se2tleTpcInByZWRpY3RcIix2YWx1ZTpmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBlPSgwLGEuY29yb3V0aW5lKShyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiB0KGUpe3ZhciBuLHIsbyxpLGEscyxsLGMsZixwLGgsZCx2LG09dGhpcztyZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6aWYodGhpcy5pc1J1bm5pbmc9ITAsbj0oMCxiLmRlZmF1bHQpKHRoaXMuaW5wdXRUZW5zb3JzKS5zb3J0KCksKDAsUy5kZWZhdWx0KSgoMCxiLmRlZmF1bHQpKGUpLnNvcnQoKSxuKSl7dC5uZXh0PTU7YnJlYWt9dGhyb3cgdGhpcy5pc1J1bm5pbmc9ITEsbmV3IEVycm9yKFwicHJlZGljdCgpIG11c3QgdGFrZSBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBuYW1lZCBpbnB1dHMgb2YgdGhlIG1vZGVsOiBcIituK1wiLlwiKTtjYXNlIDU6aWYoKDAsTS5kZWZhdWx0KShuLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl9KSl7dC5uZXh0PTg7YnJlYWt9dGhyb3cgdGhpcy5pc1J1bm5pbmc9ITEsbmV3IEVycm9yKFwicHJlZGljdCgpIG11c3QgdGFrZSBhbiBvYmplY3Qgd2hlcmUgdGhlIHZhbHVlcyBhcmUgdGhlIGZsYXR0ZW5lZCBkYXRhIGFzIEZsb2F0MzJBcnJheS5cIik7Y2FzZSA4OmZvcih0aGlzLmxheWVyc1dpdGhSZXN1bHRzPVtdLHI9ITAsbz0hMSxpPXZvaWQgMCx0LnByZXY9MTIsYT10aGlzLm1vZGVsTGF5ZXJzTWFwLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KHM9YS5uZXh0KCkpLmRvbmUpO3I9ITApbD1zLnZhbHVlLGwuaGFzUmVzdWx0PSExLGwudmlzaXRlZD0hMTt0Lm5leHQ9MjA7YnJlYWs7Y2FzZSAxNjp0LnByZXY9MTYsdC50MD10LmNhdGNoKDEyKSxvPSEwLGk9dC50MDtjYXNlIDIwOnQucHJldj0yMCx0LnByZXY9MjEsIXImJmEucmV0dXJuJiZhLnJldHVybigpO2Nhc2UgMjM6aWYodC5wcmV2PTIzLCFvKXt0Lm5leHQ9MjY7YnJlYWt9dGhyb3cgaTtjYXNlIDI2OnJldHVybiB0LmZpbmlzaCgyMyk7Y2FzZSAyNzpyZXR1cm4gdC5maW5pc2goMjApO2Nhc2UgMjg6cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbj1tLm1vZGVsTGF5ZXJzTWFwLmdldCh0KTttLmlucHV0VGVuc29yc1t0XS5yZXBsYWNlVGVuc29yRGF0YShlW3RdKSxuLnJlc3VsdD1uLmNhbGwobS5pbnB1dFRlbnNvcnNbdF0pLG4uaGFzUmVzdWx0PSEwLG4udmlzaXRlZD0hMH0pLHQubmV4dD0zMSx0aGlzLl90cmF2ZXJzZURBRyhuKTtjYXNlIDMxOmlmKGM9dGhpcy5kYXRhLm1vZGVsLmNsYXNzX25hbWUsXCJTZXF1ZW50aWFsXCIhPT1jKXt0Lm5leHQ9NDE7YnJlYWt9cmV0dXJuIGY9KDAsZy5kZWZhdWx0KSgoMCx4LmRlZmF1bHQpKHRoaXMubW9kZWxEQUcpLGZ1bmN0aW9uKHQpe3JldHVybiF0Lm91dGJvdW5kLmxlbmd0aH0pLHA9dGhpcy5tb2RlbExheWVyc01hcC5nZXQoZi5uYW1lKSxoPXAucmVzdWx0LGQ9e291dHB1dDpoLnRlbnNvci5kYXRhfSx0aGlzLmlzUnVubmluZz0hMSx0LmFicnVwdChcInJldHVyblwiLGQpO2Nhc2UgNDE6aWYoXCJNb2RlbFwiIT09Yyl7dC5uZXh0PTQ1O2JyZWFrfWlmKHY9ZnVuY3Rpb24oKXt2YXIgdD0oMCx4LmRlZmF1bHQpKG0ubW9kZWxEQUcpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hdC5vdXRib3VuZC5sZW5ndGh9KSxlPXt9O3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49bS5tb2RlbExheWVyc01hcC5nZXQodC5uYW1lKSxyPW4ucmVzdWx0O2VbdC5uYW1lXT1yLnRlbnNvci5kYXRhfSksbS5pc1J1bm5pbmc9ITEse3Y6ZX19KCksXCJvYmplY3RcIiE9PShcInVuZGVmaW5lZFwiPT10eXBlb2Ygdj9cInVuZGVmaW5lZFwiOnUodikpKXt0Lm5leHQ9NDU7YnJlYWt9cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsdi52KTtjYXNlIDQ1OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19LHQsdGhpcyxbWzEyLDE2LDIwLDI4XSxbMjEsLDIzLDI3XV0pfSkpO3JldHVybiB0fSgpfV0pLHR9KCk7ZS5kZWZhdWx0PVJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLG89ci5nZXRDb250ZXh0KFwid2ViZ2xcIil8fHIuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiKSxpPTE2Mzg0O28/ZS5NQVhfVEVYVFVSRV9TSVpFPWk9by5nZXRQYXJhbWV0ZXIoby5NQVhfVEVYVFVSRV9TSVpFKTpjb25zb2xlLmxvZyhcIlVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMLiBZb3VyIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlwiKSxlLk1BWF9URVhUVVJFX1NJWkU9aX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oNjcpLGw9cih1KSxjPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtvKHRoaXMsZSk7dmFyIHQ9aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMpKTtyZXR1cm4gdC5pbnB1dFRyYW5zZm9ybVByb2dyYW09dC53ZWJnbC5jcmVhdGVQcm9ncmFtKG4oNjEyKSksdC5tYWluUHJvZ3JhbT10LndlYmdsLmNyZWF0ZVByb2dyYW0obig2MTEpKSx0fXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiX2JpbmRJbnB1dFRleHR1cmVzSW5wdXRUcmFuc2Zvcm1cIix2YWx1ZTpmdW5jdGlvbih0LG4scil7dmFyIG89dGhpcy53ZWJnbC5jb250ZXh0O3RoaXMubnVtVGV4dHVyZXM9Myx0aGlzLl9iaW5kSW5wdXRUZXh0dXJlKHRoaXMuaW5wdXRUcmFuc2Zvcm1Qcm9ncmFtLHQudGV4dHVyZSxvLlRFWFRVUkUwLGUuSU5QVVRfVEVYVFVSRV9OQU1FKSx0aGlzLl9iaW5kSW5wdXRUZXh0dXJlKHRoaXMuaW5wdXRUcmFuc2Zvcm1Qcm9ncmFtLG4udGV4dHVyZSxvLlRFWFRVUkUxLGUuSU1BUF9ST1dfVEVYVFVSRV9OQU1FKSx0aGlzLl9iaW5kSW5wdXRUZXh0dXJlKHRoaXMuaW5wdXRUcmFuc2Zvcm1Qcm9ncmFtLHIudGV4dHVyZSxvLlRFWFRVUkUyLGUuSU1BUF9DT0xfVEVYVFVSRV9OQU1FKX19LHtrZXk6XCJfYmluZElucHV0VGV4dHVyZXNNYWluXCIsdmFsdWU6ZnVuY3Rpb24odCxuLHIpe3ZhciBvPXRoaXMud2ViZ2wuY29udGV4dDt0aGlzLm51bVRleHR1cmVzPTMsdGhpcy5fYmluZElucHV0VGV4dHVyZSh0aGlzLm1haW5Qcm9ncmFtLHQudGV4dHVyZSxvLlRFWFRVUkUwLGUuSU5QVVRfVEVYVFVSRV9OQU1FKSx0aGlzLl9iaW5kSW5wdXRUZXh0dXJlKHRoaXMubWFpblByb2dyYW0sbi50ZXh0dXJlLG8uVEVYVFVSRTEsZS5XRUlHSFRTX1RFWFRVUkVfTkFNRSksdGhpcy5fYmluZElucHV0VGV4dHVyZSh0aGlzLm1haW5Qcm9ncmFtLHIudGV4dHVyZSxvLlRFWFRVUkUyLGUuQklBU19URVhUVVJFX05BTUUpfX0se2tleTpcIl9iaW5kVW5pZm9ybXNJbnB1dFRyYW5zZm9ybVwiLHZhbHVlOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy53ZWJnbC5jb250ZXh0LG89dC5zaGFwZVswXSxpPXQuc2hhcGVbMV0sYT1uLnNoYXBlWzFdLHM9dGhpcy53ZWJnbC5nZXRQYWQoaSksdT10aGlzLndlYmdsLmdldFBhZChhKTtyLnVuaWZvcm0xaShyLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLmlucHV0VHJhbnNmb3JtUHJvZ3JhbSxlLklOUFVUX1JPV1NfVU5JRk9STV9OQU1FKSxvKSxyLnVuaWZvcm0xaShyLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLmlucHV0VHJhbnNmb3JtUHJvZ3JhbSxlLklOUFVUX0NPTFNfVU5JRk9STV9OQU1FKSxpKSxyLnVuaWZvcm0xaShyLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLmlucHV0VHJhbnNmb3JtUHJvZ3JhbSxlLk9VVFBVVF9DT0xTX1VOSUZPUk1fTkFNRSksYSksci51bmlmb3JtMWkoci5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5pbnB1dFRyYW5zZm9ybVByb2dyYW0sZS5JTlBVVF9DT0xfUEFEX1VOSUZPUk1fTkFNRSkscyksci51bmlmb3JtMWkoci5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5pbnB1dFRyYW5zZm9ybVByb2dyYW0sZS5PVVRQVVRfQ09MX1BBRF9VTklGT1JNX05BTUUpLHUpfX0se2tleTpcIl9iaW5kVW5pZm9ybXNNYWluXCIsdmFsdWU6ZnVuY3Rpb24odCxuLHIpe3ZhciBvPXRoaXMud2ViZ2wuY29udGV4dCxpPW4uc2hhcGVbMF0sYT10LnNoYXBlWzFdLHM9dGhpcy53ZWJnbC5nZXRQYWQoYSksdT10aGlzLndlYmdsLmdldFBhZChpKTtvLnVuaWZvcm0xaShvLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLm1haW5Qcm9ncmFtLGUuSU5QVVRfQ09MU19VTklGT1JNX05BTUUpLGEpLG8udW5pZm9ybTFpKG8uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMubWFpblByb2dyYW0sZS5PVVRQVVRfQ09MU19VTklGT1JNX05BTUUpLGkpLG8udW5pZm9ybTFpKG8uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMubWFpblByb2dyYW0sZS5JTlBVVF9DT0xfUEFEX1VOSUZPUk1fTkFNRSkscyksby51bmlmb3JtMWkoby5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5tYWluUHJvZ3JhbSxlLk9VVFBVVF9DT0xfUEFEX1VOSUZPUk1fTkFNRSksdSksXCJyZWx1XCI9PT1yJiZvLnVuaWZvcm0xaShvLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLm1haW5Qcm9ncmFtLGUuUkVMVV9BQ1RJVkFUSU9OX1VOSUZPUk1fTkFNRSksMSl9fSx7a2V5OlwiX2JpbmRPdXRwdXRUZXh0dXJlSW5wdXRUcmFuc2Zvcm1cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQuc2hhcGVbMV0scj10aGlzLndlYmdsLmdldFBhZChuKTt0aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKHQuc2hhcGVbMF0sKG4rcikvNCxlLnRleHR1cmUpfX0se2tleTpcIl9iaW5kT3V0cHV0VGV4dHVyZU1haW5cIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIHI9dC5zaGFwZVswXSxvPWUuc2hhcGVbMF0saT10aGlzLndlYmdsLmdldFBhZChvKTt0aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKHIsKG8raSkvNCxuLnRleHR1cmUpfX0se2tleTpcInRyYW5zZm9ybUlucHV0XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe2lmKGUuc2hhcGVbMF0hPT1uLnNoYXBlWzBdfHxlLnNoYXBlWzFdIT09bi5zaGFwZVsxXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGV4TWFwcGluZ1JvdyBvciBpbmRleE1hcHBpbmdDb2wgd2VibGFzIHRlbnNvciBzaGFwZXMuXCIpO3RoaXMud2ViZ2wuc2VsZWN0UHJvZ3JhbSh0aGlzLmlucHV0VHJhbnNmb3JtUHJvZ3JhbSk7dmFyIHI9bmV3IHdlYmxhcy5waXBlbGluZS5UZW5zb3IoZS5zaGFwZSxudWxsKTtyZXR1cm4gdGhpcy5fYmluZElucHV0VGV4dHVyZXNJbnB1dFRyYW5zZm9ybSh0LGUsbiksdGhpcy5fYmluZFVuaWZvcm1zSW5wdXRUcmFuc2Zvcm0odCxlKSx0aGlzLl9iaW5kT3V0cHV0VGV4dHVyZUlucHV0VHJhbnNmb3JtKGUsciksdGhpcy5fY29tcHV0ZSgpLHRoaXMuX3VuYmluZElucHV0VGV4dHVyZXMoKSxyfX0se2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyLG8saSl7aWYobyYmaSYmKHQ9dGhpcy50cmFuc2Zvcm1JbnB1dCh0LG8saSkpLHQuc2hhcGVbMV0hPT1lLnNoYXBlWzFdKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgb3Igd2VpZ2h0cyB3ZWJsYXMgdGVuc29yIHNoYXBlcy5cIik7dGhpcy53ZWJnbC5zZWxlY3RQcm9ncmFtKHRoaXMubWFpblByb2dyYW0pO3ZhciBhPXQuc2hhcGVbMF0scz1lLnNoYXBlWzBdLHU9bmV3IHdlYmxhcy5waXBlbGluZS5UZW5zb3IoW2Esc10sbnVsbCk7cmV0dXJuIHRoaXMuX2JpbmRJbnB1dFRleHR1cmVzTWFpbih0LGUsbiksdGhpcy5fYmluZFVuaWZvcm1zTWFpbih0LGUsciksdGhpcy5fYmluZE91dHB1dFRleHR1cmVNYWluKHQsZSx1KSx0aGlzLl9jb21wdXRlKCksdGhpcy5fdW5iaW5kSW5wdXRUZXh0dXJlcygpLHV9fV0pLGV9KGwuZGVmYXVsdCk7Yy5JTlBVVF9URVhUVVJFX05BTUU9XCJYXCIsYy5XRUlHSFRTX1RFWFRVUkVfTkFNRT1cIldcIixjLkJJQVNfVEVYVFVSRV9OQU1FPVwiYlwiLGMuSU5QVVRfUk9XU19VTklGT1JNX05BTUU9XCJpbnB1dFJvd3NcIixjLklOUFVUX0NPTFNfVU5JRk9STV9OQU1FPVwiaW5wdXRDb2xzXCIsYy5PVVRQVVRfQ09MU19VTklGT1JNX05BTUU9XCJvdXRwdXRDb2xzXCIsYy5JTlBVVF9DT0xfUEFEX1VOSUZPUk1fTkFNRT1cImlucHV0Q29sUGFkXCIsYy5PVVRQVVRfQ09MX1BBRF9VTklGT1JNX05BTUU9XCJvdXRwdXRDb2xQYWRcIixjLlJFTFVfQUNUSVZBVElPTl9VTklGT1JNX05BTUU9XCJyZWx1XCIsYy5JTUFQX1JPV19URVhUVVJFX05BTUU9XCJpbmRleE1hcHBpbmdSb3dcIixjLklNQVBfQ09MX1RFWFRVUkVfTkFNRT1cImluZGV4TWFwcGluZ0NvbFwiLGUuZGVmYXVsdD1jfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9big2NyksbD1yKHUpLGM9bigxODgpLGY9cihjKSxwPW4oMTI5KSxoPXIocCksZD17c3VtOjAsbXVsOjEsY29uY2F0OjIsYXZlOjMsbWF4OjR9LHY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtvKHRoaXMsZSk7dmFyIHI9aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMpKTtpZihcImNvbmNhdFwiPT09dClyLnByb2dyYW09ci53ZWJnbC5jcmVhdGVQcm9ncmFtKG4oNjE0KSk7ZWxzZXtpZighKFtcInN1bVwiLFwibXVsXCIsXCJhdmVcIixcIm1heFwiXS5pbmRleE9mKHQpPi0xKSl0aHJvdyBuZXcgRXJyb3IodCtcIiBtb2RlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIFdlYkdMTWVyZ2UgbGF5ZXIuXCIpO3IucHJvZ3JhbT1yLndlYmdsLmNyZWF0ZVByb2dyYW0obig2MTMpKX1yZXR1cm4gci5tb2RlPXQsci5tb2RlQ29kZT1kW3RdLHJ9cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJfYmluZElucHV0VGV4dHVyZXNBcnJheVwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoPnRoaXMuTUFYX05VTV9URVhUVVJFUyl0aHJvdyBuZXcgRXJyb3IoXCJNYXggbnVtYmVyIG9mIGlucHV0cyB0byBXZWJHTE1lcmdlIGV4Y2VlZGVkLlwiKTt2YXIgbj10aGlzLndlYmdsLmNvbnRleHQ7dGhpcy5udW1UZXh0dXJlcz10Lmxlbmd0aDtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyluLmFjdGl2ZVRleHR1cmUobi5URVhUVVJFMCtyKSxuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCx0W3JdLnRleHR1cmUpO3ZhciBvPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxlLklOUFVUX1RFWFRVUkVTX0FSUkFZX05BTUUrXCJbMF1cIik7bi51bmlmb3JtMWl2KG8sKDAsZi5kZWZhdWx0KSh0aGlzLm51bVRleHR1cmVzKSl9fSx7a2V5OlwiX2JpbmRVbmlmb3Jtc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMud2ViZ2wuY29udGV4dCxyPXRbMF0uc2hhcGVbMV0sbz10aGlzLndlYmdsLmdldFBhZChyKTtpZihuLnVuaWZvcm0xaShuLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sZS5OVU1fSU5QVVRTX1VOSUZPUk1fTkFNRSksdC5sZW5ndGgpLG4udW5pZm9ybTFpKG4uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxlLk9VVFBVVF9DT0xTX1VOSUZPUk1fTkFNRSksciksbi51bmlmb3JtMWkobi5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLGUuT1VUUFVUX0NPTF9QQURfVU5JRk9STV9OQU1FKSxvKSxcImNvbmNhdFwiPT09dGhpcy5tb2RlKXt2YXIgaT10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZVswXX0pLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0Lmxlbmd0aD4xJiYoZSs9dFt0Lmxlbmd0aC0xXSksdC5wdXNoKGUpLHR9LFswXSkuc2xpY2UoMCwtMSksYT0oMCxoLmRlZmF1bHQpKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlWzBdfSkpO24udW5pZm9ybTFpKG4uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxlLk9VVFBVVF9ST1dTX1VOSUZPUk1fTkFNRSksYSksbi51bmlmb3JtMWl2KG4uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxlLklOUFVUX0NIQU5ORUxfU1RBUlRfSU5ESUNFU19VTklGT1JNX05BTUUpLGkpfWVsc2Ugbi51bmlmb3JtMWkobi5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLGUuTU9ERV9DT0RFX1VOSUZPUk1fTkFNRSksdGhpcy5tb2RlQ29kZSl9fSx7a2V5OlwiX2JpbmRPdXRwdXRUZXh0dXJlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj10WzBdLnNoYXBlWzBdO1wiY29uY2F0XCI9PT10aGlzLm1vZGUmJihuPSgwLGguZGVmYXVsdCkodC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGVbMF19KSkpO3ZhciByPXRbMF0uc2hhcGVbMV0sbz10aGlzLndlYmdsLmdldFBhZChyKTt0aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKG4sKHIrbykvNCxlLnRleHR1cmUpfX0se2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLndlYmdsLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKTt2YXIgZT12b2lkIDA7aWYoXCJjb25jYXRcIj09PXRoaXMubW9kZSl7aWYoIXQuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGVbMF09PT10WzBdLnNoYXBlWzBdfSkpdGhyb3cgbmV3IEVycm9yKFwiTm9uLWNvbmNhdCBheGlzIGRpbWVuc2lvbiBvZiBpbnB1dHMgdG8gV2ViR0xNZXJnZSBtdXN0IGFsbCBiZSB0aGUgc2FtZS5cIik7dmFyIG49dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJhbnNwb3NlKCl9KSxyPVsoMCxoLmRlZmF1bHQpKG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlWzBdfSkpLG5bMF0uc2hhcGVbMV1dO2U9bmV3IHdlYmxhcy5waXBlbGluZS5UZW5zb3IocixudWxsKSx0aGlzLndlYmdsLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKSx0aGlzLl9iaW5kSW5wdXRUZXh0dXJlc0FycmF5KG4pLHRoaXMuX2JpbmRVbmlmb3JtcyhuKSx0aGlzLl9iaW5kT3V0cHV0VGV4dHVyZShuLGUpfWVsc2UgZT1uZXcgd2VibGFzLnBpcGVsaW5lLlRlbnNvcih0WzBdLnNoYXBlLG51bGwpLHRoaXMuX2JpbmRJbnB1dFRleHR1cmVzQXJyYXkodCksdGhpcy5fYmluZFVuaWZvcm1zKHQpLHRoaXMuX2JpbmRPdXRwdXRUZXh0dXJlKHQsZSk7cmV0dXJuIHRoaXMuX2NvbXB1dGUoKSx0aGlzLl91bmJpbmRJbnB1dFRleHR1cmVzKCksXCJjb25jYXRcIj09PXRoaXMubW9kZSYmKGU9ZS50cmFuc3Bvc2UoKSksZX19XSksZX0obC5kZWZhdWx0KTt2LklOUFVUX1RFWFRVUkVTX0FSUkFZX05BTUU9XCJpbnB1dHNcIix2LklOUFVUX0NIQU5ORUxfU1RBUlRfSU5ESUNFU19VTklGT1JNX05BTUU9XCJpbnB1dENoYW5uZWxTdGFydEluZGljZXNcIix2Lk5VTV9JTlBVVFNfVU5JRk9STV9OQU1FPVwibnVtSW5wdXRzXCIsdi5NT0RFX0NPREVfVU5JRk9STV9OQU1FPVwibW9kZUNvZGVcIix2Lk9VVFBVVF9ST1dTX1VOSUZPUk1fTkFNRT1cIm91dHB1dFJvd3NcIix2Lk9VVFBVVF9DT0xTX1VOSUZPUk1fTkFNRT1cIm91dHB1dENvbHNcIix2Lk9VVFBVVF9DT0xfUEFEX1VOSUZPUk1fTkFNRT1cIm91dHB1dENvbFBhZFwiLGUuZGVmYXVsdD12fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9big2NyksbD1yKHUpLGM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe28odGhpcyxlKTt2YXIgdD1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcykpO3JldHVybiB0LnByb2dyYW09dC53ZWJnbC5jcmVhdGVQcm9ncmFtKG4oNjE1KSksdH1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcIl9iaW5kSW5wdXRUZXh0dXJlc1wiLHZhbHVlOmZ1bmN0aW9uKHQsbixyLG8saSl7dmFyIGE9dGhpcy53ZWJnbC5jb250ZXh0O3RoaXMubnVtVGV4dHVyZXM9NSx0aGlzLl9iaW5kSW5wdXRUZXh0dXJlKHRoaXMucHJvZ3JhbSx0LnRleHR1cmUsYS5URVhUVVJFMCxlLklOUFVUX1RFWFRVUkVfTkFNRSksdGhpcy5fYmluZElucHV0VGV4dHVyZSh0aGlzLnByb2dyYW0sby50ZXh0dXJlLGEuVEVYVFVSRTEsZS5NRUFOX1RFWFRVUkVfTkFNRSksdGhpcy5fYmluZElucHV0VGV4dHVyZSh0aGlzLnByb2dyYW0saS50ZXh0dXJlLGEuVEVYVFVSRTIsZS5TVERfVEVYVFVSRV9OQU1FKSx0aGlzLl9iaW5kSW5wdXRUZXh0dXJlKHRoaXMucHJvZ3JhbSxuLnRleHR1cmUsYS5URVhUVVJFMyxlLkdBTU1BX1RFWFRVUkVfTkFNRSksdGhpcy5fYmluZElucHV0VGV4dHVyZSh0aGlzLnByb2dyYW0sci50ZXh0dXJlLGEuVEVYVFVSRTQsZS5CRVRBX1RFWFRVUkVfTkFNRSl9fSx7a2V5OlwiX2JpbmRVbmlmb3Jtc1wiLHZhbHVlOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy53ZWJnbC5jb250ZXh0LG89dGhpcy53ZWJnbC5nZXRQYWQodC5zaGFwZVsxXSk7ci51bmlmb3JtMWYoci5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLGUuRVBTSUxPTl9VTklGT1JNX05BTUUpLG4pLHIudW5pZm9ybTFpKHIuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxlLk9VVFBVVF9DT0xTX1VOSUZPUk1fTkFNRSksdC5zaGFwZVsxXSksci51bmlmb3JtMWkoci5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLGUuT1VUUFVUX0NPTF9QQURfVU5JRk9STV9OQU1FKSxvKX19LHtrZXk6XCJfYmluZE91dHB1dFRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMud2ViZ2wuZ2V0UGFkKHQuc2hhcGVbMV0pO3RoaXMud2ViZ2wuYmluZE91dHB1dFRleHR1cmUodC5zaGFwZVswXSwodC5zaGFwZVsxXStuKS80LGUudGV4dHVyZSl9fSx7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIsbyxpKXt0aGlzLndlYmdsLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKTt2YXIgYT1uZXcgd2VibGFzLnBpcGVsaW5lLlRlbnNvcih0LnNoYXBlLG51bGwpO3JldHVybiB0aGlzLl9iaW5kSW5wdXRUZXh0dXJlcyh0LG4scixvLGkpLHRoaXMuX2JpbmRVbmlmb3Jtcyh0LGUpLHRoaXMuX2JpbmRPdXRwdXRUZXh0dXJlKHQsYSksdGhpcy5fY29tcHV0ZSgpLHRoaXMuX3VuYmluZElucHV0VGV4dHVyZXMoKSxhfX1dKSxlfShsLmRlZmF1bHQpO2MuSU5QVVRfVEVYVFVSRV9OQU1FPVwiWFwiLGMuTUVBTl9URVhUVVJFX05BTUU9XCJtZWFuXCIsYy5TVERfVEVYVFVSRV9OQU1FPVwic3RkXCIsYy5HQU1NQV9URVhUVVJFX05BTUU9XCJnYW1tYVwiLGMuQkVUQV9URVhUVVJFX05BTUU9XCJiZXRhXCIsYy5FUFNJTE9OX1VOSUZPUk1fTkFNRT1cImVwc2lsb25cIixjLk9VVFBVVF9DT0xTX1VOSUZPUk1fTkFNRT1cIm91dHB1dENvbHNcIixjLk9VVFBVVF9DT0xfUEFEX1VOSUZPUk1fTkFNRT1cIm91dHB1dENvbFBhZFwiLGUuZGVmYXVsdD1jfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1uKDEyNyksZj1yKGMpLHA9ZnVuY3Rpb24odCl7XG5mdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiSW5wdXRMYXllclwiO3ZhciByPXQuc2hhcGUsYT12b2lkIDA9PT1yP1tdOnI7cmV0dXJuIG4uc2hhcGU9dC5iYXRjaElucHV0U2hhcGUmJnQuYmF0Y2hJbnB1dFNoYXBlLmxlbmd0aD90LmJhdGNoSW5wdXRTaGFwZS5zbGljZSgxKTphLG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoISgwLGYuZGVmYXVsdCkodC50ZW5zb3Iuc2hhcGUsdGhpcy5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiW0lucHV0TGF5ZXJdIGlucHV0IHRlbnNvciBzaGFwZSBcIit0LnRlbnNvci5zaGFwZStcIiBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgc2hhcGUgXCIrdGhpcy5zaGFwZStcIi5cIik7cmV0dXJuIHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PXB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMjUpLGY9cihjKSxwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtoLmNhbGwobiksbi5sYXllckNsYXNzPVwiRUxVXCI7dmFyIHI9dC5hbHBoYSxhPXZvaWQgMD09PXI/MTpyO3JldHVybiBuLmFscGhhPWEsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY29tcHV0ZSh0LnRlbnNvcix0aGlzLmFscGhhKSx0fX1dKSxlfShsLmRlZmF1bHQpLGg9ZnVuY3Rpb24oKXt0aGlzLl9jb21wdXRlPSgwLGYuZGVmYXVsdCkoe2FyZ3M6W1wiYXJyYXlcIixcInNjYWxhclwiXSxib2R5OmZ1bmN0aW9uKHQsZSl7dD1NYXRoLm1heCh0LDApK2UqKE1hdGguZXhwKE1hdGgubWluKHQsMCkpLTEpfX0pfTtlLmRlZmF1bHQ9cH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9bigxOSksZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiTGVha3lSZUxVXCI7dmFyIHI9dC5hbHBoYSxhPXZvaWQgMD09PXI/LjM6cjtyZXR1cm4gbi5hbHBoYT1hLG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuKDAsYy5yZWx1KSh0LHthbHBoYTp0aGlzLmFscGhhfSksdH19XSksZX0obC5kZWZhdWx0KTtlLmRlZmF1bHQ9Zn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9bigyNSksZj1yKGMpLHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO3JldHVybiBuLl9jb21wdXRlPSgwLGYuZGVmYXVsdCkoe2FyZ3M6W1wiYXJyYXlcIixcImFycmF5XCJdLGJvZHk6ZnVuY3Rpb24odCxlKXt0PU1hdGgubWF4KHQsMCkrZSpNYXRoLm1pbih0LDApfX0pLG4ubGF5ZXJDbGFzcz1cIlBSZUxVXCIsbi5wYXJhbXM9W1wiYWxwaGFzXCJdLG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NvbXB1dGUodC50ZW5zb3IsdGhpcy53ZWlnaHRzLmFscGhhcy50ZW5zb3IpLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PXB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMjUpLGY9cihjKSxwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtyZXR1cm4gbi5fY29tcHV0ZT0oMCxmLmRlZmF1bHQpKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sYm9keTpmdW5jdGlvbih0LGUsbil7dD1lKk1hdGgubG9nKDErTWF0aC5leHAobip0KSl9fSksbi5sYXllckNsYXNzPVwiUGFyYW1ldHJpY1NvZnRwbHVzXCIsbi5wYXJhbXM9W1wiYWxwaGFzXCIsXCJiZXRhc1wiXSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jb21wdXRlKHQudGVuc29yLHRoaXMud2VpZ2h0cy5hbHBoYXMudGVuc29yLHRoaXMud2VpZ2h0cy5iZXRhcy50ZW5zb3IpLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PXB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMjUpLGY9cihjKSxwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtyZXR1cm4gbi5fY29tcHV0ZT0oMCxmLmRlZmF1bHQpKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiXSxib2R5OmZ1bmN0aW9uKHQsZSxuLHIsbyl7dD1lK01hdGgubWluKE1hdGgubWF4KHQtZSwwKSxNYXRoLmFicyhyKSkrbipNYXRoLm1pbih0LWUsMCkrTWF0aC5tYXgodC0oZStNYXRoLmFicyhyKSksMCkqb319KSxuLmxheWVyQ2xhc3M9XCJTUmVMVVwiLG4ucGFyYW1zPVtcInRfbGVmdFwiLFwiYV9sZWZ0XCIsXCJ0X3JpZ2h0XCIsXCJhX3JpZ2h0XCJdLG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NvbXB1dGUodC50ZW5zb3IsdGhpcy53ZWlnaHRzLnRfbGVmdC50ZW5zb3IsdGhpcy53ZWlnaHRzLmFfbGVmdC50ZW5zb3IsdGhpcy53ZWlnaHRzLnRfcmlnaHQudGVuc29yLHRoaXMud2VpZ2h0cy5hX3JpZ2h0LnRlbnNvciksdH19XSksZX0obC5kZWZhdWx0KTtlLmRlZmF1bHQ9cH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9bigyNSksZj1yKGMpLHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO2guY2FsbChuKSxuLmxheWVyQ2xhc3M9XCJUaHJlc2hvbGRlZFJlTFVcIjt2YXIgcj10LnRoZXRhLGE9dm9pZCAwPT09cj8xOnI7cmV0dXJuIG4udGhldGE9YSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jb21wdXRlKHQudGVuc29yLHRoaXMudGhldGEpLHR9fV0pLGV9KGwuZGVmYXVsdCksaD1mdW5jdGlvbigpe3RoaXMuX2NvbXB1dGU9KDAsZi5kZWZhdWx0KSh7YXJnczpbXCJhcnJheVwiLFwic2NhbGFyXCJdLGJvZHk6ZnVuY3Rpb24odCxlKXt0Kj1OdW1iZXIodD5lKX19KX07ZS5kZWZhdWx0PXB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlNSZUxVPWUuVGhyZXNob2xkZWRSZUxVPWUuUGFyYW1ldHJpY1NvZnRwbHVzPWUuRUxVPWUuUFJlTFU9ZS5MZWFreVJlTFU9dm9pZCAwO3ZhciBvPW4oMjAzKSxpPXIobyksYT1uKDIwNCkscz1yKGEpLHU9bigyMDIpLGw9cih1KSxjPW4oMjA1KSxmPXIoYykscD1uKDIwNyksaD1yKHApLGQ9bigyMDYpLHY9cihkKTtlLkxlYWt5UmVMVT1pLmRlZmF1bHQsZS5QUmVMVT1zLmRlZmF1bHQsZS5FTFU9bC5kZWZhdWx0LGUuUGFyYW1ldHJpY1NvZnRwbHVzPWYuZGVmYXVsdCxlLlRocmVzaG9sZGVkUmVMVT1oLmRlZmF1bHQsZS5TUmVMVT12LmRlZmF1bHR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHM9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXMubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7IXImJnMucmV0dXJuJiZzLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIHQoZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGw9bigyKSxjPXIobCksZj1uKDY4KSxwPXIoZiksaD1uKDMpLGQ9cihoKSx2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJBdHJvdXNDb252b2x1dGlvbjJEXCI7dmFyIHI9dC5hdHJvdXNSYXRlLGE9dm9pZCAwPT09cj9bMSwxXTpyO3JldHVybiBuLmF0cm91c1JhdGU9YSxufXJldHVybiBhKGUsdCksdShlLFt7a2V5OlwiX2NhbGNPdXRwdXRTaGFwZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRbMF0sbj10WzFdLHI9cyh0aGlzLmtlcm5lbFNoYXBlLDMpLG89clswXSxpPXJbMV0sYT1yWzJdLHU9aSsoaS0xKSoodGhpcy5hdHJvdXNSYXRlWzBdLTEpLGw9YSsoYS0xKSoodGhpcy5hdHJvdXNSYXRlWzFdLTEpLGM9XCJzYW1lXCI9PT10aGlzLmJvcmRlck1vZGU/TWF0aC5mbG9vcigoZSt0aGlzLnN1YnNhbXBsZVswXS0xKS90aGlzLnN1YnNhbXBsZVswXSk6TWF0aC5mbG9vcigoZS11K3RoaXMuc3Vic2FtcGxlWzBdKS90aGlzLnN1YnNhbXBsZVswXSksZj1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLmZsb29yKChuK3RoaXMuc3Vic2FtcGxlWzFdLTEpL3RoaXMuc3Vic2FtcGxlWzFdKTpNYXRoLmZsb29yKChuLWwrdGhpcy5zdWJzYW1wbGVbMV0pL3RoaXMuc3Vic2FtcGxlWzFdKSxwPW8saD1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLm1heCgwLE1hdGguZmxvb3IoKGMtMSkqdGhpcy5zdWJzYW1wbGVbMF0rdS1lKSk6MCxkPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGgubWF4KDAsTWF0aC5mbG9vcigoZi0xKSp0aGlzLnN1YnNhbXBsZVsxXStsLW4pKTowLHY9TWF0aC5mbG9vcihoLzIpLG09aC12LF89TWF0aC5mbG9vcihkLzIpLGc9ZC1fO3RoaXMub3V0cHV0U2hhcGU9W2MsZixwXSx0aGlzLmlucHV0UGFkZGluZz1bdixtLF8sZ119fSx7a2V5OlwiX2ltMmNvbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXModC50ZW5zb3Iuc2hhcGUsMyksbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT10aGlzLmtlcm5lbFNoYXBlWzFdLGE9dGhpcy5rZXJuZWxTaGFwZVsyXSx1PXRoaXMub3V0cHV0U2hhcGVbMF0sbD10aGlzLm91dHB1dFNoYXBlWzFdLGY9dSpsLHA9aSphKm8saD1pKyhpLTEpKih0aGlzLmF0cm91c1JhdGVbMF0tMSksdj1hKyhhLTEpKih0aGlzLmF0cm91c1JhdGVbMV0tMSk7dGhpcy5faW1Db2xzTWF0fHwodGhpcy5faW1Db2xzTWF0PW5ldyBjLmRlZmF1bHQoW10sW2YscF0pKTtmb3IodmFyIG09bmV3IGMuZGVmYXVsdChbXSxbaSxhLG9dKSxfPTAsZz0wLHk9bi1oO2c8PXk7Zys9dGhpcy5zdWJzYW1wbGVbMF0pZm9yKHZhciBiPTAsdz1yLXY7Yjw9dztiKz10aGlzLnN1YnNhbXBsZVsxXSlkLmRlZmF1bHQuYXNzaWduKG0udGVuc29yLHQudGVuc29yLmhpKGcraCxiK3YsbykubG8oZyxiLDApLnN0ZXAodGhpcy5hdHJvdXNSYXRlWzBdLHRoaXMuYXRyb3VzUmF0ZVsxXSwxKSksdGhpcy5faW1Db2xzTWF0LnRlbnNvci5kYXRhLnNldChtLnRlbnNvci5kYXRhLF8pLF8rPXA7cmV0dXJuIHRoaXMuX3VzZVdlYmxhcyYmdGhpcy5faW1Db2xzTWF0LmNyZWF0ZVdlYmxhc1RlbnNvcigpLHRoaXMuX2ltQ29sc01hdH19XSksZX0ocC5kZWZhdWx0KTtlLmRlZmF1bHQ9dn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9big2OCksZj1yKGMpLHA9bigxOTEpLGg9cihwKSxkPW4oMTMwKSx2PXIoZCksbT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiQ29udm9sdXRpb24xRFwiO3ZhciByPXQubmJGaWx0ZXIsYT12b2lkIDA9PT1yPzE6cixzPXQuZmlsdGVyTGVuZ3RoLHU9dm9pZCAwPT09cz8xOnMsbD10LmFjdGl2YXRpb24sYz12b2lkIDA9PT1sP1wibGluZWFyXCI6bCxwPXQuYm9yZGVyTW9kZSxoPXZvaWQgMD09PXA/XCJ2YWxpZFwiOnAsZD10LnN1YnNhbXBsZUxlbmd0aCx2PXZvaWQgMD09PWQ/MTpkLG09dC5iaWFzLF89dm9pZCAwPT09bXx8bTtpZihcInZhbGlkXCIhPT1oJiZcInNhbWVcIiE9PWgpdGhyb3cgbmV3IEVycm9yKG4ubmFtZStcIiBbQ29udm9sdXRpb24xRCBsYXllcl0gSW52YWxpZCBib3JkZXJNb2RlLlwiKTtuLmJpYXM9XyxuLnBhcmFtcz1uLmJpYXM/W1wiV1wiLFwiYlwiXTpbXCJXXCJdO3ZhciBnPXtuYkZpbHRlcjphLG5iUm93OnUsbmJDb2w6MSxhY3RpdmF0aW9uOmMsYm9yZGVyTW9kZTpoLHN1YnNhbXBsZTpbdiwxXSxkaW1PcmRlcmluZzpcInRoXCIsYmlhczpffTtyZXR1cm4gbi5fY29udjJkQXR0cnM9ZyxuLl9jb252MmQ9bmV3IGYuZGVmYXVsdChPYmplY3QuYXNzaWduKGcse2dwdTp0LmdwdX0pKSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5Olwic2V0V2VpZ2h0c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2NvbnYyZEF0dHJzLG49ZS5uYkZpbHRlcixyPWUubmJSb3csbz1lLm5iQ29sLGk9dFswXS50ZW5zb3Iuc2hhcGU7aWYoaVswXSE9PXJ8fGlbMV0hPT1vfHxpWzNdIT09bil7aWYoY29uc29sZS53YXJuKFwiVXNpbmcgbGVnYWN5IHNoYXBlIG9mIHdlaWdodHNcIiksIShpWzBdPT09biYoaVsyXT09PXImaVszXT09PW8pKSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzaGFwZSBvZiB3ZWlnaHRzXCIpfWVsc2UgdFswXS50ZW5zb3I9dFswXS50ZW5zb3IudHJhbnNwb3NlKDMsMiwwLDEpO3RoaXMuX2NvbnYyZC5zZXRXZWlnaHRzKHQpfX0se2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt0LnRlbnNvcj0oMCx2LmRlZmF1bHQpKHQudGVuc29yKS50cmFuc3Bvc2UoMCwyLDEpO3ZhciBlPXRoaXMuX2NvbnYyZC5jYWxsKHQpO3JldHVybiB0LnRlbnNvcj0oMCxoLmRlZmF1bHQpKGUudGVuc29yKS50cmFuc3Bvc2UoMSwwLDIpLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PW19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZS5kZWZhdWx0PXQsZX1mdW5jdGlvbiBpKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBhKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gcyh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHM9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXMubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7IXImJnMucmV0dXJuJiZzLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIHQoZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksbD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGM9ZnVuY3Rpb24gdChlLG4scil7bnVsbD09PWUmJihlPUZ1bmN0aW9uLnByb3RvdHlwZSk7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2lmKHZvaWQgMD09PW8pe3ZhciBpPU9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtyZXR1cm4gbnVsbD09PWk/dm9pZCAwOnQoaSxuLHIpfWlmKFwidmFsdWVcImluIG8pcmV0dXJuIG8udmFsdWU7dmFyIGE9by5nZXQ7aWYodm9pZCAwIT09YSlyZXR1cm4gYS5jYWxsKHIpfSxmPW4oMTkpLHA9byhmKSxoPW4oMiksZD1yKGgpLHY9bigxKSxtPXIodiksXz1uKDMpLGc9cihfKSx5PW4oNjYpLGI9cih5KSx3PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aSh0aGlzLGUpO3ZhciBuPWEodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJDb252b2x1dGlvbjNEXCI7dmFyIHI9dC5uYkZpbHRlcixvPXZvaWQgMD09PXI/MTpyLHM9dC5rZXJuZWxEaW0xLHU9dm9pZCAwPT09cz8xOnMsbD10Lmtlcm5lbERpbTIsYz12b2lkIDA9PT1sPzE6bCxmPXQua2VybmVsRGltMyxoPXZvaWQgMD09PWY/MTpmLGQ9dC5hY3RpdmF0aW9uLHY9dm9pZCAwPT09ZD9cImxpbmVhclwiOmQsbT10LmJvcmRlck1vZGUsXz12b2lkIDA9PT1tP1widmFsaWRcIjptLGc9dC5zdWJzYW1wbGUseT12b2lkIDA9PT1nP1sxLDEsMV06ZyxiPXQuZGltT3JkZXJpbmcsdz12b2lkIDA9PT1iP1widGZcIjpiLHg9dC5iaWFzLEU9dm9pZCAwPT09eHx8eDtpZihuLmtlcm5lbFNoYXBlPVtvLHUsYyxoXSxuLmFjdGl2YXRpb249dixuLmFjdGl2YXRpb25GdW5jPXBbdl0sXCJ2YWxpZFwiIT09XyYmXCJzYW1lXCIhPT1fKXRocm93IG5ldyBFcnJvcihuLm5hbWUrXCIgW0NvbnZvbHV0aW9uM0QgbGF5ZXJdIEludmFsaWQgYm9yZGVyTW9kZS5cIik7aWYobi5ib3JkZXJNb2RlPV8sbi5zdWJzYW1wbGU9eSxcInRmXCIhPT13JiZcInRoXCIhPT13KXRocm93IG5ldyBFcnJvcihuLm5hbWUrXCIgW0NvbnZvbHV0aW9uM0QgbGF5ZXJdIE9ubHkgdGYgYW5kIHRoIGRpbSBvcmRlcmluZyBhcmUgYWxsb3dlZC5cIik7cmV0dXJuIG4uZGltT3JkZXJpbmc9dyxuLmJpYXM9RSxuLnBhcmFtcz1uLmJpYXM/W1wiV1wiLFwiYlwiXTpbXCJXXCJdLG4uZ3B1JiZ3ZWJsYXMmJihuLl91c2VXZWJsYXM9ITAsbi5fcGlwZWxpbmVFbmFibGVkPSExKSxufXJldHVybiBzKGUsdCksbChlLFt7a2V5Olwic2V0V2VpZ2h0c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe1widGhcIj09PXRoaXMuZGltT3JkZXJpbmcmJih0WzBdLnRlbnNvcj10WzBdLnRlbnNvci50cmFuc3Bvc2UoMiwzLDQsMSwwKSksYyhlLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJzZXRXZWlnaHRzXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuX3dSb3dzTWF0PXRoaXMuX3cycm93KCksdGhpcy5fdXNlV2VibGFzJiYodGhpcy5fd1Jvd3NNYXQuY3JlYXRlV2VibGFzVGVuc29yKCksdGhpcy5fd1Jvd3NNYXQuX2dwdU1heFNpemVFeGNlZWRlZHx8KHRoaXMuX3dSb3dzTWF0LndlYmxhc1RlbnNvcj10aGlzLl93Um93c01hdC53ZWJsYXNUZW5zb3IudHJhbnNwb3NlKCkpLHRoaXMuYmlhcz90aGlzLndlaWdodHMuYi5jcmVhdGVXZWJsYXNUZW5zb3IoKToodGhpcy5femVyb3NWZWM9bmV3IGQuZGVmYXVsdChbXSxbdGhpcy53ZWlnaHRzLlcudGVuc29yLnNoYXBlWzRdXSksdGhpcy5femVyb3NWZWMuY3JlYXRlV2VibGFzVGVuc29yKCkpKX19LHtrZXk6XCJfY2FsY091dHB1dFNoYXBlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC50ZW5zb3Iuc2hhcGVbMF0sbj10LnRlbnNvci5zaGFwZVsxXSxyPXQudGVuc29yLnNoYXBlWzJdLG89dSh0aGlzLmtlcm5lbFNoYXBlLDQpLGk9b1swXSxhPW9bMV0scz1vWzJdLGw9b1szXSxjPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGguZmxvb3IoKGUrdGhpcy5zdWJzYW1wbGVbMF0tMSkvdGhpcy5zdWJzYW1wbGVbMF0pOk1hdGguZmxvb3IoKGUtYSt0aGlzLnN1YnNhbXBsZVswXSkvdGhpcy5zdWJzYW1wbGVbMF0pLGY9XCJzYW1lXCI9PT10aGlzLmJvcmRlck1vZGU/TWF0aC5mbG9vcigobit0aGlzLnN1YnNhbXBsZVsxXS0xKS90aGlzLnN1YnNhbXBsZVsxXSk6TWF0aC5mbG9vcigobi1zK3RoaXMuc3Vic2FtcGxlWzFdKS90aGlzLnN1YnNhbXBsZVsxXSkscD1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLmZsb29yKChyK3RoaXMuc3Vic2FtcGxlWzJdLTEpL3RoaXMuc3Vic2FtcGxlWzJdKTpNYXRoLmZsb29yKChyLWwrdGhpcy5zdWJzYW1wbGVbMl0pL3RoaXMuc3Vic2FtcGxlWzJdKSxoPWksZD1cInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZT9NYXRoLm1heCgwLE1hdGguZmxvb3IoKGMtMSkqdGhpcy5zdWJzYW1wbGVbMF0rYS1lKSk6MCx2PVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGgubWF4KDAsTWF0aC5mbG9vcigoZi0xKSp0aGlzLnN1YnNhbXBsZVsxXStzLW4pKTowLG09XCJzYW1lXCI9PT10aGlzLmJvcmRlck1vZGU/TWF0aC5tYXgoMCxNYXRoLmZsb29yKChwLTEpKnRoaXMuc3Vic2FtcGxlWzJdK2wtcikpOjAsXz1NYXRoLmZsb29yKGQvMiksZz1kLV8seT1NYXRoLmZsb29yKHYvMiksYj12LXksdz1NYXRoLmZsb29yKG0vMikseD1tLXc7dGhpcy5vdXRwdXRTaGFwZT1bYyxmLHAsaF0sdGhpcy5pbnB1dFBhZGRpbmc9W18sZyx5LGIsdyx4XX19LHtrZXk6XCJfcGFkSW5wdXRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZihcInNhbWVcIj09PXRoaXMuYm9yZGVyTW9kZSl7dmFyIGU9dSh0LnRlbnNvci5zaGFwZSw0KSxuPWVbMF0scj1lWzFdLG89ZVsyXSxpPWVbM10sYT11KHRoaXMuaW5wdXRQYWRkaW5nLDYpLHM9YVswXSxsPWFbMV0sYz1hWzJdLGY9YVszXSxwPWFbNF0saD1hWzVdLHY9bitzK2wsbT1yK2MrZixfPW8rcCtoLHk9bmV3IGQuZGVmYXVsdChbXSxbdixtLF8saV0pO2cuZGVmYXVsdC5hc3NpZ24oeS50ZW5zb3IuaGkobitzLHIrYyxvK3AsaSkubG8ocyxjLHAsMCksdC50ZW5zb3IpLHQudGVuc29yPXkudGVuc29yfXJldHVybiB0fX0se2tleTpcIl92b2wyY29sXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dSh0LnRlbnNvci5zaGFwZSw0KSxuPWVbMF0scj1lWzFdLG89ZVsyXSxpPWVbM10sYT10aGlzLmtlcm5lbFNoYXBlWzFdLHM9dGhpcy5rZXJuZWxTaGFwZVsyXSxsPXRoaXMua2VybmVsU2hhcGVbM10sYz10aGlzLm91dHB1dFNoYXBlWzBdLGY9dGhpcy5vdXRwdXRTaGFwZVsxXSxwPXRoaXMub3V0cHV0U2hhcGVbMl0saD1jKmYqcCx2PWEqcypsKmk7aWYodGhpcy5fdm9sQ29sc01hdHx8KHRoaXMuX3ZvbENvbHNNYXQ9bmV3IGQuZGVmYXVsdChbXSxbaCx2XSkpLDE9PT1hJiYxPT09cyYmMT09PWwmJjE9PT10aGlzLnN1YnNhbXBsZVswXSYmMT09PXRoaXMuc3Vic2FtcGxlWzFdJiYxPT09dGhpcy5zdWJzYW1wbGVbMl0pcmV0dXJuIHRoaXMuX3ZvbENvbHNNYXQucmVwbGFjZVRlbnNvckRhdGEodC50ZW5zb3IuZGF0YSksdGhpcy5fdXNlV2VibGFzJiZ0aGlzLl92b2xDb2xzTWF0LmNyZWF0ZVdlYmxhc1RlbnNvcigpLHRoaXMuX3ZvbENvbHNNYXQ7Zm9yKHZhciBtPW5ldyBkLmRlZmF1bHQoW10sW2EscyxsLGldKSxfPTAseT0wLGI9bi1hO3k8PWI7eSs9dGhpcy5zdWJzYW1wbGVbMF0pZm9yKHZhciB3PTAseD1yLXM7dzw9eDt3Kz10aGlzLnN1YnNhbXBsZVsxXSlmb3IodmFyIEU9MCxUPW8tbDtFPD1UO0UrPXRoaXMuc3Vic2FtcGxlWzJdKWcuZGVmYXVsdC5hc3NpZ24obS50ZW5zb3IsdC50ZW5zb3IuaGkoeSthLHcrcyxFK2wsaSkubG8oeSx3LEUsMCkpLHRoaXMuX3ZvbENvbHNNYXQudGVuc29yLmRhdGEuc2V0KG0udGVuc29yLmRhdGEsXyksXys9djtyZXR1cm4gdGhpcy5fdXNlV2VibGFzJiZ0aGlzLl92b2xDb2xzTWF0LmNyZWF0ZVdlYmxhc1RlbnNvcigpLHRoaXMuX3ZvbENvbHNNYXR9fSx7a2V5OlwiX3cycm93XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy53ZWlnaHRzLlcudGVuc29yLnNoYXBlWzNdLGU9dSh0aGlzLmtlcm5lbFNoYXBlLDQpLG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9ZVszXSxhPXIqbyppKnQscz1uZXcgZC5kZWZhdWx0KFtdLFthLG5dKSxsPW5ldyBkLmRlZmF1bHQoW10sW3IsbyxpLHRdKSxjPW5ldyBkLmRlZmF1bHQoW10sW2FdKSxmPTA7ZjxuO2YrKylnLmRlZmF1bHQuYXNzaWduKGwudGVuc29yLHRoaXMud2VpZ2h0cy5XLnRlbnNvci5waWNrKG51bGwsbnVsbCxudWxsLG51bGwsZikpLGMucmVwbGFjZVRlbnNvckRhdGEobC50ZW5zb3IuZGF0YSksZy5kZWZhdWx0LmFzc2lnbihzLnRlbnNvci5waWNrKG51bGwsZiksYy50ZW5zb3IpO3JldHVybiBzfX0se2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDEsMiwzLDApKSx0aGlzLl9jYWxjT3V0cHV0U2hhcGUodCksdGhpcy5fcGFkSW5wdXQodCksdGhpcy5fdm9sMmNvbCh0KTt2YXIgZT10aGlzLmtlcm5lbFNoYXBlWzBdLG49dGhpcy5vdXRwdXRTaGFwZVswXSxyPXRoaXMub3V0cHV0U2hhcGVbMV0sbz10aGlzLm91dHB1dFNoYXBlWzJdLGk9bipyKm8sYT1uZXcgZC5kZWZhdWx0KFtdLFtpLGVdKTtpZighdGhpcy5fdXNlV2VibGFzfHx0aGlzLl92b2xDb2xzTWF0Ll9ncHVNYXhTaXplRXhjZWVkZWR8fHRoaXMuX3dSb3dzTWF0Ll9ncHVNYXhTaXplRXhjZWVkZWQpe2lmKHRoaXMuYmlhcylmb3IodmFyIHM9MDtzPGU7cysrKWcuZGVmYXVsdC5hc3NpZ25zKGEudGVuc29yLnBpY2sobnVsbCxzKSx0aGlzLndlaWdodHMuYi50ZW5zb3IuZ2V0KHMpKTsoMCxiLmRlZmF1bHQpKGEudGVuc29yLHRoaXMuX3ZvbENvbHNNYXQudGVuc29yLHRoaXMuX3dSb3dzTWF0LnRlbnNvciwxLDEpfWVsc2V7dmFyIHU9dGhpcy5iaWFzP3RoaXMud2VpZ2h0cy5iLndlYmxhc1RlbnNvcjp0aGlzLl96ZXJvc1ZlYy53ZWJsYXNUZW5zb3I7YS50ZW5zb3IuZGF0YT13ZWJsYXMucGlwZWxpbmUuc2dlbW0oMSx0aGlzLl92b2xDb2xzTWF0LndlYmxhc1RlbnNvcix0aGlzLl93Um93c01hdC53ZWJsYXNUZW5zb3IsMSx1KS50cmFuc2ZlcigpfWZvcih2YXIgbD1uZXcgZC5kZWZhdWx0KFtdLHRoaXMub3V0cHV0U2hhcGUpLGM9bmV3IGQuZGVmYXVsdChbXSxbbipyKm9dKSxmPW5ldyBkLmRlZmF1bHQoW10sW24scixvXSkscD0wO3A8ZTtwKyspZy5kZWZhdWx0LmFzc2lnbihjLnRlbnNvcixhLnRlbnNvci5waWNrKG51bGwscCkpLGYucmVwbGFjZVRlbnNvckRhdGEoYy50ZW5zb3IuZGF0YSksZy5kZWZhdWx0LmFzc2lnbihsLnRlbnNvci5waWNrKG51bGwsbnVsbCxudWxsLHApLGYudGVuc29yKTtyZXR1cm4gdC50ZW5zb3I9bC50ZW5zb3IsdGhpcy5hY3RpdmF0aW9uRnVuYyh0KSxcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDMsMCwxLDIpKSx0fX1dKSxlfShtLmRlZmF1bHQpO2UuZGVmYXVsdD13fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1uKDIpLGY9cihjKSxwPW4oMyksaD1yKHApLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIkNyb3BwaW5nMURcIjt2YXIgcj10LmNyb3BwaW5nLGE9dm9pZCAwPT09cj9bMCwwXTpyLHM9dC5kaW1PcmRlcmluZyx1PXZvaWQgMD09PXM/XCJ0ZlwiOnM7cmV0dXJuIG4uY3JvcHBpbmc9YSxuLmRpbU9yZGVyaW5nPXUsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnRlbnNvci5zaGFwZSxuPVtlWzBdLXRoaXMuY3JvcHBpbmdbMF0tdGhpcy5jcm9wcGluZ1sxXSxlWzFdXSxyPW5ldyBmLmRlZmF1bHQoW10sbik7cmV0dXJuIGguZGVmYXVsdC5hc3NpZ24oci50ZW5zb3IsdC50ZW5zb3IuaGkoZVswXS10aGlzLmNyb3BwaW5nWzFdLGVbMl0pLmxvKHRoaXMuY3JvcHBpbmdbMF0sMCkpLHQudGVuc29yPXIudGVuc29yLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PWR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMiksZj1yKGMpLHA9bigzKSxoPXIocCksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiQ3JvcHBpbmcyRFwiO3ZhciByPXQuY3JvcHBpbmcsYT12b2lkIDA9PT1yP1tbMCwwXSxbMCwwXV06cixzPXQuZGltT3JkZXJpbmcsdT12b2lkIDA9PT1zP1widGZcIjpzO3JldHVybiBuLmNyb3BwaW5nPWEsbi5kaW1PcmRlcmluZz11LG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgxLDIsMCkpO3ZhciBlPXQudGVuc29yLnNoYXBlLG49W2VbMF0tdGhpcy5jcm9wcGluZ1swXVswXS10aGlzLmNyb3BwaW5nWzBdWzFdLGVbMV0tdGhpcy5jcm9wcGluZ1sxXVswXS10aGlzLmNyb3BwaW5nWzFdWzFdLGVbMl1dLHI9bmV3IGYuZGVmYXVsdChbXSxuKTtyZXR1cm4gaC5kZWZhdWx0LmFzc2lnbihyLnRlbnNvcix0LnRlbnNvci5oaShlWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sZVsxXS10aGlzLmNyb3BwaW5nWzFdWzFdLGVbMl0pLmxvKHRoaXMuY3JvcHBpbmdbMF1bMF0sdGhpcy5jcm9wcGluZ1sxXVswXSwwKSksdC50ZW5zb3I9ci50ZW5zb3IsXCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgyLDAsMSkpLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PWR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMiksZj1yKGMpLHA9bigzKSxoPXIocCksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiQ3JvcHBpbmczRFwiO3ZhciByPXQuY3JvcHBpbmcsYT12b2lkIDA9PT1yP1tbMCwwXSxbMCwwXSxbMCwwXV06cixzPXQuZGltT3JkZXJpbmcsdT12b2lkIDA9PT1zP1widGZcIjpzO3JldHVybiBuLmNyb3BwaW5nPWEsbi5kaW1PcmRlcmluZz11LG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgxLDIsMywwKSk7dmFyIGU9dC50ZW5zb3Iuc2hhcGUsbj1bZVswXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sZVsxXS10aGlzLmNyb3BwaW5nWzFdWzBdLXRoaXMuY3JvcHBpbmdbMV1bMV0sZVsyXS10aGlzLmNyb3BwaW5nWzJdWzBdLXRoaXMuY3JvcHBpbmdbMl1bMV0sZVszXV0scj1uZXcgZi5kZWZhdWx0KFtdLG4pO3JldHVybiBoLmRlZmF1bHQuYXNzaWduKHIudGVuc29yLHQudGVuc29yLmhpKGVbMF0tdGhpcy5jcm9wcGluZ1swXVsxXSxlWzFdLXRoaXMuY3JvcHBpbmdbMV1bMV0sZVsyXS10aGlzLmNyb3BwaW5nWzJdWzFdLGVbM10pLmxvKHRoaXMuY3JvcHBpbmdbMF1bMF0sdGhpcy5jcm9wcGluZ1sxXVswXSx0aGlzLmNyb3BwaW5nWzJdWzBdLDApKSx0LnRlbnNvcj1yLnRlbnNvcixcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDMsMCwxLDIpKSx0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1kfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGU9e307aWYobnVsbCE9dClmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGUuZGVmYXVsdD10LGV9ZnVuY3Rpb24gaSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gYSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIHModCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2YXIgbj1bXSxyPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYSxzPXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oYT1zLm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7cj0hMCk7fWNhdGNoKHQpe289ITAsaT10fWZpbmFsbHl7dHJ5eyFyJiZzLnJldHVybiYmcy5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgaX19cmV0dXJuIG59cmV0dXJuIGZ1bmN0aW9uKGUsbil7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZTtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiB0KGUsbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9fSgpLGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxjPWZ1bmN0aW9uIHQoZSxuLHIpe251bGw9PT1lJiYoZT1GdW5jdGlvbi5wcm90b3R5cGUpO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtpZih2b2lkIDA9PT1vKXt2YXIgaT1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7cmV0dXJuIG51bGw9PT1pP3ZvaWQgMDp0KGksbixyKX1pZihcInZhbHVlXCJpbiBvKXJldHVybiBvLnZhbHVlO3ZhciBhPW8uZ2V0O2lmKHZvaWQgMCE9PWEpcmV0dXJuIGEuY2FsbChyKX0sZj1uKDE5KSxwPW8oZiksaD1uKDIpLGQ9cihoKSx2PW4oMSksbT1yKHYpLF89bigzKSxnPXIoXykseT1uKDY2KSxiPXIoeSksdz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O2kodGhpcyxlKTt2YXIgbj1hKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiRGVjb252b2x1dGlvbjJEXCI7dmFyIHI9dC5uYkZpbHRlcixvPXZvaWQgMD09PXI/MTpyLHM9dC5uYlJvdyx1PXZvaWQgMD09PXM/MTpzLGw9dC5uYkNvbCxjPXZvaWQgMD09PWw/MTpsLGY9dC5vdXRwdXRTaGFwZSxoPXZvaWQgMD09PWY/W106ZixkPXQuYWN0aXZhdGlvbix2PXZvaWQgMD09PWQ/XCJsaW5lYXJcIjpkLG09dC5ib3JkZXJNb2RlLF89dm9pZCAwPT09bT9cInZhbGlkXCI6bSxnPXQuc3Vic2FtcGxlLHk9dm9pZCAwPT09Zz9bMSwxXTpnLGI9dC5kaW1PcmRlcmluZyx3PXZvaWQgMD09PWI/XCJ0ZlwiOmIseD10LmJpYXMsRT12b2lkIDA9PT14fHx4O2lmKG4ua2VybmVsU2hhcGU9W28sdSxjXSxudWxsPT1oWzBdP24ub3V0cHV0U2hhcGU9aC5zbGljZSgxKTpuLm91dHB1dFNoYXBlPWgsbi5hY3RpdmF0aW9uPXYsbi5hY3RpdmF0aW9uRnVuYz1wW3ZdLFwidmFsaWRcIiE9PV8mJlwic2FtZVwiIT09Xyl0aHJvdyBuZXcgRXJyb3Iobi5uYW1lK1wiIFtEZWNvbnZvbHV0aW9uMkQgbGF5ZXJdIEludmFsaWQgYm9yZGVyTW9kZS5cIik7aWYobi5ib3JkZXJNb2RlPV8sbi5zdWJzYW1wbGU9eSxcInRmXCIhPT13JiZcInRoXCIhPT13KXRocm93IG5ldyBFcnJvcihuLm5hbWUrXCIgW0RlY29udm9sdXRpb24yRCBsYXllcl0gT25seSB0ZiBhbmQgdGggZGltIG9yZGVyaW5nIGFyZSBhbGxvd2VkLlwiKTtyZXR1cm4gbi5kaW1PcmRlcmluZz13LG4uYmlhcz1FLG4ucGFyYW1zPW4uYmlhcz9bXCJXXCIsXCJiXCJdOltcIldcIl0sbi5ncHUmJndlYmxhcyYmKG4uX3VzZVdlYmxhcz0hMCxuLl9waXBlbGluZUVuYWJsZWQ9ITEpLG59cmV0dXJuIHMoZSx0KSxsKGUsW3trZXk6XCJzZXRXZWlnaHRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHRbMF0udGVuc29yPXRbMF0udGVuc29yLnRyYW5zcG9zZSgyLDMsMSwwKSksYyhlLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJzZXRXZWlnaHRzXCIsdGhpcykuY2FsbCh0aGlzLHQpLHRoaXMuX3dSb3dzTWF0PXRoaXMuX3cycm93KCksdGhpcy5fdXNlV2VibGFzJiYodGhpcy5fd1Jvd3NNYXQuY3JlYXRlV2VibGFzVGVuc29yKCksdGhpcy5fd1Jvd3NNYXQuX2dwdU1heFNpemVFeGNlZWRlZHx8KHRoaXMuX3dSb3dzTWF0LndlYmxhc1RlbnNvcj10aGlzLl93Um93c01hdC53ZWJsYXNUZW5zb3IudHJhbnNwb3NlKCkpKX19LHtrZXk6XCJfY2FsY091dHB1dFBhZGRpbmdcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnRlbnNvci5zaGFwZVswXSxuPXQudGVuc29yLnNoYXBlWzFdLHI9dGhpcy5rZXJuZWxTaGFwZVsxXSxvPXRoaXMua2VybmVsU2hhcGVbMl0saT10aGlzLm91dHB1dFNoYXBlWzBdLGE9dGhpcy5vdXRwdXRTaGFwZVsxXSxzPVwic2FtZVwiPT09dGhpcy5ib3JkZXJNb2RlP01hdGgubWF4KDAsTWF0aC5mbG9vcigoZS0xKSp0aGlzLnN1YnNhbXBsZVswXStyLWkpKTowLHU9XCJzYW1lXCI9PT10aGlzLmJvcmRlck1vZGU/TWF0aC5tYXgoMCxNYXRoLmZsb29yKChuLTEpKnRoaXMuc3Vic2FtcGxlWzFdK28tYSkpOjAsbD1NYXRoLmZsb29yKHMvMiksYz1zLWwsZj1NYXRoLmZsb29yKHUvMikscD11LWY7dGhpcy5vdXRwdXRQYWRkaW5nPVtsLGMsZixwXX19LHtrZXk6XCJfaW0yY29sXCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXUodC50ZW5zb3Iuc2hhcGUsMyksbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1uZXcgZC5kZWZhdWx0KFtdLFtuKnIsb10pLGE9bmV3IGQuZGVmYXVsdChbXSxbbipyXSkscz1uZXcgZC5kZWZhdWx0KFtdLFtuLHJdKSxsPTA7bDxvO2wrKylnLmRlZmF1bHQuYXNzaWduKHMudGVuc29yLHQudGVuc29yLnBpY2sobnVsbCxudWxsLGwpKSxhLnJlcGxhY2VUZW5zb3JEYXRhKHMudGVuc29yLmRhdGEpLGcuZGVmYXVsdC5hc3NpZ24oaS50ZW5zb3IucGljayhudWxsLGwpLGEudGVuc29yKTtyZXR1cm4gaX19LHtrZXk6XCJfdzJyb3dcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD11KHRoaXMud2VpZ2h0cy5XLnRlbnNvci5zaGFwZSw0KSxlPXRbMF0sbj10WzFdLHI9dFsyXSxvPXRbM10saT1uZXcgZC5kZWZhdWx0KFtdLFtyLGUqbipvXSksYT1uZXcgZC5kZWZhdWx0KFtdLFtlKm4qb10pLHM9bmV3IGQuZGVmYXVsdChbXSxbZSxuLG9dKSxsPTA7bDxyO2wrKylnLmRlZmF1bHQuYXNzaWduKHMudGVuc29yLHRoaXMud2VpZ2h0cy5XLnRlbnNvci5waWNrKG51bGwsbnVsbCxsLG51bGwpKSxhLnJlcGxhY2VUZW5zb3JEYXRhKHMudGVuc29yLmRhdGEpLGcuZGVmYXVsdC5hc3NpZ24oaS50ZW5zb3IucGljayhsLG51bGwpLGEudGVuc29yKTtyZXR1cm4gaX19LHtrZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgxLDIsMCkpO1xudmFyIGU9dGhpcy5faW0yY29sKHQpO3RoaXMuX3VzZVdlYmxhcyYmZS5jcmVhdGVXZWJsYXNUZW5zb3IoKTt2YXIgbj10LnRlbnNvci5zaGFwZVswXSxyPXQudGVuc29yLnNoYXBlWzFdLG89dSh0aGlzLmtlcm5lbFNoYXBlLDMpLGk9b1swXSxhPW9bMV0scz1vWzJdLGw9bmV3IGQuZGVmYXVsdChbXSxbbipyLGEqcyppXSk7aWYoIXRoaXMuX3VzZVdlYmxhc3x8ZS5fZ3B1TWF4U2l6ZUV4Y2VlZGVkfHx0aGlzLl93Um93c01hdC5fZ3B1TWF4U2l6ZUV4Y2VlZGVkKSgwLGIuZGVmYXVsdCkobC50ZW5zb3IsZS50ZW5zb3IsdGhpcy5fd1Jvd3NNYXQudGVuc29yLDEsMSk7ZWxzZXt2YXIgYz1uZXcgZC5kZWZhdWx0KFtdLFt0aGlzLndlaWdodHMuVy50ZW5zb3Iuc2hhcGVbM11dKTtjLmNyZWF0ZVdlYmxhc1RlbnNvcigpLGwudGVuc29yLmRhdGE9d2VibGFzLnBpcGVsaW5lLnNnZW1tKDEsZS53ZWJsYXNUZW5zb3IsdGhpcy5fd1Jvd3NNYXQud2VibGFzVGVuc29yLDAsYykudHJhbnNmZXIoKSxlLndlYmxhc1RlbnNvci5kZWxldGUoKSxkZWxldGUgZS53ZWJsYXNUZW5zb3J9dGhpcy5fY2FsY091dHB1dFBhZGRpbmcodCk7dmFyIGY9dSh0aGlzLm91dHB1dFBhZGRpbmcsNCkscD1mWzBdLGg9ZlsxXSx2PWZbMl0sbT1mWzNdLF89bmV3IGQuZGVmYXVsdChbXSx0aGlzLm91dHB1dFNoYXBlKSx5PW5ldyBkLmRlZmF1bHQoW10sW3RoaXMub3V0cHV0U2hhcGVbMF0rcCtoLHRoaXMub3V0cHV0U2hhcGVbMV0rdittLHRoaXMub3V0cHV0U2hhcGVbMl1dKTtpZih0aGlzLmJpYXMpZm9yKHZhciB3PTA7dzxpO3crKylnLmRlZmF1bHQuYXNzaWducyh5LnRlbnNvci5waWNrKG51bGwsbnVsbCx3KSx0aGlzLndlaWdodHMuYi50ZW5zb3IuZ2V0KHcpKTtmb3IodmFyIHg9W2EscyxpXSxFPW5ldyBkLmRlZmF1bHQoW10seCksVD1uZXcgZC5kZWZhdWx0KFtdLFthKnMqaV0pLE89MCxTPTA7UzxuO1MrKylmb3IodmFyIFA9MDtQPHI7UCsrKXtnLmRlZmF1bHQuYXNzaWduKFQudGVuc29yLGwudGVuc29yLnBpY2soTyxudWxsKSksRS5yZXBsYWNlVGVuc29yRGF0YShULnRlbnNvci5kYXRhKTt2YXIgTT1TKnRoaXMuc3Vic2FtcGxlWzBdLGo9UCp0aGlzLnN1YnNhbXBsZVsxXTtnLmRlZmF1bHQuYWRkZXEoeS50ZW5zb3IuaGkoTSthLGorcyx0aGlzLm91dHB1dFNoYXBlWzJdKS5sbyhNLGosMCksRS50ZW5zb3IpLE8rPTF9cmV0dXJuIGcuZGVmYXVsdC5hc3NpZ24oXy50ZW5zb3IseS50ZW5zb3IuaGkodGhpcy5vdXRwdXRTaGFwZVswXStwLHRoaXMub3V0cHV0U2hhcGVbMV0rdix0aGlzLm91dHB1dFNoYXBlWzJdKS5sbyhwLHYsMCkpLHQudGVuc29yPV8udGVuc29yLHRoaXMuYWN0aXZhdGlvbkZ1bmModCksXCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgyLDAsMSkpLHR9fV0pLGV9KG0uZGVmYXVsdCk7ZS5kZWZhdWx0PXd9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZS5kZWZhdWx0PXQsZX1mdW5jdGlvbiBpKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBhKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gcyh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPVtdLHI9ITAsbz0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHM9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShhPXMubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhZXx8bi5sZW5ndGghPT1lKTtyPSEwKTt9Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7IXImJnMucmV0dXJuJiZzLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24oZSxuKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlO2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIHQoZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksbD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGM9bigxOSksZj1vKGMpLHA9bigyKSxoPXIocCksZD1uKDEpLHY9cihkKSxtPW4oNjgpLF89cihtKSxnPW4oMykseT1yKGcpLGI9big2Niksdz1yKGIpLHg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtyZXR1cm4gaSh0aGlzLGUpLGEodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKX1yZXR1cm4gcyhlLHQpLGwoZSxbe2tleTpcIl9pbTJjb2xcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT11KHQudGVuc29yLnNoYXBlLDMpLG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9dGhpcy5rZXJuZWxTaGFwZVsxXSxhPXRoaXMua2VybmVsU2hhcGVbMl0scz10aGlzLm91dHB1dFNoYXBlWzBdLGw9dGhpcy5vdXRwdXRTaGFwZVsxXSxjPXMqbCxmPWkqYTt0aGlzLl9pbUNvbHNNYXR8fCh0aGlzLl9pbUNvbHNNYXQ9bmV3IGguZGVmYXVsdChbXSxbYypvLGZdKSk7Zm9yKHZhciBwPW5ldyBoLmRlZmF1bHQoW10sW2ksYSwxXSksZD0wLHY9MDt2PG87disrKWZvcih2YXIgbT0wLF89bi1pO208PV87bSs9dGhpcy5zdWJzYW1wbGVbMF0pZm9yKHZhciBnPTAsYj1yLWE7Zzw9YjtnKz10aGlzLnN1YnNhbXBsZVsxXSl5LmRlZmF1bHQuYXNzaWduKHAudGVuc29yLHQudGVuc29yLmhpKG0raSxnK2EsdisxKS5sbyhtLGcsdikpLHRoaXMuX2ltQ29sc01hdC50ZW5zb3IuZGF0YS5zZXQocC50ZW5zb3IuZGF0YSxkKSxkKz1mO3JldHVybiB0aGlzLl91c2VXZWJsYXMmJnRoaXMuX2ltQ29sc01hdC5jcmVhdGVXZWJsYXNUZW5zb3IoKSx0aGlzLl9pbUNvbHNNYXR9fSx7a2V5OlwiX3cycm93XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLndlaWdodHMuVy50ZW5zb3Iuc2hhcGVbMl0sZT11KHRoaXMua2VybmVsU2hhcGUsMyksbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1yKm87dGhpcy5fd1Jvd3NNYXQ9bmV3IGguZGVmYXVsdChbXSxbaSxuKnRdKTtmb3IodmFyIGE9bmV3IGguZGVmYXVsdChbXSxbcixvXSkscz1uZXcgaC5kZWZhdWx0KFtdLFtpXSksbD0wLGM9MDtjPHQ7YysrKWZvcih2YXIgZj0wO2Y8bjtmKyspeS5kZWZhdWx0LmFzc2lnbihhLnRlbnNvcix0aGlzLndlaWdodHMuVy50ZW5zb3IucGljayhudWxsLG51bGwsYyxmKSkscy5yZXBsYWNlVGVuc29yRGF0YShhLnRlbnNvci5kYXRhKSx5LmRlZmF1bHQuYXNzaWduKHRoaXMuX3dSb3dzTWF0LnRlbnNvci5waWNrKG51bGwsbCkscy50ZW5zb3IpLGwrPTE7cmV0dXJuIHRoaXMuX3dSb3dzTWF0fX0se2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLl9jYWxjT3V0cHV0U2hhcGUodC50ZW5zb3Iuc2hhcGUpLHRoaXMuX3BhZElucHV0KHQpLHRoaXMuX2ltMmNvbCh0KTt2YXIgZT10aGlzLmtlcm5lbFNoYXBlWzBdLG49dGhpcy5vdXRwdXRTaGFwZVswXSxyPXRoaXMub3V0cHV0U2hhcGVbMV0sbz1uKnIsaT1uZXcgaC5kZWZhdWx0KFtdLFtvKnQudGVuc29yLnNoYXBlWzJdLGUqdC50ZW5zb3Iuc2hhcGVbMl1dKTshdGhpcy5fdXNlV2VibGFzfHx0aGlzLl9pbUNvbHNNYXQuX2dwdU1heFNpemVFeGNlZWRlZHx8dGhpcy5fd1Jvd3NNYXQuX2dwdU1heFNpemVFeGNlZWRlZD8oMCx3LmRlZmF1bHQpKGkudGVuc29yLHRoaXMuX2ltQ29sc01hdC50ZW5zb3IsdGhpcy5fd1Jvd3NNYXQudGVuc29yLDEsMSk6aS50ZW5zb3IuZGF0YT13ZWJsYXMucGlwZWxpbmUuc2dlbW0oMSx0aGlzLl9pbUNvbHNNYXQud2VibGFzVGVuc29yLHRoaXMuX3dSb3dzTWF0LndlYmxhc1RlbnNvciwxLHRoaXMuX3plcm9zVmVjLndlYmxhc1RlbnNvcikudHJhbnNmZXIoKTtmb3IodmFyIGE9bmV3IGguZGVmYXVsdChbXSxbbixyLHQudGVuc29yLnNoYXBlWzJdKmVdKSxzPW4qcip0LnRlbnNvci5zaGFwZVsyXSplLHU9bmV3IEZsb2F0MzJBcnJheShzKSxsPTA7bDx0LnRlbnNvci5zaGFwZVsyXTtsKyspZm9yKHZhciBjPTAsZj1sKnMrbCplLHA9KGwrMSkqcztmPHA7YysrLGYrPWUqdC50ZW5zb3Iuc2hhcGVbMl0pZm9yKHZhciBkPTA7ZDxlO2QrKyl1W2YrZC1sKnNdPWkudGVuc29yLmRhdGFbZitkXTtyZXR1cm4gYS5yZXBsYWNlVGVuc29yRGF0YSh1KSx0LnRlbnNvcj1hLnRlbnNvcix0fX1dKSxlfShfLmRlZmF1bHQpLEU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpKHRoaXMsZSk7dmFyIG49YSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIlNlcGFyYWJsZUNvbnZvbHV0aW9uMkRcIjt2YXIgcj10Lm5iRmlsdGVyLG89dm9pZCAwPT09cj8xOnIscz10Lm5iUm93LHU9dm9pZCAwPT09cz8xOnMsbD10Lm5iQ29sLGM9dm9pZCAwPT09bD8xOmwscD10LmFjdGl2YXRpb24saD12b2lkIDA9PT1wP1wibGluZWFyXCI6cCxkPXQuYm9yZGVyTW9kZSx2PXZvaWQgMD09PWQ/XCJ2YWxpZFwiOmQsbT10LnN1YnNhbXBsZSxfPXZvaWQgMD09PW0/WzEsMV06bSxnPXQuZGVwdGhNdWx0aXBsaWVyLHk9dm9pZCAwPT09Zz8xOmcsYj10LmRpbU9yZGVyaW5nLHc9dm9pZCAwPT09Yj9cInRmXCI6Yix4PXQuYmlhcyxFPXZvaWQgMD09PXh8fHg7aWYobi5hY3RpdmF0aW9uPWgsbi5hY3RpdmF0aW9uRnVuYz1mW2hdLFwidmFsaWRcIiE9PXYmJlwic2FtZVwiIT09dil0aHJvdyBuZXcgRXJyb3Iobi5uYW1lK1wiIFtTZXBhcmFibGVDb252b2x1dGlvbjJEIGxheWVyXSBJbnZhbGlkIGJvcmRlck1vZGUuXCIpO2lmKG4uYm9yZGVyTW9kZT12LG4uc3Vic2FtcGxlPV8sbi5kZXB0aE11bHRpcGxpZXI9eSxcInRmXCIhPT13JiZcInRoXCIhPT13KXRocm93IG5ldyBFcnJvcihuLm5hbWUrXCIgW1NlcGFyYWJsZUNvbnZvbHV0aW9uMkQgbGF5ZXJdIE9ubHkgdGYgYW5kIHRoIGRpbSBvcmRlcmluZyBhcmUgYWxsb3dlZC5cIik7cmV0dXJuIG4uZGltT3JkZXJpbmc9dyxuLmJpYXM9RSxuLnBhcmFtcz1uLmJpYXM/W1wiZGVwdGh3aXNlX2tlcm5lbFwiLFwicG9pbnR3aXNlX2tlcm5lbFwiLFwiYlwiXTpbXCJkZXB0aHdpc2Vfa2VybmVsXCIsXCJwb2ludHdpc2Vfa2VybmVsXCJdLG4uZGVwdGh3aXNlQ29udkF0dHJzPXtuYkZpbHRlcjpuLmRlcHRoTXVsdGlwbGllcixuYlJvdzp1LG5iQ29sOmMsYWN0aXZhdGlvbjpcImxpbmVhclwiLGJvcmRlck1vZGU6dixzdWJzYW1wbGU6XyxkaW1PcmRlcmluZzp3LGJpYXM6ITEsZ3B1OnQuZ3B1fSxuLnBvaW50d2lzZUNvbnZBdHRycz17bmJGaWx0ZXI6byxuYlJvdzoxLG5iQ29sOjEsYWN0aXZhdGlvbjpcImxpbmVhclwiLGJvcmRlck1vZGU6dixzdWJzYW1wbGU6WzEsMV0sZGltT3JkZXJpbmc6dyxiaWFzOm4uYmlhcyxncHU6dC5ncHV9LG59cmV0dXJuIHMoZSx0KSxsKGUsW3trZXk6XCJzZXRXZWlnaHRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5fZGVwdGh3aXNlQ29udj1uZXcgeCh0aGlzLmRlcHRod2lzZUNvbnZBdHRycyksdGhpcy5fZGVwdGh3aXNlQ29udi5zZXRXZWlnaHRzKHQuc2xpY2UoMCwxKSksdGhpcy5fcG9pbnR3aXNlQ29udj1uZXcgXy5kZWZhdWx0KHRoaXMucG9pbnR3aXNlQ29udkF0dHJzKSx0aGlzLl9wb2ludHdpc2VDb252LnNldFdlaWdodHModC5zbGljZSgxLDMpKX19LHtrZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fZGVwdGh3aXNlQ29udi5jYWxsKHQpLG49dGhpcy5fcG9pbnR3aXNlQ29udi5jYWxsKGUpO3JldHVybiB0LnRlbnNvcj1uLnRlbnNvcix0aGlzLmFjdGl2YXRpb25GdW5jKHQpLHR9fV0pLGV9KHYuZGVmYXVsdCk7ZS5kZWZhdWx0PUV9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMiksZj1yKGMpLHA9bigzKSxoPXIocCksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiVXBTYW1wbGluZzFEXCI7dmFyIHI9dC5sZW5ndGgsYT12b2lkIDA9PT1yPzI6cjtyZXR1cm4gbi5sZW5ndGg9YSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnRlbnNvci5zaGFwZSxuPVtlWzBdKnRoaXMubGVuZ3RoLGVbMV1dLHI9bmV3IGYuZGVmYXVsdChbXSxuKSxvPTA7bzx0aGlzLmxlbmd0aDtvKyspaC5kZWZhdWx0LmFzc2lnbihyLnRlbnNvci5sbyhvLDApLnN0ZXAodGhpcy5sZW5ndGgsMSksdC50ZW5zb3IpO3JldHVybiB0LnRlbnNvcj1yLnRlbnNvcix0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1kfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1uKDIpLGY9cihjKSxwPW4oMyksaD1yKHApLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIlVwU2FtcGxpbmcyRFwiO3ZhciByPXQuc2l6ZSxhPXZvaWQgMD09PXI/WzIsMl06cixzPXQuZGltT3JkZXJpbmcsdT12b2lkIDA9PT1zP1widGZcIjpzO3JldHVybiBuLnNpemU9YSxuLmRpbU9yZGVyaW5nPXUsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDEsMiwwKSk7Zm9yKHZhciBlPXQudGVuc29yLnNoYXBlLG49W2VbMF0qdGhpcy5zaXplWzBdLGVbMV0qdGhpcy5zaXplWzFdLGVbMl1dLHI9bmV3IGYuZGVmYXVsdChbXSxuKSxvPTA7bzx0aGlzLnNpemVbMF07bysrKWZvcih2YXIgaT0wO2k8dGhpcy5zaXplWzFdO2krKyloLmRlZmF1bHQuYXNzaWduKHIudGVuc29yLmxvKG8saSwwKS5zdGVwKHRoaXMuc2l6ZVswXSx0aGlzLnNpemVbMV0sMSksdC50ZW5zb3IpO3JldHVybiB0LnRlbnNvcj1yLnRlbnNvcixcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDIsMCwxKSksdH19XSksZX0obC5kZWZhdWx0KTtlLmRlZmF1bHQ9ZH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9bigyKSxmPXIoYykscD1uKDMpLGg9cihwKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJVcFNhbXBsaW5nM0RcIjt2YXIgcj10LnNpemUsYT12b2lkIDA9PT1yP1syLDIsMl06cixzPXQuZGltT3JkZXJpbmcsdT12b2lkIDA9PT1zP1widGZcIjpzO3JldHVybiBuLnNpemU9YSxuLmRpbU9yZGVyaW5nPXUsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDEsMiwzLDApKTtmb3IodmFyIGU9dC50ZW5zb3Iuc2hhcGUsbj1bZVswXSp0aGlzLnNpemVbMF0sZVsxXSp0aGlzLnNpemVbMV0sZVsyXSp0aGlzLnNpemVbMl0sZVszXV0scj1uZXcgZi5kZWZhdWx0KFtdLG4pLG89MDtvPHRoaXMuc2l6ZVswXTtvKyspZm9yKHZhciBpPTA7aTx0aGlzLnNpemVbMV07aSsrKWZvcih2YXIgYT0wO2E8dGhpcy5zaXplWzJdO2ErKyloLmRlZmF1bHQuYXNzaWduKHIudGVuc29yLmxvKG8saSxhLDApLnN0ZXAodGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSx0aGlzLnNpemVbMl0sMSksdC50ZW5zb3IpO3JldHVybiB0LnRlbnNvcj1yLnRlbnNvcixcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDMsMCwxLDIpKSx0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1kfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1uKDIpLGY9cihjKSxwPW4oMyksaD1yKHApLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIlplcm9QYWRkaW5nMURcIjt2YXIgcj10LnBhZGRpbmcsYT12b2lkIDA9PT1yPzE6cjtyZXR1cm4gbi5wYWRkaW5nPWEsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnRlbnNvci5zaGFwZSxuPVtlWzBdKzIqdGhpcy5wYWRkaW5nLGVbMV1dLHI9bmV3IGYuZGVmYXVsdChbXSxuKTtyZXR1cm4gaC5kZWZhdWx0LmFzc2lnbihyLnRlbnNvci5oaShlWzBdK3RoaXMucGFkZGluZyxlWzFdKS5sbyh0aGlzLnBhZGRpbmcsMCksdC50ZW5zb3IpLHQudGVuc29yPXIudGVuc29yLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PWR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMiksZj1yKGMpLHA9bigzKSxoPXIocCksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiWmVyb1BhZGRpbmcyRFwiO3ZhciByPXQucGFkZGluZyxhPXZvaWQgMD09PXI/WzEsMV06cixzPXQuZGltT3JkZXJpbmcsdT12b2lkIDA9PT1zP1widGZcIjpzO3JldHVybiBuLnBhZGRpbmc9YSxuLmRpbU9yZGVyaW5nPXUsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDEsMiwwKSk7dmFyIGU9dC50ZW5zb3Iuc2hhcGUsbj1bZVswXSsyKnRoaXMucGFkZGluZ1swXSxlWzFdKzIqdGhpcy5wYWRkaW5nWzFdLGVbMl1dLHI9bmV3IGYuZGVmYXVsdChbXSxuKTtyZXR1cm4gaC5kZWZhdWx0LmFzc2lnbihyLnRlbnNvci5oaShlWzBdK3RoaXMucGFkZGluZ1swXSxlWzFdK3RoaXMucGFkZGluZ1sxXSxlWzJdKS5sbyh0aGlzLnBhZGRpbmdbMF0sdGhpcy5wYWRkaW5nWzFdLDApLHQudGVuc29yKSx0LnRlbnNvcj1yLnRlbnNvcixcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDIsMCwxKSksdH19XSksZX0obC5kZWZhdWx0KTtlLmRlZmF1bHQ9ZH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9bigyKSxmPXIoYykscD1uKDMpLGg9cihwKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJaZXJvUGFkZGluZzNEXCI7dmFyIHI9dC5wYWRkaW5nLGE9dm9pZCAwPT09cj9bMSwxLDFdOnIscz10LmRpbU9yZGVyaW5nLHU9dm9pZCAwPT09cz9cInRmXCI6cztyZXR1cm4gbi5wYWRkaW5nPWEsbi5kaW1PcmRlcmluZz11LG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7XCJ0aFwiPT09dGhpcy5kaW1PcmRlcmluZyYmKHQudGVuc29yPXQudGVuc29yLnRyYW5zcG9zZSgxLDIsMywwKSk7dmFyIGU9dC50ZW5zb3Iuc2hhcGUsbj1bZVswXSsyKnRoaXMucGFkZGluZ1swXSxlWzFdKzIqdGhpcy5wYWRkaW5nWzFdLGVbMl0rMip0aGlzLnBhZGRpbmdbMl0sZVszXV0scj1uZXcgZi5kZWZhdWx0KFtdLG4pO3JldHVybiBoLmRlZmF1bHQuYXNzaWduKHIudGVuc29yLmhpKGVbMF0rdGhpcy5wYWRkaW5nWzBdLGVbMV0rdGhpcy5wYWRkaW5nWzFdLGVbMl0rdGhpcy5wYWRkaW5nWzJdLGVbM10pLmxvKHRoaXMucGFkZGluZ1swXSx0aGlzLnBhZGRpbmdbMV0sdGhpcy5wYWRkaW5nWzJdLDApLHQudGVuc29yKSx0LnRlbnNvcj1yLnRlbnNvcixcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDMsMCwxLDIpKSx0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1kfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Dcm9wcGluZzNEPWUuQ3JvcHBpbmcyRD1lLkNyb3BwaW5nMUQ9ZS5aZXJvUGFkZGluZzNEPWUuWmVyb1BhZGRpbmcyRD1lLlplcm9QYWRkaW5nMUQ9ZS5VcFNhbXBsaW5nM0Q9ZS5VcFNhbXBsaW5nMkQ9ZS5VcFNhbXBsaW5nMUQ9ZS5Db252b2x1dGlvbjNEPWUuRGVjb252b2x1dGlvbjJEPWUuU2VwYXJhYmxlQ29udm9sdXRpb24yRD1lLkF0cm91c0NvbnZvbHV0aW9uMkQ9ZS5Db252b2x1dGlvbjJEPWUuQ29udm9sdXRpb24xRD12b2lkIDA7dmFyIG89bigyMTApLGk9cihvKSxhPW4oNjgpLHM9cihhKSx1PW4oMjA5KSxsPXIodSksYz1uKDIxNiksZj1yKGMpLHA9bigyMTUpLGg9cihwKSxkPW4oMjExKSx2PXIoZCksbT1uKDIxNyksXz1yKG0pLGc9bigyMTgpLHk9cihnKSxiPW4oMjE5KSx3PXIoYikseD1uKDIyMCksRT1yKHgpLFQ9bigyMjEpLE89cihUKSxTPW4oMjIyKSxQPXIoUyksTT1uKDIxMiksaj1yKE0pLEE9bigyMTMpLEM9cihBKSxrPW4oMjE0KSxSPXIoayk7ZS5Db252b2x1dGlvbjFEPWkuZGVmYXVsdCxlLkNvbnZvbHV0aW9uMkQ9cy5kZWZhdWx0LGUuQXRyb3VzQ29udm9sdXRpb24yRD1sLmRlZmF1bHQsZS5TZXBhcmFibGVDb252b2x1dGlvbjJEPWYuZGVmYXVsdCxlLkRlY29udm9sdXRpb24yRD1oLmRlZmF1bHQsZS5Db252b2x1dGlvbjNEPXYuZGVmYXVsdCxlLlVwU2FtcGxpbmcxRD1fLmRlZmF1bHQsZS5VcFNhbXBsaW5nMkQ9eS5kZWZhdWx0LGUuVXBTYW1wbGluZzNEPXcuZGVmYXVsdCxlLlplcm9QYWRkaW5nMUQ9RS5kZWZhdWx0LGUuWmVyb1BhZGRpbmcyRD1PLmRlZmF1bHQsZS5aZXJvUGFkZGluZzNEPVAuZGVmYXVsdCxlLkNyb3BwaW5nMUQ9ai5kZWZhdWx0LGUuQ3JvcHBpbmcyRD1DLmRlZmF1bHQsZS5Dcm9wcGluZzNEPVIuZGVmYXVsdH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlLmRlZmF1bHQ9dCxlfWZ1bmN0aW9uIGkodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGEodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBzKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxsPW4oMTkpLGM9byhsKSxmPW4oMSkscD1yKGYpLGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpKHRoaXMsZSk7dmFyIG49YSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIkFjdGl2YXRpb25cIjt2YXIgcj10LmFjdGl2YXRpb24sbz12b2lkIDA9PT1yP1wibGluZWFyXCI6cjtyZXR1cm4gbi5hY3RpdmF0aW9uPW8sbi5hY3RpdmF0aW9uRnVuYz1jW29dLG59cmV0dXJuIHMoZSx0KSx1KGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYWN0aXZhdGlvbkZ1bmModCksdH19XSksZX0ocC5kZWZhdWx0KTtlLmRlZmF1bHQ9aH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlLmRlZmF1bHQ9dCxlfWZ1bmN0aW9uIGkodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGEodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBzKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxsPWZ1bmN0aW9uIHQoZSxuLHIpe251bGw9PT1lJiYoZT1GdW5jdGlvbi5wcm90b3R5cGUpO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtpZih2b2lkIDA9PT1vKXt2YXIgaT1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7cmV0dXJuIG51bGw9PT1pP3ZvaWQgMDp0KGksbixyKX1pZihcInZhbHVlXCJpbiBvKXJldHVybiBvLnZhbHVlO3ZhciBhPW8uZ2V0O2lmKHZvaWQgMCE9PWEpcmV0dXJuIGEuY2FsbChyKX0sYz1uKDE5KSxmPW8oYykscD1uKDIpLGg9cihwKSxkPW4oMSksdj1yKGQpLG09big1NiksXz1uKDMpLGc9cihfKSx5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aSh0aGlzLGUpO3ZhciBuPWEodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJEZW5zZVwiO3ZhciByPXQub3V0cHV0RGltLG89dm9pZCAwPT09cj8xOnIscz10LmFjdGl2YXRpb24sdT12b2lkIDA9PT1zP1wibGluZWFyXCI6cyxsPXQuaW5wdXREaW0sYz12b2lkIDA9PT1sP251bGw6bCxwPXQuYmlhcyxoPXZvaWQgMD09PXB8fHA7cmV0dXJuIG4uYWN0aXZhdGlvbj11LG4uYWN0aXZhdGlvbkZ1bmM9Zlt1XSxuLm91dHB1dERpbT1vLG4uaW5wdXREaW09YyxuLmJpYXM9aCxuLnBhcmFtcz1uLmJpYXM/W1wiV1wiLFwiYlwiXTpbXCJXXCJdLG4uaW5wdXREaW0mJihuLmlucHV0U2hhcGU9W24uaW5wdXREaW1dKSxuLmdwdSYmd2VibGFzJiYobi5fdXNlV2VibGFzPSEwLG4uX3BpcGVsaW5lRW5hYmxlZD0hMSksbn1yZXR1cm4gcyhlLHQpLHUoZSxbe2tleTpcInNldFdlaWdodHNcIix2YWx1ZTpmdW5jdGlvbih0KXtsKGUucHJvdG90eXBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcInNldFdlaWdodHNcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5fdXNlV2VibGFzJiYodGhpcy53ZWlnaHRzLlcuY3JlYXRlV2VibGFzVGVuc29yKCksdGhpcy53ZWlnaHRzLlcuX2dwdU1heFNpemVFeGNlZWRlZHx8KHRoaXMud2VpZ2h0cy5XLndlYmxhc1RlbnNvcj10aGlzLndlaWdodHMuVy53ZWJsYXNUZW5zb3IudHJhbnNwb3NlKCkpLHRoaXMuYmlhcz90aGlzLndlaWdodHMuYi5jcmVhdGVXZWJsYXNUZW5zb3IoKToodGhpcy5femVyb3NWZWM9bmV3IGguZGVmYXVsdChbXSxbdGhpcy53ZWlnaHRzLlcudGVuc29yLnNoYXBlWzFdXSksdGhpcy5femVyb3NWZWMuY3JlYXRlV2VibGFzVGVuc29yKCkpKX19LHtrZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGguZGVmYXVsdChbXSxbdGhpcy5vdXRwdXREaW1dKTtpZih0aGlzLl91c2VXZWJsYXMmJnQuY3JlYXRlV2VibGFzVGVuc29yKCksIXRoaXMuX3VzZVdlYmxhc3x8dC5fZ3B1TWF4U2l6ZUV4Y2VlZGVkfHx0aGlzLndlaWdodHMuVy5fZ3B1TWF4U2l6ZUV4Y2VlZGVkKXRoaXMuYmlhcyYmZy5kZWZhdWx0LmFzc2lnbihlLnRlbnNvcix0aGlzLndlaWdodHMuYi50ZW5zb3IpLCgwLG0uZ2VtdikoMSx0aGlzLndlaWdodHMuVy50ZW5zb3IudHJhbnNwb3NlKDEsMCksdC50ZW5zb3IsMSxlLnRlbnNvcik7ZWxzZXt2YXIgbj10aGlzLmJpYXM/dGhpcy53ZWlnaHRzLmIud2VibGFzVGVuc29yOnRoaXMuX3plcm9zVmVjLndlYmxhc1RlbnNvcjtlLnRlbnNvci5kYXRhPXdlYmxhcy5waXBlbGluZS5zZ2VtbSgxLHQud2VibGFzVGVuc29yLHRoaXMud2VpZ2h0cy5XLndlYmxhc1RlbnNvciwxLG4pLnRyYW5zZmVyKCl9cmV0dXJuIHQudGVuc29yPWUudGVuc29yLHRoaXMuYWN0aXZhdGlvbkZ1bmModCksdH19XSksZX0odi5kZWZhdWx0KTtlLmRlZmF1bHQ9eX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIkRyb3BvdXRcIjt2YXIgcj10LnAsYT12b2lkIDA9PT1yPy41OnI7cmV0dXJuIG4ucD1NYXRoLm1pbihNYXRoLm1heCgwLGEpLDEpLG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PWN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDIpLGw9cih1KSxjPW4oMSksZj1yKGMpLHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO3JldHVybiBuLmxheWVyQ2xhc3M9XCJGbGF0dGVuXCIsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0LnRlbnNvci5zaGFwZS5sZW5ndGg+MSl7dmFyIGU9bmV3IGwuZGVmYXVsdChbXSxbdC50ZW5zb3Iuc2hhcGUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0sMSldKTtlLnJlcGxhY2VUZW5zb3JEYXRhKHQudGVuc29yLmRhdGEpLHQudGVuc29yPWUudGVuc29yfXJldHVybiB0fX1dKSxlfShmLmRlZmF1bHQpO2UuZGVmYXVsdD1wfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGU9e307aWYobnVsbCE9dClmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGUuZGVmYXVsdD10LGV9ZnVuY3Rpb24gaSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gYSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIHModCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGw9bigxOSksYz1vKGwpLGY9bigyKSxwPXIoZiksaD1uKDEpLGQ9cihoKSx2PW4oNTYpLG09bigzKSxfPXIobSksZz1uKDI1KSx5PXIoZyksYj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O2kodGhpcyxlKTt2YXIgbj1hKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5fY29tcHV0ZU91dHB1dD0oMCx5LmRlZmF1bHQpKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sYm9keTpmdW5jdGlvbih0LGUsbil7dD1lKm4rKDEtbikqdH19KSxuLmxheWVyQ2xhc3M9XCJIaWdod2F5XCI7dmFyIHI9dC50cmFuc2Zvcm1CaWFzLG89dm9pZCAwPT09cj8tMjpyLHM9dC5hY3RpdmF0aW9uLHU9dm9pZCAwPT09cz9cImxpbmVhclwiOnMsbD10LmJpYXMsZj12b2lkIDA9PT1sfHxsO3JldHVybiBuLnRyYW5zZm9ybUJpYXM9byxuLmFjdGl2YXRpb249dSxuLmFjdGl2YXRpb25GdW5jPWNbdV0sbi5iaWFzPWYsbi5wYXJhbXM9bi5iaWFzP1tcIldcIixcImJcIixcIldfY2FycnlcIixcImJfY2FycnlcIl06W1wiV1wiLFwiV19jYXJyeVwiXSxufXJldHVybiBzKGUsdCksdShlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBwLmRlZmF1bHQoW10sW3RoaXMud2VpZ2h0cy5XLnRlbnNvci5zaGFwZVsxXV0pO3RoaXMuYmlhcyYmXy5kZWZhdWx0LmFzc2lnbihlLnRlbnNvcix0aGlzLndlaWdodHMuYi50ZW5zb3IpLCgwLHYuZ2VtdikoMSx0aGlzLndlaWdodHMuVy50ZW5zb3IudHJhbnNwb3NlKDEsMCksdC50ZW5zb3IsMSxlLnRlbnNvciksdGhpcy5hY3RpdmF0aW9uRnVuYyhlKTt2YXIgbj1uZXcgcC5kZWZhdWx0KFtdLFt0aGlzLndlaWdodHMuV19jYXJyeS50ZW5zb3Iuc2hhcGVbMV1dKTtyZXR1cm4gdGhpcy5iaWFzJiZfLmRlZmF1bHQuYXNzaWduKG4udGVuc29yLHRoaXMud2VpZ2h0cy5iX2NhcnJ5LnRlbnNvciksKDAsdi5nZW12KSgxLHRoaXMud2VpZ2h0cy5XX2NhcnJ5LnRlbnNvci50cmFuc3Bvc2UoMSwwKSx0LnRlbnNvciwxLG4udGVuc29yKSxjLnNpZ21vaWQobiksdGhpcy5fY29tcHV0ZU91dHB1dCh0LnRlbnNvcixlLnRlbnNvcixuLnRlbnNvciksdH19XSksZX0oZC5kZWZhdWx0KTtlLmRlZmF1bHQ9Yn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMiksbD1yKHUpLGM9bigxKSxmPXIoYykscD1uKDU2KSxoPW4oMyksZD1yKGgpLHY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIk1heG91dERlbnNlXCI7dmFyIHI9dC5vdXRwdXREaW0sYT12b2lkIDA9PT1yPzE6cixzPXQuaW5wdXREaW0sdT12b2lkIDA9PT1zP251bGw6cyxsPXQuYmlhcyxjPXZvaWQgMD09PWx8fGw7cmV0dXJuIG4ub3V0cHV0RGltPWEsbi5pbnB1dERpbT11LG4uYmlhcz1jLG4ucGFyYW1zPW4uYmlhcz9bXCJXXCIsXCJiXCJdOltcIldcIl0sbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy53ZWlnaHRzLlcudGVuc29yLnNoYXBlWzBdLG49bmV3IGwuZGVmYXVsdChbXSxbdGhpcy5vdXRwdXREaW1dKSxyPTA7cjxlO3IrKyl7dmFyIG89bmV3IGwuZGVmYXVsdChbXSxbdGhpcy5vdXRwdXREaW1dKTt0aGlzLmJpYXMmJmQuZGVmYXVsdC5hc3NpZ24oby50ZW5zb3IsdGhpcy53ZWlnaHRzLmIudGVuc29yLnBpY2socixudWxsKSksKDAscC5nZW12KSgxLHRoaXMud2VpZ2h0cy5XLnRlbnNvci5waWNrKHIsbnVsbCxudWxsKS50cmFuc3Bvc2UoMSwwKSx0LnRlbnNvciwxLG8udGVuc29yKSxkLmRlZmF1bHQubWF4ZXEobi50ZW5zb3Isby50ZW5zb3IpfXJldHVybiB0LnRlbnNvcj1uLnRlbnNvcix0fX1dKSxlfShmLmRlZmF1bHQpO2UuZGVmYXVsdD12fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZihBcnJheS5pc0FycmF5KHQpKXtmb3IodmFyIGU9MCxuPUFycmF5KHQubGVuZ3RoKTtlPHQubGVuZ3RoO2UrKyluW2VdPXRbZV07cmV0dXJuIG59cmV0dXJuIEFycmF5LmZyb20odCl9ZnVuY3Rpb24gaSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gYSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIHModCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGw9bigyKSxjPXIobCksZj1uKDEpLHA9cihmKSxoPW4oNjYpLGQ9cihoKSx2PW4oMyksbT1yKHYpLF89bigxMzApLGc9cihfKSx5PW4oNjA4KSxiPXIoeSksdz1uKDEyNykseD1yKHcpLEU9bigxODgpLFQ9cihFKSxPPW4oMTI5KSxTPXIoTyksUD1uKDU3KSxNPXIoUCksaj1uKDE5OSksQT1yKGopLEM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpKHRoaXMsZSk7dmFyIG49YSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIk1lcmdlXCI7dmFyIHI9dC5tb2RlLG89dm9pZCAwPT09cj9cInN1bVwiOnIscz10LmNvbmNhdEF4aXMsdT12b2lkIDA9PT1zPy0xOnMsbD10LmRvdEF4ZXMsYz12b2lkIDA9PT1sPy0xOmwsZj10Lm91dHB1dFNoYXBlLHA9dm9pZCAwPT09Zj9udWxsOmYsaD10Lm91dHB1dE1hc2ssZD12b2lkIDA9PT1oP251bGw6aCx2PVtcInN1bVwiLFwibXVsXCIsXCJjb25jYXRcIixcImF2ZVwiLFwiY29zXCIsXCJkb3RcIixcIm1heFwiXTtpZighKHYuaW5kZXhPZihvKT4tMSkpdGhyb3cgbmV3IEVycm9yKG4ubmFtZStcIiBbTWVyZ2UgbGF5ZXJdIFwiK28rXCIgbm90IGF2YWlsYWJsZS5cIik7aWYobi5tb2RlPW8sbi5jb25jYXRBeGlzPXU8PTA/dTp1LTEsQXJyYXkuaXNBcnJheShjKT9uLmRvdEF4ZXM9W2NbMF08PTA/Y1swXTpjWzBdLTEsY1sxXTw9MD9jWzFdOmNbMV0tMV06bi5kb3RBeGVzPVtjPD0wP2M6Yy0xLGM8PTA/YzpjLTFdLG4ub3V0cHV0U2hhcGU9cCxuLm91dHB1dE1hc2s9ZCxuLmdwdSYmd2VibGFzJiYobi5fdXNlV2VibGFzPSEwLG4ucGlwZWxpbmUpKXt2YXIgbT0oMCxNLmRlZmF1bHQpKG4ubGF5ZXJDbGFzcyx0KTttPyhuLl9waXBlbGluZUVuYWJsZWQ9ITAsbi53ZWJnbE1lcmdlPW5ldyBBLmRlZmF1bHQobi5tb2RlKSk6bi5fcGlwZWxpbmVFbmFibGVkPSExfXJldHVybiBufXJldHVybiBzKGUsdCksdShlLFt7a2V5OlwiX3ZhbGlkYXRlSW5wdXRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRlbnNvci5zaGFwZS5zbGljZSgpfSk7aWYoW1wic3VtXCIsXCJtdWxcIixcImF2ZVwiLFwiY29zXCIsXCJtYXhcIl0uaW5kZXhPZih0aGlzLm1vZGUpPi0xJiYhbi5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4oMCx4LmRlZmF1bHQpKHQsblswXSl9KSl0aHJvdyBuZXcgRXJyb3IodGhpcy5uYW1lK1wiIFtNZXJnZSBsYXllcl0gQWxsIGlucHV0IHNoYXBlcyBtdXN0IGJlIHRoZSBzYW1lIGZvciBtb2RlIFwiK3RoaXMubW9kZStcIi5cIik7aWYoW1wiY29zXCIsXCJkb3RcIl0uaW5kZXhPZih0aGlzLm1vZGUpPi0xKXtpZigyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKHRoaXMubmFtZStcIiBbTWVyZ2UgbGF5ZXJdIEV4YWN0bHkgMiBpbnB1dHMgcmVxdWlyZWQgZm9yIG1vZGUgXCIrdGhpcy5tb2RlK1wiLlwiKTtpZih0aGlzLmRvdEF4ZXNbMF08MCYmKHRoaXMuZG90QXhlc1swXT1uWzBdLmxlbmd0aCt0aGlzLmRvdEF4ZXNbMF0pLHRoaXMuZG90QXhlc1sxXTwwJiYodGhpcy5kb3RBeGVzWzFdPW5bMV0ubGVuZ3RoK3RoaXMuZG90QXhlc1sxXSksblswXVt0aGlzLmRvdEF4ZXNbMF1dIT09blsxXVt0aGlzLmRvdEF4ZXNbMV1dKXRocm93IG5ldyBFcnJvcih0aGlzLm5hbWUrXCIgW01lcmdlIGxheWVyXSBEaW1lbnNpb25zIGluY29tcGF0aWJpbGl0eSB1c2luZyBkb3QgbW9kZS5cIik7XG59ZWxzZVwiY29uY2F0XCI9PT10aGlzLm1vZGUmJiFmdW5jdGlvbigpe3ZhciB0PW4uc2xpY2UoKSxyPWUuY29uY2F0QXhpczwwP3RbMF0ubGVuZ3RoK2UuY29uY2F0QXhpczplLmNvbmNhdEF4aXM7aWYoMD09PWUuY29uY2F0QXhpcyYmKHI9MCksKDAsVC5kZWZhdWx0KSh0Lmxlbmd0aCkuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdLnNwbGljZShyLDEpfSksIXQuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuKDAseC5kZWZhdWx0KShlLHRbMF0pfSkpdGhyb3cgbmV3IEVycm9yKGUubmFtZStcIiBbTWVyZ2UgbGF5ZXJdIEluIGNvbmNhdCBtb2RlLCBhbGwgc2hhcGVzIG11c3QgYmUgdGhlIHNhbWUgZXhjZXB0IGFsb25nIHRoZSBjb25jYXQgYXhpcy5cIil9KCk7cmV0dXJuITB9fSx7a2V5OlwiX2NhbGxQaXBlbGluZU1vZGVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdC5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdC5fZnJvbVBpcGVsaW5lfSkpcmV0dXJuIHRoaXMuX2NhbGxSZWd1bGFyTW9kZSh0KTt2YXIgZT1uZXcgYy5kZWZhdWx0KFtdLHRbMF0ud2VibGFzVGVuc29yLnNoYXBlKTtyZXR1cm4gZS53ZWJsYXNUZW5zb3I9dGhpcy53ZWJnbE1lcmdlLmNhbGwodC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQud2VibGFzVGVuc29yfSkpLGUuX2Zyb21QaXBlbGluZT0hMCxlLl9hY3R1YWxTaGFwZT10WzBdLl9hY3R1YWxTaGFwZSxcImNvbmNhdFwiPT09dGhpcy5tb2RlJiYoZS5fYWN0dWFsU2hhcGU9W10uY29uY2F0KG8odFswXS5fYWN0dWFsU2hhcGUuc2xpY2UoMCwtMSkpLFsoMCxTLmRlZmF1bHQpKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9hY3R1YWxTaGFwZS5zbGljZSgtMSlbMF19KSldKSksZX19LHtrZXk6XCJfY2FsbFJlZ3VsYXJNb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMuX3ZhbGlkYXRlSW5wdXRzKHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcih0aGlzLm5hbWUrXCIgW01lcmdlIGxheWVyXSBJbnZhbGlkIGlucHV0cyB0byBjYWxsIG1ldGhvZC5cIik7dmFyIHI9dm9pZCAwLG89dm9pZCAwO2lmKFtcInN1bVwiLFwibXVsXCIsXCJhdmVcIixcIm1heFwiXS5pbmRleE9mKHRoaXMubW9kZSk+LTEpbz10WzBdLnRlbnNvci5zaGFwZS5zbGljZSgpLHI9bmV3IGMuZGVmYXVsdChbXSxvKTtlbHNlIGlmKFwiY29uY2F0XCI9PT10aGlzLm1vZGUpIWZ1bmN0aW9uKCl7bz10WzBdLnRlbnNvci5zaGFwZS5zbGljZSgpO3ZhciBuPWUuY29uY2F0QXhpczwwP28ubGVuZ3RoK2UuY29uY2F0QXhpczplLmNvbmNhdEF4aXM7MD09PWUuY29uY2F0QXhpcyYmKG49MCksdC5zbGljZSgxLHQubGVuZ3RoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPXQudGVuc29yLnNoYXBlLnNsaWNlKClbbl07b1tuXSs9ZX0pLHI9bmV3IGMuZGVmYXVsdChbXSxvKX0oKTtlbHNlIGlmKFtcImNvc1wiLFwiZG90XCJdLmluZGV4T2YodGhpcy5tb2RlKT4tMSl7dmFyIGk9dFswXS50ZW5zb3Iuc2hhcGUuc2xpY2UoKSxhPXRbMV0udGVuc29yLnNoYXBlLnNsaWNlKCk7aS5zcGxpY2UodGhpcy5kb3RBeGVzWzBdLDEpLGEuc3BsaWNlKHRoaXMuZG90QXhlc1sxXSwxKSxvPWkuY29uY2F0KGEpLDE9PT1vLmxlbmd0aCYmby5wdXNoKDEpLHI9bmV3IGMuZGVmYXVsdChbXSxvKX1pZihcInN1bVwiPT09dGhpcy5tb2RlKWZvcih2YXIgcz0wO3M8dC5sZW5ndGg7cysrKW0uZGVmYXVsdC5hZGRlcShyLnRlbnNvcix0W3NdLnRlbnNvcik7ZWxzZSBpZihcIm11bFwiPT09dGhpcy5tb2RlKXttLmRlZmF1bHQuYXNzaWducyhyLnRlbnNvciwxKTtmb3IodmFyIHU9MDt1PHQubGVuZ3RoO3UrKyltLmRlZmF1bHQubXVsZXEoci50ZW5zb3IsdFt1XS50ZW5zb3IpfWVsc2UgaWYoXCJhdmVcIj09PXRoaXMubW9kZSl7Zm9yKHZhciBsPTA7bDx0Lmxlbmd0aDtsKyspbS5kZWZhdWx0LmFkZGVxKHIudGVuc29yLHRbbF0udGVuc29yKTttLmRlZmF1bHQuZGl2c2VxKHIudGVuc29yLHQubGVuZ3RoKX1lbHNlIGlmKFwibWF4XCI9PT10aGlzLm1vZGUpe20uZGVmYXVsdC5hc3NpZ24oci50ZW5zb3IsdFswXS50ZW5zb3IpO2Zvcih2YXIgZj0xO2Y8dC5sZW5ndGg7ZisrKW0uZGVmYXVsdC5tYXhlcShyLnRlbnNvcix0W2ZdLnRlbnNvcil9ZWxzZSBpZihcImNvbmNhdFwiPT09dGhpcy5tb2RlKXt2YXIgcD10aGlzLmNvbmNhdEF4aXM8MD90WzBdLnRlbnNvci5zaGFwZS5sZW5ndGgrdGhpcy5jb25jYXRBeGlzOnRoaXMuY29uY2F0QXhpczswPT09dGhpcy5jb25jYXRBeGlzJiYocD0wKSwwPT09cD8oMCxiLmRlZmF1bHQpKHIudGVuc29yLHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRlbnNvcn0pKTohZnVuY3Rpb24oKXtmb3IodmFyIGUsbj1bcF0sbz0wO288dFswXS50ZW5zb3Iuc2hhcGUubGVuZ3RoO28rKylvIT09cCYmbi5wdXNoKG8pOygwLGIuZGVmYXVsdCkoKGU9ci50ZW5zb3IpLnRyYW5zcG9zZS5hcHBseShlLG4pLHQubWFwKGZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybihlPXQudGVuc29yKS50cmFuc3Bvc2UuYXBwbHkoZSxuKX0pKX0oKX1lbHNlIGlmKFwiZG90XCI9PT10aGlzLm1vZGUpe2lmKDIhPT10WzBdLnRlbnNvci5zaGFwZS5sZW5ndGh8fDIhPT10WzFdLnRlbnNvci5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKHRoaXMubmFtZStcIiBbTWVyZ2UgbGF5ZXJdIGRvdCBtb2RlIGZvciAzKyBkaW0gdGVuc29ycyBub3QgeWV0IGltcGxlbWVudGVkLlwiKTswPT09dGhpcy5kb3RBeGVzWzBdJiYwPT09dGhpcy5kb3RBeGVzWzFdPygwLGQuZGVmYXVsdCkoci50ZW5zb3IsdFswXS50ZW5zb3IudHJhbnNwb3NlKDEsMCksdFsxXS50ZW5zb3IpOjE9PT10aGlzLmRvdEF4ZXNbMF0mJjE9PT10aGlzLmRvdEF4ZXNbMV0mJigwLGQuZGVmYXVsdCkoci50ZW5zb3IsdFswXS50ZW5zb3IsdFsxXS50ZW5zb3IudHJhbnNwb3NlKDEsMCkpfWVsc2UgaWYoXCJjb3NcIj09PXRoaXMubW9kZSl7aWYoMiE9PXRbMF0udGVuc29yLnNoYXBlLmxlbmd0aHx8MiE9PXRbMV0udGVuc29yLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IodGhpcy5uYW1lK1wiIFtNZXJnZSBsYXllcl0gY29zIG1vZGUgZm9yIDMrIGRpbSB0ZW5zb3JzIG5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO3ZhciBoPW5ldyBjLmRlZmF1bHQoW10sci50ZW5zb3Iuc2hhcGUpLHY9bmV3IGMuZGVmYXVsdChbXSxyLnRlbnNvci5zaGFwZSk7MD09PXRoaXMuZG90QXhlc1swXSYmMD09PXRoaXMuZG90QXhlc1sxXT8oKDAsZC5kZWZhdWx0KShoLnRlbnNvcix0WzBdLnRlbnNvci50cmFuc3Bvc2UoMSwwKSx0WzBdLnRlbnNvciksKDAsZC5kZWZhdWx0KSh2LnRlbnNvcix0WzFdLnRlbnNvci50cmFuc3Bvc2UoMSwwKSx0WzFdLnRlbnNvciksKDAsZC5kZWZhdWx0KShyLnRlbnNvcix0WzBdLnRlbnNvci50cmFuc3Bvc2UoMSwwKSx0WzFdLnRlbnNvcikpOjE9PT10aGlzLmRvdEF4ZXNbMF0mJjE9PT10aGlzLmRvdEF4ZXNbMV0mJigoMCxkLmRlZmF1bHQpKGgudGVuc29yLHRbMF0udGVuc29yLHRbMF0udGVuc29yLnRyYW5zcG9zZSgxLDApKSwoMCxkLmRlZmF1bHQpKHYudGVuc29yLHRbMV0udGVuc29yLHRbMV0udGVuc29yLnRyYW5zcG9zZSgxLDApKSwoMCxkLmRlZmF1bHQpKHIudGVuc29yLHRbMF0udGVuc29yLHRbMV0udGVuc29yLnRyYW5zcG9zZSgxLDApKSksbS5kZWZhdWx0Lm11bGVxKGgudGVuc29yLHYudGVuc29yKSxtLmRlZmF1bHQuc3FydGVxKGgudGVuc29yKSxtLmRlZmF1bHQuZGl2ZXEoci50ZW5zb3IsaC50ZW5zb3IpLHIudGVuc29yPSgwLGcuZGVmYXVsdCkoci50ZW5zb3IsMCl9cmV0dXJuIHJ9fSx7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9waXBlbGluZUVuYWJsZWQ/dGhpcy5fY2FsbFBpcGVsaW5lTW9kZSh0KTp0aGlzLl9jYWxsUmVndWxhck1vZGUodCl9fV0pLGV9KHAuZGVmYXVsdCk7ZS5kZWZhdWx0PUN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpe2Zvcih2YXIgZT0wLG49QXJyYXkodC5sZW5ndGgpO2U8dC5sZW5ndGg7ZSsrKW5bZV09dFtlXTtyZXR1cm4gbn1yZXR1cm4gQXJyYXkuZnJvbSh0KX1mdW5jdGlvbiBpKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBhKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gcyh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksbD1uKDEpLGM9cihsKSxmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aSh0aGlzLGUpO3ZhciBuPWEodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJQZXJtdXRlXCI7dmFyIHI9dC5kaW1zLG89dm9pZCAwPT09cj9bXTpyO3JldHVybiBuLmRpbXM9by5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQtMX0pLG59cmV0dXJuIHMoZSx0KSx1KGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU7aWYodGhpcy5kaW1zLmxlbmd0aCE9PXQudGVuc29yLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IodGhpcy5uYW1lK1wiIFtQZXJtdXRlIGxheWVyXSBUaGUgc3BlY2lmaWVkIGRpbXMgcGVybXV0YXRpb24gbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMuXCIpO3JldHVybiB0LnRlbnNvcj0oZT10LnRlbnNvcikudHJhbnNwb3NlLmFwcGx5KGUsbyh0aGlzLmRpbXMpKSx0fX1dKSxlfShjLmRlZmF1bHQpO2UuZGVmYXVsdD1mfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1uKDEzMCksZj1yKGMpLHA9big2MTApLGg9cihwKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJSZXBlYXRWZWN0b3JcIjt2YXIgcj10Lm4sYT12b2lkIDA9PT1yPzE6cjtyZXR1cm4gbi5uPWEsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtpZigxIT09dC50ZW5zb3Iuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcih0aGlzLm5hbWUrXCIgW1JlcGVhdFZlY3RvciBsYXllcl0gT25seSAxRCB0ZW5zb3IgaW5wdXRzIGFsbG93ZWQuXCIpO3JldHVybiB0LnRlbnNvcj0oMCxoLmRlZmF1bHQpKCgwLGYuZGVmYXVsdCkodC50ZW5zb3IsMCksW3RoaXMubiwxXSksdH19XSksZX0obC5kZWZhdWx0KTtlLmRlZmF1bHQ9ZH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMiksbD1yKHUpLGM9bigxKSxmPXIoYykscD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiUmVzaGFwZVwiO3ZhciByPXQudGFyZ2V0U2hhcGUsYT12b2lkIDA9PT1yP1tdOnI7cmV0dXJuIG4udGFyZ2V0U2hhcGU9YSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRoaXMudGFyZ2V0U2hhcGUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0sMSkhPT10LnRlbnNvci5zaXplKXRocm93IG5ldyBFcnJvcih0aGlzLm5hbWUrXCIgW1Jlc2hhcGUgbGF5ZXJdIFRoZSB0b3RhbCBzaXplIG9mIG5ldyBhcnJheSBtdXN0IGJlIHVuY2hhbmdlZCBpbiByZXNoYXBlIGxheWVyLlwiKTt2YXIgZT1uZXcgbC5kZWZhdWx0KFtdLHRoaXMudGFyZ2V0U2hhcGUpO3JldHVybiBlLnJlcGxhY2VUZW5zb3JEYXRhKHQudGVuc29yLmRhdGEpLHQudGVuc29yPWUudGVuc29yLHR9fV0pLGV9KGYuZGVmYXVsdCk7ZS5kZWZhdWx0PXB9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJTcGF0aWFsRHJvcG91dDJEXCI7dmFyIHI9dC5wLGE9dm9pZCAwPT09cj8uNTpyLHM9dC5kaW1PcmRlcmluZyx1PXZvaWQgMD09PXM/XCJ0ZlwiOnM7cmV0dXJuIG4ucD1NYXRoLm1pbihNYXRoLm1heCgwLGEpLDEpLG4uZGltT3JkZXJpbmc9dSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1jfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiU3BhdGlhbERyb3BvdXQzRFwiO3ZhciByPXQucCxhPXZvaWQgMD09PXI/LjU6cixzPXQuZGltT3JkZXJpbmcsdT12b2lkIDA9PT1zP1widGZcIjpzO3JldHVybiBuLnA9TWF0aC5taW4oTWF0aC5tYXgoMCxhKSwxKSxuLmRpbU9yZGVyaW5nPXUsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdH19XSksZX0obC5kZWZhdWx0KTtlLmRlZmF1bHQ9Y30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTWF4b3V0RGVuc2U9ZS5IaWdod2F5PWUuTWVyZ2U9ZS5SZXBlYXRWZWN0b3I9ZS5QZXJtdXRlPWUuUmVzaGFwZT1lLkZsYXR0ZW49ZS5TcGF0aWFsRHJvcG91dDNEPWUuU3BhdGlhbERyb3BvdXQyRD1lLkRyb3BvdXQ9ZS5BY3RpdmF0aW9uPWUuRGVuc2U9dm9pZCAwO3ZhciBvPW4oMjI1KSxpPXIobyksYT1uKDIyNCkscz1yKGEpLHU9bigyMjYpLGw9cih1KSxjPW4oMjM0KSxmPXIoYykscD1uKDIzNSksaD1yKHApLGQ9bigyMjcpLHY9cihkKSxtPW4oMjMzKSxfPXIobSksZz1uKDIzMSkseT1yKGcpLGI9bigyMzIpLHc9cihiKSx4PW4oMjMwKSxFPXIoeCksVD1uKDIyOCksTz1yKFQpLFM9bigyMjkpLFA9cihTKTtlLkRlbnNlPWkuZGVmYXVsdCxlLkFjdGl2YXRpb249cy5kZWZhdWx0LGUuRHJvcG91dD1sLmRlZmF1bHQsZS5TcGF0aWFsRHJvcG91dDJEPWYuZGVmYXVsdCxlLlNwYXRpYWxEcm9wb3V0M0Q9aC5kZWZhdWx0LGUuRmxhdHRlbj12LmRlZmF1bHQsZS5SZXNoYXBlPV8uZGVmYXVsdCxlLlBlcm11dGU9eS5kZWZhdWx0LGUuUmVwZWF0VmVjdG9yPXcuZGVmYXVsdCxlLk1lcmdlPUUuZGVmYXVsdCxlLkhpZ2h3YXk9Ty5kZWZhdWx0LGUuTWF4b3V0RGVuc2U9UC5kZWZhdWx0fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1uKDIpLGY9cihjKSxwPW4oMyksaD1yKHApLGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIkVtYmVkZGluZ1wiO3ZhciByPXQuaW5wdXREaW0sYT12b2lkIDA9PT1yPzE6cixzPXQub3V0cHV0RGltLHU9dm9pZCAwPT09cz8xOnMsbD10LmlucHV0TGVuZ3RoLGM9dm9pZCAwPT09bD8wOmwsZj10Lm1hc2taZXJvLHA9dm9pZCAwIT09ZiYmZixoPXQuZHJvcG91dCxkPXZvaWQgMD09PWg/MDpoO3JldHVybiBuLmlucHV0RGltPWEsbi5vdXRwdXREaW09dSxuLmlucHV0TGVuZ3RoPWMsbi5tYXNrWmVybz1wLG4uZHJvcG91dD1kLG4ucGFyYW1zPVtcIldcIl0sbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGYuZGVmYXVsdChbXSxbdC50ZW5zb3Iuc2hhcGVbMF0sdGhpcy53ZWlnaHRzLlcudGVuc29yLnNoYXBlWzFdXSksbj0wLHI9dC50ZW5zb3Iuc2hhcGVbMF07bjxyO24rKyloLmRlZmF1bHQuYXNzaWduKGUudGVuc29yLnBpY2sobixudWxsKSx0aGlzLndlaWdodHMuVy50ZW5zb3IucGljayh0LnRlbnNvci5nZXQobiksbnVsbCkpO3JldHVybiB0LnRlbnNvcj1lLnRlbnNvcix0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1kfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5FbWJlZGRpbmc9dm9pZCAwO3ZhciBvPW4oMjM3KSxpPXIobyk7ZS5FbWJlZGRpbmc9aS5kZWZhdWx0fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiR2F1c3NpYW5Ecm9wb3V0XCI7dmFyIHI9dC5wLGE9dm9pZCAwPT09cj8uNTpyO3JldHVybiBuLnA9TWF0aC5taW4oTWF0aC5tYXgoMCxhKSwxKSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1jfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9bigxKSxsPXIodSksYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiR2F1c3NpYW5Ob2lzZVwiO3Quc2lnbWE7cmV0dXJuIG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PWN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdhdXNzaWFuTm9pc2U9ZS5HYXVzc2lhbkRyb3BvdXQ9dm9pZCAwO3ZhciBvPW4oMjM5KSxpPXIobyksYT1uKDI0MCkscz1yKGEpO2UuR2F1c3NpYW5Ecm9wb3V0PWkuZGVmYXVsdCxlLkdhdXNzaWFuTm9pc2U9cy5kZWZhdWx0fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLHU9ZnVuY3Rpb24gdChlLG4scil7bnVsbD09PWUmJihlPUZ1bmN0aW9uLnByb3RvdHlwZSk7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2lmKHZvaWQgMD09PW8pe3ZhciBpPU9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtyZXR1cm4gbnVsbD09PWk/dm9pZCAwOnQoaSxuLHIpfWlmKFwidmFsdWVcImluIG8pcmV0dXJuIG8udmFsdWU7dmFyIGE9by5nZXQ7aWYodm9pZCAwIT09YSlyZXR1cm4gYS5jYWxsKHIpfSxsPW4oMSksYz1yKGwpLGY9bigyKSxwPXIoZiksaD1uKDMpLGQ9cihoKSx2PW4oMTkyKSxtPXIodiksXz1uKDE4MyksZz1yKF8pLHk9big1NyksYj1yKHkpLHc9bigyMDApLHg9cih3KSxFPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtuLmxheWVyQ2xhc3M9XCJCYXRjaE5vcm1hbGl6YXRpb25cIjt2YXIgcj10LmVwc2lsb24sYT12b2lkIDA9PT1yPy4wMDE6cixzPXQubW9kZSx1PXZvaWQgMD09PXM/MDpzLGw9dC5heGlzLGM9dm9pZCAwPT09bD8tMTpsO2lmKG4uZXBzaWxvbj1hLG4ubW9kZT11LG4uYXhpcz1jLG4uYXhpc05vcm1hbGl6ZWQ9ITEsbi5wYXJhbXM9MD09PW4ubW9kZT9bXCJnYW1tYVwiLFwiYmV0YVwiLFwicnVubmluZ19tZWFuXCIsXCJydW5uaW5nX3N0ZFwiXTpbXCJnYW1tYVwiLFwiYmV0YVwiXSxuLmdwdSYmd2VibGFzJiYobi5fdXNlV2VibGFzPSEwLG4ucGlwZWxpbmUpKXt2YXIgZj0oMCxiLmRlZmF1bHQpKG4ubGF5ZXJDbGFzcyx0KTtmPyhuLl9waXBlbGluZUVuYWJsZWQ9ITAsbi53ZWJnbEJhdGNoTm9ybT1uZXcgeC5kZWZhdWx0KTpuLl9waXBlbGluZUVuYWJsZWQ9ITF9cmV0dXJuIG59cmV0dXJuIGEoZSx0KSxzKGUsW3trZXk6XCJzZXRXZWlnaHRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIG49dGhpczt1KGUucHJvdG90eXBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcInNldFdlaWdodHNcIix0aGlzKS5jYWxsKHRoaXMsdCksdGhpcy5fdXNlV2VibGFzJiZ0aGlzLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe24ud2VpZ2h0c1t0XS5jcmVhdGVXZWJsYXNUZW5zb3IoKX0pfX0se2tleTpcIl9jYWxsUGlwZWxpbmVNb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX2Zyb21QaXBlbGluZT8odC53ZWJsYXNUZW5zb3I9dGhpcy53ZWJnbEJhdGNoTm9ybS5jYWxsKHQud2VibGFzVGVuc29yLHRoaXMuZXBzaWxvbix0aGlzLndlaWdodHMuZ2FtbWEud2VibGFzVGVuc29yLHRoaXMud2VpZ2h0cy5iZXRhLndlYmxhc1RlbnNvcix0aGlzLndlaWdodHMucnVubmluZ19tZWFuLndlYmxhc1RlbnNvcix0aGlzLndlaWdodHMucnVubmluZ19zdGQud2VibGFzVGVuc29yKSx0KTp0aGlzLl9jYWxsUmVndWxhck1vZGUodCl9fSx7a2V5OlwiX2NhbGxSZWd1bGFyTW9kZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5heGlzTm9ybWFsaXplZHx8KHRoaXMuYXhpcz10aGlzLmF4aXM8MD90LnRlbnNvci5zaGFwZS5sZW5ndGgrdGhpcy5heGlzOnRoaXMuYXhpcy0xLHRoaXMuYXhpc05vcm1hbGl6ZWQ9ITApO2Zvcih2YXIgbj1bXSxyPTA7cjx0LnRlbnNvci5zaGFwZS5sZW5ndGg7cisrKXI9PT10aGlzLmF4aXM/bi5wdXNoKDEpOm4ucHVzaChudWxsKTtmb3IodmFyIG89bmV3IHAuZGVmYXVsdChbXSx0LnRlbnNvci5zaGFwZSksaT1uZXcgcC5kZWZhdWx0KFtdLHQudGVuc29yLnNoYXBlKSxhPTA7YTx0LnRlbnNvci5zaGFwZVt0aGlzLmF4aXNdO2ErKyl7dmFyIHMsdTtuW3RoaXMuYXhpc109YSxkLmRlZmF1bHQuYXNzaWducygocz1vLnRlbnNvcikucGljay5hcHBseShzLG4pLHRoaXMud2VpZ2h0cy5nYW1tYS50ZW5zb3IuZ2V0KGEpKSxkLmRlZmF1bHQuYXNzaWducygodT1pLnRlbnNvcikucGljay5hcHBseSh1LG4pLHRoaXMud2VpZ2h0cy5iZXRhLnRlbnNvci5nZXQoYSkpfXZhciBsPW5ldyBwLmRlZmF1bHQoW10sdC50ZW5zb3Iuc2hhcGUpLGM9bmV3IHAuZGVmYXVsdChbXSx0LnRlbnNvci5zaGFwZSk7aWYoMD09PXRoaXMubW9kZSl7Zm9yKHZhciBmPTA7Zjx0LnRlbnNvci5zaGFwZVt0aGlzLmF4aXNdO2YrKyl7dmFyIGgsdjtuW3RoaXMuYXhpc109ZixkLmRlZmF1bHQuYXNzaWducygoaD1sLnRlbnNvcikucGljay5hcHBseShoLG4pLHRoaXMud2VpZ2h0cy5ydW5uaW5nX21lYW4udGVuc29yLmdldChmKSksZC5kZWZhdWx0LmFzc2lnbnMoKHY9Yy50ZW5zb3IpLnBpY2suYXBwbHkodixuKSx0aGlzLndlaWdodHMucnVubmluZ19zdGQudGVuc29yLmdldChmKSt0aGlzLmVwc2lsb24pfWQuZGVmYXVsdC5zcXJ0ZXEoYy50ZW5zb3IpfWVsc2UgaWYoMT09PXRoaXMubW9kZSl7dmFyIF89dC50ZW5zb3Iuc2hhcGUuc2xpY2UoKTtfLnNwbGljZSh0aGlzLmF4aXMsMSk7Zm9yKHZhciB5PW5ldyBwLmRlZmF1bHQoW10sXyksYj0wO2I8dC50ZW5zb3Iuc2hhcGVbdGhpcy5heGlzXTtiKyspe3ZhciB3O25bdGhpcy5heGlzXT1iLGQuZGVmYXVsdC5hZGRlcSh5LnRlbnNvciwodz10LnRlbnNvcikucGljay5hcHBseSh3LG4pKX1kLmRlZmF1bHQuZGl2c2VxKHkudGVuc29yLHQudGVuc29yLnNoYXBlW3RoaXMuYXhpc10pO2Zvcih2YXIgeD1uZXcgcC5kZWZhdWx0KFtdLF8pLEU9bmV3IHAuZGVmYXVsdChbXSxfKSxUPTA7VDx0LnRlbnNvci5zaGFwZVt0aGlzLmF4aXNdO1QrKyl7dmFyIE87blt0aGlzLmF4aXNdPVQsZC5kZWZhdWx0LnN1YihFLnRlbnNvciwoTz10LnRlbnNvcikucGljay5hcHBseShPLG4pLHkudGVuc29yKSxkLmRlZmF1bHQucG93c2VxKEUudGVuc29yLDIpLGQuZGVmYXVsdC5hZGRlcSh4LnRlbnNvcixFLnRlbnNvcil9ZC5kZWZhdWx0LmRpdnNlcSh4LnRlbnNvcix0LnRlbnNvci5zaGFwZVt0aGlzLmF4aXNdKSxkLmRlZmF1bHQuYWRkc2VxKHgudGVuc29yLHRoaXMuZXBzaWxvbiksZC5kZWZhdWx0LnNxcnRlcSh4LnRlbnNvciksZC5kZWZhdWx0LmFkZHNlcSh4LnRlbnNvcix0aGlzLmVwc2lsb24pO2Zvcih2YXIgUz0wO1M8dC50ZW5zb3Iuc2hhcGVbdGhpcy5heGlzXTtTKyspe3ZhciBQLE07blt0aGlzLmF4aXNdPVMsZC5kZWZhdWx0LmFzc2lnbigoUD1sLnRlbnNvcikucGljay5hcHBseShQLG4pLHkudGVuc29yKSxkLmRlZmF1bHQuYXNzaWduKChNPWMudGVuc29yKS5waWNrLmFwcGx5KE0sbikseC50ZW5zb3IpfX1lbHNle2lmKDIhPT10aGlzLm1vZGUpdGhyb3cgbmV3IEVycm9yKFwiW25vcm1hbGl6YXRpb24uQmF0Y2hOb3JtYWxpemF0aW9uXSBJbnZhbGlkIG1vZGUgXCIrdGhpcy5tb2RlK1wiLlwiKTtmb3IodmFyIGo9ZnVuY3Rpb24ocil7dmFyIG8saSxhO25bZS5heGlzXT1yO3ZhciBzPSgwLGcuZGVmYXVsdCkoKDAsbS5kZWZhdWx0KSgobz10LnRlbnNvcikucGljay5hcHBseShvLG4pKSksdT1zLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9LDApL3MubGVuZ3RoLGY9cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuKHQtdSkqKHQtdSl9KS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSwwKS9zLmxlbmd0aDtkLmRlZmF1bHQuYXNzaWducygoaT1sLnRlbnNvcikucGljay5hcHBseShpLG4pLHUpLGQuZGVmYXVsdC5hc3NpZ25zKChhPWMudGVuc29yKS5waWNrLmFwcGx5KGEsbiksZitlLmVwc2lsb24pfSxBPTA7QTx0LnRlbnNvci5zaGFwZVt0aGlzLmF4aXNdO0ErKylqKEEpO2QuZGVmYXVsdC5zcXJ0ZXEoYy50ZW5zb3IpfXJldHVybiBkLmRlZmF1bHQuc3ViZXEodC50ZW5zb3IsbC50ZW5zb3IpLGQuZGVmYXVsdC5kaXZlcSh0LnRlbnNvcixjLnRlbnNvciksZC5kZWZhdWx0Lm11bGVxKHQudGVuc29yLG8udGVuc29yKSxkLmRlZmF1bHQuYWRkZXEodC50ZW5zb3IsaS50ZW5zb3IpLHR9fSx7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9waXBlbGluZUVuYWJsZWQ/dGhpcy5fY2FsbFBpcGVsaW5lTW9kZSh0KTp0aGlzLl9jYWxsUmVndWxhck1vZGUodCl9fV0pLGV9KGMuZGVmYXVsdCk7ZS5kZWZhdWx0PUV9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkJhdGNoTm9ybWFsaXphdGlvbj12b2lkIDA7dmFyIG89bigyNDIpLGk9cihvKTtlLkJhdGNoTm9ybWFsaXphdGlvbj1pLmRlZmF1bHR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPW4oMTM0KSx1PXIocyksbD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7cmV0dXJuIG4ubGF5ZXJDbGFzcz1cIkF2ZXJhZ2VQb29saW5nMURcIixuLnBvb2xpbmdGdW5jPVwiYXZlcmFnZVwiLG59cmV0dXJuIGEoZSx0KSxlfSh1LmRlZmF1bHQpO2UuZGVmYXVsdD1sfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1uKDEzNSksdT1yKHMpLGw9big1NyksYz1yKGwpLGY9bigxMzIpLHA9cihmKSxoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtpZihuLmxheWVyQ2xhc3M9XCJBdmVyYWdlUG9vbGluZzJEXCIsbi5wb29saW5nRnVuYz1cImF2ZXJhZ2VcIixuLmdwdSYmd2VibGFzJiYobi5fdXNlV2VibGFzPSEwLG4ucGlwZWxpbmUpKXt2YXIgcj0oMCxjLmRlZmF1bHQpKG4ubGF5ZXJDbGFzcyx0KTtyPyhuLl9waXBlbGluZUVuYWJsZWQ9ITAsbi53ZWJnbFBvb2xpbmcyRD1uZXcgcC5kZWZhdWx0KG4ucG9vbGluZ0Z1bmMpKTpuLl9waXBlbGluZUVuYWJsZWQ9ITF9cmV0dXJuIG59cmV0dXJuIGEoZSx0KSxlfSh1LmRlZmF1bHQpO2UuZGVmYXVsdD1ofSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1uKDEzNiksdT1yKHMpLGw9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO3JldHVybiBuLmxheWVyQ2xhc3M9XCJBdmVyYWdlUG9vbGluZzNEXCIsbi5wb29saW5nRnVuYz1cImF2ZXJhZ2VcIixufXJldHVybiBhKGUsdCksZX0odS5kZWZhdWx0KTtlLmRlZmF1bHQ9bH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEscz10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9cy5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXshciYmcy5yZXR1cm4mJnMucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufXJldHVybiBmdW5jdGlvbihlLG4pe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGU7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlyZXR1cm4gdChlLG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSx1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksbD1uKDEpLGM9cihsKSxmPW4oMikscD1yKGYpLGg9bigzKSxkPXIoaCksdj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7cmV0dXJuIG4ubGF5ZXJDbGFzcz1cIkdsb2JhbEF2ZXJhZ2VQb29saW5nMURcIixufXJldHVybiBhKGUsdCksdShlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1zKHQudGVuc29yLnNoYXBlLDIpLG49ZVswXSxyPWVbMV0sbz1uZXcgcC5kZWZhdWx0KFtdLFtyXSksaT0wLGE9cjtpPGE7aSsrKW8udGVuc29yLnNldChpLGQuZGVmYXVsdC5zdW0odC50ZW5zb3IucGljayhudWxsLGkpKS9uKTtyZXR1cm4gdC50ZW5zb3I9by50ZW5zb3IsdH19XSksZX0oYy5kZWZhdWx0KTtlLmRlZmF1bHQ9dn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGEscz10W1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGE9cy5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGEudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO3I9ITApO31jYXRjaCh0KXtvPSEwLGk9dH1maW5hbGx5e3RyeXshciYmcy5yZXR1cm4mJnMucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufXJldHVybiBmdW5jdGlvbihlLG4pe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGU7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlyZXR1cm4gdChlLG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSx1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksbD1uKDEpLGM9cihsKSxmPW4oMikscD1yKGYpLGg9bigzKSxkPXIoaCksdj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiR2xvYmFsQXZlcmFnZVBvb2xpbmcyRFwiO3ZhciByPXQuZGltT3JkZXJpbmcsYT12b2lkIDA9PT1yP1widGZcIjpyO3JldHVybiBuLmRpbU9yZGVyaW5nPWEsbn1yZXR1cm4gYShlLHQpLHUoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtcInRoXCI9PT10aGlzLmRpbU9yZGVyaW5nJiYodC50ZW5zb3I9dC50ZW5zb3IudHJhbnNwb3NlKDEsMiwwKSk7Zm9yKHZhciBlPXModC50ZW5zb3Iuc2hhcGUsMyksbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1uZXcgcC5kZWZhdWx0KFtdLFtvXSksYT0wLHU9bzthPHU7YSsrKWkudGVuc29yLnNldChhLGQuZGVmYXVsdC5zdW0odC50ZW5zb3IucGljayhudWxsLG51bGwsYSkpLyhuKnIpKTtyZXR1cm4gdC50ZW5zb3I9aS50ZW5zb3IsdH19XSksZX0oYy5kZWZhdWx0KTtlLmRlZmF1bHQ9dn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBhKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSx1PW4oMSksbD1yKHUpLGM9bigyKSxmPXIoYykscD1uKDMpLGg9cihwKSxkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307byh0aGlzLGUpO3ZhciBuPWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQpKTtyZXR1cm4gbi5sYXllckNsYXNzPVwiR2xvYmFsTWF4UG9vbGluZzFEXCIsbn1yZXR1cm4gYShlLHQpLHMoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC50ZW5zb3Iuc2hhcGVbMV0sbj1uZXcgZi5kZWZhdWx0KFtdLFtlXSkscj0wLG89ZTtyPG87cisrKW4udGVuc29yLnNldChyLGguZGVmYXVsdC5zdXAodC50ZW5zb3IucGljayhudWxsLHIpKSk7cmV0dXJuIHQudGVuc29yPW4udGVuc29yLHR9fV0pLGV9KGwuZGVmYXVsdCk7ZS5kZWZhdWx0PWR9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbiYmdChlLnByb3RvdHlwZSxuKSxyJiZ0KGUsciksZX19KCksdT1uKDEpLGw9cih1KSxjPW4oMiksZj1yKGMpLHA9bigzKSxoPXIocCksZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O28odGhpcyxlKTt2YXIgbj1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5sYXllckNsYXNzPVwiR2xvYmFsTWF4UG9vbGluZzJEXCI7dmFyIHI9dC5kaW1PcmRlcmluZyxhPXZvaWQgMD09PXI/XCJ0ZlwiOnI7cmV0dXJuIG4uZGltT3JkZXJpbmc9YSxufXJldHVybiBhKGUsdCkscyhlLFt7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe1widGhcIj09PXRoaXMuZGltT3JkZXJpbmcmJih0LnRlbnNvcj10LnRlbnNvci50cmFuc3Bvc2UoMSwyLDApKTtcbmZvcih2YXIgZT10LnRlbnNvci5zaGFwZVsyXSxuPW5ldyBmLmRlZmF1bHQoW10sW2VdKSxyPTAsbz1lO3I8bztyKyspbi50ZW5zb3Iuc2V0KHIsaC5kZWZhdWx0LnN1cCh0LnRlbnNvci5waWNrKG51bGwsbnVsbCxyKSkpO3JldHVybiB0LnRlbnNvcj1uLnRlbnNvcix0fX1dKSxlfShsLmRlZmF1bHQpO2UuZGVmYXVsdD1kfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1uKDEzNCksdT1yKHMpLGw9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO3JldHVybiBuLmxheWVyQ2xhc3M9XCJNYXhQb29saW5nMURcIixuLnBvb2xpbmdGdW5jPVwibWF4XCIsbn1yZXR1cm4gYShlLHQpLGV9KHUuZGVmYXVsdCk7ZS5kZWZhdWx0PWx9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gYSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPW4oMTM1KSx1PXIocyksbD1uKDU3KSxjPXIobCksZj1uKDEzMikscD1yKGYpLGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO2lmKG4ubGF5ZXJDbGFzcz1cIk1heFBvb2xpbmcyRFwiLG4ucG9vbGluZ0Z1bmM9XCJtYXhcIixuLmdwdSYmd2VibGFzJiYobi5fdXNlV2VibGFzPSEwLG4ucGlwZWxpbmUpKXt2YXIgcj0oMCxjLmRlZmF1bHQpKG4ubGF5ZXJDbGFzcyx0KTtyPyhuLl9waXBlbGluZUVuYWJsZWQ9ITAsbi53ZWJnbFBvb2xpbmcyRD1uZXcgcC5kZWZhdWx0KG4ucG9vbGluZ0Z1bmMpKTpuLl9waXBlbGluZUVuYWJsZWQ9ITF9cmV0dXJuIG59cmV0dXJuIGEoZSx0KSxlfSh1LmRlZmF1bHQpO2UuZGVmYXVsdD1ofSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIGEodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1uKDEzNiksdT1yKHMpLGw9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtvKHRoaXMsZSk7dmFyIG49aSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO3JldHVybiBuLmxheWVyQ2xhc3M9XCJNYXhQb29saW5nM0RcIixuLnBvb2xpbmdGdW5jPVwibWF4XCIsbn1yZXR1cm4gYShlLHQpLGV9KHUuZGVmYXVsdCk7ZS5kZWZhdWx0PWx9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdsb2JhbEF2ZXJhZ2VQb29saW5nMkQ9ZS5HbG9iYWxNYXhQb29saW5nMkQ9ZS5HbG9iYWxBdmVyYWdlUG9vbGluZzFEPWUuR2xvYmFsTWF4UG9vbGluZzFEPWUuQXZlcmFnZVBvb2xpbmczRD1lLkF2ZXJhZ2VQb29saW5nMkQ9ZS5BdmVyYWdlUG9vbGluZzFEPWUuTWF4UG9vbGluZzNEPWUuTWF4UG9vbGluZzJEPWUuTWF4UG9vbGluZzFEPXZvaWQgMDt2YXIgbz1uKDI1MSksaT1yKG8pLGE9bigyNTIpLHM9cihhKSx1PW4oMjUzKSxsPXIodSksYz1uKDI0NCksZj1yKGMpLHA9bigyNDUpLGg9cihwKSxkPW4oMjQ2KSx2PXIoZCksbT1uKDI0OSksXz1yKG0pLGc9bigyNDcpLHk9cihnKSxiPW4oMjUwKSx3PXIoYikseD1uKDI0OCksRT1yKHgpO2UuTWF4UG9vbGluZzFEPWkuZGVmYXVsdCxlLk1heFBvb2xpbmcyRD1zLmRlZmF1bHQsZS5NYXhQb29saW5nM0Q9bC5kZWZhdWx0LGUuQXZlcmFnZVBvb2xpbmcxRD1mLmRlZmF1bHQsZS5BdmVyYWdlUG9vbGluZzJEPWguZGVmYXVsdCxlLkF2ZXJhZ2VQb29saW5nM0Q9di5kZWZhdWx0LGUuR2xvYmFsTWF4UG9vbGluZzFEPV8uZGVmYXVsdCxlLkdsb2JhbEF2ZXJhZ2VQb29saW5nMUQ9eS5kZWZhdWx0LGUuR2xvYmFsTWF4UG9vbGluZzJEPXcuZGVmYXVsdCxlLkdsb2JhbEF2ZXJhZ2VQb29saW5nMkQ9RS5kZWZhdWx0fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGU9e307aWYobnVsbCE9dClmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGUuZGVmYXVsdD10LGV9ZnVuY3Rpb24gaSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gYSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIHModCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGw9bigxOSksYz1vKGwpLGY9bigyKSxwPXIoZiksaD1uKDEpLGQ9cihoKSx2PW4oNTYpLG09bigzKSxfPXIobSksZz1uKDI1KSx5PXIoZyksYj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O2kodGhpcyxlKTt2YXIgbj1hKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5fY29tYmluZT0oMCx5LmRlZmF1bHQpKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLGJvZHk6ZnVuY3Rpb24odCxlLG4scil7dD1lK24rcn19KSxuLl91cGRhdGU9KDAseS5kZWZhdWx0KSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLGJvZHk6ZnVuY3Rpb24odCxlLG4pe3Q9dCooMS1uKStlKm59fSksbi5sYXllckNsYXNzPVwiR1JVXCI7dmFyIHI9dC5vdXRwdXREaW0sbz12b2lkIDA9PT1yPzE6cixzPXQuYWN0aXZhdGlvbix1PXZvaWQgMD09PXM/XCJ0YW5oXCI6cyxsPXQuaW5uZXJBY3RpdmF0aW9uLGY9dm9pZCAwPT09bD9cImhhcmRTaWdtb2lkXCI6bCxwPXQucmV0dXJuU2VxdWVuY2VzLGg9dm9pZCAwIT09cCYmcCxkPXQuZ29CYWNrd2FyZHMsdj12b2lkIDAhPT1kJiZkLG09dC5zdGF0ZWZ1bCxfPXZvaWQgMCE9PW0mJm07cmV0dXJuIG4ub3V0cHV0RGltPW8sbi5hY3RpdmF0aW9uPXUsbi5pbm5lckFjdGl2YXRpb249ZixuLmFjdGl2YXRpb25GdW5jPWNbdV0sbi5pbm5lckFjdGl2YXRpb25GdW5jPWNbZl0sbi5yZXR1cm5TZXF1ZW5jZXM9aCxuLmdvQmFja3dhcmRzPXYsbi5zdGF0ZWZ1bD1fLG4ucGFyYW1zPVtcIldfelwiLFwiVV96XCIsXCJiX3pcIixcIldfclwiLFwiVV9yXCIsXCJiX3JcIixcIldfaFwiLFwiVV9oXCIsXCJiX2hcIl0sbn1yZXR1cm4gcyhlLHQpLHUoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49bmV3IHAuZGVmYXVsdChbXSxbdC50ZW5zb3Iuc2hhcGVbMV1dKSxyPXRoaXMud2VpZ2h0cy5iX3oudGVuc29yLnNoYXBlWzBdLG89dGhpcy53ZWlnaHRzLmJfci50ZW5zb3Iuc2hhcGVbMF0saT10aGlzLndlaWdodHMuYl9oLnRlbnNvci5zaGFwZVswXSxhPW5ldyBwLmRlZmF1bHQoW10sW3JdKSxzPW5ldyBwLmRlZmF1bHQoW10sW3JdKSx1PW5ldyBwLmRlZmF1bHQoW10sW3JdKSxsPW5ldyBwLmRlZmF1bHQoW10sW29dKSxjPW5ldyBwLmRlZmF1bHQoW10sW29dKSxmPW5ldyBwLmRlZmF1bHQoW10sW29dKSxoPXRoaXMuc3RhdGVmdWwmJnRoaXMuY3VycmVudEhpZGRlblN0YXRlP3RoaXMuY3VycmVudEhpZGRlblN0YXRlOm5ldyBwLmRlZmF1bHQoW10sW2ldKSxkPW5ldyBwLmRlZmF1bHQoW10sW2ldKSxtPW5ldyBwLmRlZmF1bHQoW10sW2ldKSxnPW5ldyBwLmRlZmF1bHQoW10sW2ldKTt0aGlzLmhpZGRlblN0YXRlU2VxdWVuY2U9bmV3IHAuZGVmYXVsdChbXSxbdC50ZW5zb3Iuc2hhcGVbMF0saV0pO2Zvcih2YXIgeT1mdW5jdGlvbigpe3ZhciB0PVtzLHUsYyxmLGQsbV07dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBfLmRlZmF1bHQuYXNzaWducyh0LnRlbnNvciwwKX0pfSxiPWZ1bmN0aW9uKCl7Xy5kZWZhdWx0LmFzc2lnbihnLnRlbnNvcixoLnRlbnNvciksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5XX3oudGVuc29yLnRyYW5zcG9zZSgxLDApLG4udGVuc29yLDEscy50ZW5zb3IpLCgwLHYuZ2VtdikoMSxlLndlaWdodHMuVV96LnRlbnNvci50cmFuc3Bvc2UoMSwwKSxnLnRlbnNvciwxLHUudGVuc29yKSxlLl9jb21iaW5lKGEudGVuc29yLHMudGVuc29yLHUudGVuc29yLGUud2VpZ2h0cy5iX3oudGVuc29yKSxlLmlubmVyQWN0aXZhdGlvbkZ1bmMoYSksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5XX3IudGVuc29yLnRyYW5zcG9zZSgxLDApLG4udGVuc29yLDEsYy50ZW5zb3IpLCgwLHYuZ2VtdikoMSxlLndlaWdodHMuVV9yLnRlbnNvci50cmFuc3Bvc2UoMSwwKSxnLnRlbnNvciwxLGYudGVuc29yKSxlLl9jb21iaW5lKGwudGVuc29yLGMudGVuc29yLGYudGVuc29yLGUud2VpZ2h0cy5iX3IudGVuc29yKSxlLmlubmVyQWN0aXZhdGlvbkZ1bmMobCksXy5kZWZhdWx0Lm11bGVxKGwudGVuc29yLGcudGVuc29yKSwoMCx2LmdlbXYpKDEsZS53ZWlnaHRzLldfaC50ZW5zb3IudHJhbnNwb3NlKDEsMCksbi50ZW5zb3IsMSxkLnRlbnNvciksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5VX2gudGVuc29yLnRyYW5zcG9zZSgxLDApLGwudGVuc29yLDEsbS50ZW5zb3IpLGUuX2NvbWJpbmUoaC50ZW5zb3IsZC50ZW5zb3IsbS50ZW5zb3IsZS53ZWlnaHRzLmJfaC50ZW5zb3IpLGUuYWN0aXZhdGlvbkZ1bmMoaCksZS5fdXBkYXRlKGgudGVuc29yLGcudGVuc29yLGEudGVuc29yKX0sdz0wLHg9dC50ZW5zb3Iuc2hhcGVbMF07dzx4O3crKyl7dmFyIEU9dGhpcy5nb0JhY2t3YXJkcz94LXctMTp3O18uZGVmYXVsdC5hc3NpZ24obi50ZW5zb3IsdC50ZW5zb3IucGljayhFLG51bGwpKSx5KCksYigpLHRoaXMucmV0dXJuU2VxdWVuY2VzJiZfLmRlZmF1bHQuYXNzaWduKHRoaXMuaGlkZGVuU3RhdGVTZXF1ZW5jZS50ZW5zb3IucGljayh3LG51bGwpLGgudGVuc29yKX1yZXR1cm4gdGhpcy5yZXR1cm5TZXF1ZW5jZXM/dC50ZW5zb3I9dGhpcy5oaWRkZW5TdGF0ZVNlcXVlbmNlLnRlbnNvcjp0LnRlbnNvcj1oLnRlbnNvcix0aGlzLnN0YXRlZnVsJiYodGhpcy5jdXJyZW50SGlkZGVuU3RhdGU9aCksdH19XSksZX0oZC5kZWZhdWx0KTtlLmRlZmF1bHQ9Yn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlLmRlZmF1bHQ9dCxlfWZ1bmN0aW9uIGkodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGEodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBzKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxsPW4oMTkpLGM9byhsKSxmPW4oMikscD1yKGYpLGg9bigxKSxkPXIoaCksdj1uKDU2KSxtPW4oMyksXz1yKG0pLGc9bigyNSkseT1yKGcpLGI9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpKHRoaXMsZSk7dmFyIG49YSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24uX2NvbWJpbmU9KDAseS5kZWZhdWx0KSh7YXJnczpbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiXSxib2R5OmZ1bmN0aW9uKHQsZSxuLHIpe3Q9ZStuK3J9fSksbi5fdXBkYXRlPSgwLHkuZGVmYXVsdCkoe2FyZ3M6W1wiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sYm9keTpmdW5jdGlvbih0LGUsbixyKXt0PXQqbitlKnJ9fSksbi5sYXllckNsYXNzPVwiTFNUTVwiO3ZhciByPXQub3V0cHV0RGltLG89dm9pZCAwPT09cj8xOnIscz10LmFjdGl2YXRpb24sdT12b2lkIDA9PT1zP1widGFuaFwiOnMsbD10LmlubmVyQWN0aXZhdGlvbixmPXZvaWQgMD09PWw/XCJoYXJkU2lnbW9pZFwiOmwscD10LnJldHVyblNlcXVlbmNlcyxoPXZvaWQgMCE9PXAmJnAsZD10LmdvQmFja3dhcmRzLHY9dm9pZCAwIT09ZCYmZCxtPXQuc3RhdGVmdWwsXz12b2lkIDAhPT1tJiZtO3JldHVybiBuLm91dHB1dERpbT1vLG4uYWN0aXZhdGlvbj11LG4uaW5uZXJBY3RpdmF0aW9uPWYsbi5hY3RpdmF0aW9uRnVuYz1jW3VdLG4uaW5uZXJBY3RpdmF0aW9uRnVuYz1jW2ZdLG4ucmV0dXJuU2VxdWVuY2VzPWgsbi5nb0JhY2t3YXJkcz12LG4uc3RhdGVmdWw9XyxuLnBhcmFtcz1bXCJXX2lcIixcIlVfaVwiLFwiYl9pXCIsXCJXX2NcIixcIlVfY1wiLFwiYl9jXCIsXCJXX2ZcIixcIlVfZlwiLFwiYl9mXCIsXCJXX29cIixcIlVfb1wiLFwiYl9vXCJdLG59cmV0dXJuIHMoZSx0KSx1KGUsW3trZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPW5ldyBwLmRlZmF1bHQoW10sW3QudGVuc29yLnNoYXBlWzFdXSkscj10aGlzLndlaWdodHMuYl9pLnRlbnNvci5zaGFwZVswXSxvPXRoaXMud2VpZ2h0cy5iX2MudGVuc29yLnNoYXBlWzBdLGk9dGhpcy53ZWlnaHRzLmJfZi50ZW5zb3Iuc2hhcGVbMF0sYT10aGlzLndlaWdodHMuYl9vLnRlbnNvci5zaGFwZVswXSxzPW5ldyBwLmRlZmF1bHQoW10sW3JdKSx1PW5ldyBwLmRlZmF1bHQoW10sW3JdKSxsPW5ldyBwLmRlZmF1bHQoW10sW3JdKSxjPW5ldyBwLmRlZmF1bHQoW10sW2ldKSxmPW5ldyBwLmRlZmF1bHQoW10sW2ldKSxoPW5ldyBwLmRlZmF1bHQoW10sW2ldKSxkPW5ldyBwLmRlZmF1bHQoW10sW2FdKSxtPW5ldyBwLmRlZmF1bHQoW10sW2FdKSxnPW5ldyBwLmRlZmF1bHQoW10sW2FdKSx5PW5ldyBwLmRlZmF1bHQoW10sW29dKSxiPW5ldyBwLmRlZmF1bHQoW10sW29dKSx3PW5ldyBwLmRlZmF1bHQoW10sW29dKSx4PXRoaXMuc3RhdGVmdWwmJnRoaXMucHJldmlvdXNDYW5kaWRhdGU/dGhpcy5wcmV2aW91c0NhbmRpZGF0ZTpuZXcgcC5kZWZhdWx0KFtdLFtvXSksRT10aGlzLnN0YXRlZnVsJiZ0aGlzLmN1cnJlbnRIaWRkZW5TdGF0ZT90aGlzLmN1cnJlbnRIaWRkZW5TdGF0ZTpuZXcgcC5kZWZhdWx0KFtdLFtvXSksVD1uZXcgcC5kZWZhdWx0KFtdLFtvXSk7dGhpcy5oaWRkZW5TdGF0ZVNlcXVlbmNlPW5ldyBwLmRlZmF1bHQoW10sW3QudGVuc29yLnNoYXBlWzBdLG9dKTtmb3IodmFyIE89ZnVuY3Rpb24oKXt2YXIgdD1bdSxsLGYsaCxtLGcsYix3XTt0LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIF8uZGVmYXVsdC5hc3NpZ25zKHQudGVuc29yLDApfSl9LFM9ZnVuY3Rpb24oKXtfLmRlZmF1bHQuYXNzaWduKFQudGVuc29yLEUudGVuc29yKSwoMCx2LmdlbXYpKDEsZS53ZWlnaHRzLldfaS50ZW5zb3IudHJhbnNwb3NlKDEsMCksbi50ZW5zb3IsMSx1LnRlbnNvciksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5VX2kudGVuc29yLnRyYW5zcG9zZSgxLDApLFQudGVuc29yLDEsbC50ZW5zb3IpLGUuX2NvbWJpbmUocy50ZW5zb3IsdS50ZW5zb3IsbC50ZW5zb3IsZS53ZWlnaHRzLmJfaS50ZW5zb3IpLGUuaW5uZXJBY3RpdmF0aW9uRnVuYyhzKSwoMCx2LmdlbXYpKDEsZS53ZWlnaHRzLldfZi50ZW5zb3IudHJhbnNwb3NlKDEsMCksbi50ZW5zb3IsMSxmLnRlbnNvciksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5VX2YudGVuc29yLnRyYW5zcG9zZSgxLDApLFQudGVuc29yLDEsaC50ZW5zb3IpLGUuX2NvbWJpbmUoYy50ZW5zb3IsZi50ZW5zb3IsaC50ZW5zb3IsZS53ZWlnaHRzLmJfZi50ZW5zb3IpLGUuaW5uZXJBY3RpdmF0aW9uRnVuYyhjKSwoMCx2LmdlbXYpKDEsZS53ZWlnaHRzLldfby50ZW5zb3IudHJhbnNwb3NlKDEsMCksbi50ZW5zb3IsMSxtLnRlbnNvciksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5VX28udGVuc29yLnRyYW5zcG9zZSgxLDApLFQudGVuc29yLDEsZy50ZW5zb3IpLGUuX2NvbWJpbmUoZC50ZW5zb3IsbS50ZW5zb3IsZy50ZW5zb3IsZS53ZWlnaHRzLmJfby50ZW5zb3IpLGUuaW5uZXJBY3RpdmF0aW9uRnVuYyhkKSwoMCx2LmdlbXYpKDEsZS53ZWlnaHRzLldfYy50ZW5zb3IudHJhbnNwb3NlKDEsMCksbi50ZW5zb3IsMSxiLnRlbnNvciksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5VX2MudGVuc29yLnRyYW5zcG9zZSgxLDApLFQudGVuc29yLDEsdy50ZW5zb3IpLGUuX2NvbWJpbmUoeS50ZW5zb3IsYi50ZW5zb3Isdy50ZW5zb3IsZS53ZWlnaHRzLmJfYy50ZW5zb3IpLGUuYWN0aXZhdGlvbkZ1bmMoeSksZS5fdXBkYXRlKHkudGVuc29yLHgudGVuc29yLHMudGVuc29yLGMudGVuc29yKSxfLmRlZmF1bHQuYXNzaWduKHgudGVuc29yLHkudGVuc29yKSxlLmFjdGl2YXRpb25GdW5jKHkpLF8uZGVmYXVsdC5tdWwoRS50ZW5zb3IsZC50ZW5zb3IseS50ZW5zb3IpfSxQPTAsTT10LnRlbnNvci5zaGFwZVswXTtQPE07UCsrKXt2YXIgaj10aGlzLmdvQmFja3dhcmRzP00tUC0xOlA7Xy5kZWZhdWx0LmFzc2lnbihuLnRlbnNvcix0LnRlbnNvci5waWNrKGosbnVsbCkpLE8oKSxTKCksXy5kZWZhdWx0LmFzc2lnbih0aGlzLmhpZGRlblN0YXRlU2VxdWVuY2UudGVuc29yLnBpY2soUCxudWxsKSxFLnRlbnNvcil9cmV0dXJuIHRoaXMucmV0dXJuU2VxdWVuY2VzP3QudGVuc29yPXRoaXMuaGlkZGVuU3RhdGVTZXF1ZW5jZS50ZW5zb3I6dC50ZW5zb3I9RS50ZW5zb3IsdGhpcy5zdGF0ZWZ1bCYmKHRoaXMucHJldmlvdXNDYW5kaWRhdGU9eCx0aGlzLmN1cnJlbnRIaWRkZW5TdGF0ZT1FKSx0fX1dKSxlfShkLmRlZmF1bHQpO2UuZGVmYXVsdD1ifSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGU9e307aWYobnVsbCE9dClmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGUuZGVmYXVsdD10LGV9ZnVuY3Rpb24gaSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gYSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIHModCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGw9bigxOSksYz1vKGwpLGY9bigyKSxwPXIoZiksaD1uKDEpLGQ9cihoKSx2PW4oNTYpLG09bigzKSxfPXIobSksZz1uKDI1KSx5PXIoZyksYj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O2kodGhpcyxlKTt2YXIgbj1hKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0KSk7bi5fY29tYmluZT0oMCx5LmRlZmF1bHQpKHthcmdzOltcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLGJvZHk6ZnVuY3Rpb24odCxlLG4scil7dD1lK24rcn19KSxuLmxheWVyQ2xhc3M9XCJTaW1wbGVSTk5cIjt2YXIgcj10Lm91dHB1dERpbSxvPXZvaWQgMD09PXI/MTpyLHM9dC5hY3RpdmF0aW9uLHU9dm9pZCAwPT09cz9cInRhbmhcIjpzLGw9dC5yZXR1cm5TZXF1ZW5jZXMsZj12b2lkIDAhPT1sJiZsLHA9dC5nb0JhY2t3YXJkcyxoPXZvaWQgMCE9PXAmJnAsZD10LnN0YXRlZnVsLHY9dm9pZCAwIT09ZCYmZDtyZXR1cm4gbi5vdXRwdXREaW09byxuLmFjdGl2YXRpb249dSxuLmFjdGl2YXRpb25GdW5jPWNbdV0sbi5yZXR1cm5TZXF1ZW5jZXM9ZixuLmdvQmFja3dhcmRzPWgsbi5zdGF0ZWZ1bD12LG4ucGFyYW1zPVtcIldcIixcIlVcIixcImJcIl0sbn1yZXR1cm4gcyhlLHQpLHUoZSxbe2tleTpcImNhbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49bmV3IHAuZGVmYXVsdChbXSxbdC50ZW5zb3Iuc2hhcGVbMV1dKSxyPXRoaXMud2VpZ2h0cy5iLnRlbnNvci5zaGFwZVswXSxvPXRoaXMuc3RhdGVmdWwmJnRoaXMuY3VycmVudEhpZGRlblN0YXRlP3RoaXMuY3VycmVudEhpZGRlblN0YXRlOm5ldyBwLmRlZmF1bHQoW10sW3JdKSxpPW5ldyBwLmRlZmF1bHQoW10sW3JdKSxhPW5ldyBwLmRlZmF1bHQoW10sW3JdKSxzPW5ldyBwLmRlZmF1bHQoW10sW3JdKTt0aGlzLmhpZGRlblN0YXRlU2VxdWVuY2U9bmV3IHAuZGVmYXVsdChbXSxbdC50ZW5zb3Iuc2hhcGVbMF0scl0pO2Zvcih2YXIgdT1mdW5jdGlvbigpe3ZhciB0PVtpLGFdO3QuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gXy5kZWZhdWx0LmFzc2lnbnModC50ZW5zb3IsMCl9KX0sbD1mdW5jdGlvbigpe18uZGVmYXVsdC5hc3NpZ24ocy50ZW5zb3Isby50ZW5zb3IpLCgwLHYuZ2VtdikoMSxlLndlaWdodHMuVy50ZW5zb3IudHJhbnNwb3NlKDEsMCksbi50ZW5zb3IsMSxpLnRlbnNvciksKDAsdi5nZW12KSgxLGUud2VpZ2h0cy5VLnRlbnNvci50cmFuc3Bvc2UoMSwwKSxzLnRlbnNvciwxLGEudGVuc29yKSxlLl9jb21iaW5lKG8udGVuc29yLGkudGVuc29yLGEudGVuc29yLGUud2VpZ2h0cy5iLnRlbnNvciksZS5hY3RpdmF0aW9uRnVuYyhvKX0sYz0wLGY9dC50ZW5zb3Iuc2hhcGVbMF07YzxmO2MrKyl7dmFyIGg9dGhpcy5nb0JhY2t3YXJkcz9mLWMtMTpjO18uZGVmYXVsdC5hc3NpZ24obi50ZW5zb3IsdC50ZW5zb3IucGljayhoLG51bGwpKSx1KCksbCgpLHRoaXMucmV0dXJuU2VxdWVuY2VzJiZfLmRlZmF1bHQuYXNzaWduKHRoaXMuaGlkZGVuU3RhdGVTZXF1ZW5jZS50ZW5zb3IucGljayhjLG51bGwpLG8udGVuc29yKX1yZXR1cm4gdGhpcy5yZXR1cm5TZXF1ZW5jZXM/dC50ZW5zb3I9dGhpcy5oaWRkZW5TdGF0ZVNlcXVlbmNlLnRlbnNvcjp0LnRlbnNvcj1vLnRlbnNvcix0aGlzLnN0YXRlZnVsJiYodGhpcy5jdXJyZW50SGlkZGVuU3RhdGU9byksdH19XSksZX0oZC5kZWZhdWx0KTtlLmRlZmF1bHQ9Yn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlLmRlZmF1bHQ9dCxlfWZ1bmN0aW9uIG8odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIGkodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGEodCxlKXtpZighdCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6ZX1mdW5jdGlvbiBzKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxsPW4oMSksYz1vKGwpLGY9bigyKSxwPW8oZiksaD1uKDMpLGQ9byhoKSx2PW4oNTczKSxtPW8odiksXz1uKDEzNyksZz1yKF8pLHk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpKHRoaXMsZSk7dmFyIG49YSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIkJpZGlyZWN0aW9uYWxcIjt2YXIgcj10LmxheWVyLG89dC5tZXJnZU1vZGUscz12b2lkIDA9PT1vP1wiY29uY2F0XCI6bztpZighcil0aHJvdyBuZXcgRXJyb3IoXCJbQmlkaXJlY3Rpb25hbF0gd3JhcHBlZCBsYXllciBpcyB1bmRlZmluZWQuXCIpO24uZm9yd2FyZExheWVyPXI7dmFyIHU9KDAsbS5kZWZhdWx0KShyLFtcIm91dHB1dERpbVwiLFwiYWN0aXZhdGlvblwiLFwiaW5uZXJBY3RpdmF0aW9uXCIsXCJyZXR1cm5TZXF1ZW5jZXNcIixcImdvQmFja3dhcmRzXCIsXCJzdGF0ZWZ1bFwiXSk7cmV0dXJuIHUuZ29CYWNrd2FyZHM9IXUuZ29CYWNrd2FyZHMsbi5iYWNrd2FyZExheWVyPW5ldyBnW3IubGF5ZXJDbGFzc10odSksbi5tZXJnZU1vZGU9cyxufXJldHVybiBzKGUsdCksdShlLFt7a2V5Olwic2V0V2VpZ2h0c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuZm9yd2FyZExheWVyLnNldFdlaWdodHModC5zbGljZSgwLHQubGVuZ3RoLzIpKSx0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0V2VpZ2h0cyh0LnNsaWNlKHQubGVuZ3RoLzIpKX19LHtrZXk6XCJjYWxsXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHAuZGVmYXVsdCh0LnRlbnNvci5kYXRhLHQudGVuc29yLnNoYXBlKSxuPW5ldyBwLmRlZmF1bHQodC50ZW5zb3IuZGF0YSx0LnRlbnNvci5zaGFwZSkscj10aGlzLmZvcndhcmRMYXllci5jYWxsKGUpLG89dGhpcy5iYWNrd2FyZExheWVyLmNhbGwobik7aWYoXCJjb25jYXRcIj09PXRoaXMubWVyZ2VNb2RlKXt2YXIgaT1yLnRlbnNvci5zaGFwZS5zbGljZSgpO2lbaS5sZW5ndGgtMV0rPW8udGVuc29yLnNoYXBlW2kubGVuZ3RoLTFdO3ZhciBhPW5ldyBwLmRlZmF1bHQoW10saSk7dGhpcy5mb3J3YXJkTGF5ZXIucmV0dXJuU2VxdWVuY2VzPyhkLmRlZmF1bHQuYXNzaWduKGEudGVuc29yLmhpKGlbMF0sci50ZW5zb3Iuc2hhcGVbMV0pLmxvKDAsMCksci50ZW5zb3IpLGQuZGVmYXVsdC5hc3NpZ24oYS50ZW5zb3IuaGkoaVswXSxpWzFdKS5sbygwLHIudGVuc29yLnNoYXBlWzFdKSxvLnRlbnNvci5zdGVwKC0xKSkpOihkLmRlZmF1bHQuYXNzaWduKGEudGVuc29yLmhpKHIudGVuc29yLnNoYXBlWzBdKS5sbygwKSxyLnRlbnNvciksZC5kZWZhdWx0LmFzc2lnbihhLnRlbnNvci5oaShpWzBdKS5sbyhyLnRlbnNvci5zaGFwZVswXSksby50ZW5zb3IpKSx0LnRlbnNvcj1hLnRlbnNvcn1lbHNlIGlmKFwic3VtXCI9PT10aGlzLm1lcmdlTW9kZSl7dmFyIHM9ci50ZW5zb3Iuc2hhcGUuc2xpY2UoKSx1PW5ldyBwLmRlZmF1bHQoW10scyk7ZC5kZWZhdWx0LmFkZGVxKHUudGVuc29yLHIudGVuc29yKSxkLmRlZmF1bHQuYWRkZXEodS50ZW5zb3Isby50ZW5zb3IpLHQudGVuc29yPXUudGVuc29yfWVsc2UgaWYoXCJtdWxcIj09PXRoaXMubWVyZ2VNb2RlKXt2YXIgbD1yLnRlbnNvci5zaGFwZS5zbGljZSgpLGM9bmV3IHAuZGVmYXVsdChbXSxsKTtkLmRlZmF1bHQuYXNzaWducyhjLnRlbnNvciwxKSxkLmRlZmF1bHQubXVsZXEoYy50ZW5zb3Isci50ZW5zb3IpLGQuZGVmYXVsdC5tdWxlcShjLnRlbnNvcixvLnRlbnNvciksdC50ZW5zb3I9Yy50ZW5zb3J9ZWxzZSBpZihcImF2ZVwiPT09dGhpcy5tZXJnZU1vZGUpe3ZhciBmPXIudGVuc29yLnNoYXBlLnNsaWNlKCksaD1uZXcgcC5kZWZhdWx0KFtdLGYpO2QuZGVmYXVsdC5hZGRlcShoLnRlbnNvcixyLnRlbnNvciksZC5kZWZhdWx0LmFkZGVxKGgudGVuc29yLG8udGVuc29yKSxkLmRlZmF1bHQuZGl2c2VxKGgudGVuc29yLDIpLHQudGVuc29yPWgudGVuc29yfXJldHVybiB0fX1dKSxlfShjLmRlZmF1bHQpO2UuZGVmYXVsdD15fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19ZnVuY3Rpb24gbyh0KXtpZihBcnJheS5pc0FycmF5KHQpKXtmb3IodmFyIGU9MCxuPUFycmF5KHQubGVuZ3RoKTtlPHQubGVuZ3RoO2UrKyluW2VdPXRbZV07cmV0dXJuIG59cmV0dXJuIEFycmF5LmZyb20odCl9ZnVuY3Rpb24gaSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gYSh0LGUpe2lmKCF0KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDplfWZ1bmN0aW9uIHModCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgZSk7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZSYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKTp0Ll9fcHJvdG9fXz1lKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGw9bigxKSxjPXIobCksZj1uKDIpLHA9cihmKSxoPW4oMyksZD1yKGgpLHY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpKHRoaXMsZSk7dmFyIG49YSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCkpO24ubGF5ZXJDbGFzcz1cIlRpbWVEaXN0cmlidXRlZFwiO3ZhciByPXQubGF5ZXI7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiW1RpbWVEaXN0cmlidXRlZF0gd3JhcHBlZCBsYXllciBpcyB1bmRlZmluZWQuXCIpO3JldHVybiBuLmxheWVyPXIsbn1yZXR1cm4gcyhlLHQpLHUoZSxbe2tleTpcInNldFdlaWdodHNcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLmxheWVyLnNldFdlaWdodHModCl9fSx7a2V5OlwiY2FsbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlLG4scj1bXS5jb25jYXQobyh0LnRlbnNvci5zaGFwZS5zbGljZSgxKSkpLGk9bmV3IHAuZGVmYXVsdChbXSxyKTtkLmRlZmF1bHQuYXNzaWduKGkudGVuc29yLChlPXQudGVuc29yKS5waWNrLmFwcGx5KGUsWzBdLmNvbmNhdChvKHIubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsfSkpKSkpO3ZhciBhPXRoaXMubGF5ZXIuY2FsbChpKSxzPWEudGVuc29yLnNoYXBlLnNsaWNlKCksdT1uZXcgcC5kZWZhdWx0KFtdLFt0LnRlbnNvci5zaGFwZVswXV0uY29uY2F0KG8ocykpKTtkLmRlZmF1bHQuYXNzaWduKChuPXUudGVuc29yKS5waWNrLmFwcGx5KG4sWzBdLmNvbmNhdChvKHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsfSkpKSksYS50ZW5zb3IpO2Zvcih2YXIgbD0xLGM9dC50ZW5zb3Iuc2hhcGVbMF07bDxjO2wrKyl7dmFyIGYsaCx2PW5ldyBwLmRlZmF1bHQoW10scik7ZC5kZWZhdWx0LmFzc2lnbih2LnRlbnNvciwoZj10LnRlbnNvcikucGljay5hcHBseShmLFtsXS5jb25jYXQobyhyLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbH0pKSkpKSxhPXRoaXMubGF5ZXIuY2FsbCh2KSxkLmRlZmF1bHQuYXNzaWduKChoPXUudGVuc29yKS5waWNrLmFwcGx5KGgsW2xdLmNvbmNhdChvKHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsfSkpKSksYS50ZW5zb3IpfXJldHVybiB0LnRlbnNvcj11LnRlbnNvcix0fX1dKSxlfShjLmRlZmF1bHQpO2UuZGVmYXVsdD12fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5CaWRpcmVjdGlvbmFsPWUuVGltZURpc3RyaWJ1dGVkPXZvaWQgMDt2YXIgbz1uKDI1OSksaT1yKG8pLGE9bigyNTgpLHM9cihhKTtlLlRpbWVEaXN0cmlidXRlZD1pLmRlZmF1bHQsZS5CaWRpcmVjdGlvbmFsPXMuZGVmYXVsdH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fWZ1bmN0aW9uIG8odCxlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06MWUtNCxyPSgwLHUuZGVmYXVsdCkoKDAsYS5kZWZhdWx0KSh0KSksbz1lO2lmKHIubGVuZ3RoIT09by5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBpPTA7aTxyLmxlbmd0aDtpKyspe2lmKCEoMCxjLmRlZmF1bHQpKHJbaV0pKXJldHVybiExO2lmKHJbaV08b1tpXS1ufHxyW2ldPm9baV0rbilyZXR1cm4hMX1yZXR1cm4hMH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFwcHJveEVxdWFscz1vO3ZhciBpPW4oMTkyKSxhPXIoaSkscz1uKDE4MyksdT1yKHMpLGw9big1NzApLGM9cihsKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7dmFyIGU9dC5sZW5ndGg7aWYoZSU0PjApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtyZXR1cm5cIj1cIj09PXRbZS0yXT8yOlwiPVwiPT09dFtlLTFdPzE6MH1mdW5jdGlvbiBvKHQpe3JldHVybiAzKnQubGVuZ3RoLzQtcih0KX1mdW5jdGlvbiBpKHQpe3ZhciBlLG4sbyxpLGEscyx1PXQubGVuZ3RoO2E9cih0KSxzPW5ldyBmKDMqdS80LWEpLG89YT4wP3UtNDp1O3ZhciBsPTA7Zm9yKGU9MCxuPTA7ZTxvO2UrPTQsbis9MylpPWNbdC5jaGFyQ29kZUF0KGUpXTw8MTh8Y1t0LmNoYXJDb2RlQXQoZSsxKV08PDEyfGNbdC5jaGFyQ29kZUF0KGUrMildPDw2fGNbdC5jaGFyQ29kZUF0KGUrMyldLHNbbCsrXT1pPj4xNiYyNTUsc1tsKytdPWk+PjgmMjU1LHNbbCsrXT0yNTUmaTtyZXR1cm4gMj09PWE/KGk9Y1t0LmNoYXJDb2RlQXQoZSldPDwyfGNbdC5jaGFyQ29kZUF0KGUrMSldPj40LHNbbCsrXT0yNTUmaSk6MT09PWEmJihpPWNbdC5jaGFyQ29kZUF0KGUpXTw8MTB8Y1t0LmNoYXJDb2RlQXQoZSsxKV08PDR8Y1t0LmNoYXJDb2RlQXQoZSsyKV0+PjIsc1tsKytdPWk+PjgmMjU1LHNbbCsrXT0yNTUmaSksc31mdW5jdGlvbiBhKHQpe3JldHVybiBsW3Q+PjE4JjYzXStsW3Q+PjEyJjYzXStsW3Q+PjYmNjNdK2xbNjMmdF19ZnVuY3Rpb24gcyh0LGUsbil7Zm9yKHZhciByLG89W10saT1lO2k8bjtpKz0zKXI9KHRbaV08PDE2KSsodFtpKzFdPDw4KSt0W2krMl0sby5wdXNoKGEocikpO3JldHVybiBvLmpvaW4oXCJcIil9ZnVuY3Rpb24gdSh0KXtmb3IodmFyIGUsbj10Lmxlbmd0aCxyPW4lMyxvPVwiXCIsaT1bXSxhPTE2MzgzLHU9MCxjPW4tcjt1PGM7dSs9YSlpLnB1c2gocyh0LHUsdSthPmM/Yzp1K2EpKTtyZXR1cm4gMT09PXI/KGU9dFtuLTFdLG8rPWxbZT4+Ml0sbys9bFtlPDw0JjYzXSxvKz1cIj09XCIpOjI9PT1yJiYoZT0odFtuLTJdPDw4KSt0W24tMV0sbys9bFtlPj4xMF0sbys9bFtlPj40JjYzXSxvKz1sW2U8PDImNjNdLG8rPVwiPVwiKSxpLnB1c2gobyksaS5qb2luKFwiXCIpfWUuYnl0ZUxlbmd0aD1vLGUudG9CeXRlQXJyYXk9aSxlLmZyb21CeXRlQXJyYXk9dTtmb3IodmFyIGw9W10sYz1bXSxmPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXkscD1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIixoPTAsZD1wLmxlbmd0aDtoPGQ7KytoKWxbaF09cFtoXSxjW3AuY2hhckNvZGVBdChoKV09aDtjW1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyLGNbXCJfXCIuY2hhckNvZGVBdCgwKV09NjN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtcInVzZSByZXN0cmljdFwiO2Z1bmN0aW9uIHIodCl7dmFyIGU9MzI7cmV0dXJuIHQmPS10LHQmJmUtLSw2NTUzNSZ0JiYoZS09MTYpLDE2NzExOTM1JnQmJihlLT04KSwyNTI2NDUxMzUmdCYmKGUtPTQpLDg1ODk5MzQ1OSZ0JiYoZS09MiksMTQzMTY1NTc2NSZ0JiYoZS09MSksZX12YXIgbz0zMjtlLklOVF9CSVRTPW8sZS5JTlRfTUFYPTIxNDc0ODM2NDcsZS5JTlRfTUlOPS0xPDxvLTEsZS5zaWduPWZ1bmN0aW9uKHQpe3JldHVybih0PjApLSh0PDApfSxlLmFicz1mdW5jdGlvbih0KXt2YXIgZT10Pj5vLTE7cmV0dXJuKHReZSktZX0sZS5taW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gZV4odF5lKSYtKHQ8ZSl9LGUubWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHReKHReZSkmLSh0PGUpfSxlLmlzUG93Mj1mdW5jdGlvbih0KXtyZXR1cm4hKHQmdC0xfHwhdCl9LGUubG9nMj1mdW5jdGlvbih0KXt2YXIgZSxuO3JldHVybiBlPSh0PjY1NTM1KTw8NCx0Pj4+PWUsbj0odD4yNTUpPDwzLHQ+Pj49bixlfD1uLG49KHQ+MTUpPDwyLHQ+Pj49bixlfD1uLG49KHQ+Myk8PDEsdD4+Pj1uLGV8PW4sZXx0Pj4xfSxlLmxvZzEwPWZ1bmN0aW9uKHQpe3JldHVybiB0Pj0xZTk/OTp0Pj0xZTg/ODp0Pj0xZTc/Nzp0Pj0xZTY/Njp0Pj0xZTU/NTp0Pj0xZTQ/NDp0Pj0xZTM/Mzp0Pj0xMDA/Mjp0Pj0xMD8xOjB9LGUucG9wQ291bnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQtPXQ+Pj4xJjE0MzE2NTU3NjUsdD0oODU4OTkzNDU5JnQpKyh0Pj4+MiY4NTg5OTM0NTkpLDE2ODQzMDA5Kih0Kyh0Pj4+NCkmMjUyNjQ1MTM1KT4+PjI0fSxlLmNvdW50VHJhaWxpbmdaZXJvcz1yLGUubmV4dFBvdzI9ZnVuY3Rpb24odCl7cmV0dXJuIHQrPTA9PT10LC0tdCx0fD10Pj4+MSx0fD10Pj4+Mix0fD10Pj4+NCx0fD10Pj4+OCx0fD10Pj4+MTYsdCsxfSxlLnByZXZQb3cyPWZ1bmN0aW9uKHQpe3JldHVybiB0fD10Pj4+MSx0fD10Pj4+Mix0fD10Pj4+NCx0fD10Pj4+OCx0fD10Pj4+MTYsdC0odD4+PjEpfSxlLnBhcml0eT1mdW5jdGlvbih0KXtyZXR1cm4gdF49dD4+PjE2LHRePXQ+Pj44LHRePXQ+Pj40LHQmPTE1LDI3MDMwPj4+dCYxfTt2YXIgaT1uZXcgQXJyYXkoMjU2KTshZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTwyNTY7KytlKXt2YXIgbj1lLHI9ZSxvPTc7Zm9yKG4+Pj49MTtuO24+Pj49MSlyPDw9MSxyfD0xJm4sLS1vO3RbZV09cjw8byYyNTV9fShpKSxlLnJldmVyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIGlbMjU1JnRdPDwyNHxpW3Q+Pj44JjI1NV08PDE2fGlbdD4+PjE2JjI1NV08PDh8aVt0Pj4+MjQmMjU1XX0sZS5pbnRlcmxlYXZlMj1mdW5jdGlvbih0LGUpe3JldHVybiB0Jj02NTUzNSx0PTE2NzExOTM1Jih0fHQ8PDgpLHQ9MjUyNjQ1MTM1Jih0fHQ8PDQpLHQ9ODU4OTkzNDU5Jih0fHQ8PDIpLHQ9MTQzMTY1NTc2NSYodHx0PDwxKSxlJj02NTUzNSxlPTE2NzExOTM1JihlfGU8PDgpLGU9MjUyNjQ1MTM1JihlfGU8PDQpLGU9ODU4OTkzNDU5JihlfGU8PDIpLGU9MTQzMTY1NTc2NSYoZXxlPDwxKSx0fGU8PDF9LGUuZGVpbnRlcmxlYXZlMj1mdW5jdGlvbih0LGUpe3JldHVybiB0PXQ+Pj5lJjE0MzE2NTU3NjUsdD04NTg5OTM0NTkmKHR8dD4+PjEpLHQ9MjUyNjQ1MTM1Jih0fHQ+Pj4yKSx0PTE2NzExOTM1Jih0fHQ+Pj40KSx0PTY1NTM1Jih0fHQ+Pj4xNiksdDw8MTY+PjE2fSxlLmludGVybGVhdmUzPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdCY9MTAyMyx0PTQyNzgxOTAzMzUmKHR8dDw8MTYpLHQ9MjUxNzE5Njk1Jih0fHQ8PDgpLHQ9MzI3MjM1NjAzNSYodHx0PDw0KSx0PTEyMjcxMzM1MTMmKHR8dDw8MiksZSY9MTAyMyxlPTQyNzgxOTAzMzUmKGV8ZTw8MTYpLGU9MjUxNzE5Njk1JihlfGU8PDgpLGU9MzI3MjM1NjAzNSYoZXxlPDw0KSxlPTEyMjcxMzM1MTMmKGV8ZTw8MiksdHw9ZTw8MSxuJj0xMDIzLG49NDI3ODE5MDMzNSYobnxuPDwxNiksbj0yNTE3MTk2OTUmKG58bjw8OCksbj0zMjcyMzU2MDM1JihufG48PDQpLG49MTIyNzEzMzUxMyYobnxuPDwyKSx0fG48PDJ9LGUuZGVpbnRlcmxlYXZlMz1mdW5jdGlvbih0LGUpe3JldHVybiB0PXQ+Pj5lJjEyMjcxMzM1MTMsdD0zMjcyMzU2MDM1Jih0fHQ+Pj4yKSx0PTI1MTcxOTY5NSYodHx0Pj4+NCksdD00Mjc4MTkwMzM1Jih0fHQ+Pj44KSx0PTEwMjMmKHR8dD4+PjE2KSx0PDwyMj4+MjJ9LGUubmV4dENvbWJpbmF0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPXR8dC0xO3JldHVybiBlKzF8KH5lJi1+ZSktMT4+PnIodCkrMX19LGZ1bmN0aW9uKHQsZSxuKXsoZnVuY3Rpb24oZSxuLHIpeyFmdW5jdGlvbihlKXt0LmV4cG9ydHM9ZSgpfShmdW5jdGlvbigpe3ZhciB0LG8saTtyZXR1cm4gZnVuY3Rpb24gdChlLG4scil7ZnVuY3Rpb24gbyhhLHMpe2lmKCFuW2FdKXtpZighZVthXSl7dmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgX2RlcmVxXyYmX2RlcmVxXztpZighcyYmdSlyZXR1cm4gdShhLCEwKTtpZihpKXJldHVybiBpKGEsITApO3ZhciBsPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrYStcIidcIik7dGhyb3cgbC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGx9dmFyIGM9blthXT17ZXhwb3J0czp7fX07ZVthXVswXS5jYWxsKGMuZXhwb3J0cyxmdW5jdGlvbih0KXt2YXIgbj1lW2FdWzFdW3RdO3JldHVybiBvKG4/bjp0KX0sYyxjLmV4cG9ydHMsdCxlLG4scil9cmV0dXJuIG5bYV0uZXhwb3J0c31mb3IodmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgX2RlcmVxXyYmX2RlcmVxXyxhPTA7YTxyLmxlbmd0aDthKyspbyhyW2FdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt2YXIgZT1uZXcgbih0KSxyPWUucHJvbWlzZSgpO3JldHVybiBlLnNldEhvd01hbnkoMSksZS5zZXRVbndyYXAoKSxlLmluaXQoKSxyfXZhciBuPXQuX1NvbWVQcm9taXNlQXJyYXk7dC5hbnk9ZnVuY3Rpb24odCl7cmV0dXJuIGUodCl9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbigpe3JldHVybiBlKHRoaXMpfX19LHt9XSwyOltmdW5jdGlvbih0LG4scil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbygpe3RoaXMuX2N1c3RvbVNjaGVkdWxlcj0hMSx0aGlzLl9pc1RpY2tVc2VkPSExLHRoaXMuX2xhdGVRdWV1ZT1uZXcgYygxNiksdGhpcy5fbm9ybWFsUXVldWU9bmV3IGMoMTYpLHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzPSExLHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkPSEwO3ZhciB0PXRoaXM7dGhpcy5kcmFpblF1ZXVlcz1mdW5jdGlvbigpe3QuX2RyYWluUXVldWVzKCl9LHRoaXMuX3NjaGVkdWxlPWx9ZnVuY3Rpb24gaSh0LGUsbil7dGhpcy5fbGF0ZVF1ZXVlLnB1c2godCxlLG4pLHRoaXMuX3F1ZXVlVGljaygpfWZ1bmN0aW9uIGEodCxlLG4pe3RoaXMuX25vcm1hbFF1ZXVlLnB1c2godCxlLG4pLHRoaXMuX3F1ZXVlVGljaygpfWZ1bmN0aW9uIHModCl7dGhpcy5fbm9ybWFsUXVldWUuX3B1c2hPbmUodCksdGhpcy5fcXVldWVUaWNrKCl9dmFyIHU7dHJ5e3Rocm93IG5ldyBFcnJvcn1jYXRjaCh0KXt1PXR9dmFyIGw9dChcIi4vc2NoZWR1bGVcIiksYz10KFwiLi9xdWV1ZVwiKSxmPXQoXCIuL3V0aWxcIik7by5wcm90b3R5cGUuc2V0U2NoZWR1bGVyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3NjaGVkdWxlO3JldHVybiB0aGlzLl9zY2hlZHVsZT10LHRoaXMuX2N1c3RvbVNjaGVkdWxlcj0hMCxlfSxvLnByb3RvdHlwZS5oYXNDdXN0b21TY2hlZHVsZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VzdG9tU2NoZWR1bGVyfSxvLnByb3RvdHlwZS5lbmFibGVUcmFtcG9saW5lPWZ1bmN0aW9uKCl7dGhpcy5fdHJhbXBvbGluZUVuYWJsZWQ9ITB9LG8ucHJvdG90eXBlLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3Nhcnk9ZnVuY3Rpb24oKXtmLmhhc0RldlRvb2xzJiYodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQ9ITEpfSxvLnByb3RvdHlwZS5oYXZlSXRlbXNRdWV1ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNUaWNrVXNlZHx8dGhpcy5faGF2ZURyYWluZWRRdWV1ZXN9LG8ucHJvdG90eXBlLmZhdGFsRXJyb3I9ZnVuY3Rpb24odCxuKXtuPyhlLnN0ZGVyci53cml0ZShcIkZhdGFsIFwiKyh0IGluc3RhbmNlb2YgRXJyb3I/dC5zdGFjazp0KStcIlxcblwiKSxlLmV4aXQoMikpOnRoaXMudGhyb3dMYXRlcih0KX0sby5wcm90b3R5cGUudGhyb3dMYXRlcj1mdW5jdGlvbih0LGUpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiYoZT10LHQ9ZnVuY3Rpb24oKXt0aHJvdyBlfSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNldFRpbWVvdXQpc2V0VGltZW91dChmdW5jdGlvbigpe3QoZSl9LDApO2Vsc2UgdHJ5e3RoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCl7dChlKX0pfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpfX0sZi5oYXNEZXZUb29scz8oby5wcm90b3R5cGUuaW52b2tlTGF0ZXI9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX3RyYW1wb2xpbmVFbmFibGVkP2kuY2FsbCh0aGlzLHQsZSxuKTp0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0LmNhbGwoZSxuKX0sMTAwKX0pfSxvLnByb3RvdHlwZS5pbnZva2U9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX3RyYW1wb2xpbmVFbmFibGVkP2EuY2FsbCh0aGlzLHQsZSxuKTp0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpe3QuY2FsbChlLG4pfSl9LG8ucHJvdG90eXBlLnNldHRsZVByb21pc2VzPWZ1bmN0aW9uKHQpe3RoaXMuX3RyYW1wb2xpbmVFbmFibGVkP3MuY2FsbCh0aGlzLHQpOnRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCl7dC5fc2V0dGxlUHJvbWlzZXMoKX0pfSk6KG8ucHJvdG90eXBlLmludm9rZUxhdGVyPWksby5wcm90b3R5cGUuaW52b2tlPWEsby5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXM9cyksby5wcm90b3R5cGUuX2RyYWluUXVldWU9ZnVuY3Rpb24odCl7Zm9yKDt0Lmxlbmd0aCgpPjA7KXt2YXIgZT10LnNoaWZ0KCk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSl7dmFyIG49dC5zaGlmdCgpLHI9dC5zaGlmdCgpO2UuY2FsbChuLHIpfWVsc2UgZS5fc2V0dGxlUHJvbWlzZXMoKX19LG8ucHJvdG90eXBlLl9kcmFpblF1ZXVlcz1mdW5jdGlvbigpe3RoaXMuX2RyYWluUXVldWUodGhpcy5fbm9ybWFsUXVldWUpLHRoaXMuX3Jlc2V0KCksdGhpcy5faGF2ZURyYWluZWRRdWV1ZXM9ITAsdGhpcy5fZHJhaW5RdWV1ZSh0aGlzLl9sYXRlUXVldWUpfSxvLnByb3RvdHlwZS5fcXVldWVUaWNrPWZ1bmN0aW9uKCl7dGhpcy5faXNUaWNrVXNlZHx8KHRoaXMuX2lzVGlja1VzZWQ9ITAsdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcykpfSxvLnByb3RvdHlwZS5fcmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9pc1RpY2tVc2VkPSExfSxuLmV4cG9ydHM9byxuLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3I9dX0se1wiLi9xdWV1ZVwiOjI2LFwiLi9zY2hlZHVsZVwiOjI5LFwiLi91dGlsXCI6MzZ9XSwzOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPSExLGk9ZnVuY3Rpb24odCxlKXt0aGlzLl9yZWplY3QoZSl9LGE9ZnVuY3Rpb24odCxlKXtlLnByb21pc2VSZWplY3Rpb25RdWV1ZWQ9ITAsZS5iaW5kaW5nUHJvbWlzZS5fdGhlbihpLGksbnVsbCx0aGlzLHQpfSxzPWZ1bmN0aW9uKHQsZSl7MD09PSg1MDM5NzE4NCZ0aGlzLl9iaXRGaWVsZCkmJnRoaXMuX3Jlc29sdmVDYWxsYmFjayhlLnRhcmdldCl9LHU9ZnVuY3Rpb24odCxlKXtlLnByb21pc2VSZWplY3Rpb25RdWV1ZWR8fHRoaXMuX3JlamVjdCh0KX07dC5wcm90b3R5cGUuYmluZD1mdW5jdGlvbihpKXtvfHwobz0hMCx0LnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbT1yLnByb3BhZ2F0ZUZyb21GdW5jdGlvbigpLHQucHJvdG90eXBlLl9ib3VuZFZhbHVlPXIuYm91bmRWYWx1ZUZ1bmN0aW9uKCkpO3ZhciBsPW4oaSksYz1uZXcgdChlKTtjLl9wcm9wYWdhdGVGcm9tKHRoaXMsMSk7dmFyIGY9dGhpcy5fdGFyZ2V0KCk7aWYoYy5fc2V0Qm91bmRUbyhsKSxsIGluc3RhbmNlb2YgdCl7dmFyIHA9e3Byb21pc2VSZWplY3Rpb25RdWV1ZWQ6ITEscHJvbWlzZTpjLHRhcmdldDpmLGJpbmRpbmdQcm9taXNlOmx9O2YuX3RoZW4oZSxhLHZvaWQgMCxjLHApLGwuX3RoZW4ocyx1LHZvaWQgMCxjLHApLGMuX3NldE9uQ2FuY2VsKGwpfWVsc2UgYy5fcmVzb2x2ZUNhbGxiYWNrKGYpO3JldHVybiBjfSx0LnByb3RvdHlwZS5fc2V0Qm91bmRUbz1mdW5jdGlvbih0KXt2b2lkIDAhPT10Pyh0aGlzLl9iaXRGaWVsZD0yMDk3MTUyfHRoaXMuX2JpdEZpZWxkLHRoaXMuX2JvdW5kVG89dCk6dGhpcy5fYml0RmllbGQ9dGhpcy5fYml0RmllbGQmLTIwOTcxNTN9LHQucHJvdG90eXBlLl9pc0JvdW5kPWZ1bmN0aW9uKCl7cmV0dXJuIDIwOTcxNTI9PT0oMjA5NzE1MiZ0aGlzLl9iaXRGaWVsZCl9LHQuYmluZD1mdW5jdGlvbihlLG4pe3JldHVybiB0LnJlc29sdmUobikuYmluZChlKX19fSx7fV0sNDpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXt0cnl7UHJvbWlzZT09PWkmJihQcm9taXNlPW8pfWNhdGNoKHQpe31yZXR1cm4gaX12YXIgbztcInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSYmKG89UHJvbWlzZSk7dmFyIGk9dChcIi4vcHJvbWlzZVwiKSgpO2kubm9Db25mbGljdD1yLGUuZXhwb3J0cz1pfSx7XCIuL3Byb21pc2VcIjoyMn1dLDU6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1PYmplY3QuY3JlYXRlO2lmKHIpe3ZhciBvPXIobnVsbCksaT1yKG51bGwpO29bXCIgc2l6ZVwiXT1pW1wiIHNpemVcIl09MH1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbih0LG4pe3ZhciByO2lmKG51bGwhPXQmJihyPXRbbl0pLFwiZnVuY3Rpb25cIiE9dHlwZW9mIHIpe3ZhciBvPVwiT2JqZWN0IFwiK3MuY2xhc3NTdHJpbmcodCkrXCIgaGFzIG5vIG1ldGhvZCAnXCIrcy50b1N0cmluZyhuKStcIidcIjt0aHJvdyBuZXcgZS5UeXBlRXJyb3Iobyl9cmV0dXJuIHJ9ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLnBvcCgpLHI9bih0LGUpO3JldHVybiByLmFwcGx5KHQsdGhpcyl9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gdFt0aGlzXX1mdW5jdGlvbiBpKHQpe3ZhciBlPSt0aGlzO3JldHVybiBlPDAmJihlPU1hdGgubWF4KDAsZSt0Lmxlbmd0aCkpLHRbZV19dmFyIGEscz10KFwiLi91dGlsXCIpLHU9cy5jYW5FdmFsdWF0ZTtzLmlzSWRlbnRpZmllcjtlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQpe3ZhciBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBlLnB1c2godCksdGhpcy5fdGhlbihyLHZvaWQgMCx2b2lkIDAsZSx2b2lkIDApfSxlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7dmFyIGUsbj1cIm51bWJlclwiPT10eXBlb2YgdDtpZihuKWU9aTtlbHNlIGlmKHUpe3ZhciByPWEodCk7ZT1udWxsIT09cj9yOm99ZWxzZSBlPW87cmV0dXJuIHRoaXMuX3RoZW4oZSx2b2lkIDAsdm9pZCAwLHQsdm9pZCAwKX19fSx7XCIuL3V0aWxcIjozNn1dLDY6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsbyl7dmFyIGk9dChcIi4vdXRpbFwiKSxhPWkudHJ5Q2F0Y2gscz1pLmVycm9yT2JqLHU9ZS5fYXN5bmM7ZS5wcm90b3R5cGUuYnJlYWs9ZS5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKCl7aWYoIW8uY2FuY2VsbGF0aW9uKCkpcmV0dXJuIHRoaXMuX3dhcm4oXCJjYW5jZWxsYXRpb24gaXMgZGlzYWJsZWRcIik7Zm9yKHZhciB0PXRoaXMsZT10O3QuX2lzQ2FuY2VsbGFibGUoKTspe2lmKCF0Ll9jYW5jZWxCeShlKSl7ZS5faXNGb2xsb3dpbmcoKT9lLl9mb2xsb3dlZSgpLmNhbmNlbCgpOmUuX2NhbmNlbEJyYW5jaGVkKCk7YnJlYWt9dmFyIG49dC5fY2FuY2VsbGF0aW9uUGFyZW50O2lmKG51bGw9PW58fCFuLl9pc0NhbmNlbGxhYmxlKCkpe3QuX2lzRm9sbG93aW5nKCk/dC5fZm9sbG93ZWUoKS5jYW5jZWwoKTp0Ll9jYW5jZWxCcmFuY2hlZCgpO2JyZWFrfXQuX2lzRm9sbG93aW5nKCkmJnQuX2ZvbGxvd2VlKCkuY2FuY2VsKCksdC5fc2V0V2lsbEJlQ2FuY2VsbGVkKCksZT10LHQ9bn19LGUucHJvdG90eXBlLl9icmFuY2hIYXNDYW5jZWxsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsLS19LGUucHJvdG90eXBlLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbHx8dGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbDw9MH0sZS5wcm90b3R5cGUuX2NhbmNlbEJ5PWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcz8odGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbD0wLHRoaXMuX2ludm9rZU9uQ2FuY2VsKCksITApOih0aGlzLl9icmFuY2hIYXNDYW5jZWxsZWQoKSwhIXRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpJiYodGhpcy5faW52b2tlT25DYW5jZWwoKSwhMCkpfSxlLnByb3RvdHlwZS5fY2FuY2VsQnJhbmNoZWQ9ZnVuY3Rpb24oKXt0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSYmdGhpcy5fY2FuY2VsKCl9LGUucHJvdG90eXBlLl9jYW5jZWw9ZnVuY3Rpb24oKXt0aGlzLl9pc0NhbmNlbGxhYmxlKCkmJih0aGlzLl9zZXRDYW5jZWxsZWQoKSx1Lmludm9rZSh0aGlzLl9jYW5jZWxQcm9taXNlcyx0aGlzLHZvaWQgMCkpfSxlLnByb3RvdHlwZS5fY2FuY2VsUHJvbWlzZXM9ZnVuY3Rpb24oKXt0aGlzLl9sZW5ndGgoKT4wJiZ0aGlzLl9zZXR0bGVQcm9taXNlcygpfSxlLnByb3RvdHlwZS5fdW5zZXRPbkNhbmNlbD1mdW5jdGlvbigpe3RoaXMuX29uQ2FuY2VsRmllbGQ9dm9pZCAwfSxlLnByb3RvdHlwZS5faXNDYW5jZWxsYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUGVuZGluZygpJiYhdGhpcy5faXNDYW5jZWxsZWQoKX0sZS5wcm90b3R5cGUuaXNDYW5jZWxsYWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUGVuZGluZygpJiYhdGhpcy5pc0NhbmNlbGxlZCgpfSxlLnByb3RvdHlwZS5fZG9JbnZva2VPbkNhbmNlbD1mdW5jdGlvbih0LGUpe2lmKGkuaXNBcnJheSh0KSlmb3IodmFyIG49MDtuPHQubGVuZ3RoOysrbil0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKHRbbl0sZSk7ZWxzZSBpZih2b2lkIDAhPT10KWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpe2lmKCFlKXt2YXIgcj1hKHQpLmNhbGwodGhpcy5fYm91bmRWYWx1ZSgpKTtyPT09cyYmKHRoaXMuX2F0dGFjaEV4dHJhVHJhY2Uoci5lKSxcbnUudGhyb3dMYXRlcihyLmUpKX19ZWxzZSB0Ll9yZXN1bHRDYW5jZWxsZWQodGhpcyl9LGUucHJvdG90eXBlLl9pbnZva2VPbkNhbmNlbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX29uQ2FuY2VsKCk7dGhpcy5fdW5zZXRPbkNhbmNlbCgpLHUuaW52b2tlKHRoaXMuX2RvSW52b2tlT25DYW5jZWwsdGhpcyx0KX0sZS5wcm90b3R5cGUuX2ludm9rZUludGVybmFsT25DYW5jZWw9ZnVuY3Rpb24oKXt0aGlzLl9pc0NhbmNlbGxhYmxlKCkmJih0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKHRoaXMuX29uQ2FuY2VsKCksITApLHRoaXMuX3Vuc2V0T25DYW5jZWwoKSl9LGUucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQ9ZnVuY3Rpb24oKXt0aGlzLmNhbmNlbCgpfX19LHtcIi4vdXRpbFwiOjM2fV0sNzpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsbixzKXtyZXR1cm4gZnVuY3Rpb24odSl7dmFyIGw9cy5fYm91bmRWYWx1ZSgpO3Q6Zm9yKHZhciBjPTA7Yzx0Lmxlbmd0aDsrK2Mpe3ZhciBmPXRbY107aWYoZj09PUVycm9yfHxudWxsIT1mJiZmLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yKXtpZih1IGluc3RhbmNlb2YgZilyZXR1cm4gaShuKS5jYWxsKGwsdSl9ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmKXt2YXIgcD1pKGYpLmNhbGwobCx1KTtpZihwPT09YSlyZXR1cm4gcDtpZihwKXJldHVybiBpKG4pLmNhbGwobCx1KX1lbHNlIGlmKHIuaXNPYmplY3QodSkpe2Zvcih2YXIgaD1vKGYpLGQ9MDtkPGgubGVuZ3RoOysrZCl7dmFyIHY9aFtkXTtpZihmW3ZdIT11W3ZdKWNvbnRpbnVlIHR9cmV0dXJuIGkobikuY2FsbChsLHUpfX1yZXR1cm4gZX19dmFyIHI9dChcIi4vdXRpbFwiKSxvPXQoXCIuL2VzNVwiKS5rZXlzLGk9ci50cnlDYXRjaCxhPXIuZXJyb3JPYmo7cmV0dXJuIG59fSx7XCIuL2VzNVwiOjEzLFwiLi91dGlsXCI6MzZ9XSw4OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt0aGlzLl90cmFjZT1uZXcgZS5DYXB0dXJlZFRyYWNlKHIoKSl9ZnVuY3Rpb24gbigpe2lmKG8pcmV0dXJuIG5ldyBlfWZ1bmN0aW9uIHIoKXt2YXIgdD1pLmxlbmd0aC0xO2lmKHQ+PTApcmV0dXJuIGlbdF19dmFyIG89ITEsaT1bXTtyZXR1cm4gdC5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkPWZ1bmN0aW9uKCl7fSx0LnByb3RvdHlwZS5fcHVzaENvbnRleHQ9ZnVuY3Rpb24oKXt9LHQucHJvdG90eXBlLl9wb3BDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LHQuX3BlZWtDb250ZXh0PXQucHJvdG90eXBlLl9wZWVrQ29udGV4dD1mdW5jdGlvbigpe30sZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0PWZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy5fdHJhY2UmJih0aGlzLl90cmFjZS5fcHJvbWlzZUNyZWF0ZWQ9bnVsbCxpLnB1c2godGhpcy5fdHJhY2UpKX0sZS5wcm90b3R5cGUuX3BvcENvbnRleHQ9ZnVuY3Rpb24oKXtpZih2b2lkIDAhPT10aGlzLl90cmFjZSl7dmFyIHQ9aS5wb3AoKSxlPXQuX3Byb21pc2VDcmVhdGVkO3JldHVybiB0Ll9wcm9taXNlQ3JlYXRlZD1udWxsLGV9cmV0dXJuIG51bGx9LGUuQ2FwdHVyZWRUcmFjZT1udWxsLGUuY3JlYXRlPW4sZS5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzPWZ1bmN0aW9uKCl7fSxlLmFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzPWZ1bmN0aW9uKCl7dmFyIG49dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0LGk9dC5wcm90b3R5cGUuX3BvcENvbnRleHQsYT10Ll9wZWVrQ29udGV4dCxzPXQucHJvdG90eXBlLl9wZWVrQ29udGV4dCx1PXQucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZDtlLmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXM9ZnVuY3Rpb24oKXt0LnByb3RvdHlwZS5fcHVzaENvbnRleHQ9bix0LnByb3RvdHlwZS5fcG9wQ29udGV4dD1pLHQuX3BlZWtDb250ZXh0PWEsdC5wcm90b3R5cGUuX3BlZWtDb250ZXh0PXMsdC5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkPXUsbz0hMX0sbz0hMCx0LnByb3RvdHlwZS5fcHVzaENvbnRleHQ9ZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0LHQucHJvdG90eXBlLl9wb3BDb250ZXh0PWUucHJvdG90eXBlLl9wb3BDb250ZXh0LHQuX3BlZWtDb250ZXh0PXQucHJvdG90eXBlLl9wZWVrQ29udGV4dD1yLHQucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX3BlZWtDb250ZXh0KCk7dCYmbnVsbD09dC5fcHJvbWlzZUNyZWF0ZWQmJih0Ll9wcm9taXNlQ3JlYXRlZD10aGlzKX19LGV9fSx7fV0sOTpbZnVuY3Rpb24odCxuLHIpe1widXNlIHN0cmljdFwiO24uZXhwb3J0cz1mdW5jdGlvbihuLHIpe2Z1bmN0aW9uIG8odCxlKXtyZXR1cm57cHJvbWlzZTplfX1mdW5jdGlvbiBpKCl7cmV0dXJuITF9ZnVuY3Rpb24gYSh0LGUsbil7dmFyIHI9dGhpczt0cnl7dChlLG4sZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwib25DYW5jZWwgbXVzdCBiZSBhIGZ1bmN0aW9uLCBnb3Q6IFwiK0QudG9TdHJpbmcodCkpO3IuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKHQpfSl9Y2F0Y2godCl7cmV0dXJuIHR9fWZ1bmN0aW9uIHModCl7aWYoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLl9vbkNhbmNlbCgpO3ZvaWQgMCE9PWU/RC5pc0FycmF5KGUpP2UucHVzaCh0KTp0aGlzLl9zZXRPbkNhbmNlbChbZSx0XSk6dGhpcy5fc2V0T25DYW5jZWwodCl9ZnVuY3Rpb24gdSgpe3JldHVybiB0aGlzLl9vbkNhbmNlbEZpZWxkfWZ1bmN0aW9uIGwodCl7dGhpcy5fb25DYW5jZWxGaWVsZD10fWZ1bmN0aW9uIGMoKXt0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQ9dm9pZCAwLHRoaXMuX29uQ2FuY2VsRmllbGQ9dm9pZCAwfWZ1bmN0aW9uIGYodCxlKXtpZigwIT09KDEmZSkpe3RoaXMuX2NhbmNlbGxhdGlvblBhcmVudD10O3ZhciBuPXQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw7dm9pZCAwPT09biYmKG49MCksdC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbD1uKzF9MCE9PSgyJmUpJiZ0Ll9pc0JvdW5kKCkmJnRoaXMuX3NldEJvdW5kVG8odC5fYm91bmRUbyl9ZnVuY3Rpb24gcCh0LGUpezAhPT0oMiZlKSYmdC5faXNCb3VuZCgpJiZ0aGlzLl9zZXRCb3VuZFRvKHQuX2JvdW5kVG8pfWZ1bmN0aW9uIGgoKXt2YXIgdD10aGlzLl9ib3VuZFRvO3JldHVybiB2b2lkIDAhPT10JiZ0IGluc3RhbmNlb2Ygbj90LmlzRnVsZmlsbGVkKCk/dC52YWx1ZSgpOnZvaWQgMDp0fWZ1bmN0aW9uIGQoKXt0aGlzLl90cmFjZT1uZXcgayh0aGlzLl9wZWVrQ29udGV4dCgpKX1mdW5jdGlvbiB2KHQsZSl7aWYoQih0KSl7dmFyIG49dGhpcy5fdHJhY2U7aWYodm9pZCAwIT09biYmZSYmKG49bi5fcGFyZW50KSx2b2lkIDAhPT1uKW4uYXR0YWNoRXh0cmFUcmFjZSh0KTtlbHNlIGlmKCF0Ll9fc3RhY2tDbGVhbmVkX18pe3ZhciByPVQodCk7RC5ub3RFbnVtZXJhYmxlUHJvcCh0LFwic3RhY2tcIixyLm1lc3NhZ2UrXCJcXG5cIityLnN0YWNrLmpvaW4oXCJcXG5cIikpLEQubm90RW51bWVyYWJsZVByb3AodCxcIl9fc3RhY2tDbGVhbmVkX19cIiwhMCl9fX1mdW5jdGlvbiBtKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09dCYmbnVsbCE9PWUmJiQpe2lmKHZvaWQgMCE9PW8mJm8uX3JldHVybmVkTm9uVW5kZWZpbmVkKCkpcmV0dXJuO2lmKDA9PT0oNjU1MzUmci5fYml0RmllbGQpKXJldHVybjtuJiYobis9XCIgXCIpO3ZhciBpPVwiXCIsYT1cIlwiO2lmKGUuX3RyYWNlKXtmb3IodmFyIHM9ZS5fdHJhY2Uuc3RhY2suc3BsaXQoXCJcXG5cIiksdT14KHMpLGw9dS5sZW5ndGgtMTtsPj0wOy0tbCl7dmFyIGM9dVtsXTtpZighVy50ZXN0KGMpKXt2YXIgZj1jLm1hdGNoKFgpO2YmJihpPVwiYXQgXCIrZlsxXStcIjpcIitmWzJdK1wiOlwiK2ZbM10rXCIgXCIpO2JyZWFrfX1pZih1Lmxlbmd0aD4wKWZvcih2YXIgcD11WzBdLGw9MDtsPHMubGVuZ3RoOysrbClpZihzW2xdPT09cCl7bD4wJiYoYT1cIlxcblwiK3NbbC0xXSk7YnJlYWt9fXZhciBoPVwiYSBwcm9taXNlIHdhcyBjcmVhdGVkIGluIGEgXCIrbitcImhhbmRsZXIgXCIraStcImJ1dCB3YXMgbm90IHJldHVybmVkIGZyb20gaXQsIHNlZSBodHRwOi8vZ29vLmdsL3JScU1Vd1wiK2E7ci5fd2FybihoLCEwLGUpfX1mdW5jdGlvbiBfKHQsZSl7dmFyIG49dCtcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIjtyZXR1cm4gZSYmKG4rPVwiIFVzZSBcIitlK1wiIGluc3RlYWQuXCIpLGcobil9ZnVuY3Rpb24gZyh0LGUscil7aWYoYXQud2FybmluZ3Mpe3ZhciBvLGk9bmV3IEwodCk7aWYoZSlyLl9hdHRhY2hFeHRyYVRyYWNlKGkpO2Vsc2UgaWYoYXQubG9uZ1N0YWNrVHJhY2VzJiYobz1uLl9wZWVrQ29udGV4dCgpKSlvLmF0dGFjaEV4dHJhVHJhY2UoaSk7ZWxzZXt2YXIgYT1UKGkpO2kuc3RhY2s9YS5tZXNzYWdlK1wiXFxuXCIrYS5zdGFjay5qb2luKFwiXFxuXCIpfWV0KFwid2FybmluZ1wiLGkpfHxPKGksXCJcIiwhMCl9fWZ1bmN0aW9uIHkodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoLTE7KytuKWVbbl0ucHVzaChcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCIpLGVbbl09ZVtuXS5qb2luKFwiXFxuXCIpO3JldHVybiBuPGUubGVuZ3RoJiYoZVtuXT1lW25dLmpvaW4oXCJcXG5cIikpLHQrXCJcXG5cIitlLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gYih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoOysrZSkoMD09PXRbZV0ubGVuZ3RofHxlKzE8dC5sZW5ndGgmJnRbZV1bMF09PT10W2UrMV1bMF0pJiYodC5zcGxpY2UoZSwxKSxlLS0pfWZ1bmN0aW9uIHcodCl7Zm9yKHZhciBlPXRbMF0sbj0xO248dC5sZW5ndGg7KytuKXtmb3IodmFyIHI9dFtuXSxvPWUubGVuZ3RoLTEsaT1lW29dLGE9LTEscz1yLmxlbmd0aC0xO3M+PTA7LS1zKWlmKHJbc109PT1pKXthPXM7YnJlYWt9Zm9yKHZhciBzPWE7cz49MDstLXMpe3ZhciB1PXJbc107aWYoZVtvXSE9PXUpYnJlYWs7ZS5wb3AoKSxvLS19ZT1yfX1mdW5jdGlvbiB4KHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciByPXRbbl0sbz1cIiAgICAoTm8gc3RhY2sgdHJhY2UpXCI9PT1yfHx6LnRlc3QociksaT1vJiZydChyKTtvJiYhaSYmKHEmJlwiIFwiIT09ci5jaGFyQXQoMCkmJihyPVwiICAgIFwiK3IpLGUucHVzaChyKSl9cmV0dXJuIGV9ZnVuY3Rpb24gRSh0KXtmb3IodmFyIGU9dC5zdGFjay5yZXBsYWNlKC9cXHMrJC9nLFwiXCIpLnNwbGl0KFwiXFxuXCIpLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZVtuXTtpZihcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCI9PT1yfHx6LnRlc3QocikpYnJlYWt9cmV0dXJuIG4+MCYmXCJTeW50YXhFcnJvclwiIT10Lm5hbWUmJihlPWUuc2xpY2UobikpLGV9ZnVuY3Rpb24gVCh0KXt2YXIgZT10LnN0YWNrLG49dC50b1N0cmluZygpO3JldHVybiBlPVwic3RyaW5nXCI9PXR5cGVvZiBlJiZlLmxlbmd0aD4wP0UodCk6W1wiICAgIChObyBzdGFjayB0cmFjZSlcIl0se21lc3NhZ2U6bixzdGFjazpcIlN5bnRheEVycm9yXCI9PXQubmFtZT9lOngoZSl9fWZ1bmN0aW9uIE8odCxlLG4pe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBjb25zb2xlKXt2YXIgcjtpZihELmlzT2JqZWN0KHQpKXt2YXIgbz10LnN0YWNrO3I9ZStHKG8sdCl9ZWxzZSByPWUrU3RyaW5nKHQpO1wiZnVuY3Rpb25cIj09dHlwZW9mIE4/TihyLG4pOlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNvbnNvbGUubG9nJiZcIm9iamVjdFwiIT10eXBlb2YgY29uc29sZS5sb2d8fGNvbnNvbGUubG9nKHIpfX1mdW5jdGlvbiBTKHQsZSxuLHIpe3ZhciBvPSExO3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYobz0hMCxcInJlamVjdGlvbkhhbmRsZWRcIj09PXQ/ZShyKTplKG4scikpfWNhdGNoKHQpe0YudGhyb3dMYXRlcih0KX1cInVuaGFuZGxlZFJlamVjdGlvblwiPT09dD9ldCh0LG4scil8fG98fE8obixcIlVuaGFuZGxlZCByZWplY3Rpb24gXCIpOmV0KHQscil9ZnVuY3Rpb24gUCh0KXt2YXIgZTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KWU9XCJbZnVuY3Rpb24gXCIrKHQubmFtZXx8XCJhbm9ueW1vdXNcIikrXCJdXCI7ZWxzZXtlPXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudG9TdHJpbmc/dC50b1N0cmluZygpOkQudG9TdHJpbmcodCk7dmFyIG49L1xcW29iamVjdCBbYS16QS1aMC05JF9dK1xcXS87aWYobi50ZXN0KGUpKXRyeXt2YXIgcj1KU09OLnN0cmluZ2lmeSh0KTtlPXJ9Y2F0Y2godCl7fTA9PT1lLmxlbmd0aCYmKGU9XCIoZW1wdHkgYXJyYXkpXCIpfXJldHVyblwiKDxcIitNKGUpK1wiPiwgbm8gc3RhY2sgdHJhY2UpXCJ9ZnVuY3Rpb24gTSh0KXt2YXIgZT00MTtyZXR1cm4gdC5sZW5ndGg8ZT90OnQuc3Vic3RyKDAsZS0zKStcIi4uLlwifWZ1bmN0aW9uIGooKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBpdH1mdW5jdGlvbiBBKHQpe3ZhciBlPXQubWF0Y2gob3QpO2lmKGUpcmV0dXJue2ZpbGVOYW1lOmVbMV0sbGluZTpwYXJzZUludChlWzJdLDEwKX19ZnVuY3Rpb24gQyh0LGUpe2lmKGooKSl7Zm9yKHZhciBuLHIsbz10LnN0YWNrLnNwbGl0KFwiXFxuXCIpLGk9ZS5zdGFjay5zcGxpdChcIlxcblwiKSxhPS0xLHM9LTEsdT0wO3U8by5sZW5ndGg7Kyt1KXt2YXIgbD1BKG9bdV0pO2lmKGwpe249bC5maWxlTmFtZSxhPWwubGluZTticmVha319Zm9yKHZhciB1PTA7dTxpLmxlbmd0aDsrK3Upe3ZhciBsPUEoaVt1XSk7aWYobCl7cj1sLmZpbGVOYW1lLHM9bC5saW5lO2JyZWFrfX1hPDB8fHM8MHx8IW58fCFyfHxuIT09cnx8YT49c3x8KHJ0PWZ1bmN0aW9uKHQpe2lmKFYudGVzdCh0KSlyZXR1cm4hMDt2YXIgZT1BKHQpO3JldHVybiEhKGUmJmUuZmlsZU5hbWU9PT1uJiZhPD1lLmxpbmUmJmUubGluZTw9cyl9KX19ZnVuY3Rpb24gayh0KXt0aGlzLl9wYXJlbnQ9dCx0aGlzLl9wcm9taXNlc0NyZWF0ZWQ9MDt2YXIgZT10aGlzLl9sZW5ndGg9MSsodm9pZCAwPT09dD8wOnQuX2xlbmd0aCk7aXQodGhpcyxrKSxlPjMyJiZ0aGlzLnVuY3ljbGUoKX12YXIgUixJLE4sVT1uLl9nZXREb21haW4sRj1uLl9hc3luYyxMPXQoXCIuL2Vycm9yc1wiKS5XYXJuaW5nLEQ9dChcIi4vdXRpbFwiKSxCPUQuY2FuQXR0YWNoVHJhY2UsVj0vW1xcXFxcXC9dYmx1ZWJpcmRbXFxcXFxcL11qc1tcXFxcXFwvXShyZWxlYXNlfGRlYnVnfGluc3RydW1lbnRlZCkvLFc9L1xcKCg/OnRpbWVyc1xcLmpzKTpcXGQrOlxcZCtcXCkvLFg9L1tcXC88XFwoXSguKz8pOihcXGQrKTooXFxkKylcXCk/XFxzKiQvLHo9bnVsbCxHPW51bGwscT0hMSxIPSEoMD09RC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSksWT0hKDA9PUQuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIil8fCFIJiYhRC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSksSz0hKDA9PUQuZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIil8fCFIJiYhRC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSksJD0wIT1ELmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSYmKFl8fCEhRC5lbnYoXCJCTFVFQklSRF9XX0ZPUkdPVFRFTl9SRVRVUk5cIikpO24ucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX3RhcmdldCgpO3QuX2JpdEZpZWxkPXQuX2JpdEZpZWxkJi0xMDQ4NTc3fDUyNDI4OH0sbi5wcm90b3R5cGUuX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZD1mdW5jdGlvbigpezA9PT0oNTI0Mjg4JnRoaXMuX2JpdEZpZWxkKSYmKHRoaXMuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkKCksRi5pbnZva2VMYXRlcih0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24sdGhpcyx2b2lkIDApKX0sbi5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZD1mdW5jdGlvbigpe1MoXCJyZWplY3Rpb25IYW5kbGVkXCIsUix2b2lkIDAsdGhpcyl9LG4ucHJvdG90eXBlLl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZD1mdW5jdGlvbigpe3RoaXMuX2JpdEZpZWxkPTI2ODQzNTQ1Nnx0aGlzLl9iaXRGaWVsZH0sbi5wcm90b3R5cGUuX3JldHVybmVkTm9uVW5kZWZpbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT0oMjY4NDM1NDU2JnRoaXMuX2JpdEZpZWxkKX0sbi5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMuX2lzUmVqZWN0aW9uVW5oYW5kbGVkKCkpe3ZhciB0PXRoaXMuX3NldHRsZWRWYWx1ZSgpO3RoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKSxTKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsSSx0LHRoaXMpfX0sbi5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD0yNjIxNDR8dGhpcy5fYml0RmllbGR9LG4ucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD10aGlzLl9iaXRGaWVsZCYtMjYyMTQ1fSxuLnByb3RvdHlwZS5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZD1mdW5jdGlvbigpe3JldHVybigyNjIxNDQmdGhpcy5fYml0RmllbGQpPjB9LG4ucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZD1mdW5jdGlvbigpe3RoaXMuX2JpdEZpZWxkPTEwNDg1NzZ8dGhpcy5fYml0RmllbGR9LG4ucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9dGhpcy5fYml0RmllbGQmLTEwNDg1NzcsdGhpcy5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCgpJiYodGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCksdGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkKCkpfSxuLnByb3RvdHlwZS5faXNSZWplY3Rpb25VbmhhbmRsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4oMTA0ODU3NiZ0aGlzLl9iaXRGaWVsZCk+MH0sbi5wcm90b3R5cGUuX3dhcm49ZnVuY3Rpb24odCxlLG4pe3JldHVybiBnKHQsZSxufHx0aGlzKX0sbi5vblBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPVUoKTtJPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/bnVsbD09PWU/dDpELmRvbWFpbkJpbmQoZSx0KTp2b2lkIDB9LG4ub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkPWZ1bmN0aW9uKHQpe3ZhciBlPVUoKTtSPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/bnVsbD09PWU/dDpELmRvbWFpbkJpbmQoZSx0KTp2b2lkIDB9O3ZhciBaPWZ1bmN0aW9uKCl7fTtuLmxvbmdTdGFja1RyYWNlcz1mdW5jdGlvbigpe2lmKEYuaGF2ZUl0ZW1zUXVldWVkKCkmJiFhdC5sb25nU3RhY2tUcmFjZXMpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7aWYoIWF0LmxvbmdTdGFja1RyYWNlcyYmaigpKXt2YXIgdD1uLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UsZT1uLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZTthdC5sb25nU3RhY2tUcmFjZXM9ITAsWj1mdW5jdGlvbigpe2lmKEYuaGF2ZUl0ZW1zUXVldWVkKCkmJiFhdC5sb25nU3RhY2tUcmFjZXMpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7bi5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlPXQsbi5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2U9ZSxyLmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKSxGLmVuYWJsZVRyYW1wb2xpbmUoKSxhdC5sb25nU3RhY2tUcmFjZXM9ITF9LG4ucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZT1kLG4ucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlPXYsci5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpLEYuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSgpfX0sbi5oYXNMb25nU3RhY2tUcmFjZXM9ZnVuY3Rpb24oKXtyZXR1cm4gYXQubG9uZ1N0YWNrVHJhY2VzJiZqKCl9O3ZhciBRPWZ1bmN0aW9uKCl7dHJ5e2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIEN1c3RvbUV2ZW50KXt2YXIgdD1uZXcgQ3VzdG9tRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyZXR1cm4gRC5nbG9iYWwuZGlzcGF0Y2hFdmVudCh0KSxmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBDdXN0b21FdmVudCh0LnRvTG93ZXJDYXNlKCkse2RldGFpbDplLGNhbmNlbGFibGU6ITB9KTtyZXR1cm4hRC5nbG9iYWwuZGlzcGF0Y2hFdmVudChuKX19aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgRXZlbnQpe3ZhciB0PW5ldyBFdmVudChcIkN1c3RvbUV2ZW50XCIpO3JldHVybiBELmdsb2JhbC5kaXNwYXRjaEV2ZW50KHQpLGZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEV2ZW50KHQudG9Mb3dlckNhc2UoKSx7Y2FuY2VsYWJsZTohMH0pO3JldHVybiBuLmRldGFpbD1lLCFELmdsb2JhbC5kaXNwYXRjaEV2ZW50KG4pfX12YXIgdD1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO3JldHVybiB0LmluaXRDdXN0b21FdmVudChcInRlc3Rpbmd0aGVldmVudFwiLCExLCEwLHt9KSxELmdsb2JhbC5kaXNwYXRjaEV2ZW50KHQpLGZ1bmN0aW9uKHQsZSl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyZXR1cm4gbi5pbml0Q3VzdG9tRXZlbnQodC50b0xvd2VyQ2FzZSgpLCExLCEwLGUpLCFELmdsb2JhbC5kaXNwYXRjaEV2ZW50KG4pfX1jYXRjaCh0KXt9cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuITF9fSgpLEo9ZnVuY3Rpb24oKXtyZXR1cm4gRC5pc05vZGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5lbWl0LmFwcGx5KGUsYXJndW1lbnRzKX06RC5nbG9iYWw/ZnVuY3Rpb24odCl7dmFyIGU9XCJvblwiK3QudG9Mb3dlckNhc2UoKSxuPUQuZ2xvYmFsW2VdO3JldHVybiEhbiYmKG4uYXBwbHkoRC5nbG9iYWwsW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpLCEwKX06ZnVuY3Rpb24oKXtyZXR1cm4hMX19KCksdHQ9e3Byb21pc2VDcmVhdGVkOm8scHJvbWlzZUZ1bGZpbGxlZDpvLHByb21pc2VSZWplY3RlZDpvLHByb21pc2VSZXNvbHZlZDpvLHByb21pc2VDYW5jZWxsZWQ6byxwcm9taXNlQ2hhaW5lZDpmdW5jdGlvbih0LGUsbil7cmV0dXJue3Byb21pc2U6ZSxjaGlsZDpufX0sd2FybmluZzpmdW5jdGlvbih0LGUpe3JldHVybnt3YXJuaW5nOmV9fSx1bmhhbmRsZWRSZWplY3Rpb246ZnVuY3Rpb24odCxlLG4pe3JldHVybntyZWFzb246ZSxwcm9taXNlOm59fSxyZWplY3Rpb25IYW5kbGVkOm99LGV0PWZ1bmN0aW9uKHQpe3ZhciBlPSExO3RyeXtlPUouYXBwbHkobnVsbCxhcmd1bWVudHMpfWNhdGNoKHQpe0YudGhyb3dMYXRlcih0KSxlPSEwfXZhciBuPSExO3RyeXtuPVEodCx0dFt0XS5hcHBseShudWxsLGFyZ3VtZW50cykpfWNhdGNoKHQpe0YudGhyb3dMYXRlcih0KSxuPSEwfXJldHVybiBufHxlfTtuLmNvbmZpZz1mdW5jdGlvbih0KXtpZih0PU9iamVjdCh0KSxcImxvbmdTdGFja1RyYWNlc1wiaW4gdCYmKHQubG9uZ1N0YWNrVHJhY2VzP24ubG9uZ1N0YWNrVHJhY2VzKCk6IXQubG9uZ1N0YWNrVHJhY2VzJiZuLmhhc0xvbmdTdGFja1RyYWNlcygpJiZaKCkpLFwid2FybmluZ3NcImluIHQpe3ZhciBlPXQud2FybmluZ3M7YXQud2FybmluZ3M9ISFlLCQ9YXQud2FybmluZ3MsRC5pc09iamVjdChlKSYmXCJ3Rm9yZ290dGVuUmV0dXJuXCJpbiBlJiYoJD0hIWUud0ZvcmdvdHRlblJldHVybil9aWYoXCJjYW5jZWxsYXRpb25cImluIHQmJnQuY2FuY2VsbGF0aW9uJiYhYXQuY2FuY2VsbGF0aW9uKXtpZihGLmhhdmVJdGVtc1F1ZXVlZCgpKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgY2FuY2VsbGF0aW9uIGFmdGVyIHByb21pc2VzIGFyZSBpbiB1c2VcIik7bi5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YT1jLG4ucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tPWYsbi5wcm90b3R5cGUuX29uQ2FuY2VsPXUsbi5wcm90b3R5cGUuX3NldE9uQ2FuY2VsPWwsbi5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrPXMsbi5wcm90b3R5cGUuX2V4ZWN1dGU9YSxudD1mLGF0LmNhbmNlbGxhdGlvbj0hMH1yZXR1cm5cIm1vbml0b3JpbmdcImluIHQmJih0Lm1vbml0b3JpbmcmJiFhdC5tb25pdG9yaW5nPyhhdC5tb25pdG9yaW5nPSEwLG4ucHJvdG90eXBlLl9maXJlRXZlbnQ9ZXQpOiF0Lm1vbml0b3JpbmcmJmF0Lm1vbml0b3JpbmcmJihhdC5tb25pdG9yaW5nPSExLG4ucHJvdG90eXBlLl9maXJlRXZlbnQ9aSkpLG59LG4ucHJvdG90eXBlLl9maXJlRXZlbnQ9aSxuLnByb3RvdHlwZS5fZXhlY3V0ZT1mdW5jdGlvbih0LGUsbil7dHJ5e3QoZSxuKX1jYXRjaCh0KXtyZXR1cm4gdH19LG4ucHJvdG90eXBlLl9vbkNhbmNlbD1mdW5jdGlvbigpe30sbi5wcm90b3R5cGUuX3NldE9uQ2FuY2VsPWZ1bmN0aW9uKHQpe30sbi5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrPWZ1bmN0aW9uKHQpe30sbi5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlPWZ1bmN0aW9uKCl7fSxuLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZT1mdW5jdGlvbigpe30sbi5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YT1mdW5jdGlvbigpe30sbi5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb209ZnVuY3Rpb24odCxlKXt9O3ZhciBudD1wLHJ0PWZ1bmN0aW9uKCl7cmV0dXJuITF9LG90PS9bXFwvPFxcKF0oW146XFwvXSspOihcXGQrKTooPzpcXGQrKVxcKT9cXHMqJC87RC5pbmhlcml0cyhrLEVycm9yKSxyLkNhcHR1cmVkVHJhY2U9ayxrLnByb3RvdHlwZS51bmN5Y2xlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbGVuZ3RoO2lmKCEodDwyKSl7Zm9yKHZhciBlPVtdLG49e30scj0wLG89dGhpczt2b2lkIDAhPT1vOysrcillLnB1c2gobyksbz1vLl9wYXJlbnQ7dD10aGlzLl9sZW5ndGg9cjtmb3IodmFyIHI9dC0xO3I+PTA7LS1yKXt2YXIgaT1lW3JdLnN0YWNrO3ZvaWQgMD09PW5baV0mJihuW2ldPXIpfWZvcih2YXIgcj0wO3I8dDsrK3Ipe3ZhciBhPWVbcl0uc3RhY2sscz1uW2FdO2lmKHZvaWQgMCE9PXMmJnMhPT1yKXtzPjAmJihlW3MtMV0uX3BhcmVudD12b2lkIDAsZVtzLTFdLl9sZW5ndGg9MSksZVtyXS5fcGFyZW50PXZvaWQgMCxlW3JdLl9sZW5ndGg9MTt2YXIgdT1yPjA/ZVtyLTFdOnRoaXM7czx0LTE/KHUuX3BhcmVudD1lW3MrMV0sdS5fcGFyZW50LnVuY3ljbGUoKSx1Ll9sZW5ndGg9dS5fcGFyZW50Ll9sZW5ndGgrMSk6KHUuX3BhcmVudD12b2lkIDAsdS5fbGVuZ3RoPTEpO2Zvcih2YXIgbD11Ll9sZW5ndGgrMSxjPXItMjtjPj0wOy0tYyllW2NdLl9sZW5ndGg9bCxsKys7cmV0dXJufX19fSxrLnByb3RvdHlwZS5hdHRhY2hFeHRyYVRyYWNlPWZ1bmN0aW9uKHQpe2lmKCF0Ll9fc3RhY2tDbGVhbmVkX18pe3RoaXMudW5jeWNsZSgpO2Zvcih2YXIgZT1UKHQpLG49ZS5tZXNzYWdlLHI9W2Uuc3RhY2tdLG89dGhpczt2b2lkIDAhPT1vOylyLnB1c2goeChvLnN0YWNrLnNwbGl0KFwiXFxuXCIpKSksbz1vLl9wYXJlbnQ7dyhyKSxiKHIpLEQubm90RW51bWVyYWJsZVByb3AodCxcInN0YWNrXCIseShuLHIpKSxELm5vdEVudW1lcmFibGVQcm9wKHQsXCJfX3N0YWNrQ2xlYW5lZF9fXCIsITApfX07dmFyIGl0PWZ1bmN0aW9uKCl7dmFyIHQ9L15cXHMqYXRcXHMqLyxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/dDp2b2lkIDAhPT1lLm5hbWUmJnZvaWQgMCE9PWUubWVzc2FnZT9lLnRvU3RyaW5nKCk6UChlKX07aWYoXCJudW1iZXJcIj09dHlwZW9mIEVycm9yLnN0YWNrVHJhY2VMaW1pdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Upe0Vycm9yLnN0YWNrVHJhY2VMaW1pdCs9Nix6PXQsRz1lO3ZhciBuPUVycm9yLmNhcHR1cmVTdGFja1RyYWNlO3JldHVybiBydD1mdW5jdGlvbih0KXtyZXR1cm4gVi50ZXN0KHQpfSxmdW5jdGlvbih0LGUpe0Vycm9yLnN0YWNrVHJhY2VMaW1pdCs9NixuKHQsZSksRXJyb3Iuc3RhY2tUcmFjZUxpbWl0LT02fX12YXIgcj1uZXcgRXJyb3I7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHIuc3RhY2smJnIuc3RhY2suc3BsaXQoXCJcXG5cIilbMF0uaW5kZXhPZihcInN0YWNrRGV0ZWN0aW9uQFwiKT49MClyZXR1cm4gej0vQC8sRz1lLHE9ITAsZnVuY3Rpb24odCl7dC5zdGFjaz0obmV3IEVycm9yKS5zdGFja307dmFyIG87dHJ5e3Rocm93IG5ldyBFcnJvcn1jYXRjaCh0KXtvPVwic3RhY2tcImluIHR9cmV0dXJuXCJzdGFja1wiaW4gcnx8IW98fFwibnVtYmVyXCIhPXR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQ/KEc9ZnVuY3Rpb24odCxlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD90Olwib2JqZWN0XCIhPXR5cGVvZiBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlfHx2b2lkIDA9PT1lLm5hbWV8fHZvaWQgMD09PWUubWVzc2FnZT9QKGUpOmUudG9TdHJpbmcoKX0sbnVsbCk6KHo9dCxHPWUsZnVuY3Rpb24odCl7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0Kz02O3RyeXt0aHJvdyBuZXcgRXJyb3J9Y2F0Y2goZSl7dC5zdGFjaz1lLnN0YWNrfUVycm9yLnN0YWNrVHJhY2VMaW1pdC09Nn0pfShbXSk7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNvbnNvbGUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBjb25zb2xlLndhcm4mJihOPWZ1bmN0aW9uKHQpe2NvbnNvbGUud2Fybih0KX0sRC5pc05vZGUmJmUuc3RkZXJyLmlzVFRZP049ZnVuY3Rpb24odCxlKXt2YXIgbj1lP1wiXHUwMDFiWzMzbVwiOlwiXHUwMDFiWzMxbVwiO2NvbnNvbGUud2FybihuK3QrXCJcdTAwMWJbMG1cXG5cIil9OkQuaXNOb2RlfHxcInN0cmluZ1wiIT10eXBlb2YobmV3IEVycm9yKS5zdGFja3x8KE49ZnVuY3Rpb24odCxlKXtjb25zb2xlLndhcm4oXCIlY1wiK3QsZT9cImNvbG9yOiBkYXJrb3JhbmdlXCI6XCJjb2xvcjogcmVkXCIpfSkpO3ZhciBhdD17d2FybmluZ3M6WSxsb25nU3RhY2tUcmFjZXM6ITEsY2FuY2VsbGF0aW9uOiExLG1vbml0b3Jpbmc6ITF9O3JldHVybiBLJiZuLmxvbmdTdGFja1RyYWNlcygpLHtsb25nU3RhY2tUcmFjZXM6ZnVuY3Rpb24oKXtyZXR1cm4gYXQubG9uZ1N0YWNrVHJhY2VzfSx3YXJuaW5nczpmdW5jdGlvbigpe3JldHVybiBhdC53YXJuaW5nc30sY2FuY2VsbGF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGF0LmNhbmNlbGxhdGlvbn0sbW9uaXRvcmluZzpmdW5jdGlvbigpe3JldHVybiBhdC5tb25pdG9yaW5nfSxwcm9wYWdhdGVGcm9tRnVuY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gbnR9LGJvdW5kVmFsdWVGdW5jdGlvbjpmdW5jdGlvbigpe3JldHVybiBofSxjaGVja0ZvcmdvdHRlblJldHVybnM6bSxzZXRCb3VuZHM6Qyx3YXJuOmcsZGVwcmVjYXRlZDpfLENhcHR1cmVkVHJhY2U6ayxmaXJlRG9tRXZlbnQ6USxmaXJlR2xvYmFsRXZlbnQ6Sn19fSx7XCIuL2Vycm9yc1wiOjEyLFwiLi91dGlsXCI6MzZ9XSwxMDpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIHRoaXMudmFsdWV9ZnVuY3Rpb24gbigpe3Rocm93IHRoaXMucmVhc29ufXQucHJvdG90eXBlLnJldHVybj10LnByb3RvdHlwZS50aGVuUmV0dXJuPWZ1bmN0aW9uKG4pe3JldHVybiBuIGluc3RhbmNlb2YgdCYmbi5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKSx0aGlzLl90aGVuKGUsdm9pZCAwLHZvaWQgMCx7dmFsdWU6bn0sdm9pZCAwKX0sdC5wcm90b3R5cGUudGhyb3c9dC5wcm90b3R5cGUudGhlblRocm93PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90aGVuKG4sdm9pZCAwLHZvaWQgMCx7cmVhc29uOnR9LHZvaWQgMCl9LHQucHJvdG90eXBlLmNhdGNoVGhyb3c9ZnVuY3Rpb24odCl7aWYoYXJndW1lbnRzLmxlbmd0aDw9MSlyZXR1cm4gdGhpcy5fdGhlbih2b2lkIDAsbix2b2lkIDAse3JlYXNvbjp0fSx2b2lkIDApO3ZhciBlPWFyZ3VtZW50c1sxXSxyPWZ1bmN0aW9uKCl7dGhyb3cgZX07cmV0dXJuIHRoaXMuY2F1Z2h0KHQscil9LHQucHJvdG90eXBlLmNhdGNoUmV0dXJuPWZ1bmN0aW9uKG4pe2lmKGFyZ3VtZW50cy5sZW5ndGg8PTEpcmV0dXJuIG4gaW5zdGFuY2VvZiB0JiZuLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpLHRoaXMuX3RoZW4odm9pZCAwLGUsdm9pZCAwLHt2YWx1ZTpufSx2b2lkIDApO3ZhciByPWFyZ3VtZW50c1sxXTtyIGluc3RhbmNlb2YgdCYmci5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTt2YXIgbz1mdW5jdGlvbigpe3JldHVybiByfTtyZXR1cm4gdGhpcy5jYXVnaHQobixvKX19fSx7fV0sMTE6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7cmV0dXJuIGkodGhpcyl9ZnVuY3Rpb24gcih0LG4pe3JldHVybiBvKHQsbixlLGUpfXZhciBvPXQucmVkdWNlLGk9dC5hbGw7dC5wcm90b3R5cGUuZWFjaD1mdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQsZSwwKS5fdGhlbihuLHZvaWQgMCx2b2lkIDAsdGhpcyx2b2lkIDApfSx0LnByb3RvdHlwZS5tYXBTZXJpZXM9ZnVuY3Rpb24odCl7cmV0dXJuIG8odGhpcyx0LGUsZSl9LHQuZWFjaD1mdW5jdGlvbih0LHIpe3JldHVybiBvKHQscixlLDApLl90aGVuKG4sdm9pZCAwLHZvaWQgMCx0LHZvaWQgMCl9LHQubWFwU2VyaWVzPXJ9fSx7fV0sMTI6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSl7ZnVuY3Rpb24gbihyKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG4/KGYodGhpcyxcIm1lc3NhZ2VcIixcInN0cmluZ1wiPT10eXBlb2Ygcj9yOmUpLGYodGhpcyxcIm5hbWVcIix0KSx2b2lkKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsdGhpcy5jb25zdHJ1Y3Rvcik6RXJyb3IuY2FsbCh0aGlzKSkpOm5ldyBuKHIpfXJldHVybiBjKG4sRXJyb3IpLG59ZnVuY3Rpb24gbyh0KXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG8/KGYodGhpcyxcIm5hbWVcIixcIk9wZXJhdGlvbmFsRXJyb3JcIiksZih0aGlzLFwibWVzc2FnZVwiLHQpLHRoaXMuY2F1c2U9dCx0aGlzLmlzT3BlcmF0aW9uYWw9ITAsdm9pZCh0IGluc3RhbmNlb2YgRXJyb3I/KGYodGhpcyxcIm1lc3NhZ2VcIix0Lm1lc3NhZ2UpLGYodGhpcyxcInN0YWNrXCIsdC5zdGFjaykpOkVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpKSk6bmV3IG8odCl9dmFyIGksYSxzPXQoXCIuL2VzNVwiKSx1PXMuZnJlZXplLGw9dChcIi4vdXRpbFwiKSxjPWwuaW5oZXJpdHMsZj1sLm5vdEVudW1lcmFibGVQcm9wLHA9cihcIldhcm5pbmdcIixcIndhcm5pbmdcIiksaD1yKFwiQ2FuY2VsbGF0aW9uRXJyb3JcIixcImNhbmNlbGxhdGlvbiBlcnJvclwiKSxkPXIoXCJUaW1lb3V0RXJyb3JcIixcInRpbWVvdXQgZXJyb3JcIiksdj1yKFwiQWdncmVnYXRlRXJyb3JcIixcImFnZ3JlZ2F0ZSBlcnJvclwiKTt0cnl7aT1UeXBlRXJyb3IsYT1SYW5nZUVycm9yfWNhdGNoKHQpe2k9cihcIlR5cGVFcnJvclwiLFwidHlwZSBlcnJvclwiKSxhPXIoXCJSYW5nZUVycm9yXCIsXCJyYW5nZSBlcnJvclwiKX1mb3IodmFyIG09XCJqb2luIHBvcCBwdXNoIHNoaWZ0IHVuc2hpZnQgc2xpY2UgZmlsdGVyIGZvckVhY2ggc29tZSBldmVyeSBtYXAgaW5kZXhPZiBsYXN0SW5kZXhPZiByZWR1Y2UgcmVkdWNlUmlnaHQgc29ydCByZXZlcnNlXCIuc3BsaXQoXCIgXCIpLF89MDtfPG0ubGVuZ3RoOysrXylcImZ1bmN0aW9uXCI9PXR5cGVvZiBBcnJheS5wcm90b3R5cGVbbVtfXV0mJih2LnByb3RvdHlwZVttW19dXT1BcnJheS5wcm90b3R5cGVbbVtfXV0pO3MuZGVmaW5lUHJvcGVydHkodi5wcm90b3R5cGUsXCJsZW5ndGhcIix7dmFsdWU6MCxjb25maWd1cmFibGU6ITEsd3JpdGFibGU6ITAsZW51bWVyYWJsZTohMH0pLHYucHJvdG90eXBlLmlzT3BlcmF0aW9uYWw9ITA7dmFyIGc9MDt2LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciB0PUFycmF5KDQqZysxKS5qb2luKFwiIFwiKSxlPVwiXFxuXCIrdCtcIkFnZ3JlZ2F0ZUVycm9yIG9mOlxcblwiO2crKyx0PUFycmF5KDQqZysxKS5qb2luKFwiIFwiKTtmb3IodmFyIG49MDtuPHRoaXMubGVuZ3RoOysrbil7Zm9yKHZhciByPXRoaXNbbl09PT10aGlzP1wiW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXVwiOnRoaXNbbl0rXCJcIixvPXIuc3BsaXQoXCJcXG5cIiksaT0wO2k8by5sZW5ndGg7KytpKW9baV09dCtvW2ldO3I9by5qb2luKFwiXFxuXCIpLGUrPXIrXCJcXG5cIn1yZXR1cm4gZy0tLGV9LGMobyxFcnJvcik7dmFyIHk9RXJyb3IuX19CbHVlYmlyZEVycm9yVHlwZXNfXzt5fHwoeT11KHtDYW5jZWxsYXRpb25FcnJvcjpoLFRpbWVvdXRFcnJvcjpkLE9wZXJhdGlvbmFsRXJyb3I6byxSZWplY3Rpb25FcnJvcjpvLEFnZ3JlZ2F0ZUVycm9yOnZ9KSxzLmRlZmluZVByb3BlcnR5KEVycm9yLFwiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiLHt2YWx1ZTp5LHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExfSkpLGUuZXhwb3J0cz17RXJyb3I6RXJyb3IsVHlwZUVycm9yOmksUmFuZ2VFcnJvcjphLENhbmNlbGxhdGlvbkVycm9yOnkuQ2FuY2VsbGF0aW9uRXJyb3IsT3BlcmF0aW9uYWxFcnJvcjp5Lk9wZXJhdGlvbmFsRXJyb3IsVGltZW91dEVycm9yOnkuVGltZW91dEVycm9yLEFnZ3JlZ2F0ZUVycm9yOnkuQWdncmVnYXRlRXJyb3IsV2FybmluZzpwfX0se1wiLi9lczVcIjoxMyxcIi4vdXRpbFwiOjM2fV0sMTM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj1mdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3JldHVybiB2b2lkIDA9PT10aGlzfSgpO2lmKHIpZS5leHBvcnRzPXtmcmVlemU6T2JqZWN0LmZyZWV6ZSxkZWZpbmVQcm9wZXJ0eTpPYmplY3QuZGVmaW5lUHJvcGVydHksZ2V0RGVzY3JpcHRvcjpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLGtleXM6T2JqZWN0LmtleXMsbmFtZXM6T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsZ2V0UHJvdG90eXBlT2Y6T2JqZWN0LmdldFByb3RvdHlwZU9mLGlzQXJyYXk6QXJyYXkuaXNBcnJheSxpc0VTNTpyLHByb3BlcnR5SXNXcml0YWJsZTpmdW5jdGlvbih0LGUpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxlKTtyZXR1cm4hKG4mJiFuLndyaXRhYmxlJiYhbi5zZXQpfX07ZWxzZXt2YXIgbz17fS5oYXNPd25Qcm9wZXJ0eSxpPXt9LnRvU3RyaW5nLGE9e30uY29uc3RydWN0b3IucHJvdG90eXBlLHM9ZnVuY3Rpb24odCl7dmFyIGU9W107Zm9yKHZhciBuIGluIHQpby5jYWxsKHQsbikmJmUucHVzaChuKTtyZXR1cm4gZX0sdT1mdW5jdGlvbih0LGUpe3JldHVybnt2YWx1ZTp0W2VdfX0sbD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRbZV09bi52YWx1ZSx0fSxjPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxmPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gT2JqZWN0KHQpLmNvbnN0cnVjdG9yLnByb3RvdHlwZX1jYXRjaCh0KXtyZXR1cm4gYX19LHA9ZnVuY3Rpb24odCl7dHJ5e3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PWkuY2FsbCh0KX1jYXRjaCh0KXtyZXR1cm4hMX19O2UuZXhwb3J0cz17aXNBcnJheTpwLGtleXM6cyxuYW1lczpzLGRlZmluZVByb3BlcnR5OmwsZ2V0RGVzY3JpcHRvcjp1LGZyZWV6ZTpjLGdldFByb3RvdHlwZU9mOmYsaXNFUzU6cixwcm9wZXJ0eUlzV3JpdGFibGU6ZnVuY3Rpb24oKXtyZXR1cm4hMH19fX0se31dLDE0OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXA7dC5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKHQscil7cmV0dXJuIG4odGhpcyx0LHIsZSl9LHQuZmlsdGVyPWZ1bmN0aW9uKHQscixvKXtyZXR1cm4gbih0LHIsbyxlKX19fSx7fV0sMTU6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiByKHQsZSxuKXt0aGlzLnByb21pc2U9dCx0aGlzLnR5cGU9ZSx0aGlzLmhhbmRsZXI9bix0aGlzLmNhbGxlZD0hMSx0aGlzLmNhbmNlbFByb21pc2U9bnVsbH1mdW5jdGlvbiBvKHQpe3RoaXMuZmluYWxseUhhbmRsZXI9dH1mdW5jdGlvbiBpKHQsZSl7cmV0dXJuIG51bGwhPXQuY2FuY2VsUHJvbWlzZSYmKGFyZ3VtZW50cy5sZW5ndGg+MT90LmNhbmNlbFByb21pc2UuX3JlamVjdChlKTp0LmNhbmNlbFByb21pc2UuX2NhbmNlbCgpLHQuY2FuY2VsUHJvbWlzZT1udWxsLCEwKX1mdW5jdGlvbiBhKCl7cmV0dXJuIHUuY2FsbCh0aGlzLHRoaXMucHJvbWlzZS5fdGFyZ2V0KCkuX3NldHRsZWRWYWx1ZSgpKX1mdW5jdGlvbiBzKHQpe2lmKCFpKHRoaXMsdCkpcmV0dXJuIGYuZT10LGZ9ZnVuY3Rpb24gdSh0KXt2YXIgcj10aGlzLnByb21pc2UsdT10aGlzLmhhbmRsZXI7aWYoIXRoaXMuY2FsbGVkKXt0aGlzLmNhbGxlZD0hMDt2YXIgbD10aGlzLmlzRmluYWxseUhhbmRsZXIoKT91LmNhbGwoci5fYm91bmRWYWx1ZSgpKTp1LmNhbGwoci5fYm91bmRWYWx1ZSgpLHQpO2lmKHZvaWQgMCE9PWwpe3IuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkKCk7dmFyIHA9bihsLHIpO2lmKHAgaW5zdGFuY2VvZiBlKXtpZihudWxsIT10aGlzLmNhbmNlbFByb21pc2Upe2lmKHAuX2lzQ2FuY2VsbGVkKCkpe3ZhciBoPW5ldyBjKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7cmV0dXJuIHIuX2F0dGFjaEV4dHJhVHJhY2UoaCksZi5lPWgsZn1wLmlzUGVuZGluZygpJiZwLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhuZXcgbyh0aGlzKSl9cmV0dXJuIHAuX3RoZW4oYSxzLHZvaWQgMCx0aGlzLHZvaWQgMCl9fX1yZXR1cm4gci5pc1JlamVjdGVkKCk/KGkodGhpcyksZi5lPXQsZik6KGkodGhpcyksdCl9dmFyIGw9dChcIi4vdXRpbFwiKSxjPWUuQ2FuY2VsbGF0aW9uRXJyb3IsZj1sLmVycm9yT2JqO3JldHVybiByLnByb3RvdHlwZS5pc0ZpbmFsbHlIYW5kbGVyPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLnR5cGV9LG8ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtpKHRoaXMuZmluYWxseUhhbmRsZXIpfSxlLnByb3RvdHlwZS5fcGFzc1Rocm91Z2g9ZnVuY3Rpb24odCxlLG4sbyl7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgdD90aGlzLnRoZW4oKTp0aGlzLl90aGVuKG4sbyx2b2lkIDAsbmV3IHIodGhpcyxlLHQpLHZvaWQgMCl9LGUucHJvdG90eXBlLmxhc3RseT1lLnByb3RvdHlwZS5maW5hbGx5PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXNzVGhyb3VnaCh0LDAsdSx1KX0sZS5wcm90b3R5cGUudGFwPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXNzVGhyb3VnaCh0LDEsdSl9LHJ9fSx7XCIuL3V0aWxcIjozNn1dLDE2OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbixyLG8saSxhKXtmdW5jdGlvbiBzKHQsbixyKXtmb3IodmFyIGk9MDtpPG4ubGVuZ3RoOysraSl7ci5fcHVzaENvbnRleHQoKTt2YXIgYT1oKG5baV0pKHQpO2lmKHIuX3BvcENvbnRleHQoKSxhPT09cCl7ci5fcHVzaENvbnRleHQoKTt2YXIgcz1lLnJlamVjdChwLmUpO3JldHVybiByLl9wb3BDb250ZXh0KCksc312YXIgdT1vKGEscik7aWYodSBpbnN0YW5jZW9mIGUpcmV0dXJuIHV9cmV0dXJuIG51bGx9ZnVuY3Rpb24gdSh0LG4sbyxpKXtpZihhLmNhbmNlbGxhdGlvbigpKXt2YXIgcz1uZXcgZShyKSx1PXRoaXMuX2ZpbmFsbHlQcm9taXNlPW5ldyBlKHIpO3RoaXMuX3Byb21pc2U9cy5sYXN0bHkoZnVuY3Rpb24oKXtyZXR1cm4gdX0pLHMuX2NhcHR1cmVTdGFja1RyYWNlKCkscy5fc2V0T25DYW5jZWwodGhpcyl9ZWxzZXt2YXIgbD10aGlzLl9wcm9taXNlPW5ldyBlKHIpO2wuX2NhcHR1cmVTdGFja1RyYWNlKCl9dGhpcy5fc3RhY2s9aSx0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbj10LHRoaXMuX3JlY2VpdmVyPW4sdGhpcy5fZ2VuZXJhdG9yPXZvaWQgMCx0aGlzLl95aWVsZEhhbmRsZXJzPVwiZnVuY3Rpb25cIj09dHlwZW9mIG8/W29dLmNvbmNhdChkKTpkLHRoaXMuX3lpZWxkZWRQcm9taXNlPW51bGwsdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2U9ITF9dmFyIGw9dChcIi4vZXJyb3JzXCIpLGM9bC5UeXBlRXJyb3IsZj10KFwiLi91dGlsXCIpLHA9Zi5lcnJvck9iaixoPWYudHJ5Q2F0Y2gsZD1bXTtmLmluaGVyaXRzKHUsaSksdS5wcm90b3R5cGUuX2lzUmVzb2x2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Byb21pc2V9LHUucHJvdG90eXBlLl9jbGVhbnVwPWZ1bmN0aW9uKCl7dGhpcy5fcHJvbWlzZT10aGlzLl9nZW5lcmF0b3I9bnVsbCxhLmNhbmNlbGxhdGlvbigpJiZudWxsIT09dGhpcy5fZmluYWxseVByb21pc2UmJih0aGlzLl9maW5hbGx5UHJvbWlzZS5fZnVsZmlsbCgpLHRoaXMuX2ZpbmFsbHlQcm9taXNlPW51bGwpfSx1LnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZD1mdW5jdGlvbigpe2lmKCF0aGlzLl9pc1Jlc29sdmVkKCkpe3ZhciB0LG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHRoaXMuX2dlbmVyYXRvci5yZXR1cm47aWYobil0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpLHQ9aCh0aGlzLl9nZW5lcmF0b3IucmV0dXJuKS5jYWxsKHRoaXMuX2dlbmVyYXRvcix2b2lkIDApLHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtlbHNle3ZhciByPW5ldyBlLkNhbmNlbGxhdGlvbkVycm9yKFwiZ2VuZXJhdG9yIC5yZXR1cm4oKSBzZW50aW5lbFwiKTtlLmNvcm91dGluZS5yZXR1cm5TZW50aW5lbD1yLHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UociksdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKSx0PWgodGhpcy5fZ2VuZXJhdG9yLnRocm93KS5jYWxsKHRoaXMuX2dlbmVyYXRvcixyKSx0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCl9dGhpcy5fY2FuY2VsbGF0aW9uUGhhc2U9ITAsdGhpcy5feWllbGRlZFByb21pc2U9bnVsbCx0aGlzLl9jb250aW51ZSh0KX19LHUucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkPWZ1bmN0aW9uKHQpe3RoaXMuX3lpZWxkZWRQcm9taXNlPW51bGwsdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTt2YXIgZT1oKHRoaXMuX2dlbmVyYXRvci5uZXh0KS5jYWxsKHRoaXMuX2dlbmVyYXRvcix0KTt0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCksdGhpcy5fY29udGludWUoZSl9LHUucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQ9ZnVuY3Rpb24odCl7dGhpcy5feWllbGRlZFByb21pc2U9bnVsbCx0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHQpLHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7dmFyIGU9aCh0aGlzLl9nZW5lcmF0b3IudGhyb3cpLmNhbGwodGhpcy5fZ2VuZXJhdG9yLHQpO3RoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKSx0aGlzLl9jb250aW51ZShlKX0sdS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZD1mdW5jdGlvbigpe2lmKHRoaXMuX3lpZWxkZWRQcm9taXNlIGluc3RhbmNlb2YgZSl7dmFyIHQ9dGhpcy5feWllbGRlZFByb21pc2U7dGhpcy5feWllbGRlZFByb21pc2U9bnVsbCx0LmNhbmNlbCgpfX0sdS5wcm90b3R5cGUucHJvbWlzZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9taXNlfSx1LnByb3RvdHlwZS5fcnVuPWZ1bmN0aW9uKCl7dGhpcy5fZ2VuZXJhdG9yPXRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uLmNhbGwodGhpcy5fcmVjZWl2ZXIpLHRoaXMuX3JlY2VpdmVyPXRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uPXZvaWQgMCx0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHZvaWQgMCl9LHUucHJvdG90eXBlLl9jb250aW51ZT1mdW5jdGlvbih0KXt2YXIgbj10aGlzLl9wcm9taXNlO2lmKHQ9PT1wKXJldHVybiB0aGlzLl9jbGVhbnVwKCksdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2U/bi5jYW5jZWwoKTpuLl9yZWplY3RDYWxsYmFjayh0LmUsITEpO3ZhciByPXQudmFsdWU7aWYodC5kb25lPT09ITApcmV0dXJuIHRoaXMuX2NsZWFudXAoKSx0aGlzLl9jYW5jZWxsYXRpb25QaGFzZT9uLmNhbmNlbCgpOm4uX3Jlc29sdmVDYWxsYmFjayhyKTt2YXIgaT1vKHIsdGhpcy5fcHJvbWlzZSk7aWYoIShpIGluc3RhbmNlb2YgZSkmJihpPXMoaSx0aGlzLl95aWVsZEhhbmRsZXJzLHRoaXMuX3Byb21pc2UpLG51bGw9PT1pKSlyZXR1cm4gdm9pZCB0aGlzLl9wcm9taXNlUmVqZWN0ZWQobmV3IGMoXCJBIHZhbHVlICVzIHdhcyB5aWVsZGVkIHRoYXQgY291bGQgbm90IGJlIHRyZWF0ZWQgYXMgYSBwcm9taXNlXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblxcblwiLnJlcGxhY2UoXCIlc1wiLHIpK1wiRnJvbSBjb3JvdXRpbmU6XFxuXCIrdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwtNykuam9pbihcIlxcblwiKSkpO2k9aS5fdGFyZ2V0KCk7dmFyIGE9aS5fYml0RmllbGQ7MD09PSg1MDM5NzE4NCZhKT8odGhpcy5feWllbGRlZFByb21pc2U9aSxpLl9wcm94eSh0aGlzLG51bGwpKTowIT09KDMzNTU0NDMyJmEpP2UuX2FzeW5jLmludm9rZSh0aGlzLl9wcm9taXNlRnVsZmlsbGVkLHRoaXMsaS5fdmFsdWUoKSk6MCE9PSgxNjc3NzIxNiZhKT9lLl9hc3luYy5pbnZva2UodGhpcy5fcHJvbWlzZVJlamVjdGVkLHRoaXMsaS5fcmVhc29uKCkpOnRoaXMuX3Byb21pc2VDYW5jZWxsZWQoKX0sZS5jb3JvdXRpbmU9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBjKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTt2YXIgbj1PYmplY3QoZSkueWllbGRIYW5kbGVyLHI9dSxvPShuZXcgRXJyb3IpLnN0YWNrO3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpLGk9bmV3IHIodm9pZCAwLHZvaWQgMCxuLG8pLGE9aS5wcm9taXNlKCk7cmV0dXJuIGkuX2dlbmVyYXRvcj1lLGkuX3Byb21pc2VGdWxmaWxsZWQodm9pZCAwKSxhfX0sZS5jb3JvdXRpbmUuYWRkWWllbGRIYW5kbGVyPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IGMoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK2YuY2xhc3NTdHJpbmcodCkpO2QucHVzaCh0KX0sZS5zcGF3bj1mdW5jdGlvbih0KXtpZihhLmRlcHJlY2F0ZWQoXCJQcm9taXNlLnNwYXduKClcIixcIlByb21pc2UuY29yb3V0aW5lKClcIiksXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm4gbihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7dmFyIHI9bmV3IHUodCx0aGlzKSxvPXIucHJvbWlzZSgpO3JldHVybiByLl9ydW4oZS5zcGF3biksb319fSx7XCIuL2Vycm9yc1wiOjEyLFwiLi91dGlsXCI6MzZ9XSwxNzpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scixvLGksYSl7dmFyIHM9dChcIi4vdXRpbFwiKTtzLmNhbkV2YWx1YXRlLHMudHJ5Q2F0Y2gscy5lcnJvck9iajtlLmpvaW49ZnVuY3Rpb24oKXt2YXIgdCxlPWFyZ3VtZW50cy5sZW5ndGgtMTtpZihlPjAmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGFyZ3VtZW50c1tlXSl7dD1hcmd1bWVudHNbZV07dmFyIHJ9dmFyIG89W10uc2xpY2UuY2FsbChhcmd1bWVudHMpO3QmJm8ucG9wKCk7dmFyIHI9bmV3IG4obykucHJvbWlzZSgpO3JldHVybiB2b2lkIDAhPT10P3Iuc3ByZWFkKHQpOnJ9fX0se1wiLi91dGlsXCI6MzZ9XSwxODpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scixvLGksYSl7ZnVuY3Rpb24gcyh0LGUsbixyKXt0aGlzLmNvbnN0cnVjdG9yJCh0KSx0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO3ZhciBvPWwoKTt0aGlzLl9jYWxsYmFjaz1udWxsPT09bz9lOmMuZG9tYWluQmluZChvLGUpLHRoaXMuX3ByZXNlcnZlZFZhbHVlcz1yPT09aT9uZXcgQXJyYXkodGhpcy5sZW5ndGgoKSk6bnVsbCx0aGlzLl9saW1pdD1uLHRoaXMuX2luRmxpZ2h0PTAsdGhpcy5fcXVldWU9W10saC5pbnZva2UodGhpcy5fYXN5bmNJbml0LHRoaXMsdm9pZCAwKX1mdW5jdGlvbiB1KHQsbixvLGkpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pcmV0dXJuIHIoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK2MuY2xhc3NTdHJpbmcobikpO3ZhciBhPTA7aWYodm9pZCAwIT09byl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG98fG51bGw9PT1vKXJldHVybiBlLnJlamVjdChuZXcgVHlwZUVycm9yKFwib3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCBidXQgaXQgaXMgXCIrYy5jbGFzc1N0cmluZyhvKSkpO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBvLmNvbmN1cnJlbmN5KXJldHVybiBlLnJlamVjdChuZXcgVHlwZUVycm9yKFwiJ2NvbmN1cnJlbmN5JyBtdXN0IGJlIGEgbnVtYmVyIGJ1dCBpdCBpcyBcIitjLmNsYXNzU3RyaW5nKG8uY29uY3VycmVuY3kpKSk7YT1vLmNvbmN1cnJlbmN5fXJldHVybiBhPVwibnVtYmVyXCI9PXR5cGVvZiBhJiZpc0Zpbml0ZShhKSYmYT49MT9hOjAsbmV3IHModCxuLGEsaSkucHJvbWlzZSgpfXZhciBsPWUuX2dldERvbWFpbixjPXQoXCIuL3V0aWxcIiksZj1jLnRyeUNhdGNoLHA9Yy5lcnJvck9iaixoPWUuX2FzeW5jO2MuaW5oZXJpdHMocyxuKSxzLnByb3RvdHlwZS5fYXN5bmNJbml0PWZ1bmN0aW9uKCl7dGhpcy5faW5pdCQodm9pZCAwLC0yKX0scy5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oKXt9LHMucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkPWZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5fdmFsdWVzLGk9dGhpcy5sZW5ndGgoKSxzPXRoaXMuX3ByZXNlcnZlZFZhbHVlcyx1PXRoaXMuX2xpbWl0O2lmKG48MCl7aWYobj1uKi0xLTEscltuXT10LHU+PTEmJih0aGlzLl9pbkZsaWdodC0tLHRoaXMuX2RyYWluUXVldWUoKSx0aGlzLl9pc1Jlc29sdmVkKCkpKXJldHVybiEwfWVsc2V7aWYodT49MSYmdGhpcy5faW5GbGlnaHQ+PXUpcmV0dXJuIHJbbl09dCx0aGlzLl9xdWV1ZS5wdXNoKG4pLCExO251bGwhPT1zJiYoc1tuXT10KTt2YXIgbD10aGlzLl9wcm9taXNlLGM9dGhpcy5fY2FsbGJhY2ssaD1sLl9ib3VuZFZhbHVlKCk7bC5fcHVzaENvbnRleHQoKTt2YXIgZD1mKGMpLmNhbGwoaCx0LG4saSksdj1sLl9wb3BDb250ZXh0KCk7aWYoYS5jaGVja0ZvcmdvdHRlblJldHVybnMoZCx2LG51bGwhPT1zP1wiUHJvbWlzZS5maWx0ZXJcIjpcIlByb21pc2UubWFwXCIsbCksZD09PXApcmV0dXJuIHRoaXMuX3JlamVjdChkLmUpLCEwO3ZhciBtPW8oZCx0aGlzLl9wcm9taXNlKTtpZihtIGluc3RhbmNlb2YgZSl7bT1tLl90YXJnZXQoKTt2YXIgXz1tLl9iaXRGaWVsZDtpZigwPT09KDUwMzk3MTg0Jl8pKXJldHVybiB1Pj0xJiZ0aGlzLl9pbkZsaWdodCsrLHJbbl09bSxtLl9wcm94eSh0aGlzLChuKzEpKi0xKSwhMTtpZigwPT09KDMzNTU0NDMyJl8pKXJldHVybiAwIT09KDE2Nzc3MjE2Jl8pPyh0aGlzLl9yZWplY3QobS5fcmVhc29uKCkpLCEwKToodGhpcy5fY2FuY2VsKCksITApO2Q9bS5fdmFsdWUoKX1yW25dPWR9dmFyIGc9Kyt0aGlzLl90b3RhbFJlc29sdmVkO3JldHVybiBnPj1pJiYobnVsbCE9PXM/dGhpcy5fZmlsdGVyKHIscyk6dGhpcy5fcmVzb2x2ZShyKSwhMCl9LHMucHJvdG90eXBlLl9kcmFpblF1ZXVlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX3F1ZXVlLGU9dGhpcy5fbGltaXQsbj10aGlzLl92YWx1ZXM7dC5sZW5ndGg+MCYmdGhpcy5faW5GbGlnaHQ8ZTspe2lmKHRoaXMuX2lzUmVzb2x2ZWQoKSlyZXR1cm47dmFyIHI9dC5wb3AoKTt0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG5bcl0scil9fSxzLnByb3RvdHlwZS5fZmlsdGVyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUubGVuZ3RoLHI9bmV3IEFycmF5KG4pLG89MCxpPTA7aTxuOysraSl0W2ldJiYocltvKytdPWVbaV0pO3IubGVuZ3RoPW8sdGhpcy5fcmVzb2x2ZShyKX0scy5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ByZXNlcnZlZFZhbHVlc30sZS5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHUodGhpcyx0LGUsbnVsbCl9LGUubWFwPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB1KHQsZSxuLHIpfX19LHtcIi4vdXRpbFwiOjM2fV0sMTk6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsbyxpKXt2YXIgYT10KFwiLi91dGlsXCIpLHM9YS50cnlDYXRjaDtlLm1ldGhvZD1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBlLlR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIrYS5jbGFzc1N0cmluZyh0KSk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHI9bmV3IGUobik7ci5fY2FwdHVyZVN0YWNrVHJhY2UoKSxyLl9wdXNoQ29udGV4dCgpO3ZhciBvPXModCkuYXBwbHkodGhpcyxhcmd1bWVudHMpLGE9ci5fcG9wQ29udGV4dCgpO3JldHVybiBpLmNoZWNrRm9yZ290dGVuUmV0dXJucyhvLGEsXCJQcm9taXNlLm1ldGhvZFwiLHIpLHIuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKG8pLHJ9fSxlLmF0dGVtcHQ9ZS50cnk9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm4gbyhcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIrYS5jbGFzc1N0cmluZyh0KSk7dmFyIHI9bmV3IGUobik7ci5fY2FwdHVyZVN0YWNrVHJhY2UoKSxyLl9wdXNoQ29udGV4dCgpO3ZhciB1O2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7aS5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO3ZhciBsPWFyZ3VtZW50c1sxXSxjPWFyZ3VtZW50c1syXTt1PWEuaXNBcnJheShsKT9zKHQpLmFwcGx5KGMsbCk6cyh0KS5jYWxsKGMsbCl9ZWxzZSB1PXModCkoKTt2YXIgZj1yLl9wb3BDb250ZXh0KCk7cmV0dXJuIGkuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHUsZixcIlByb21pc2UudHJ5XCIsciksci5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodSkscn0sZS5wcm90b3R5cGUuX3Jlc29sdmVGcm9tU3luY1ZhbHVlPWZ1bmN0aW9uKHQpe3Q9PT1hLmVycm9yT2JqP3RoaXMuX3JlamVjdENhbGxiYWNrKHQuZSwhMSk6dGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHQsITApfX19LHtcIi4vdXRpbFwiOjM2fV0sMjA6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRXJyb3ImJmMuZ2V0UHJvdG90eXBlT2YodCk9PT1FcnJvci5wcm90b3R5cGV9ZnVuY3Rpb24gbyh0KXt2YXIgZTtpZihyKHQpKXtlPW5ldyBsKHQpLGUubmFtZT10Lm5hbWUsZS5tZXNzYWdlPXQubWVzc2FnZSxlLnN0YWNrPXQuc3RhY2s7Zm9yKHZhciBuPWMua2V5cyh0KSxvPTA7bzxuLmxlbmd0aDsrK28pe3ZhciBpPW5bb107Zi50ZXN0KGkpfHwoZVtpXT10W2ldKX1yZXR1cm4gZX1yZXR1cm4gYS5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24odCksdH1mdW5jdGlvbiBpKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7aWYobnVsbCE9PXQpe2lmKG4pe3ZhciBpPW8ocyhuKSk7dC5fYXR0YWNoRXh0cmFUcmFjZShpKSx0Ll9yZWplY3QoaSl9ZWxzZSBpZihlKXt2YXIgYT1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTt0Ll9mdWxmaWxsKGEpfWVsc2UgdC5fZnVsZmlsbChyKTt0PW51bGx9fX12YXIgYT10KFwiLi91dGlsXCIpLHM9YS5tYXliZVdyYXBBc0Vycm9yLHU9dChcIi4vZXJyb3JzXCIpLGw9dS5PcGVyYXRpb25hbEVycm9yLGM9dChcIi4vZXM1XCIpLGY9L14oPzpuYW1lfG1lc3NhZ2V8c3RhY2t8Y2F1c2UpJC87ZS5leHBvcnRzPWl9LHtcIi4vZXJyb3JzXCI6MTIsXCIuL2VzNVwiOjEzLFwiLi91dGlsXCI6MzZ9XSwyMTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsZSl7dmFyIG49dGhpcztpZighaS5pc0FycmF5KHQpKXJldHVybiByLmNhbGwobix0LGUpO3ZhciBvPXMoZSkuYXBwbHkobi5fYm91bmRWYWx1ZSgpLFtudWxsXS5jb25jYXQodCkpO289PT11JiZhLnRocm93TGF0ZXIoby5lKX1mdW5jdGlvbiByKHQsZSl7dmFyIG49dGhpcyxyPW4uX2JvdW5kVmFsdWUoKSxvPXZvaWQgMD09PXQ/cyhlKS5jYWxsKHIsbnVsbCk6cyhlKS5jYWxsKHIsbnVsbCx0KTtvPT09dSYmYS50aHJvd0xhdGVyKG8uZSl9ZnVuY3Rpb24gbyh0LGUpe3ZhciBuPXRoaXM7aWYoIXQpe3ZhciByPW5ldyBFcnJvcih0K1wiXCIpO3IuY2F1c2U9dCx0PXJ9dmFyIG89cyhlKS5jYWxsKG4uX2JvdW5kVmFsdWUoKSx0KTtvPT09dSYmYS50aHJvd0xhdGVyKG8uZSl9dmFyIGk9dChcIi4vdXRpbFwiKSxhPWUuX2FzeW5jLHM9aS50cnlDYXRjaCx1PWkuZXJyb3JPYmo7ZS5wcm90b3R5cGUuYXNDYWxsYmFjaz1lLnByb3RvdHlwZS5ub2RlaWZ5PWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdCl7dmFyIGk9cjt2b2lkIDAhPT1lJiZPYmplY3QoZSkuc3ByZWFkJiYoaT1uKSx0aGlzLl90aGVuKGksbyx2b2lkIDAsdGhpcyx0KX1yZXR1cm4gdGhpc319fSx7XCIuL3V0aWxcIjozNn1dLDIyOltmdW5jdGlvbih0LG4scil7XCJ1c2Ugc3RyaWN0XCI7bi5leHBvcnRzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcigpe31mdW5jdGlvbiBvKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgeShcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIrZC5jbGFzc1N0cmluZyhlKSk7aWYodC5jb25zdHJ1Y3RvciE9PWkpdGhyb3cgbmV3IHkoXCJ0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgaW52b2tlZCBkaXJlY3RseVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIil9ZnVuY3Rpb24gaSh0KXt0aGlzLl9iaXRGaWVsZD0wLHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA9dm9pZCAwLHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwPXZvaWQgMCx0aGlzLl9wcm9taXNlMD12b2lkIDAsdGhpcy5fcmVjZWl2ZXIwPXZvaWQgMCx0IT09dyYmKG8odGhpcyx0KSx0aGlzLl9yZXNvbHZlRnJvbUV4ZWN1dG9yKHQpKSx0aGlzLl9wcm9taXNlQ3JlYXRlZCgpLHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsdGhpcyl9ZnVuY3Rpb24gYSh0KXt0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh0KX1mdW5jdGlvbiBzKHQpe3RoaXMucHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sodCwhMSl9ZnVuY3Rpb24gdSh0KXt2YXIgZT1uZXcgaSh3KTtlLl9mdWxmaWxsbWVudEhhbmRsZXIwPXQsZS5fcmVqZWN0aW9uSGFuZGxlcjA9dCxlLl9wcm9taXNlMD10LGUuX3JlY2VpdmVyMD10fXZhciBsLGM9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHkoXCJjaXJjdWxhciBwcm9taXNlIHJlc29sdXRpb24gY2hhaW5cXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpfSxmPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKX0scD1mdW5jdGlvbih0KXtyZXR1cm4gaS5yZWplY3QobmV3IHkodCkpfSxoPXt9LGQ9dChcIi4vdXRpbFwiKTtsPWQuaXNOb2RlP2Z1bmN0aW9uKCl7dmFyIHQ9ZS5kb21haW47cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHR9OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGQubm90RW51bWVyYWJsZVByb3AoaSxcIl9nZXREb21haW5cIixsKTt2YXIgdj10KFwiLi9lczVcIiksbT10KFwiLi9hc3luY1wiKSxfPW5ldyBtO3YuZGVmaW5lUHJvcGVydHkoaSxcIl9hc3luY1wiLHt2YWx1ZTpffSk7dmFyIGc9dChcIi4vZXJyb3JzXCIpLHk9aS5UeXBlRXJyb3I9Zy5UeXBlRXJyb3I7aS5SYW5nZUVycm9yPWcuUmFuZ2VFcnJvcjt2YXIgYj1pLkNhbmNlbGxhdGlvbkVycm9yPWcuQ2FuY2VsbGF0aW9uRXJyb3I7aS5UaW1lb3V0RXJyb3I9Zy5UaW1lb3V0RXJyb3IsaS5PcGVyYXRpb25hbEVycm9yPWcuT3BlcmF0aW9uYWxFcnJvcixpLlJlamVjdGlvbkVycm9yPWcuT3BlcmF0aW9uYWxFcnJvcixpLkFnZ3JlZ2F0ZUVycm9yPWcuQWdncmVnYXRlRXJyb3I7dmFyIHc9ZnVuY3Rpb24oKXt9LHg9e30sRT17fSxUPXQoXCIuL3RoZW5hYmxlc1wiKShpLHcpLE89dChcIi4vcHJvbWlzZV9hcnJheVwiKShpLHcsVCxwLHIpLFM9dChcIi4vY29udGV4dFwiKShpKSxQPVMuY3JlYXRlLE09dChcIi4vZGVidWdnYWJpbGl0eVwiKShpLFMpLGo9KE0uQ2FwdHVyZWRUcmFjZSx0KFwiLi9maW5hbGx5XCIpKGksVCkpLEE9dChcIi4vY2F0Y2hfZmlsdGVyXCIpKEUpLEM9dChcIi4vbm9kZWJhY2tcIiksaz1kLmVycm9yT2JqLFI9ZC50cnlDYXRjaDtyZXR1cm4gaS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgUHJvbWlzZV1cIn0saS5wcm90b3R5cGUuY2F1Z2h0PWkucHJvdG90eXBlLmNhdGNoPWZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg7XG5pZihlPjEpe3ZhciBuLHI9bmV3IEFycmF5KGUtMSksbz0wO2ZvcihuPTA7bjxlLTE7KytuKXt2YXIgaT1hcmd1bWVudHNbbl07aWYoIWQuaXNPYmplY3QoaSkpcmV0dXJuIHAoXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgQSBjYXRjaCBzdGF0ZW1lbnQgcHJlZGljYXRlIFwiK2QuY2xhc3NTdHJpbmcoaSkpO3JbbysrXT1pfXJldHVybiByLmxlbmd0aD1vLHQ9YXJndW1lbnRzW25dLHRoaXMudGhlbih2b2lkIDAsQShyLHQsdGhpcykpfXJldHVybiB0aGlzLnRoZW4odm9pZCAwLHQpfSxpLnByb3RvdHlwZS5yZWZsZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RoZW4oZixmLHZvaWQgMCx0aGlzLHZvaWQgMCl9LGkucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24odCxlKXtpZihNLndhcm5pbmdzKCkmJmFyZ3VtZW50cy5sZW5ndGg+MCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgZSl7dmFyIG49XCIudGhlbigpIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgYnV0IHdhcyBwYXNzZWQ6IFwiK2QuY2xhc3NTdHJpbmcodCk7YXJndW1lbnRzLmxlbmd0aD4xJiYobis9XCIsIFwiK2QuY2xhc3NTdHJpbmcoZSkpLHRoaXMuX3dhcm4obil9cmV0dXJuIHRoaXMuX3RoZW4odCxlLHZvaWQgMCx2b2lkIDAsdm9pZCAwKX0saS5wcm90b3R5cGUuZG9uZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX3RoZW4odCxlLHZvaWQgMCx2b2lkIDAsdm9pZCAwKTtuLl9zZXRJc0ZpbmFsKCl9LGkucHJvdG90eXBlLnNwcmVhZD1mdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiB0P3AoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK2QuY2xhc3NTdHJpbmcodCkpOnRoaXMuYWxsKCkuX3RoZW4odCx2b2lkIDAsdm9pZCAwLHgsdm9pZCAwKX0saS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7dmFyIHQ9e2lzRnVsZmlsbGVkOiExLGlzUmVqZWN0ZWQ6ITEsZnVsZmlsbG1lbnRWYWx1ZTp2b2lkIDAscmVqZWN0aW9uUmVhc29uOnZvaWQgMH07cmV0dXJuIHRoaXMuaXNGdWxmaWxsZWQoKT8odC5mdWxmaWxsbWVudFZhbHVlPXRoaXMudmFsdWUoKSx0LmlzRnVsZmlsbGVkPSEwKTp0aGlzLmlzUmVqZWN0ZWQoKSYmKHQucmVqZWN0aW9uUmVhc29uPXRoaXMucmVhc29uKCksdC5pc1JlamVjdGVkPSEwKSx0fSxpLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4wJiZ0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKSxuZXcgTyh0aGlzKS5wcm9taXNlKCl9LGkucHJvdG90eXBlLmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNhdWdodChkLm9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLHQpfSxpLmdldE5ld0xpYnJhcnlDb3B5PW4uZXhwb3J0cyxpLmlzPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgaX0saS5mcm9tTm9kZT1pLmZyb21DYWxsYmFjaz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgaSh3KTtlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmISFPYmplY3QoYXJndW1lbnRzWzFdKS5tdWx0aUFyZ3Mscj1SKHQpKEMoZSxuKSk7cmV0dXJuIHI9PT1rJiZlLl9yZWplY3RDYWxsYmFjayhyLmUsITApLGUuX2lzRmF0ZVNlYWxlZCgpfHxlLl9zZXRBc3luY0d1YXJhbnRlZWQoKSxlfSxpLmFsbD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IE8odCkucHJvbWlzZSgpfSxpLmNhc3Q9ZnVuY3Rpb24odCl7dmFyIGU9VCh0KTtyZXR1cm4gZSBpbnN0YW5jZW9mIGl8fChlPW5ldyBpKHcpLGUuX2NhcHR1cmVTdGFja1RyYWNlKCksZS5fc2V0RnVsZmlsbGVkKCksZS5fcmVqZWN0aW9uSGFuZGxlcjA9dCksZX0saS5yZXNvbHZlPWkuZnVsZmlsbGVkPWkuY2FzdCxpLnJlamVjdD1pLnJlamVjdGVkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBpKHcpO3JldHVybiBlLl9jYXB0dXJlU3RhY2tUcmFjZSgpLGUuX3JlamVjdENhbGxiYWNrKHQsITApLGV9LGkuc2V0U2NoZWR1bGVyPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IHkoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK2QuY2xhc3NTdHJpbmcodCkpO3JldHVybiBfLnNldFNjaGVkdWxlcih0KX0saS5wcm90b3R5cGUuX3RoZW49ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT12b2lkIDAhPT1vLHM9YT9vOm5ldyBpKHcpLHU9dGhpcy5fdGFyZ2V0KCksYz11Ll9iaXRGaWVsZDthfHwocy5fcHJvcGFnYXRlRnJvbSh0aGlzLDMpLHMuX2NhcHR1cmVTdGFja1RyYWNlKCksdm9pZCAwPT09ciYmMCE9PSgyMDk3MTUyJnRoaXMuX2JpdEZpZWxkKSYmKHI9MCE9PSg1MDM5NzE4NCZjKT90aGlzLl9ib3VuZFZhbHVlKCk6dT09PXRoaXM/dm9pZCAwOnRoaXMuX2JvdW5kVG8pLHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDaGFpbmVkXCIsdGhpcyxzKSk7dmFyIGY9bCgpO2lmKDAhPT0oNTAzOTcxODQmYykpe3ZhciBwLGgsdj11Ll9zZXR0bGVQcm9taXNlQ3R4OzAhPT0oMzM1NTQ0MzImYyk/KGg9dS5fcmVqZWN0aW9uSGFuZGxlcjAscD10KTowIT09KDE2Nzc3MjE2JmMpPyhoPXUuX2Z1bGZpbGxtZW50SGFuZGxlcjAscD1lLHUuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKSk6KHY9dS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcixoPW5ldyBiKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIiksdS5fYXR0YWNoRXh0cmFUcmFjZShoKSxwPWUpLF8uaW52b2tlKHYsdSx7aGFuZGxlcjpudWxsPT09Zj9wOlwiZnVuY3Rpb25cIj09dHlwZW9mIHAmJmQuZG9tYWluQmluZChmLHApLHByb21pc2U6cyxyZWNlaXZlcjpyLHZhbHVlOmh9KX1lbHNlIHUuX2FkZENhbGxiYWNrcyh0LGUscyxyLGYpO3JldHVybiBzfSxpLnByb3RvdHlwZS5fbGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIDY1NTM1JnRoaXMuX2JpdEZpZWxkfSxpLnByb3RvdHlwZS5faXNGYXRlU2VhbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT0oMTE3NTA2MDQ4JnRoaXMuX2JpdEZpZWxkKX0saS5wcm90b3R5cGUuX2lzRm9sbG93aW5nPWZ1bmN0aW9uKCl7cmV0dXJuIDY3MTA4ODY0PT09KDY3MTA4ODY0JnRoaXMuX2JpdEZpZWxkKX0saS5wcm90b3R5cGUuX3NldExlbmd0aD1mdW5jdGlvbih0KXt0aGlzLl9iaXRGaWVsZD10aGlzLl9iaXRGaWVsZCYtNjU1MzZ8NjU1MzUmdH0saS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZD1mdW5jdGlvbigpe3RoaXMuX2JpdEZpZWxkPTMzNTU0NDMyfHRoaXMuX2JpdEZpZWxkLHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VGdWxmaWxsZWRcIix0aGlzKX0saS5wcm90b3R5cGUuX3NldFJlamVjdGVkPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9MTY3NzcyMTZ8dGhpcy5fYml0RmllbGQsdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsdGhpcyl9LGkucHJvdG90eXBlLl9zZXRGb2xsb3dpbmc9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD02NzEwODg2NHx0aGlzLl9iaXRGaWVsZCx0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlUmVzb2x2ZWRcIix0aGlzKX0saS5wcm90b3R5cGUuX3NldElzRmluYWw9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD00MTk0MzA0fHRoaXMuX2JpdEZpZWxkfSxpLnByb3RvdHlwZS5faXNGaW5hbD1mdW5jdGlvbigpe3JldHVybig0MTk0MzA0JnRoaXMuX2JpdEZpZWxkKT4wfSxpLnByb3RvdHlwZS5fdW5zZXRDYW5jZWxsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD10aGlzLl9iaXRGaWVsZCYtNjU1Mzd9LGkucHJvdG90eXBlLl9zZXRDYW5jZWxsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD02NTUzNnx0aGlzLl9iaXRGaWVsZCx0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2FuY2VsbGVkXCIsdGhpcyl9LGkucHJvdG90eXBlLl9zZXRXaWxsQmVDYW5jZWxsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD04Mzg4NjA4fHRoaXMuX2JpdEZpZWxkfSxpLnByb3RvdHlwZS5fc2V0QXN5bmNHdWFyYW50ZWVkPWZ1bmN0aW9uKCl7Xy5oYXNDdXN0b21TY2hlZHVsZXIoKXx8KHRoaXMuX2JpdEZpZWxkPTEzNDIxNzcyOHx0aGlzLl9iaXRGaWVsZCl9LGkucHJvdG90eXBlLl9yZWNlaXZlckF0PWZ1bmN0aW9uKHQpe3ZhciBlPTA9PT10P3RoaXMuX3JlY2VpdmVyMDp0aGlzWzQqdC00KzNdO2lmKGUhPT1oKXJldHVybiB2b2lkIDA9PT1lJiZ0aGlzLl9pc0JvdW5kKCk/dGhpcy5fYm91bmRWYWx1ZSgpOmV9LGkucHJvdG90eXBlLl9wcm9taXNlQXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXNbNCp0LTQrMl19LGkucHJvdG90eXBlLl9mdWxmaWxsbWVudEhhbmRsZXJBdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1s0KnQtNCswXX0saS5wcm90b3R5cGUuX3JlamVjdGlvbkhhbmRsZXJBdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1s0KnQtNCsxXX0saS5wcm90b3R5cGUuX2JvdW5kVmFsdWU9ZnVuY3Rpb24oKXt9LGkucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2swPWZ1bmN0aW9uKHQpe3ZhciBlPSh0Ll9iaXRGaWVsZCx0Ll9mdWxmaWxsbWVudEhhbmRsZXIwKSxuPXQuX3JlamVjdGlvbkhhbmRsZXIwLHI9dC5fcHJvbWlzZTAsbz10Ll9yZWNlaXZlckF0KDApO3ZvaWQgMD09PW8mJihvPWgpLHRoaXMuX2FkZENhbGxiYWNrcyhlLG4scixvLG51bGwpfSxpLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrQXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10Ll9mdWxmaWxsbWVudEhhbmRsZXJBdChlKSxyPXQuX3JlamVjdGlvbkhhbmRsZXJBdChlKSxvPXQuX3Byb21pc2VBdChlKSxpPXQuX3JlY2VpdmVyQXQoZSk7dm9pZCAwPT09aSYmKGk9aCksdGhpcy5fYWRkQ2FsbGJhY2tzKG4scixvLGksbnVsbCl9LGkucHJvdG90eXBlLl9hZGRDYWxsYmFja3M9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgaT10aGlzLl9sZW5ndGgoKTtpZihpPj02NTUzMSYmKGk9MCx0aGlzLl9zZXRMZW5ndGgoMCkpLDA9PT1pKXRoaXMuX3Byb21pc2UwPW4sdGhpcy5fcmVjZWl2ZXIwPXIsXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA9bnVsbD09PW8/dDpkLmRvbWFpbkJpbmQobyx0KSksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwPW51bGw9PT1vP2U6ZC5kb21haW5CaW5kKG8sZSkpO2Vsc2V7dmFyIGE9NCppLTQ7dGhpc1thKzJdPW4sdGhpc1thKzNdPXIsXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKHRoaXNbYSswXT1udWxsPT09bz90OmQuZG9tYWluQmluZChvLHQpKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYodGhpc1thKzFdPW51bGw9PT1vP2U6ZC5kb21haW5CaW5kKG8sZSkpfXJldHVybiB0aGlzLl9zZXRMZW5ndGgoaSsxKSxpfSxpLnByb3RvdHlwZS5fcHJveHk9ZnVuY3Rpb24odCxlKXt0aGlzLl9hZGRDYWxsYmFja3Modm9pZCAwLHZvaWQgMCxlLHQsbnVsbCl9LGkucHJvdG90eXBlLl9yZXNvbHZlQ2FsbGJhY2s9ZnVuY3Rpb24odCxlKXtpZigwPT09KDExNzUwNjA0OCZ0aGlzLl9iaXRGaWVsZCkpe2lmKHQ9PT10aGlzKXJldHVybiB0aGlzLl9yZWplY3RDYWxsYmFjayhjKCksITEpO3ZhciBuPVQodCx0aGlzKTtpZighKG4gaW5zdGFuY2VvZiBpKSlyZXR1cm4gdGhpcy5fZnVsZmlsbCh0KTtlJiZ0aGlzLl9wcm9wYWdhdGVGcm9tKG4sMik7dmFyIHI9bi5fdGFyZ2V0KCk7aWYocj09PXRoaXMpcmV0dXJuIHZvaWQgdGhpcy5fcmVqZWN0KGMoKSk7dmFyIG89ci5fYml0RmllbGQ7aWYoMD09PSg1MDM5NzE4NCZvKSl7dmFyIGE9dGhpcy5fbGVuZ3RoKCk7YT4wJiZyLl9taWdyYXRlQ2FsbGJhY2swKHRoaXMpO2Zvcih2YXIgcz0xO3M8YTsrK3Mpci5fbWlncmF0ZUNhbGxiYWNrQXQodGhpcyxzKTt0aGlzLl9zZXRGb2xsb3dpbmcoKSx0aGlzLl9zZXRMZW5ndGgoMCksdGhpcy5fc2V0Rm9sbG93ZWUocil9ZWxzZSBpZigwIT09KDMzNTU0NDMyJm8pKXRoaXMuX2Z1bGZpbGwoci5fdmFsdWUoKSk7ZWxzZSBpZigwIT09KDE2Nzc3MjE2Jm8pKXRoaXMuX3JlamVjdChyLl9yZWFzb24oKSk7ZWxzZXt2YXIgdT1uZXcgYihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO3IuX2F0dGFjaEV4dHJhVHJhY2UodSksdGhpcy5fcmVqZWN0KHUpfX19LGkucHJvdG90eXBlLl9yZWplY3RDYWxsYmFjaz1mdW5jdGlvbih0LGUsbil7dmFyIHI9ZC5lbnN1cmVFcnJvck9iamVjdCh0KSxvPXI9PT10O2lmKCFvJiYhbiYmTS53YXJuaW5ncygpKXt2YXIgaT1cImEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIG5vbi1lcnJvcjogXCIrZC5jbGFzc1N0cmluZyh0KTt0aGlzLl93YXJuKGksITApfXRoaXMuX2F0dGFjaEV4dHJhVHJhY2UociwhIWUmJm8pLHRoaXMuX3JlamVjdCh0KX0saS5wcm90b3R5cGUuX3Jlc29sdmVGcm9tRXhlY3V0b3I9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLl9jYXB0dXJlU3RhY2tUcmFjZSgpLHRoaXMuX3B1c2hDb250ZXh0KCk7dmFyIG49ITAscj10aGlzLl9leGVjdXRlKHQsZnVuY3Rpb24odCl7ZS5fcmVzb2x2ZUNhbGxiYWNrKHQpfSxmdW5jdGlvbih0KXtlLl9yZWplY3RDYWxsYmFjayh0LG4pfSk7bj0hMSx0aGlzLl9wb3BDb250ZXh0KCksdm9pZCAwIT09ciYmZS5fcmVqZWN0Q2FsbGJhY2sociwhMCl9LGkucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89ci5fYml0RmllbGQ7aWYoMD09PSg2NTUzNiZvKSl7ci5fcHVzaENvbnRleHQoKTt2YXIgaTtlPT09eD9uJiZcIm51bWJlclwiPT10eXBlb2Ygbi5sZW5ndGg/aT1SKHQpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSxuKTooaT1rLGkuZT1uZXcgeShcImNhbm5vdCAuc3ByZWFkKCkgYSBub24tYXJyYXk6IFwiK2QuY2xhc3NTdHJpbmcobikpKTppPVIodCkuY2FsbChlLG4pO3ZhciBhPXIuX3BvcENvbnRleHQoKTtvPXIuX2JpdEZpZWxkLDA9PT0oNjU1MzYmbykmJihpPT09RT9yLl9yZWplY3Qobik6aT09PWs/ci5fcmVqZWN0Q2FsbGJhY2soaS5lLCExKTooTS5jaGVja0ZvcmdvdHRlblJldHVybnMoaSxhLFwiXCIscix0aGlzKSxyLl9yZXNvbHZlQ2FsbGJhY2soaSkpKX19LGkucHJvdG90eXBlLl90YXJnZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpczt0Ll9pc0ZvbGxvd2luZygpOyl0PXQuX2ZvbGxvd2VlKCk7cmV0dXJuIHR9LGkucHJvdG90eXBlLl9mb2xsb3dlZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMH0saS5wcm90b3R5cGUuX3NldEZvbGxvd2VlPWZ1bmN0aW9uKHQpe3RoaXMuX3JlamVjdGlvbkhhbmRsZXIwPXR9LGkucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlPWZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBhPXQgaW5zdGFuY2VvZiBpLHM9dGhpcy5fYml0RmllbGQsdT0wIT09KDEzNDIxNzcyOCZzKTswIT09KDY1NTM2JnMpPyhhJiZ0Ll9pbnZva2VJbnRlcm5hbE9uQ2FuY2VsKCksbiBpbnN0YW5jZW9mIGomJm4uaXNGaW5hbGx5SGFuZGxlcigpPyhuLmNhbmNlbFByb21pc2U9dCxSKGUpLmNhbGwobixvKT09PWsmJnQuX3JlamVjdChrLmUpKTplPT09Zj90Ll9mdWxmaWxsKGYuY2FsbChuKSk6biBpbnN0YW5jZW9mIHI/bi5fcHJvbWlzZUNhbmNlbGxlZCh0KTphfHx0IGluc3RhbmNlb2YgTz90Ll9jYW5jZWwoKTpuLmNhbmNlbCgpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2E/KHUmJnQuX3NldEFzeW5jR3VhcmFudGVlZCgpLHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihlLG4sbyx0KSk6ZS5jYWxsKG4sbyx0KTpuIGluc3RhbmNlb2Ygcj9uLl9pc1Jlc29sdmVkKCl8fCgwIT09KDMzNTU0NDMyJnMpP24uX3Byb21pc2VGdWxmaWxsZWQobyx0KTpuLl9wcm9taXNlUmVqZWN0ZWQobyx0KSk6YSYmKHUmJnQuX3NldEFzeW5jR3VhcmFudGVlZCgpLDAhPT0oMzM1NTQ0MzImcyk/dC5fZnVsZmlsbChvKTp0Ll9yZWplY3QobykpfSxpLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcj1mdW5jdGlvbih0KXt2YXIgZT10LmhhbmRsZXIsbj10LnByb21pc2Uscj10LnJlY2VpdmVyLG89dC52YWx1ZTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP24gaW5zdGFuY2VvZiBpP3RoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihlLHIsbyxuKTplLmNhbGwocixvLG4pOm4gaW5zdGFuY2VvZiBpJiZuLl9yZWplY3Qobyl9LGkucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlQ3R4PWZ1bmN0aW9uKHQpe3RoaXMuX3NldHRsZVByb21pc2UodC5wcm9taXNlLHQuaGFuZGxlcix0LnJlY2VpdmVyLHQudmFsdWUpfSxpLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTA9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMuX3Byb21pc2UwLG89dGhpcy5fcmVjZWl2ZXJBdCgwKTt0aGlzLl9wcm9taXNlMD12b2lkIDAsdGhpcy5fcmVjZWl2ZXIwPXZvaWQgMCx0aGlzLl9zZXR0bGVQcm9taXNlKHIsdCxvLGUpfSxpLnByb3RvdHlwZS5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4PWZ1bmN0aW9uKHQpe3ZhciBlPTQqdC00O3RoaXNbZSsyXT10aGlzW2UrM109dGhpc1tlKzBdPXRoaXNbZSsxXT12b2lkIDB9LGkucHJvdG90eXBlLl9mdWxmaWxsPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2JpdEZpZWxkO2lmKCEoKDExNzUwNjA0OCZlKT4+PjE2KSl7aWYodD09PXRoaXMpe3ZhciBuPWMoKTtyZXR1cm4gdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShuKSx0aGlzLl9yZWplY3Qobil9dGhpcy5fc2V0RnVsZmlsbGVkKCksdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA9dCwoNjU1MzUmZSk+MCYmKDAhPT0oMTM0MjE3NzI4JmUpP3RoaXMuX3NldHRsZVByb21pc2VzKCk6Xy5zZXR0bGVQcm9taXNlcyh0aGlzKSl9fSxpLnByb3RvdHlwZS5fcmVqZWN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2JpdEZpZWxkO2lmKCEoKDExNzUwNjA0OCZlKT4+PjE2KSlyZXR1cm4gdGhpcy5fc2V0UmVqZWN0ZWQoKSx0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwPXQsdGhpcy5faXNGaW5hbCgpP18uZmF0YWxFcnJvcih0LGQuaXNOb2RlKTp2b2lkKCg2NTUzNSZlKT4wP18uc2V0dGxlUHJvbWlzZXModGhpcyk6dGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCkpfSxpLnByb3RvdHlwZS5fZnVsZmlsbFByb21pc2VzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTE7bjx0O24rKyl7dmFyIHI9dGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyQXQobiksbz10aGlzLl9wcm9taXNlQXQobiksaT10aGlzLl9yZWNlaXZlckF0KG4pO3RoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChuKSx0aGlzLl9zZXR0bGVQcm9taXNlKG8scixpLGUpfX0saS5wcm90b3R5cGUuX3JlamVjdFByb21pc2VzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTE7bjx0O24rKyl7dmFyIHI9dGhpcy5fcmVqZWN0aW9uSGFuZGxlckF0KG4pLG89dGhpcy5fcHJvbWlzZUF0KG4pLGk9dGhpcy5fcmVjZWl2ZXJBdChuKTt0aGlzLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXgobiksdGhpcy5fc2V0dGxlUHJvbWlzZShvLHIsaSxlKX19LGkucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2JpdEZpZWxkLGU9NjU1MzUmdDtpZihlPjApe2lmKDAhPT0oMTY4NDI3NTImdCkpe3ZhciBuPXRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7dGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAsbix0KSx0aGlzLl9yZWplY3RQcm9taXNlcyhlLG4pfWVsc2V7dmFyIHI9dGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7dGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCxyLHQpLHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhlLHIpfXRoaXMuX3NldExlbmd0aCgwKX10aGlzLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEoKX0saS5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2JpdEZpZWxkO3JldHVybiAwIT09KDMzNTU0NDMyJnQpP3RoaXMuX3JlamVjdGlvbkhhbmRsZXIwOjAhPT0oMTY3NzcyMTYmdCk/dGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDp2b2lkIDB9LGkuZGVmZXI9aS5wZW5kaW5nPWZ1bmN0aW9uKCl7TS5kZXByZWNhdGVkKFwiUHJvbWlzZS5kZWZlclwiLFwibmV3IFByb21pc2VcIik7dmFyIHQ9bmV3IGkodyk7cmV0dXJue3Byb21pc2U6dCxyZXNvbHZlOmEscmVqZWN0OnN9fSxkLm5vdEVudW1lcmFibGVQcm9wKGksXCJfbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3JcIixjKSx0KFwiLi9tZXRob2RcIikoaSx3LFQscCxNKSx0KFwiLi9iaW5kXCIpKGksdyxULE0pLHQoXCIuL2NhbmNlbFwiKShpLE8scCxNKSx0KFwiLi9kaXJlY3RfcmVzb2x2ZVwiKShpKSx0KFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCIpKGkpLHQoXCIuL2pvaW5cIikoaSxPLFQsdyxfLGwpLGkuUHJvbWlzZT1pLGkudmVyc2lvbj1cIjMuNC43XCIsdChcIi4vbWFwLmpzXCIpKGksTyxwLFQsdyxNKSx0KFwiLi9jYWxsX2dldC5qc1wiKShpKSx0KFwiLi91c2luZy5qc1wiKShpLHAsVCxQLHcsTSksdChcIi4vdGltZXJzLmpzXCIpKGksdyxNKSx0KFwiLi9nZW5lcmF0b3JzLmpzXCIpKGkscCx3LFQscixNKSx0KFwiLi9ub2RlaWZ5LmpzXCIpKGkpLHQoXCIuL3Byb21pc2lmeS5qc1wiKShpLHcpLHQoXCIuL3Byb3BzLmpzXCIpKGksTyxULHApLHQoXCIuL3JhY2UuanNcIikoaSx3LFQscCksdChcIi4vcmVkdWNlLmpzXCIpKGksTyxwLFQsdyxNKSx0KFwiLi9zZXR0bGUuanNcIikoaSxPLE0pLHQoXCIuL3NvbWUuanNcIikoaSxPLHApLHQoXCIuL2ZpbHRlci5qc1wiKShpLHcpLHQoXCIuL2VhY2guanNcIikoaSx3KSx0KFwiLi9hbnkuanNcIikoaSksZC50b0Zhc3RQcm9wZXJ0aWVzKGkpLGQudG9GYXN0UHJvcGVydGllcyhpLnByb3RvdHlwZSksdSh7YToxfSksdSh7YjoyfSksdSh7YzozfSksdSgxKSx1KGZ1bmN0aW9uKCl7fSksdSh2b2lkIDApLHUoITEpLHUobmV3IGkodykpLE0uc2V0Qm91bmRzKG0uZmlyc3RMaW5lRXJyb3IsZC5sYXN0TGluZUVycm9yKSxpfX0se1wiLi9hbnkuanNcIjoxLFwiLi9hc3luY1wiOjIsXCIuL2JpbmRcIjozLFwiLi9jYWxsX2dldC5qc1wiOjUsXCIuL2NhbmNlbFwiOjYsXCIuL2NhdGNoX2ZpbHRlclwiOjcsXCIuL2NvbnRleHRcIjo4LFwiLi9kZWJ1Z2dhYmlsaXR5XCI6OSxcIi4vZGlyZWN0X3Jlc29sdmVcIjoxMCxcIi4vZWFjaC5qc1wiOjExLFwiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL2ZpbHRlci5qc1wiOjE0LFwiLi9maW5hbGx5XCI6MTUsXCIuL2dlbmVyYXRvcnMuanNcIjoxNixcIi4vam9pblwiOjE3LFwiLi9tYXAuanNcIjoxOCxcIi4vbWV0aG9kXCI6MTksXCIuL25vZGViYWNrXCI6MjAsXCIuL25vZGVpZnkuanNcIjoyMSxcIi4vcHJvbWlzZV9hcnJheVwiOjIzLFwiLi9wcm9taXNpZnkuanNcIjoyNCxcIi4vcHJvcHMuanNcIjoyNSxcIi4vcmFjZS5qc1wiOjI3LFwiLi9yZWR1Y2UuanNcIjoyOCxcIi4vc2V0dGxlLmpzXCI6MzAsXCIuL3NvbWUuanNcIjozMSxcIi4vc3luY2hyb25vdXNfaW5zcGVjdGlvblwiOjMyLFwiLi90aGVuYWJsZXNcIjozMyxcIi4vdGltZXJzLmpzXCI6MzQsXCIuL3VzaW5nLmpzXCI6MzUsXCIuL3V0aWxcIjozNn1dLDIzOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbixyLG8saSl7ZnVuY3Rpb24gYSh0KXtzd2l0Y2godCl7Y2FzZS0yOnJldHVybltdO2Nhc2UtMzpyZXR1cm57fX19ZnVuY3Rpb24gcyh0KXt2YXIgcj10aGlzLl9wcm9taXNlPW5ldyBlKG4pO3QgaW5zdGFuY2VvZiBlJiZyLl9wcm9wYWdhdGVGcm9tKHQsMyksci5fc2V0T25DYW5jZWwodGhpcyksdGhpcy5fdmFsdWVzPXQsdGhpcy5fbGVuZ3RoPTAsdGhpcy5fdG90YWxSZXNvbHZlZD0wLHRoaXMuX2luaXQodm9pZCAwLC0yKX12YXIgdT10KFwiLi91dGlsXCIpO3UuaXNBcnJheTtyZXR1cm4gdS5pbmhlcml0cyhzLGkpLHMucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9sZW5ndGh9LHMucHJvdG90eXBlLnByb21pc2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvbWlzZX0scy5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24gdChuLGkpe3ZhciBzPXIodGhpcy5fdmFsdWVzLHRoaXMuX3Byb21pc2UpO2lmKHMgaW5zdGFuY2VvZiBlKXtzPXMuX3RhcmdldCgpO3ZhciBsPXMuX2JpdEZpZWxkO2lmKHRoaXMuX3ZhbHVlcz1zLDA9PT0oNTAzOTcxODQmbCkpcmV0dXJuIHRoaXMuX3Byb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpLHMuX3RoZW4odCx0aGlzLl9yZWplY3Qsdm9pZCAwLHRoaXMsaSk7aWYoMD09PSgzMzU1NDQzMiZsKSlyZXR1cm4gMCE9PSgxNjc3NzIxNiZsKT90aGlzLl9yZWplY3Qocy5fcmVhc29uKCkpOnRoaXMuX2NhbmNlbCgpO3M9cy5fdmFsdWUoKX1pZihzPXUuYXNBcnJheShzKSxudWxsPT09cyl7dmFyIGM9byhcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIit1LmNsYXNzU3RyaW5nKHMpKS5yZWFzb24oKTtyZXR1cm4gdm9pZCB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhjLCExKX1yZXR1cm4gMD09PXMubGVuZ3RoP3ZvaWQoaT09PS01P3RoaXMuX3Jlc29sdmVFbXB0eUFycmF5KCk6dGhpcy5fcmVzb2x2ZShhKGkpKSk6dm9pZCB0aGlzLl9pdGVyYXRlKHMpfSxzLnByb3RvdHlwZS5faXRlcmF0ZT1mdW5jdGlvbih0KXt2YXIgbj10aGlzLmdldEFjdHVhbExlbmd0aCh0Lmxlbmd0aCk7dGhpcy5fbGVuZ3RoPW4sdGhpcy5fdmFsdWVzPXRoaXMuc2hvdWxkQ29weVZhbHVlcygpP25ldyBBcnJheShuKTp0aGlzLl92YWx1ZXM7Zm9yKHZhciBvPXRoaXMuX3Byb21pc2UsaT0hMSxhPW51bGwscz0wO3M8bjsrK3Mpe3ZhciB1PXIodFtzXSxvKTt1IGluc3RhbmNlb2YgZT8odT11Ll90YXJnZXQoKSxhPXUuX2JpdEZpZWxkKTphPW51bGwsaT9udWxsIT09YSYmdS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTpudWxsIT09YT8wPT09KDUwMzk3MTg0JmEpPyh1Ll9wcm94eSh0aGlzLHMpLHRoaXMuX3ZhbHVlc1tzXT11KTppPTAhPT0oMzM1NTQ0MzImYSk/dGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCh1Ll92YWx1ZSgpLHMpOjAhPT0oMTY3NzcyMTYmYSk/dGhpcy5fcHJvbWlzZVJlamVjdGVkKHUuX3JlYXNvbigpLHMpOnRoaXMuX3Byb21pc2VDYW5jZWxsZWQocyk6aT10aGlzLl9wcm9taXNlRnVsZmlsbGVkKHUscyl9aXx8by5fc2V0QXN5bmNHdWFyYW50ZWVkKCl9LHMucHJvdG90eXBlLl9pc1Jlc29sdmVkPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLl92YWx1ZXN9LHMucHJvdG90eXBlLl9yZXNvbHZlPWZ1bmN0aW9uKHQpe3RoaXMuX3ZhbHVlcz1udWxsLHRoaXMuX3Byb21pc2UuX2Z1bGZpbGwodCl9LHMucHJvdG90eXBlLl9jYW5jZWw9ZnVuY3Rpb24oKXshdGhpcy5faXNSZXNvbHZlZCgpJiZ0aGlzLl9wcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkmJih0aGlzLl92YWx1ZXM9bnVsbCx0aGlzLl9wcm9taXNlLl9jYW5jZWwoKSl9LHMucHJvdG90eXBlLl9yZWplY3Q9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWVzPW51bGwsdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sodCwhMSl9LHMucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy5fdmFsdWVzW2VdPXQ7dmFyIG49Kyt0aGlzLl90b3RhbFJlc29sdmVkO3JldHVybiBuPj10aGlzLl9sZW5ndGgmJih0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyksITApfSxzLnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jYW5jZWwoKSwhMH0scy5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fdG90YWxSZXNvbHZlZCsrLHRoaXMuX3JlamVjdCh0KSwhMH0scy5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZD1mdW5jdGlvbigpe2lmKCF0aGlzLl9pc1Jlc29sdmVkKCkpe3ZhciB0PXRoaXMuX3ZhbHVlcztpZih0aGlzLl9jYW5jZWwoKSx0IGluc3RhbmNlb2YgZSl0LmNhbmNlbCgpO2Vsc2UgZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXWluc3RhbmNlb2YgZSYmdFtuXS5jYW5jZWwoKX19LHMucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMH0scy5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxzfX0se1wiLi91dGlsXCI6MzZ9XSwyNDpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIXgudGVzdCh0KX1mdW5jdGlvbiBvKHQpe3RyeXtyZXR1cm4gdC5fX2lzUHJvbWlzaWZpZWRfXz09PSEwfWNhdGNoKHQpe3JldHVybiExfX1mdW5jdGlvbiBpKHQsZSxuKXt2YXIgcj1oLmdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdCh0LGUrbixiKTtyZXR1cm4hIXImJm8ocil9ZnVuY3Rpb24gYSh0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKz0yKXt2YXIgbz10W3JdO2lmKG4udGVzdChvKSlmb3IodmFyIGk9by5yZXBsYWNlKG4sXCJcIiksYT0wO2E8dC5sZW5ndGg7YSs9MilpZih0W2FdPT09aSl0aHJvdyBuZXcgZyhcIkNhbm5vdCBwcm9taXNpZnkgYW4gQVBJIHRoYXQgaGFzIG5vcm1hbCBtZXRob2RzIHdpdGggJyVzJy1zdWZmaXhcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIucmVwbGFjZShcIiVzXCIsZSkpfX1mdW5jdGlvbiBzKHQsZSxuLHIpe2Zvcih2YXIgcz1oLmluaGVyaXRlZERhdGFLZXlzKHQpLHU9W10sbD0wO2w8cy5sZW5ndGg7KytsKXt2YXIgYz1zW2xdLGY9dFtjXSxwPXI9PT1FfHxFKGMsZix0KTtcImZ1bmN0aW9uXCIhPXR5cGVvZiBmfHxvKGYpfHxpKHQsYyxlKXx8IXIoYyxmLHQscCl8fHUucHVzaChjLGYpfXJldHVybiBhKHUsZSxuKSx1fWZ1bmN0aW9uIHUodCxyLG8saSxhLHMpe2Z1bmN0aW9uIHUoKXt2YXIgbz1yO3I9PT1wJiYobz10aGlzKTt2YXIgaT1uZXcgZShuKTtpLl9jYXB0dXJlU3RhY2tUcmFjZSgpO3ZhciBhPVwic3RyaW5nXCI9PXR5cGVvZiBjJiZ0aGlzIT09bD90aGlzW2NdOnQsdT1kKGkscyk7dHJ5e2EuYXBwbHkobyx2KGFyZ3VtZW50cyx1KSl9Y2F0Y2godCl7aS5fcmVqZWN0Q2FsbGJhY2sobSh0KSwhMCwhMCl9cmV0dXJuIGkuX2lzRmF0ZVNlYWxlZCgpfHxpLl9zZXRBc3luY0d1YXJhbnRlZWQoKSxpfXZhciBsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCksYz10O3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBjJiYodD1pKSxoLm5vdEVudW1lcmFibGVQcm9wKHUsXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCEwKSx1fWZ1bmN0aW9uIGwodCxlLG4scixvKXtmb3IodmFyIGk9bmV3IFJlZ0V4cChUKGUpK1wiJFwiKSxhPXModCxlLGksbiksdT0wLGw9YS5sZW5ndGg7dTxsO3UrPTIpe3ZhciBjPWFbdV0sZj1hW3UrMV0sZD1jK2U7aWYocj09PU8pdFtkXT1PKGMscCxjLGYsZSxvKTtlbHNle3ZhciB2PXIoZixmdW5jdGlvbigpe3JldHVybiBPKGMscCxjLGYsZSxvKX0pO2gubm90RW51bWVyYWJsZVByb3AodixcIl9faXNQcm9taXNpZmllZF9fXCIsITApLHRbZF09dn19cmV0dXJuIGgudG9GYXN0UHJvcGVydGllcyh0KSx0fWZ1bmN0aW9uIGModCxlLG4pe3JldHVybiBPKHQsZSx2b2lkIDAsdCxudWxsLG4pfXZhciBmLHA9e30saD10KFwiLi91dGlsXCIpLGQ9dChcIi4vbm9kZWJhY2tcIiksdj1oLndpdGhBcHBlbmRlZCxtPWgubWF5YmVXcmFwQXNFcnJvcixfPWguY2FuRXZhbHVhdGUsZz10KFwiLi9lcnJvcnNcIikuVHlwZUVycm9yLHk9XCJBc3luY1wiLGI9e19faXNQcm9taXNpZmllZF9fOiEwfSx3PVtcImFyaXR5XCIsXCJsZW5ndGhcIixcIm5hbWVcIixcImFyZ3VtZW50c1wiLFwiY2FsbGVyXCIsXCJjYWxsZWVcIixcInByb3RvdHlwZVwiLFwiX19pc1Byb21pc2lmaWVkX19cIl0seD1uZXcgUmVnRXhwKFwiXig/OlwiK3cuam9pbihcInxcIikrXCIpJFwiKSxFPWZ1bmN0aW9uKHQpe3JldHVybiBoLmlzSWRlbnRpZmllcih0KSYmXCJfXCIhPT10LmNoYXJBdCgwKSYmXCJjb25zdHJ1Y3RvclwiIT09dH0sVD1mdW5jdGlvbih0KXtyZXR1cm4gdC5yZXBsYWNlKC8oWyRdKS8sXCJcXFxcJFwiKX0sTz1fP2Y6dTtlLnByb21pc2lmeT1mdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IGcoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK2guY2xhc3NTdHJpbmcodCkpO2lmKG8odCkpcmV0dXJuIHQ7ZT1PYmplY3QoZSk7dmFyIG49dm9pZCAwPT09ZS5jb250ZXh0P3A6ZS5jb250ZXh0LGk9ISFlLm11bHRpQXJncyxhPWModCxuLGkpO3JldHVybiBoLmNvcHlEZXNjcmlwdG9ycyh0LGEsciksYX0sZS5wcm9taXNpZnlBbGw9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgZyhcInRoZSB0YXJnZXQgb2YgcHJvbWlzaWZ5QWxsIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25cXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO2U9T2JqZWN0KGUpO3ZhciBuPSEhZS5tdWx0aUFyZ3Mscj1lLnN1ZmZpeDtcInN0cmluZ1wiIT10eXBlb2YgciYmKHI9eSk7dmFyIG89ZS5maWx0ZXI7XCJmdW5jdGlvblwiIT10eXBlb2YgbyYmKG89RSk7dmFyIGk9ZS5wcm9taXNpZmllcjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBpJiYoaT1PKSwhaC5pc0lkZW50aWZpZXIocikpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzdWZmaXggbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO2Zvcih2YXIgYT1oLmluaGVyaXRlZERhdGFLZXlzKHQpLHM9MDtzPGEubGVuZ3RoOysrcyl7dmFyIHU9dFthW3NdXTtcImNvbnN0cnVjdG9yXCIhPT1hW3NdJiZoLmlzQ2xhc3ModSkmJihsKHUucHJvdG90eXBlLHIsbyxpLG4pLGwodSxyLG8saSxuKSl9cmV0dXJuIGwodCxyLG8saSxuKX19fSx7XCIuL2Vycm9yc1wiOjEyLFwiLi9ub2RlYmFja1wiOjIwLFwiLi91dGlsXCI6MzZ9XSwyNTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scixvKXtmdW5jdGlvbiBpKHQpe3ZhciBlLG49ITE7aWYodm9pZCAwIT09cyYmdCBpbnN0YW5jZW9mIHMpZT1mKHQpLG49ITA7ZWxzZXt2YXIgcj1jLmtleXModCksbz1yLmxlbmd0aDtlPW5ldyBBcnJheSgyKm8pO2Zvcih2YXIgaT0wO2k8bzsrK2kpe3ZhciBhPXJbaV07ZVtpXT10W2FdLGVbaStvXT1hfX10aGlzLmNvbnN0cnVjdG9yJChlKSx0aGlzLl9pc01hcD1uLHRoaXMuX2luaXQkKHZvaWQgMCwtMyl9ZnVuY3Rpb24gYSh0KXt2YXIgbixhPXIodCk7cmV0dXJuIGwoYSk/KG49YSBpbnN0YW5jZW9mIGU/YS5fdGhlbihlLnByb3BzLHZvaWQgMCx2b2lkIDAsdm9pZCAwLHZvaWQgMCk6bmV3IGkoYSkucHJvbWlzZSgpLGEgaW5zdGFuY2VvZiBlJiZuLl9wcm9wYWdhdGVGcm9tKGEsMiksbik6byhcImNhbm5vdCBhd2FpdCBwcm9wZXJ0aWVzIG9mIGEgbm9uLW9iamVjdFxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIil9dmFyIHMsdT10KFwiLi91dGlsXCIpLGw9dS5pc09iamVjdCxjPXQoXCIuL2VzNVwiKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXAmJihzPU1hcCk7dmFyIGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQscil7dGhpc1tlXT10LHRoaXNbZStuXT1yLGUrK312YXIgZT0wLG49MDtyZXR1cm4gZnVuY3Rpb24ocil7bj1yLnNpemUsZT0wO3ZhciBvPW5ldyBBcnJheSgyKnIuc2l6ZSk7cmV0dXJuIHIuZm9yRWFjaCh0LG8pLG99fSgpLHA9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBzLG49dC5sZW5ndGgvMnwwLHI9MDtyPG47KytyKXt2YXIgbz10W24rcl0saT10W3JdO2Uuc2V0KG8saSl9cmV0dXJuIGV9O3UuaW5oZXJpdHMoaSxuKSxpLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbigpe30saS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQ9ZnVuY3Rpb24odCxlKXt0aGlzLl92YWx1ZXNbZV09dDt2YXIgbj0rK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7aWYobj49dGhpcy5fbGVuZ3RoKXt2YXIgcjtpZih0aGlzLl9pc01hcClyPXAodGhpcy5fdmFsdWVzKTtlbHNle3I9e307Zm9yKHZhciBvPXRoaXMubGVuZ3RoKCksaT0wLGE9dGhpcy5sZW5ndGgoKTtpPGE7KytpKXJbdGhpcy5fdmFsdWVzW2krb11dPXRoaXMuX3ZhbHVlc1tpXX1yZXR1cm4gdGhpcy5fcmVzb2x2ZShyKSwhMH1yZXR1cm4hMX0saS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcz1mdW5jdGlvbigpe3JldHVybiExfSxpLnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGg9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PjF9LGUucHJvdG90eXBlLnByb3BzPWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcyl9LGUucHJvcHM9ZnVuY3Rpb24odCl7cmV0dXJuIGEodCl9fX0se1wiLi9lczVcIjoxMyxcIi4vdXRpbFwiOjM2fV0sMjY6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSxuLHIsbyl7Zm9yKHZhciBpPTA7aTxvOysraSluW2krcl09dFtpK2VdLHRbaStlXT12b2lkIDB9ZnVuY3Rpb24gbyh0KXt0aGlzLl9jYXBhY2l0eT10LHRoaXMuX2xlbmd0aD0wLHRoaXMuX2Zyb250PTB9by5wcm90b3R5cGUuX3dpbGxCZU92ZXJDYXBhY2l0eT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY2FwYWNpdHk8dH0sby5wcm90b3R5cGUuX3B1c2hPbmU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5sZW5ndGgoKTt0aGlzLl9jaGVja0NhcGFjaXR5KGUrMSk7dmFyIG49dGhpcy5fZnJvbnQrZSZ0aGlzLl9jYXBhY2l0eS0xO3RoaXNbbl09dCx0aGlzLl9sZW5ndGg9ZSsxfSxvLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLmxlbmd0aCgpKzM7aWYodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KHIpKXJldHVybiB0aGlzLl9wdXNoT25lKHQpLHRoaXMuX3B1c2hPbmUoZSksdm9pZCB0aGlzLl9wdXNoT25lKG4pO3ZhciBvPXRoaXMuX2Zyb250K3ItMzt0aGlzLl9jaGVja0NhcGFjaXR5KHIpO3ZhciBpPXRoaXMuX2NhcGFjaXR5LTE7dGhpc1tvKzAmaV09dCx0aGlzW28rMSZpXT1lLHRoaXNbbysyJmldPW4sdGhpcy5fbGVuZ3RoPXJ9LG8ucHJvdG90eXBlLnNoaWZ0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZnJvbnQsZT10aGlzW3RdO3JldHVybiB0aGlzW3RdPXZvaWQgMCx0aGlzLl9mcm9udD10KzEmdGhpcy5fY2FwYWNpdHktMSx0aGlzLl9sZW5ndGgtLSxlfSxvLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGVuZ3RofSxvLnByb3RvdHlwZS5fY2hlY2tDYXBhY2l0eT1mdW5jdGlvbih0KXt0aGlzLl9jYXBhY2l0eTx0JiZ0aGlzLl9yZXNpemVUbyh0aGlzLl9jYXBhY2l0eTw8MSl9LG8ucHJvdG90eXBlLl9yZXNpemVUbz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9jYXBhY2l0eTt0aGlzLl9jYXBhY2l0eT10O3ZhciBuPXRoaXMuX2Zyb250LG89dGhpcy5fbGVuZ3RoLGk9bitvJmUtMTtyKHRoaXMsMCx0aGlzLGUsaSl9LGUuZXhwb3J0cz1vfSx7fV0sMjc6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsbyl7ZnVuY3Rpb24gaSh0LGkpe3ZhciB1PXIodCk7aWYodSBpbnN0YW5jZW9mIGUpcmV0dXJuIHModSk7aWYodD1hLmFzQXJyYXkodCksbnVsbD09PXQpcmV0dXJuIG8oXCJleHBlY3RpbmcgYW4gYXJyYXkgb3IgYW4gaXRlcmFibGUgb2JqZWN0IGJ1dCBnb3QgXCIrYS5jbGFzc1N0cmluZyh0KSk7dmFyIGw9bmV3IGUobik7dm9pZCAwIT09aSYmbC5fcHJvcGFnYXRlRnJvbShpLDMpO2Zvcih2YXIgYz1sLl9mdWxmaWxsLGY9bC5fcmVqZWN0LHA9MCxoPXQubGVuZ3RoO3A8aDsrK3Ape3ZhciBkPXRbcF07KHZvaWQgMCE9PWR8fHAgaW4gdCkmJmUuY2FzdChkKS5fdGhlbihjLGYsdm9pZCAwLGwsbnVsbCl9cmV0dXJuIGx9dmFyIGE9dChcIi4vdXRpbFwiKSxzPWZ1bmN0aW9uKHQpe3JldHVybiB0LnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGkoZSx0KX0pfTtlLnJhY2U9ZnVuY3Rpb24odCl7cmV0dXJuIGkodCx2b2lkIDApfSxlLnByb3RvdHlwZS5yYWNlPWZ1bmN0aW9uKCl7cmV0dXJuIGkodGhpcyx2b2lkIDApfX19LHtcIi4vdXRpbFwiOjM2fV0sMjg6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsbyxpLGEpe2Z1bmN0aW9uIHModCxuLHIsbyl7dGhpcy5jb25zdHJ1Y3RvciQodCk7dmFyIGE9cCgpO3RoaXMuX2ZuPW51bGw9PT1hP246aC5kb21haW5CaW5kKGEsbiksdm9pZCAwIT09ciYmKHI9ZS5yZXNvbHZlKHIpLHIuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKHRoaXMpKSx0aGlzLl9pbml0aWFsVmFsdWU9cix0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGU9bnVsbCxvPT09aT90aGlzLl9lYWNoVmFsdWVzPUFycmF5KHRoaXMuX2xlbmd0aCk6MD09PW8/dGhpcy5fZWFjaFZhbHVlcz1udWxsOnRoaXMuX2VhY2hWYWx1ZXM9dm9pZCAwLHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCksdGhpcy5faW5pdCQodm9pZCAwLC01KX1mdW5jdGlvbiB1KHQsZSl7dGhpcy5pc0Z1bGZpbGxlZCgpP2UuX3Jlc29sdmUodCk6ZS5fcmVqZWN0KHQpfWZ1bmN0aW9uIGwodCxlLG4sbyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSlyZXR1cm4gcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIraC5jbGFzc1N0cmluZyhlKSk7dmFyIGk9bmV3IHModCxlLG4sbyk7cmV0dXJuIGkucHJvbWlzZSgpfWZ1bmN0aW9uIGModCl7dGhpcy5hY2N1bT10LHRoaXMuYXJyYXkuX2dvdEFjY3VtKHQpO3ZhciBuPW8odGhpcy52YWx1ZSx0aGlzLmFycmF5Ll9wcm9taXNlKTtyZXR1cm4gbiBpbnN0YW5jZW9mIGU/KHRoaXMuYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZT1uLG4uX3RoZW4oZix2b2lkIDAsdm9pZCAwLHRoaXMsdm9pZCAwKSk6Zi5jYWxsKHRoaXMsbil9ZnVuY3Rpb24gZih0KXt2YXIgbj10aGlzLmFycmF5LHI9bi5fcHJvbWlzZSxvPWQobi5fZm4pO3IuX3B1c2hDb250ZXh0KCk7dmFyIGk7aT12b2lkIDAhPT1uLl9lYWNoVmFsdWVzP28uY2FsbChyLl9ib3VuZFZhbHVlKCksdCx0aGlzLmluZGV4LHRoaXMubGVuZ3RoKTpvLmNhbGwoci5fYm91bmRWYWx1ZSgpLHRoaXMuYWNjdW0sdCx0aGlzLmluZGV4LHRoaXMubGVuZ3RoKSxpIGluc3RhbmNlb2YgZSYmKG4uX2N1cnJlbnRDYW5jZWxsYWJsZT1pKTt2YXIgcz1yLl9wb3BDb250ZXh0KCk7cmV0dXJuIGEuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKGkscyx2b2lkIDAhPT1uLl9lYWNoVmFsdWVzP1wiUHJvbWlzZS5lYWNoXCI6XCJQcm9taXNlLnJlZHVjZVwiLHIpLGl9dmFyIHA9ZS5fZ2V0RG9tYWluLGg9dChcIi4vdXRpbFwiKSxkPWgudHJ5Q2F0Y2g7aC5pbmhlcml0cyhzLG4pLHMucHJvdG90eXBlLl9nb3RBY2N1bT1mdW5jdGlvbih0KXt2b2lkIDAhPT10aGlzLl9lYWNoVmFsdWVzJiZudWxsIT09dGhpcy5fZWFjaFZhbHVlcyYmdCE9PWkmJnRoaXMuX2VhY2hWYWx1ZXMucHVzaCh0KX0scy5wcm90b3R5cGUuX2VhY2hDb21wbGV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXRoaXMuX2VhY2hWYWx1ZXMmJnRoaXMuX2VhY2hWYWx1ZXMucHVzaCh0KSx0aGlzLl9lYWNoVmFsdWVzfSxzLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbigpe30scy5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5PWZ1bmN0aW9uKCl7dGhpcy5fcmVzb2x2ZSh2b2lkIDAhPT10aGlzLl9lYWNoVmFsdWVzP3RoaXMuX2VhY2hWYWx1ZXM6dGhpcy5faW5pdGlhbFZhbHVlKX0scy5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcz1mdW5jdGlvbigpe3JldHVybiExfSxzLnByb3RvdHlwZS5fcmVzb2x2ZT1mdW5jdGlvbih0KXt0aGlzLl9wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodCksdGhpcy5fdmFsdWVzPW51bGx9LHMucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLl9pbml0aWFsVmFsdWU/dGhpcy5fY2FuY2VsKCk6dm9pZCh0aGlzLl9pc1Jlc29sdmVkKCl8fCh0aGlzLl9yZXN1bHRDYW5jZWxsZWQkKCksdGhpcy5fY3VycmVudENhbmNlbGxhYmxlIGluc3RhbmNlb2YgZSYmdGhpcy5fY3VycmVudENhbmNlbGxhYmxlLmNhbmNlbCgpLHRoaXMuX2luaXRpYWxWYWx1ZSBpbnN0YW5jZW9mIGUmJnRoaXMuX2luaXRpYWxWYWx1ZS5jYW5jZWwoKSkpfSxzLnByb3RvdHlwZS5faXRlcmF0ZT1mdW5jdGlvbih0KXt0aGlzLl92YWx1ZXM9dDt2YXIgbixyLG89dC5sZW5ndGg7aWYodm9pZCAwIT09dGhpcy5faW5pdGlhbFZhbHVlPyhuPXRoaXMuX2luaXRpYWxWYWx1ZSxyPTApOihuPWUucmVzb2x2ZSh0WzBdKSxyPTEpLHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZT1uLCFuLmlzUmVqZWN0ZWQoKSlmb3IoO3I8bzsrK3Ipe3ZhciBpPXthY2N1bTpudWxsLHZhbHVlOnRbcl0saW5kZXg6cixsZW5ndGg6byxhcnJheTp0aGlzfTtuPW4uX3RoZW4oYyx2b2lkIDAsdm9pZCAwLGksdm9pZCAwKX12b2lkIDAhPT10aGlzLl9lYWNoVmFsdWVzJiYobj1uLl90aGVuKHRoaXMuX2VhY2hDb21wbGV0ZSx2b2lkIDAsdm9pZCAwLHRoaXMsdm9pZCAwKSksbi5fdGhlbih1LHUsdm9pZCAwLG4sdGhpcyl9LGUucHJvdG90eXBlLnJlZHVjZT1mdW5jdGlvbih0LGUpe3JldHVybiBsKHRoaXMsdCxlLG51bGwpfSxlLnJlZHVjZT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gbCh0LGUsbixyKX19fSx7XCIuL3V0aWxcIjozNn1dLDI5OltmdW5jdGlvbih0LG8saSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGEscz10KFwiLi91dGlsXCIpLHU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKX0sbD1zLmdldE5hdGl2ZVByb21pc2UoKTtpZihzLmlzTm9kZSYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIpe3ZhciBjPW4uc2V0SW1tZWRpYXRlLGY9ZS5uZXh0VGljazthPXMuaXNSZWNlbnROb2RlP2Z1bmN0aW9uKHQpe2MuY2FsbChuLHQpfTpmdW5jdGlvbih0KXtmLmNhbGwoZSx0KX19ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBsJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBsLnJlc29sdmUpe3ZhciBwPWwucmVzb2x2ZSgpO2E9ZnVuY3Rpb24odCl7cC50aGVuKHQpfX1lbHNlIGE9XCJ1bmRlZmluZWRcIj09dHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXJ8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5uYXZpZ2F0b3ImJih3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmV8fHdpbmRvdy5jb3Jkb3ZhKT9cInVuZGVmaW5lZFwiIT10eXBlb2Ygcj9mdW5jdGlvbih0KXtyKHQpfTpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0VGltZW91dD9mdW5jdGlvbih0KXtzZXRUaW1lb3V0KHQsMCl9OnU6ZnVuY3Rpb24oKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGU9e2F0dHJpYnV0ZXM6ITB9LG49ITEscj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG89bmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKXt0LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIiksbj0hMX0pO28ub2JzZXJ2ZShyLGUpO3ZhciBpPWZ1bmN0aW9uKCl7bnx8KG49ITAsci5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpKX07cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByPW5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCl7ci5kaXNjb25uZWN0KCksbigpfSk7ci5vYnNlcnZlKHQsZSksaSgpfX0oKTtvLmV4cG9ydHM9YX0se1wiLi91dGlsXCI6MzZ9XSwzMDpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scil7ZnVuY3Rpb24gbyh0KXt0aGlzLmNvbnN0cnVjdG9yJCh0KX12YXIgaT1lLlByb21pc2VJbnNwZWN0aW9uLGE9dChcIi4vdXRpbFwiKTthLmluaGVyaXRzKG8sbiksby5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZD1mdW5jdGlvbih0LGUpe3RoaXMuX3ZhbHVlc1t0XT1lO3ZhciBuPSsrdGhpcy5fdG90YWxSZXNvbHZlZDtyZXR1cm4gbj49dGhpcy5fbGVuZ3RoJiYodGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpLCEwKX0sby5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgaTtyZXR1cm4gbi5fYml0RmllbGQ9MzM1NTQ0MzIsbi5fc2V0dGxlZFZhbHVlRmllbGQ9dCx0aGlzLl9wcm9taXNlUmVzb2x2ZWQoZSxuKX0sby5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBpO3JldHVybiBuLl9iaXRGaWVsZD0xNjc3NzIxNixuLl9zZXR0bGVkVmFsdWVGaWVsZD10LHRoaXMuX3Byb21pc2VSZXNvbHZlZChlLG4pfSxlLnNldHRsZT1mdW5jdGlvbih0KXtyZXR1cm4gci5kZXByZWNhdGVkKFwiLnNldHRsZSgpXCIsXCIucmVmbGVjdCgpXCIpLG5ldyBvKHQpLnByb21pc2UoKX0sZS5wcm90b3R5cGUuc2V0dGxlPWZ1bmN0aW9uKCl7cmV0dXJuIGUuc2V0dGxlKHRoaXMpfX19LHtcIi4vdXRpbFwiOjM2fV0sMzE6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIpe2Z1bmN0aW9uIG8odCl7dGhpcy5jb25zdHJ1Y3RvciQodCksdGhpcy5faG93TWFueT0wLHRoaXMuX3Vud3JhcD0hMSx0aGlzLl9pbml0aWFsaXplZD0hMX1mdW5jdGlvbiBpKHQsZSl7aWYoKDB8ZSkhPT1lfHxlPDApcmV0dXJuIHIoXCJleHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTt2YXIgbj1uZXcgbyh0KSxpPW4ucHJvbWlzZSgpO3JldHVybiBuLnNldEhvd01hbnkoZSksbi5pbml0KCksaX12YXIgYT10KFwiLi91dGlsXCIpLHM9dChcIi4vZXJyb3JzXCIpLlJhbmdlRXJyb3IsdT10KFwiLi9lcnJvcnNcIikuQWdncmVnYXRlRXJyb3IsbD1hLmlzQXJyYXksYz17fTthLmluaGVyaXRzKG8sbiksby5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oKXtpZih0aGlzLl9pbml0aWFsaXplZCl7aWYoMD09PXRoaXMuX2hvd01hbnkpcmV0dXJuIHZvaWQgdGhpcy5fcmVzb2x2ZShbXSk7dGhpcy5faW5pdCQodm9pZCAwLC01KTt2YXIgdD1sKHRoaXMuX3ZhbHVlcyk7IXRoaXMuX2lzUmVzb2x2ZWQoKSYmdCYmdGhpcy5faG93TWFueT50aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSYmdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IodGhpcy5sZW5ndGgoKSkpfX0sby5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3RoaXMuX2luaXRpYWxpemVkPSEwLHRoaXMuX2luaXQoKX0sby5wcm90b3R5cGUuc2V0VW53cmFwPWZ1bmN0aW9uKCl7dGhpcy5fdW53cmFwPSEwfSxvLnByb3RvdHlwZS5ob3dNYW55PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hvd01hbnl9LG8ucHJvdG90eXBlLnNldEhvd01hbnk9ZnVuY3Rpb24odCl7dGhpcy5faG93TWFueT10fSxvLnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYWRkRnVsZmlsbGVkKHQpLHRoaXMuX2Z1bGZpbGxlZCgpPT09dGhpcy5ob3dNYW55KCkmJih0aGlzLl92YWx1ZXMubGVuZ3RoPXRoaXMuaG93TWFueSgpLDE9PT10aGlzLmhvd01hbnkoKSYmdGhpcy5fdW53cmFwP3RoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzWzBdKTp0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyksITApfSxvLnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9hZGRSZWplY3RlZCh0KSx0aGlzLl9jaGVja091dGNvbWUoKX0sby5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWVzIGluc3RhbmNlb2YgZXx8bnVsbD09dGhpcy5fdmFsdWVzP3RoaXMuX2NhbmNlbCgpOih0aGlzLl9hZGRSZWplY3RlZChjKSx0aGlzLl9jaGVja091dGNvbWUoKSl9LG8ucHJvdG90eXBlLl9jaGVja091dGNvbWU9ZnVuY3Rpb24oKXtpZih0aGlzLmhvd01hbnkoKT50aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSl7Zm9yKHZhciB0PW5ldyB1LGU9dGhpcy5sZW5ndGgoKTtlPHRoaXMuX3ZhbHVlcy5sZW5ndGg7KytlKXRoaXMuX3ZhbHVlc1tlXSE9PWMmJnQucHVzaCh0aGlzLl92YWx1ZXNbZV0pO3JldHVybiB0Lmxlbmd0aD4wP3RoaXMuX3JlamVjdCh0KTp0aGlzLl9jYW5jZWwoKSwhMH1yZXR1cm4hMX0sby5wcm90b3R5cGUuX2Z1bGZpbGxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90b3RhbFJlc29sdmVkfSxvLnByb3RvdHlwZS5fcmVqZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aC10aGlzLmxlbmd0aCgpfSxvLnByb3RvdHlwZS5fYWRkUmVqZWN0ZWQ9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWVzLnB1c2godCl9LG8ucHJvdG90eXBlLl9hZGRGdWxmaWxsZWQ9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWVzW3RoaXMuX3RvdGFsUmVzb2x2ZWQrK109dH0sby5wcm90b3R5cGUuX2NhblBvc3NpYmx5RnVsZmlsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aCgpLXRoaXMuX3JlamVjdGVkKCl9LG8ucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPVwiSW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IFwiK3RoaXMuX2hvd01hbnkrXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIrdCtcIiBpdGVtc1wiO3JldHVybiBuZXcgcyhlKX0sby5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5PWZ1bmN0aW9uKCl7dGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IoMCkpfSxlLnNvbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaSh0LGUpfSxlLnByb3RvdHlwZS5zb21lPWZ1bmN0aW9uKHQpe3JldHVybiBpKHRoaXMsdCl9LGUuX1NvbWVQcm9taXNlQXJyYXk9b319LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDMyOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7dm9pZCAwIT09dD8odD10Ll90YXJnZXQoKSx0aGlzLl9iaXRGaWVsZD10Ll9iaXRGaWVsZCx0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZD10Ll9pc0ZhdGVTZWFsZWQoKT90Ll9zZXR0bGVkVmFsdWUoKTp2b2lkIDApOih0aGlzLl9iaXRGaWVsZD0wLHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkPXZvaWQgMCl9ZS5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZH07dmFyIG49ZS5wcm90b3R5cGUudmFsdWU9ZnVuY3Rpb24oKXtpZighdGhpcy5pc0Z1bGZpbGxlZCgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtyZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCl9LHI9ZS5wcm90b3R5cGUuZXJyb3I9ZS5wcm90b3R5cGUucmVhc29uPWZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNSZWplY3RlZCgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7cmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpfSxvPWUucHJvdG90eXBlLmlzRnVsZmlsbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT0oMzM1NTQ0MzImdGhpcy5fYml0RmllbGQpfSxpPWUucHJvdG90eXBlLmlzUmVqZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PSgxNjc3NzIxNiZ0aGlzLl9iaXRGaWVsZCl9LGE9ZS5wcm90b3R5cGUuaXNQZW5kaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT0oNTAzOTcxODQmdGhpcy5fYml0RmllbGQpfSxzPWUucHJvdG90eXBlLmlzUmVzb2x2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PSg1MDMzMTY0OCZ0aGlzLl9iaXRGaWVsZCl9O2UucHJvdG90eXBlLmlzQ2FuY2VsbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT0oODQ1NDE0NCZ0aGlzLl9iaXRGaWVsZCl9LHQucHJvdG90eXBlLl9faXNDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gNjU1MzY9PT0oNjU1MzYmdGhpcy5fYml0RmllbGQpfSx0LnByb3RvdHlwZS5faXNDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX19pc0NhbmNlbGxlZCgpfSx0LnByb3RvdHlwZS5pc0NhbmNlbGxlZD1mdW5jdGlvbigpe3JldHVybiAwIT09KDg0NTQxNDQmdGhpcy5fdGFyZ2V0KCkuX2JpdEZpZWxkKX0sdC5wcm90b3R5cGUuaXNQZW5kaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2FsbCh0aGlzLl90YXJnZXQoKSl9LHQucHJvdG90eXBlLmlzUmVqZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gaS5jYWxsKHRoaXMuX3RhcmdldCgpKX0sdC5wcm90b3R5cGUuaXNGdWxmaWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gby5jYWxsKHRoaXMuX3RhcmdldCgpKX0sdC5wcm90b3R5cGUuaXNSZXNvbHZlZD1mdW5jdGlvbigpe3JldHVybiBzLmNhbGwodGhpcy5fdGFyZ2V0KCkpfSx0LnByb3RvdHlwZS52YWx1ZT1mdW5jdGlvbigpe3JldHVybiBuLmNhbGwodGhpcy5fdGFyZ2V0KCkpfSx0LnByb3RvdHlwZS5yZWFzb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl90YXJnZXQoKTtyZXR1cm4gdC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpLHIuY2FsbCh0KX0sdC5wcm90b3R5cGUuX3ZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpfSx0LnByb3RvdHlwZS5fcmVhc29uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKSx0aGlzLl9zZXR0bGVkVmFsdWUoKX0sdC5Qcm9taXNlSW5zcGVjdGlvbj1lfX0se31dLDMzOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gcih0LHIpe2lmKGModCkpe2lmKHQgaW5zdGFuY2VvZiBlKXJldHVybiB0O3ZhciBvPWkodCk7aWYobz09PWwpe3ImJnIuX3B1c2hDb250ZXh0KCk7dmFyIHU9ZS5yZWplY3Qoby5lKTtyZXR1cm4gciYmci5fcG9wQ29udGV4dCgpLHV9aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbyl7aWYoYSh0KSl7dmFyIHU9bmV3IGUobik7cmV0dXJuIHQuX3RoZW4odS5fZnVsZmlsbCx1Ll9yZWplY3Qsdm9pZCAwLHUsbnVsbCksdX1yZXR1cm4gcyh0LG8scil9fXJldHVybiB0fWZ1bmN0aW9uIG8odCl7cmV0dXJuIHQudGhlbn1mdW5jdGlvbiBpKHQpe3RyeXtyZXR1cm4gbyh0KX1jYXRjaCh0KXtyZXR1cm4gbC5lPXQsbH19ZnVuY3Rpb24gYSh0KXt0cnl7cmV0dXJuIGYuY2FsbCh0LFwiX3Byb21pc2UwXCIpfWNhdGNoKHQpe3JldHVybiExfX1mdW5jdGlvbiBzKHQscixvKXtmdW5jdGlvbiBpKHQpe3MmJihzLl9yZXNvbHZlQ2FsbGJhY2sodCkscz1udWxsKX1mdW5jdGlvbiBhKHQpe3MmJihzLl9yZWplY3RDYWxsYmFjayh0LGYsITApLHM9bnVsbCl9dmFyIHM9bmV3IGUobiksYz1zO28mJm8uX3B1c2hDb250ZXh0KCkscy5fY2FwdHVyZVN0YWNrVHJhY2UoKSxvJiZvLl9wb3BDb250ZXh0KCk7dmFyIGY9ITAscD11LnRyeUNhdGNoKHIpLmNhbGwodCxpLGEpO3JldHVybiBmPSExLHMmJnA9PT1sJiYocy5fcmVqZWN0Q2FsbGJhY2socC5lLCEwLCEwKSxzPW51bGwpLGN9dmFyIHU9dChcIi4vdXRpbFwiKSxsPXUuZXJyb3JPYmosYz11LmlzT2JqZWN0LGY9e30uaGFzT3duUHJvcGVydHk7cmV0dXJuIHJ9fSx7XCIuL3V0aWxcIjozNn1dLDM0OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbixyKXtmdW5jdGlvbiBvKHQpe3RoaXMuaGFuZGxlPXR9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKSx0fWZ1bmN0aW9uIGEodCl7dGhyb3cgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKSx0fXZhciBzPXQoXCIuL3V0aWxcIiksdT1lLlRpbWVvdXRFcnJvcjtvLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKX07dmFyIGw9ZnVuY3Rpb24odCl7cmV0dXJuIGMoK3RoaXMpLnRoZW5SZXR1cm4odCl9LGM9ZS5kZWxheT1mdW5jdGlvbih0LGkpe3ZhciBhLHM7cmV0dXJuIHZvaWQgMCE9PWk/KGE9ZS5yZXNvbHZlKGkpLl90aGVuKGwsbnVsbCxudWxsLHQsdm9pZCAwKSxyLmNhbmNlbGxhdGlvbigpJiZpIGluc3RhbmNlb2YgZSYmYS5fc2V0T25DYW5jZWwoaSkpOihhPW5ldyBlKG4pLHM9c2V0VGltZW91dChmdW5jdGlvbigpe2EuX2Z1bGZpbGwoKX0sK3QpLHIuY2FuY2VsbGF0aW9uKCkmJmEuX3NldE9uQ2FuY2VsKG5ldyBvKHMpKSxhLl9jYXB0dXJlU3RhY2tUcmFjZSgpKSxhLl9zZXRBc3luY0d1YXJhbnRlZWQoKSxhfTtlLnByb3RvdHlwZS5kZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gYyh0LHRoaXMpfTt2YXIgZj1mdW5jdGlvbih0LGUsbil7dmFyIHI7cj1cInN0cmluZ1wiIT10eXBlb2YgZT9lIGluc3RhbmNlb2YgRXJyb3I/ZTpuZXcgdShcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIik6bmV3IHUoZSkscy5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ociksdC5fYXR0YWNoRXh0cmFUcmFjZShyKSx0Ll9yZWplY3QociksbnVsbCE9biYmbi5jYW5jZWwoKX07ZS5wcm90b3R5cGUudGltZW91dD1mdW5jdGlvbih0LGUpe3Q9K3Q7dmFyIG4scyx1PW5ldyBvKHNldFRpbWVvdXQoZnVuY3Rpb24oKXtuLmlzUGVuZGluZygpJiZmKG4sZSxzKX0sdCkpO3JldHVybiByLmNhbmNlbGxhdGlvbigpPyhzPXRoaXMudGhlbigpLG49cy5fdGhlbihpLGEsdm9pZCAwLHUsdm9pZCAwKSxuLl9zZXRPbkNhbmNlbCh1KSk6bj10aGlzLl90aGVuKGksYSx2b2lkIDAsdSx2b2lkIDApLG59fX0se1wiLi91dGlsXCI6MzZ9XSwzNTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scixvLGksYSl7ZnVuY3Rpb24gcyh0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgdH0sMCl9ZnVuY3Rpb24gdSh0KXt2YXIgZT1yKHQpO3JldHVybiBlIT09dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5faXNEaXNwb3NhYmxlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0Ll9nZXREaXNwb3NlciYmdC5faXNEaXNwb3NhYmxlKCkmJmUuX3NldERpc3Bvc2FibGUodC5fZ2V0RGlzcG9zZXIoKSksZX1mdW5jdGlvbiBsKHQsbil7ZnVuY3Rpb24gbygpe2lmKGE+PWwpcmV0dXJuIGMuX2Z1bGZpbGwoKTt2YXIgaT11KHRbYSsrXSk7aWYoaSBpbnN0YW5jZW9mIGUmJmkuX2lzRGlzcG9zYWJsZSgpKXt0cnl7aT1yKGkuX2dldERpc3Bvc2VyKCkudHJ5RGlzcG9zZShuKSx0LnByb21pc2UpfWNhdGNoKHQpe3JldHVybiBzKHQpfWlmKGkgaW5zdGFuY2VvZiBlKXJldHVybiBpLl90aGVuKG8scyxudWxsLG51bGwsbnVsbCl9bygpfXZhciBhPTAsbD10Lmxlbmd0aCxjPW5ldyBlKGkpO3JldHVybiBvKCksY31mdW5jdGlvbiBjKHQsZSxuKXt0aGlzLl9kYXRhPXQsdGhpcy5fcHJvbWlzZT1lLHRoaXMuX2NvbnRleHQ9bn1mdW5jdGlvbiBmKHQsZSxuKXt0aGlzLmNvbnN0cnVjdG9yJCh0LGUsbil9ZnVuY3Rpb24gcCh0KXtyZXR1cm4gYy5pc0Rpc3Bvc2VyKHQpPyh0aGlzLnJlc291cmNlc1t0aGlzLmluZGV4XS5fc2V0RGlzcG9zYWJsZSh0KSx0LnByb21pc2UoKSk6dH1mdW5jdGlvbiBoKHQpe3RoaXMubGVuZ3RoPXQsdGhpcy5wcm9taXNlPW51bGwsdGhpc1t0LTFdPW51bGx9dmFyIGQ9dChcIi4vdXRpbFwiKSx2PXQoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3IsbT10KFwiLi91dGlsXCIpLmluaGVyaXRzLF89ZC5lcnJvck9iaixnPWQudHJ5Q2F0Y2gseT17fTtjLnByb3RvdHlwZS5kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RhdGF9LGMucHJvdG90eXBlLnByb21pc2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvbWlzZX0sYy5wcm90b3R5cGUucmVzb3VyY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKT90aGlzLnByb21pc2UoKS52YWx1ZSgpOnl9LGMucHJvdG90eXBlLnRyeURpc3Bvc2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZXNvdXJjZSgpLG49dGhpcy5fY29udGV4dDt2b2lkIDAhPT1uJiZuLl9wdXNoQ29udGV4dCgpO3ZhciByPWUhPT15P3RoaXMuZG9EaXNwb3NlKGUsdCk6bnVsbDtyZXR1cm4gdm9pZCAwIT09biYmbi5fcG9wQ29udGV4dCgpLHRoaXMuX3Byb21pc2UuX3Vuc2V0RGlzcG9zYWJsZSgpLHRoaXMuX2RhdGE9bnVsbCxyfSxjLmlzRGlzcG9zZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQucmVzb3VyY2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudHJ5RGlzcG9zZX0sbShmLGMpLGYucHJvdG90eXBlLmRvRGlzcG9zZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZGF0YSgpO3JldHVybiBuLmNhbGwodCx0LGUpfSxoLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubGVuZ3RoLG49MDtuPHQ7KytuKXt2YXIgcj10aGlzW25dO3IgaW5zdGFuY2VvZiBlJiZyLmNhbmNlbCgpO1xufX0sZS51c2luZz1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg7aWYodDwyKXJldHVybiBuKFwieW91IG11c3QgcGFzcyBhdCBsZWFzdCAyIGFyZ3VtZW50cyB0byBQcm9taXNlLnVzaW5nXCIpO3ZhciBvPWFyZ3VtZW50c1t0LTFdO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG8pcmV0dXJuIG4oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK2QuY2xhc3NTdHJpbmcobykpO3ZhciBpLHM9ITA7Mj09PXQmJkFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKT8oaT1hcmd1bWVudHNbMF0sdD1pLmxlbmd0aCxzPSExKTooaT1hcmd1bWVudHMsdC0tKTtmb3IodmFyIHU9bmV3IGgodCksZj0wO2Y8dDsrK2Ype3ZhciB2PWlbZl07aWYoYy5pc0Rpc3Bvc2VyKHYpKXt2YXIgbT12O3Y9di5wcm9taXNlKCksdi5fc2V0RGlzcG9zYWJsZShtKX1lbHNle3ZhciB5PXIodik7eSBpbnN0YW5jZW9mIGUmJih2PXkuX3RoZW4ocCxudWxsLG51bGwse3Jlc291cmNlczp1LGluZGV4OmZ9LHZvaWQgMCkpfXVbZl09dn1mb3IodmFyIGI9bmV3IEFycmF5KHUubGVuZ3RoKSxmPTA7ZjxiLmxlbmd0aDsrK2YpYltmXT1lLnJlc29sdmUodVtmXSkucmVmbGVjdCgpO3ZhciB3PWUuYWxsKGIpLnRoZW4oZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDsrK2Upe3ZhciBuPXRbZV07aWYobi5pc1JlamVjdGVkKCkpcmV0dXJuIF8uZT1uLmVycm9yKCksXztpZighbi5pc0Z1bGZpbGxlZCgpKXJldHVybiB2b2lkIHcuY2FuY2VsKCk7dFtlXT1uLnZhbHVlKCl9eC5fcHVzaENvbnRleHQoKSxvPWcobyk7dmFyIHI9cz9vLmFwcGx5KHZvaWQgMCx0KTpvKHQpLGk9eC5fcG9wQ29udGV4dCgpO3JldHVybiBhLmNoZWNrRm9yZ290dGVuUmV0dXJucyhyLGksXCJQcm9taXNlLnVzaW5nXCIseCkscn0pLHg9dy5sYXN0bHkoZnVuY3Rpb24oKXt2YXIgdD1uZXcgZS5Qcm9taXNlSW5zcGVjdGlvbih3KTtyZXR1cm4gbCh1LHQpfSk7cmV0dXJuIHUucHJvbWlzZT14LHguX3NldE9uQ2FuY2VsKHUpLHh9LGUucHJvdG90eXBlLl9zZXREaXNwb3NhYmxlPWZ1bmN0aW9uKHQpe3RoaXMuX2JpdEZpZWxkPTEzMTA3Mnx0aGlzLl9iaXRGaWVsZCx0aGlzLl9kaXNwb3Nlcj10fSxlLnByb3RvdHlwZS5faXNEaXNwb3NhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuKDEzMTA3MiZ0aGlzLl9iaXRGaWVsZCk+MH0sZS5wcm90b3R5cGUuX2dldERpc3Bvc2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc3Bvc2VyfSxlLnByb3RvdHlwZS5fdW5zZXREaXNwb3NhYmxlPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9dGhpcy5fYml0RmllbGQmLTEzMTA3Myx0aGlzLl9kaXNwb3Nlcj12b2lkIDB9LGUucHJvdG90eXBlLmRpc3Bvc2VyPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpcmV0dXJuIG5ldyBmKHQsdGhpcyxvKCkpO3Rocm93IG5ldyB2fX19LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDM2OltmdW5jdGlvbih0LHIsbyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSgpe3RyeXt2YXIgdD1DO3JldHVybiBDPW51bGwsdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2godCl7cmV0dXJuIEEuZT10LEF9fWZ1bmN0aW9uIGEodCl7cmV0dXJuIEM9dCxpfWZ1bmN0aW9uIHModCl7cmV0dXJuIG51bGw9PXR8fHQ9PT0hMHx8dD09PSExfHxcInN0cmluZ1wiPT10eXBlb2YgdHx8XCJudW1iZXJcIj09dHlwZW9mIHR9ZnVuY3Rpb24gdSh0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fHxcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXR9ZnVuY3Rpb24gbCh0KXtyZXR1cm4gcyh0KT9uZXcgRXJyb3IoZyh0KSk6dH1mdW5jdGlvbiBjKHQsZSl7dmFyIG4scj10Lmxlbmd0aCxvPW5ldyBBcnJheShyKzEpO2ZvcihuPTA7bjxyOysrbilvW25dPXRbbl07cmV0dXJuIG9bbl09ZSxvfWZ1bmN0aW9uIGYodCxlLG4pe2lmKCFNLmlzRVM1KXJldHVybnt9Lmhhc093blByb3BlcnR5LmNhbGwodCxlKT90W2VdOnZvaWQgMDt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSk7cmV0dXJuIG51bGwhPXI/bnVsbD09ci5nZXQmJm51bGw9PXIuc2V0P3IudmFsdWU6bjp2b2lkIDB9ZnVuY3Rpb24gcCh0LGUsbil7aWYocyh0KSlyZXR1cm4gdDt2YXIgcj17dmFsdWU6bixjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMH07cmV0dXJuIE0uZGVmaW5lUHJvcGVydHkodCxlLHIpLHR9ZnVuY3Rpb24gaCh0KXt0aHJvdyB0fWZ1bmN0aW9uIGQodCl7dHJ5e2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpe3ZhciBlPU0ubmFtZXModC5wcm90b3R5cGUpLG49TS5pc0VTNSYmZS5sZW5ndGg+MSxyPWUubGVuZ3RoPjAmJiEoMT09PWUubGVuZ3RoJiZcImNvbnN0cnVjdG9yXCI9PT1lWzBdKSxvPU4udGVzdCh0K1wiXCIpJiZNLm5hbWVzKHQpLmxlbmd0aD4wO2lmKG58fHJ8fG8pcmV0dXJuITB9cmV0dXJuITF9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIHYodCl7ZnVuY3Rpb24gZSgpe31lLnByb3RvdHlwZT10O2Zvcih2YXIgbj04O24tLTspbmV3IGU7cmV0dXJuIHR9ZnVuY3Rpb24gbSh0KXtyZXR1cm4gVS50ZXN0KHQpfWZ1bmN0aW9uIF8odCxlLG4pe2Zvcih2YXIgcj1uZXcgQXJyYXkodCksbz0wO288dDsrK28pcltvXT1lK28rbjtyZXR1cm4gcn1mdW5jdGlvbiBnKHQpe3RyeXtyZXR1cm4gdCtcIlwifWNhdGNoKHQpe3JldHVyblwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIn19ZnVuY3Rpb24geSh0KXtyZXR1cm4gbnVsbCE9PXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcInN0cmluZ1wiPT10eXBlb2YgdC5tZXNzYWdlJiZcInN0cmluZ1wiPT10eXBlb2YgdC5uYW1lfWZ1bmN0aW9uIGIodCl7dHJ5e3AodCxcImlzT3BlcmF0aW9uYWxcIiwhMCl9Y2F0Y2godCl7fX1mdW5jdGlvbiB3KHQpe3JldHVybiBudWxsIT10JiYodCBpbnN0YW5jZW9mIEVycm9yLl9fQmx1ZWJpcmRFcnJvclR5cGVzX18uT3BlcmF0aW9uYWxFcnJvcnx8dC5pc09wZXJhdGlvbmFsPT09ITApfWZ1bmN0aW9uIHgodCl7cmV0dXJuIHkodCkmJk0ucHJvcGVydHlJc1dyaXRhYmxlKHQsXCJzdGFja1wiKX1mdW5jdGlvbiBFKHQpe3JldHVybnt9LnRvU3RyaW5nLmNhbGwodCl9ZnVuY3Rpb24gVCh0LGUsbil7Zm9yKHZhciByPU0ubmFtZXModCksbz0wO288ci5sZW5ndGg7KytvKXt2YXIgaT1yW29dO2lmKG4oaSkpdHJ5e00uZGVmaW5lUHJvcGVydHkoZSxpLE0uZ2V0RGVzY3JpcHRvcih0LGkpKX1jYXRjaCh0KXt9fX1mdW5jdGlvbiBPKHQpe3JldHVybiBWP3tOT0RFX0VOVjpcInByb2R1Y3Rpb25cIn1bdF06dm9pZCAwfWZ1bmN0aW9uIFMoKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm9taXNlKXRyeXt2YXIgdD1uZXcgUHJvbWlzZShmdW5jdGlvbigpe30pO2lmKFwiW29iamVjdCBQcm9taXNlXVwiPT09e30udG9TdHJpbmcuY2FsbCh0KSlyZXR1cm4gUHJvbWlzZX1jYXRjaCh0KXt9fWZ1bmN0aW9uIFAodCxlKXtyZXR1cm4gdC5iaW5kKGUpfXZhciBNPXQoXCIuL2VzNVwiKSxqPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBuYXZpZ2F0b3IsQT17ZTp7fX0sQyxrPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG4/bjp2b2lkIDAhPT10aGlzP3RoaXM6bnVsbCxSPWZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dCx0aGlzLmNvbnN0cnVjdG9yJD1lO2Zvcih2YXIgbiBpbiBlLnByb3RvdHlwZSlyLmNhbGwoZS5wcm90b3R5cGUsbikmJlwiJFwiIT09bi5jaGFyQXQobi5sZW5ndGgtMSkmJih0aGlzW24rXCIkXCJdPWUucHJvdG90eXBlW25dKX12YXIgcj17fS5oYXNPd25Qcm9wZXJ0eTtyZXR1cm4gbi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsdC5wcm90b3R5cGU9bmV3IG4sdC5wcm90b3R5cGV9LEk9ZnVuY3Rpb24oKXt2YXIgdD1bQXJyYXkucHJvdG90eXBlLE9iamVjdC5wcm90b3R5cGUsRnVuY3Rpb24ucHJvdG90eXBlXSxlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7KytuKWlmKHRbbl09PT1lKXJldHVybiEwO3JldHVybiExfTtpZihNLmlzRVM1KXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciByPVtdLG89T2JqZWN0LmNyZWF0ZShudWxsKTtudWxsIT10JiYhZSh0KTspe3ZhciBpO3RyeXtpPW4odCl9Y2F0Y2godCl7cmV0dXJuIHJ9Zm9yKHZhciBhPTA7YTxpLmxlbmd0aDsrK2Epe3ZhciBzPWlbYV07aWYoIW9bc10pe29bc109ITA7dmFyIHU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHMpO251bGwhPXUmJm51bGw9PXUuZ2V0JiZudWxsPT11LnNldCYmci5wdXNoKHMpfX10PU0uZ2V0UHJvdG90eXBlT2YodCl9cmV0dXJuIHJ9fXZhciByPXt9Lmhhc093blByb3BlcnR5O3JldHVybiBmdW5jdGlvbihuKXtpZihlKG4pKXJldHVybltdO3ZhciBvPVtdO3Q6Zm9yKHZhciBpIGluIG4paWYoci5jYWxsKG4saSkpby5wdXNoKGkpO2Vsc2V7Zm9yKHZhciBhPTA7YTx0Lmxlbmd0aDsrK2EpaWYoci5jYWxsKHRbYV0saSkpY29udGludWUgdDtvLnB1c2goaSl9cmV0dXJuIG99fSgpLE49L3RoaXNcXHMqXFwuXFxzKlxcUytcXHMqPS8sVT0vXlthLXokX11bYS16JF8wLTldKiQvaSxGPWZ1bmN0aW9uKCl7cmV0dXJuXCJzdGFja1wiaW4gbmV3IEVycm9yP2Z1bmN0aW9uKHQpe3JldHVybiB4KHQpP3Q6bmV3IEVycm9yKGcodCkpfTpmdW5jdGlvbih0KXtpZih4KHQpKXJldHVybiB0O3RyeXt0aHJvdyBuZXcgRXJyb3IoZyh0KSl9Y2F0Y2godCl7cmV0dXJuIHR9fX0oKSxMPWZ1bmN0aW9uKHQpe3JldHVybiBNLmlzQXJyYXkodCk/dDpudWxsfTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3Ipe3ZhciBEPVwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5LmZyb20/ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmZyb20odCl9OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPVtdLHI9dFtTeW1ib2wuaXRlcmF0b3JdKCk7IShlPXIubmV4dCgpKS5kb25lOyluLnB1c2goZS52YWx1ZSk7cmV0dXJuIG59O0w9ZnVuY3Rpb24odCl7cmV0dXJuIE0uaXNBcnJheSh0KT90Om51bGwhPXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHRbU3ltYm9sLml0ZXJhdG9yXT9EKHQpOm51bGx9fXZhciBCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBlJiZcIltvYmplY3QgcHJvY2Vzc11cIj09PUUoZSkudG9Mb3dlckNhc2UoKSxWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBlJiYhMCxXPXtpc0NsYXNzOmQsaXNJZGVudGlmaWVyOm0saW5oZXJpdGVkRGF0YUtleXM6SSxnZXREYXRhUHJvcGVydHlPckRlZmF1bHQ6Zix0aHJvd2VyOmgsaXNBcnJheTpNLmlzQXJyYXksYXNBcnJheTpMLG5vdEVudW1lcmFibGVQcm9wOnAsaXNQcmltaXRpdmU6cyxpc09iamVjdDp1LGlzRXJyb3I6eSxjYW5FdmFsdWF0ZTpqLGVycm9yT2JqOkEsdHJ5Q2F0Y2g6YSxpbmhlcml0czpSLHdpdGhBcHBlbmRlZDpjLG1heWJlV3JhcEFzRXJyb3I6bCx0b0Zhc3RQcm9wZXJ0aWVzOnYsZmlsbGVkUmFuZ2U6Xyx0b1N0cmluZzpnLGNhbkF0dGFjaFRyYWNlOngsZW5zdXJlRXJyb3JPYmplY3Q6RixvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjp3LG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbjpiLGNsYXNzU3RyaW5nOkUsY29weURlc2NyaXB0b3JzOlQsaGFzRGV2VG9vbHM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNocm9tZSYmY2hyb21lJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjaHJvbWUubG9hZFRpbWVzLGlzTm9kZTpCLGhhc0VudlZhcmlhYmxlczpWLGVudjpPLGdsb2JhbDprLGdldE5hdGl2ZVByb21pc2U6Uyxkb21haW5CaW5kOlB9O1cuaXNSZWNlbnROb2RlPVcuaXNOb2RlJiZmdW5jdGlvbigpe3ZhciB0PWUudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7cmV0dXJuIDA9PT10WzBdJiZ0WzFdPjEwfHx0WzBdPjB9KCksVy5pc05vZGUmJlcudG9GYXN0UHJvcGVydGllcyhlKTt0cnl7dGhyb3cgbmV3IEVycm9yfWNhdGNoKHQpe1cubGFzdExpbmVFcnJvcj10fXIuZXhwb3J0cz1XfSx7XCIuL2VzNVwiOjEzfV19LHt9LFs0XSkoNCl9KSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZudWxsIT09d2luZG93P3dpbmRvdy5QPXdpbmRvdy5Qcm9taXNlOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZudWxsIT09c2VsZiYmKHNlbGYuUD1zZWxmLlByb21pc2UpfSkuY2FsbChlLG4oMTMxKSxuKDM4KSxuKDYyMSkuc2V0SW1tZWRpYXRlKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0KXtmdW5jdGlvbiByKCl7dHJ5e3ZhciB0PW5ldyBVaW50OEFycmF5KDEpO3JldHVybiB0Ll9fcHJvdG9fXz17X19wcm90b19fOlVpbnQ4QXJyYXkucHJvdG90eXBlLGZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19LDQyPT09dC5mb28oKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5zdWJhcnJheSYmMD09PXQuc3ViYXJyYXkoMSwxKS5ieXRlTGVuZ3RofWNhdGNoKHQpe3JldHVybiExfX1mdW5jdGlvbiBvKCl7cmV0dXJuIGEuVFlQRURfQVJSQVlfU1VQUE9SVD8yMTQ3NDgzNjQ3OjEwNzM3NDE4MjN9ZnVuY3Rpb24gaSh0LGUpe2lmKG8oKTxlKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGhcIik7cmV0dXJuIGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odD1uZXcgVWludDhBcnJheShlKSx0Ll9fcHJvdG9fXz1hLnByb3RvdHlwZSk6KG51bGw9PT10JiYodD1uZXcgYShlKSksdC5sZW5ndGg9ZSksdH1mdW5jdGlvbiBhKHQsZSxuKXtpZighKGEuVFlQRURfQVJSQVlfU1VQUE9SVHx8dGhpcyBpbnN0YW5jZW9mIGEpKXJldHVybiBuZXcgYSh0LGUsbik7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIklmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nXCIpO3JldHVybiBjKHRoaXMsdCl9cmV0dXJuIHModGhpcyx0LGUsbil9ZnVuY3Rpb24gcyh0LGUsbixyKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJmUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9oKHQsZSxuLHIpOlwic3RyaW5nXCI9PXR5cGVvZiBlP2YodCxlLG4pOmQodCxlKX1mdW5jdGlvbiB1KHQpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJyl9ZnVuY3Rpb24gbCh0LGUsbixyKXtyZXR1cm4gdShlKSxlPD0wP2kodCxlKTp2b2lkIDAhPT1uP1wic3RyaW5nXCI9PXR5cGVvZiByP2kodCxlKS5maWxsKG4scik6aSh0LGUpLmZpbGwobik6aSh0LGUpfWZ1bmN0aW9uIGModCxlKXtpZih1KGUpLHQ9aSh0LGU8MD8wOjB8dihlKSksIWEuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IodmFyIG49MDtuPGU7KytuKXRbbl09MDtyZXR1cm4gdH1mdW5jdGlvbiBmKHQsZSxuKXtpZihcInN0cmluZ1wiPT10eXBlb2YgbiYmXCJcIiE9PW58fChuPVwidXRmOFwiKSwhYS5pc0VuY29kaW5nKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIHI9MHxfKGUsbik7dD1pKHQscik7dmFyIG89dC53cml0ZShlLG4pO3JldHVybiBvIT09ciYmKHQ9dC5zbGljZSgwLG8pKSx0fWZ1bmN0aW9uIHAodCxlKXt2YXIgbj1lLmxlbmd0aDwwPzA6MHx2KGUubGVuZ3RoKTt0PWkodCxuKTtmb3IodmFyIHI9MDtyPG47cis9MSl0W3JdPTI1NSZlW3JdO3JldHVybiB0fWZ1bmN0aW9uIGgodCxlLG4scil7aWYoZS5ieXRlTGVuZ3RoLG48MHx8ZS5ieXRlTGVuZ3RoPG4pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInb2Zmc2V0JyBpcyBvdXQgb2YgYm91bmRzXCIpO2lmKGUuYnl0ZUxlbmd0aDxuKyhyfHwwKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHNcIik7cmV0dXJuIGU9dm9pZCAwPT09biYmdm9pZCAwPT09cj9uZXcgVWludDhBcnJheShlKTp2b2lkIDA9PT1yP25ldyBVaW50OEFycmF5KGUsbik6bmV3IFVpbnQ4QXJyYXkoZSxuLHIpLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odD1lLHQuX19wcm90b19fPWEucHJvdG90eXBlKTp0PXAodCxlKSx0fWZ1bmN0aW9uIGQodCxlKXtpZihhLmlzQnVmZmVyKGUpKXt2YXIgbj0wfHYoZS5sZW5ndGgpO3JldHVybiB0PWkodCxuKSwwPT09dC5sZW5ndGg/dDooZS5jb3B5KHQsMCwwLG4pLHQpfWlmKGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8XCJsZW5ndGhcImluIGUpcmV0dXJuXCJudW1iZXJcIiE9dHlwZW9mIGUubGVuZ3RofHwkKGUubGVuZ3RoKT9pKHQsMCk6cCh0LGUpO2lmKFwiQnVmZmVyXCI9PT1lLnR5cGUmJkooZS5kYXRhKSlyZXR1cm4gcCh0LGUuZGF0YSl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC5cIil9ZnVuY3Rpb24gdih0KXtpZih0Pj1vKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4XCIrbygpLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gMHx0fWZ1bmN0aW9uIG0odCl7cmV0dXJuK3QhPXQmJih0PTApLGEuYWxsb2MoK3QpfWZ1bmN0aW9uIF8odCxlKXtpZihhLmlzQnVmZmVyKHQpKXJldHVybiB0Lmxlbmd0aDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyYmKEFycmF5QnVmZmVyLmlzVmlldyh0KXx8dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm4gdC5ieXRlTGVuZ3RoO1wic3RyaW5nXCIhPXR5cGVvZiB0JiYodD1cIlwiK3QpO3ZhciBuPXQubGVuZ3RoO2lmKDA9PT1uKXJldHVybiAwO2Zvcih2YXIgcj0hMTs7KXN3aXRjaChlKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBuO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2Ugdm9pZCAwOnJldHVybiBHKHQpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gMipuO2Nhc2VcImhleFwiOnJldHVybiBuPj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gWSh0KS5sZW5ndGg7ZGVmYXVsdDppZihyKXJldHVybiBHKHQpLmxlbmd0aDtlPShcIlwiK2UpLnRvTG93ZXJDYXNlKCkscj0hMH19ZnVuY3Rpb24gZyh0LGUsbil7dmFyIHI9ITE7aWYoKHZvaWQgMD09PWV8fGU8MCkmJihlPTApLGU+dGhpcy5sZW5ndGgpcmV0dXJuXCJcIjtpZigodm9pZCAwPT09bnx8bj50aGlzLmxlbmd0aCkmJihuPXRoaXMubGVuZ3RoKSxuPD0wKXJldHVyblwiXCI7aWYobj4+Pj0wLGU+Pj49MCxuPD1lKXJldHVyblwiXCI7Zm9yKHR8fCh0PVwidXRmOFwiKTs7KXN3aXRjaCh0KXtjYXNlXCJoZXhcIjpyZXR1cm4gUih0aGlzLGUsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIGoodGhpcyxlLG4pO2Nhc2VcImFzY2lpXCI6cmV0dXJuIEModGhpcyxlLG4pO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBrKHRoaXMsZSxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gTSh0aGlzLGUsbik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIEkodGhpcyxlLG4pO2RlZmF1bHQ6aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrdCk7dD0odCtcIlwiKS50b0xvd2VyQ2FzZSgpLHI9ITB9fWZ1bmN0aW9uIHkodCxlLG4pe3ZhciByPXRbZV07dFtlXT10W25dLHRbbl09cn1mdW5jdGlvbiBiKHQsZSxuLHIsbyl7aWYoMD09PXQubGVuZ3RoKXJldHVybi0xO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuPyhyPW4sbj0wKTpuPjIxNDc0ODM2NDc/bj0yMTQ3NDgzNjQ3Om48LTIxNDc0ODM2NDgmJihuPS0yMTQ3NDgzNjQ4KSxuPStuLGlzTmFOKG4pJiYobj1vPzA6dC5sZW5ndGgtMSksbjwwJiYobj10Lmxlbmd0aCtuKSxuPj10Lmxlbmd0aCl7aWYobylyZXR1cm4tMTtuPXQubGVuZ3RoLTF9ZWxzZSBpZihuPDApe2lmKCFvKXJldHVybi0xO249MH1pZihcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9YS5mcm9tKGUscikpLGEuaXNCdWZmZXIoZSkpcmV0dXJuIDA9PT1lLmxlbmd0aD8tMTp3KHQsZSxuLHIsbyk7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpcmV0dXJuIGUmPTI1NSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y/bz9VaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodCxlLG4pOlVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwodCxlLG4pOncodCxbZV0sbixyLG8pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXJcIil9ZnVuY3Rpb24gdyh0LGUsbixyLG8pe2Z1bmN0aW9uIGkodCxlKXtyZXR1cm4gMT09PWE/dFtlXTp0LnJlYWRVSW50MTZCRShlKmEpfXZhciBhPTEscz10Lmxlbmd0aCx1PWUubGVuZ3RoO2lmKHZvaWQgMCE9PXImJihyPVN0cmluZyhyKS50b0xvd2VyQ2FzZSgpLFwidWNzMlwiPT09cnx8XCJ1Y3MtMlwiPT09cnx8XCJ1dGYxNmxlXCI9PT1yfHxcInV0Zi0xNmxlXCI9PT1yKSl7aWYodC5sZW5ndGg8Mnx8ZS5sZW5ndGg8MilyZXR1cm4tMTthPTIscy89Mix1Lz0yLG4vPTJ9dmFyIGw7aWYobyl7dmFyIGM9LTE7Zm9yKGw9bjtsPHM7bCsrKWlmKGkodCxsKT09PWkoZSxjPT09LTE/MDpsLWMpKXtpZihjPT09LTEmJihjPWwpLGwtYysxPT09dSlyZXR1cm4gYyphfWVsc2UgYyE9PS0xJiYobC09bC1jKSxjPS0xfWVsc2UgZm9yKG4rdT5zJiYobj1zLXUpLGw9bjtsPj0wO2wtLSl7Zm9yKHZhciBmPSEwLHA9MDtwPHU7cCsrKWlmKGkodCxsK3ApIT09aShlLHApKXtmPSExO2JyZWFrfWlmKGYpcmV0dXJuIGx9cmV0dXJuLTF9ZnVuY3Rpb24geCh0LGUsbixyKXtuPU51bWJlcihuKXx8MDt2YXIgbz10Lmxlbmd0aC1uO3I/KHI9TnVtYmVyKHIpLHI+byYmKHI9bykpOnI9bzt2YXIgaT1lLmxlbmd0aDtpZihpJTIhPT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7cj5pLzImJihyPWkvMik7Zm9yKHZhciBhPTA7YTxyOysrYSl7dmFyIHM9cGFyc2VJbnQoZS5zdWJzdHIoMiphLDIpLDE2KTtpZihpc05hTihzKSlyZXR1cm4gYTt0W24rYV09c31yZXR1cm4gYX1mdW5jdGlvbiBFKHQsZSxuLHIpe3JldHVybiBLKEcoZSx0Lmxlbmd0aC1uKSx0LG4scil9ZnVuY3Rpb24gVCh0LGUsbixyKXtyZXR1cm4gSyhxKGUpLHQsbixyKX1mdW5jdGlvbiBPKHQsZSxuLHIpe3JldHVybiBUKHQsZSxuLHIpfWZ1bmN0aW9uIFModCxlLG4scil7cmV0dXJuIEsoWShlKSx0LG4scil9ZnVuY3Rpb24gUCh0LGUsbixyKXtyZXR1cm4gSyhIKGUsdC5sZW5ndGgtbiksdCxuLHIpfWZ1bmN0aW9uIE0odCxlLG4pe3JldHVybiAwPT09ZSYmbj09PXQubGVuZ3RoP1ouZnJvbUJ5dGVBcnJheSh0KTpaLmZyb21CeXRlQXJyYXkodC5zbGljZShlLG4pKX1mdW5jdGlvbiBqKHQsZSxuKXtuPU1hdGgubWluKHQubGVuZ3RoLG4pO2Zvcih2YXIgcj1bXSxvPWU7bzxuOyl7dmFyIGk9dFtvXSxhPW51bGwscz1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG8rczw9bil7dmFyIHUsbCxjLGY7c3dpdGNoKHMpe2Nhc2UgMTppPDEyOCYmKGE9aSk7YnJlYWs7Y2FzZSAyOnU9dFtvKzFdLDEyOD09PSgxOTImdSkmJihmPSgzMSZpKTw8Nnw2MyZ1LGY+MTI3JiYoYT1mKSk7YnJlYWs7Y2FzZSAzOnU9dFtvKzFdLGw9dFtvKzJdLDEyOD09PSgxOTImdSkmJjEyOD09PSgxOTImbCkmJihmPSgxNSZpKTw8MTJ8KDYzJnUpPDw2fDYzJmwsZj4yMDQ3JiYoZjw1NTI5Nnx8Zj41NzM0MykmJihhPWYpKTticmVhaztjYXNlIDQ6dT10W28rMV0sbD10W28rMl0sYz10W28rM10sMTI4PT09KDE5MiZ1KSYmMTI4PT09KDE5MiZsKSYmMTI4PT09KDE5MiZjKSYmKGY9KDE1JmkpPDwxOHwoNjMmdSk8PDEyfCg2MyZsKTw8Nnw2MyZjLGY+NjU1MzUmJmY8MTExNDExMiYmKGE9ZikpfX1udWxsPT09YT8oYT02NTUzMyxzPTEpOmE+NjU1MzUmJihhLT02NTUzNixyLnB1c2goYT4+PjEwJjEwMjN8NTUyOTYpLGE9NTYzMjB8MTAyMyZhKSxyLnB1c2goYSksbys9c31yZXR1cm4gQShyKX1mdW5jdGlvbiBBKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU8PXR0KXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0KTtmb3IodmFyIG49XCJcIixyPTA7cjxlOyluKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0LnNsaWNlKHIscis9dHQpKTtyZXR1cm4gbn1mdW5jdGlvbiBDKHQsZSxuKXt2YXIgcj1cIlwiO249TWF0aC5taW4odC5sZW5ndGgsbik7Zm9yKHZhciBvPWU7bzxuOysrbylyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyZ0W29dKTtyZXR1cm4gcn1mdW5jdGlvbiBrKHQsZSxuKXt2YXIgcj1cIlwiO249TWF0aC5taW4odC5sZW5ndGgsbik7Zm9yKHZhciBvPWU7bzxuOysrbylyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbb10pO3JldHVybiByfWZ1bmN0aW9uIFIodCxlLG4pe3ZhciByPXQubGVuZ3RoOyghZXx8ZTwwKSYmKGU9MCksKCFufHxuPDB8fG4+cikmJihuPXIpO2Zvcih2YXIgbz1cIlwiLGk9ZTtpPG47KytpKW8rPXoodFtpXSk7cmV0dXJuIG99ZnVuY3Rpb24gSSh0LGUsbil7Zm9yKHZhciByPXQuc2xpY2UoZSxuKSxvPVwiXCIsaT0wO2k8ci5sZW5ndGg7aSs9MilvKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJbaV0rMjU2KnJbaSsxXSk7cmV0dXJuIG99ZnVuY3Rpb24gTih0LGUsbil7aWYodCUxIT09MHx8dDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKHQrZT5uKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1mdW5jdGlvbiBVKHQsZSxuLHIsbyxpKXtpZighYS5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihlPm98fGU8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZihuK3I+dC5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gRih0LGUsbixyKXtlPDAmJihlPTY1NTM1K2UrMSk7Zm9yKHZhciBvPTAsaT1NYXRoLm1pbih0Lmxlbmd0aC1uLDIpO288aTsrK28pdFtuK29dPShlJjI1NTw8OCoocj9vOjEtbykpPj4+OCoocj9vOjEtbyl9ZnVuY3Rpb24gTCh0LGUsbixyKXtlPDAmJihlPTQyOTQ5NjcyOTUrZSsxKTtmb3IodmFyIG89MCxpPU1hdGgubWluKHQubGVuZ3RoLW4sNCk7bzxpOysrbyl0W24rb109ZT4+PjgqKHI/bzozLW8pJjI1NX1mdW5jdGlvbiBEKHQsZSxuLHIsbyxpKXtpZihuK3I+dC5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIEIodCxlLG4scixvKXtyZXR1cm4gb3x8RCh0LGUsbiw0LDMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwtMy40MDI4MjM0NjYzODUyODg2ZTM4KSxRLndyaXRlKHQsZSxuLHIsMjMsNCksbis0fWZ1bmN0aW9uIFYodCxlLG4scixvKXtyZXR1cm4gb3x8RCh0LGUsbiw4LDEuNzk3NjkzMTM0ODYyMzE1N2UzMDgsLTEuNzk3NjkzMTM0ODYyMzE1N2UzMDgpLFEud3JpdGUodCxlLG4sciw1Miw4KSxuKzh9ZnVuY3Rpb24gVyh0KXtpZih0PVgodCkucmVwbGFjZShldCxcIlwiKSx0Lmxlbmd0aDwyKXJldHVyblwiXCI7Zm9yKDt0Lmxlbmd0aCU0IT09MDspdCs9XCI9XCI7cmV0dXJuIHR9ZnVuY3Rpb24gWCh0KXtyZXR1cm4gdC50cmltP3QudHJpbSgpOnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKX1mdW5jdGlvbiB6KHQpe3JldHVybiB0PDE2P1wiMFwiK3QudG9TdHJpbmcoMTYpOnQudG9TdHJpbmcoMTYpfWZ1bmN0aW9uIEcodCxlKXtlPWV8fDEvMDtmb3IodmFyIG4scj10Lmxlbmd0aCxvPW51bGwsaT1bXSxhPTA7YTxyOysrYSl7aWYobj10LmNoYXJDb2RlQXQoYSksbj41NTI5NSYmbjw1NzM0NCl7aWYoIW8pe2lmKG4+NTYzMTkpeyhlLT0zKT4tMSYmaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1pZihhKzE9PT1yKXsoZS09Myk+LTEmJmkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9bz1uO2NvbnRpbnVlfWlmKG48NTYzMjApeyhlLT0zKT4tMSYmaS5wdXNoKDIzOSwxOTEsMTg5KSxvPW47Y29udGludWV9bj0oby01NTI5Njw8MTB8bi01NjMyMCkrNjU1MzZ9ZWxzZSBvJiYoZS09Myk+LTEmJmkucHVzaCgyMzksMTkxLDE4OSk7aWYobz1udWxsLG48MTI4KXtpZigoZS09MSk8MClicmVhaztpLnB1c2gobil9ZWxzZSBpZihuPDIwNDgpe2lmKChlLT0yKTwwKWJyZWFrO2kucHVzaChuPj42fDE5Miw2MyZufDEyOCl9ZWxzZSBpZihuPDY1NTM2KXtpZigoZS09Myk8MClicmVhaztpLnB1c2gobj4+MTJ8MjI0LG4+PjYmNjN8MTI4LDYzJm58MTI4KX1lbHNle2lmKCEobjwxMTE0MTEyKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIik7aWYoKGUtPTQpPDApYnJlYWs7aS5wdXNoKG4+PjE4fDI0MCxuPj4xMiY2M3wxMjgsbj4+NiY2M3wxMjgsNjMmbnwxMjgpfX1yZXR1cm4gaX1mdW5jdGlvbiBxKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKDI1NSZ0LmNoYXJDb2RlQXQobikpO3JldHVybiBlfWZ1bmN0aW9uIEgodCxlKXtmb3IodmFyIG4scixvLGk9W10sYT0wO2E8dC5sZW5ndGgmJiEoKGUtPTIpPDApOysrYSluPXQuY2hhckNvZGVBdChhKSxyPW4+Pjgsbz1uJTI1NixpLnB1c2gobyksaS5wdXNoKHIpO3JldHVybiBpfWZ1bmN0aW9uIFkodCl7cmV0dXJuIFoudG9CeXRlQXJyYXkoVyh0KSl9ZnVuY3Rpb24gSyh0LGUsbixyKXtmb3IodmFyIG89MDtvPHImJiEobytuPj1lLmxlbmd0aHx8bz49dC5sZW5ndGgpOysrbyllW28rbl09dFtvXTtyZXR1cm4gb31mdW5jdGlvbiAkKHQpe3JldHVybiB0IT09dH12YXIgWj1uKDI2MiksUT1uKDQ1MiksSj1uKDI2Nik7ZS5CdWZmZXI9YSxlLlNsb3dCdWZmZXI9bSxlLklOU1BFQ1RfTUFYX0JZVEVTPTUwLGEuVFlQRURfQVJSQVlfU1VQUE9SVD12b2lkIDAhPT10LlRZUEVEX0FSUkFZX1NVUFBPUlQ/dC5UWVBFRF9BUlJBWV9TVVBQT1JUOnIoKSxlLmtNYXhMZW5ndGg9bygpLGEucG9vbFNpemU9ODE5MixhLl9hdWdtZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fXz1hLnByb3RvdHlwZSx0fSxhLmZyb209ZnVuY3Rpb24odCxlLG4pe3JldHVybiBzKG51bGwsdCxlLG4pfSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQmJihhLnByb3RvdHlwZS5fX3Byb3RvX189VWludDhBcnJheS5wcm90b3R5cGUsYS5fX3Byb3RvX189VWludDhBcnJheSxcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuc3BlY2llcyYmYVtTeW1ib2wuc3BlY2llc109PT1hJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxTeW1ib2wuc3BlY2llcyx7dmFsdWU6bnVsbCxjb25maWd1cmFibGU6ITB9KSksYS5hbGxvYz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGwobnVsbCx0LGUsbil9LGEuYWxsb2NVbnNhZmU9ZnVuY3Rpb24odCl7cmV0dXJuIGMobnVsbCx0KX0sYS5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24odCl7cmV0dXJuIGMobnVsbCx0KX0sYS5pc0J1ZmZlcj1mdW5jdGlvbih0KXtyZXR1cm4hKG51bGw9PXR8fCF0Ll9pc0J1ZmZlcil9LGEuY29tcGFyZT1mdW5jdGlvbih0LGUpe2lmKCFhLmlzQnVmZmVyKHQpfHwhYS5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnRzIG11c3QgYmUgQnVmZmVyc1wiKTtpZih0PT09ZSlyZXR1cm4gMDtmb3IodmFyIG49dC5sZW5ndGgscj1lLmxlbmd0aCxvPTAsaT1NYXRoLm1pbihuLHIpO288aTsrK28paWYodFtvXSE9PWVbb10pe249dFtvXSxyPWVbb107YnJlYWt9cmV0dXJuIG48cj8tMTpyPG4/MTowfSxhLmlzRW5jb2Rpbmc9ZnVuY3Rpb24odCl7c3dpdGNoKFN0cmluZyh0KS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSxhLmNvbmNhdD1mdW5jdGlvbih0LGUpe2lmKCFKKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gYS5hbGxvYygwKTt2YXIgbjtpZih2b2lkIDA9PT1lKWZvcihlPTAsbj0wO248dC5sZW5ndGg7KytuKWUrPXRbbl0ubGVuZ3RoO3ZhciByPWEuYWxsb2NVbnNhZmUoZSksbz0wO2ZvcihuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBpPXRbbl07aWYoIWEuaXNCdWZmZXIoaSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aS5jb3B5KHIsbyksbys9aS5sZW5ndGh9cmV0dXJuIHJ9LGEuYnl0ZUxlbmd0aD1fLGEucHJvdG90eXBlLl9pc0J1ZmZlcj0hMCxhLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxlbmd0aDtpZih0JTIhPT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIik7Zm9yKHZhciBlPTA7ZTx0O2UrPTIpeSh0aGlzLGUsZSsxKTtyZXR1cm4gdGhpc30sYS5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZW5ndGg7aWYodCU0IT09MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO2Zvcih2YXIgZT0wO2U8dDtlKz00KXkodGhpcyxlLGUrMykseSh0aGlzLGUrMSxlKzIpO3JldHVybiB0aGlzfSxhLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxlbmd0aDtpZih0JTghPT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIik7Zm9yKHZhciBlPTA7ZTx0O2UrPTgpeSh0aGlzLGUsZSs3KSx5KHRoaXMsZSsxLGUrNikseSh0aGlzLGUrMixlKzUpLHkodGhpcyxlKzMsZSs0KTtyZXR1cm4gdGhpc30sYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD0wfHRoaXMubGVuZ3RoO3JldHVybiAwPT09dD9cIlwiOjA9PT1hcmd1bWVudHMubGVuZ3RoP2oodGhpcywwLHQpOmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxhLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7aWYoIWEuaXNCdWZmZXIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIHRoaXM9PT10fHwwPT09YS5jb21wYXJlKHRoaXMsdCl9LGEucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXt2YXIgdD1cIlwiLG49ZS5JTlNQRUNUX01BWF9CWVRFUztyZXR1cm4gdGhpcy5sZW5ndGg+MCYmKHQ9dGhpcy50b1N0cmluZyhcImhleFwiLDAsbikubWF0Y2goLy57Mn0vZykuam9pbihcIiBcIiksdGhpcy5sZW5ndGg+biYmKHQrPVwiIC4uLiBcIikpLFwiPEJ1ZmZlciBcIit0K1wiPlwifSxhLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYoIWEuaXNCdWZmZXIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49dD90Lmxlbmd0aDowKSx2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz10aGlzLmxlbmd0aCksZTwwfHxuPnQubGVuZ3RofHxyPDB8fG8+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYocj49byYmZT49bilyZXR1cm4gMDtpZihyPj1vKXJldHVybi0xO2lmKGU+PW4pcmV0dXJuIDE7aWYoZT4+Pj0wLG4+Pj49MCxyPj4+PTAsbz4+Pj0wLHRoaXM9PT10KXJldHVybiAwO2Zvcih2YXIgaT1vLXIscz1uLWUsdT1NYXRoLm1pbihpLHMpLGw9dGhpcy5zbGljZShyLG8pLGM9dC5zbGljZShlLG4pLGY9MDtmPHU7KytmKWlmKGxbZl0hPT1jW2ZdKXtpPWxbZl0scz1jW2ZdO2JyZWFrfXJldHVybiBpPHM/LTE6czxpPzE6MH0sYS5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmluZGV4T2YodCxlLG4pIT09LTF9LGEucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBiKHRoaXMsdCxlLG4sITApfSxhLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGIodGhpcyx0LGUsbiwhMSl9LGEucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHZvaWQgMD09PWUpcj1cInV0ZjhcIixuPXRoaXMubGVuZ3RoLGU9MDtlbHNlIGlmKHZvaWQgMD09PW4mJlwic3RyaW5nXCI9PXR5cGVvZiBlKXI9ZSxuPXRoaXMubGVuZ3RoLGU9MDtlbHNle2lmKCFpc0Zpbml0ZShlKSl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtlfD0wLGlzRmluaXRlKG4pPyhufD0wLHZvaWQgMD09PXImJihyPVwidXRmOFwiKSk6KHI9bixuPXZvaWQgMCl9dmFyIG89dGhpcy5sZW5ndGgtZTtpZigodm9pZCAwPT09bnx8bj5vKSYmKG49byksdC5sZW5ndGg+MCYmKG48MHx8ZTwwKXx8ZT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO3J8fChyPVwidXRmOFwiKTtmb3IodmFyIGk9ITE7Oylzd2l0Y2gocil7Y2FzZVwiaGV4XCI6cmV0dXJuIHgodGhpcyx0LGUsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIEUodGhpcyx0LGUsbik7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gVCh0aGlzLHQsZSxuKTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gTyh0aGlzLHQsZSxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gUyh0aGlzLHQsZSxuKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gUCh0aGlzLHQsZSxuKTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpO3I9KFwiXCIrcikudG9Mb3dlckNhc2UoKSxpPSEwfX0sYS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O3ZhciB0dD00MDk2O2EucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5sZW5ndGg7dD1+fnQsZT12b2lkIDA9PT1lP246fn5lLHQ8MD8odCs9bix0PDAmJih0PTApKTp0Pm4mJih0PW4pLGU8MD8oZSs9bixlPDAmJihlPTApKTplPm4mJihlPW4pLGU8dCYmKGU9dCk7dmFyIHI7aWYoYS5UWVBFRF9BUlJBWV9TVVBQT1JUKXI9dGhpcy5zdWJhcnJheSh0LGUpLHIuX19wcm90b19fPWEucHJvdG90eXBlO2Vsc2V7dmFyIG89ZS10O3I9bmV3IGEobyx2b2lkIDApO2Zvcih2YXIgaT0wO2k8bzsrK2kpcltpXT10aGlzW2krdF19cmV0dXJuIHJ9LGEucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24odCxlLG4pe3R8PTAsZXw9MCxufHxOKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciByPXRoaXNbdF0sbz0xLGk9MDsrK2k8ZSYmKG8qPTI1Nik7KXIrPXRoaXNbdCtpXSpvO3JldHVybiByfSxhLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHQsZSxuKXt0fD0wLGV8PTAsbnx8Tih0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgcj10aGlzW3QrLS1lXSxvPTE7ZT4wJiYobyo9MjU2KTspcis9dGhpc1t0Ky0tZV0qbztyZXR1cm4gcn0sYS5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE4odCwxLHRoaXMubGVuZ3RoKSx0aGlzW3RdfSxhLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tih0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF18dGhpc1t0KzFdPDw4fSxhLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tih0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF08PDh8dGhpc1t0KzFdfSxhLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tih0LDQsdGhpcy5sZW5ndGgpLCh0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2KSsxNjc3NzIxNip0aGlzW3QrM119LGEucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxOKHQsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1t0XSsodGhpc1t0KzFdPDwxNnx0aGlzW3QrMl08PDh8dGhpc1t0KzNdKX0sYS5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKHQsZSxuKXt0fD0wLGV8PTAsbnx8Tih0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgcj10aGlzW3RdLG89MSxpPTA7KytpPGUmJihvKj0yNTYpOylyKz10aGlzW3QraV0qbztyZXR1cm4gbyo9MTI4LHI+PW8mJihyLT1NYXRoLnBvdygyLDgqZSkpLHJ9LGEucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbih0LGUsbil7dHw9MCxlfD0wLG58fE4odCxlLHRoaXMubGVuZ3RoKTtmb3IodmFyIHI9ZSxvPTEsaT10aGlzW3QrLS1yXTtyPjAmJihvKj0yNTYpOylpKz10aGlzW3QrLS1yXSpvO3JldHVybiBvKj0xMjgsaT49byYmKGktPU1hdGgucG93KDIsOCplKSksaX0sYS5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tih0LDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW3RdPygyNTUtdGhpc1t0XSsxKSotMTp0aGlzW3RdfSxhLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbih0LGUpe2V8fE4odCwyLHRoaXMubGVuZ3RoKTt2YXIgbj10aGlzW3RdfHRoaXNbdCsxXTw8ODtyZXR1cm4gMzI3Njgmbj80Mjk0OTAxNzYwfG46bn0sYS5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24odCxlKXtlfHxOKHQsMix0aGlzLmxlbmd0aCk7dmFyIG49dGhpc1t0KzFdfHRoaXNbdF08PDg7cmV0dXJuIDMyNzY4Jm4/NDI5NDkwMTc2MHxuOm59LGEucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE4odCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2fHRoaXNbdCszXTw8MjR9LGEucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE4odCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdPDwyNHx0aGlzW3QrMV08PDE2fHRoaXNbdCsyXTw8OHx0aGlzW3QrM119LGEucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE4odCw0LHRoaXMubGVuZ3RoKSxRLnJlYWQodGhpcyx0LCEwLDIzLDQpfSxhLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxOKHQsNCx0aGlzLmxlbmd0aCksUS5yZWFkKHRoaXMsdCwhMSwyMyw0KX0sYS5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE4odCw4LHRoaXMubGVuZ3RoKSxRLnJlYWQodGhpcyx0LCEwLDUyLDgpfSxhLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tih0LDgsdGhpcy5sZW5ndGgpLFEucmVhZCh0aGlzLHQsITEsNTIsOCl9LGEucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHQ9K3QsZXw9MCxufD0wLCFyKXt2YXIgbz1NYXRoLnBvdygyLDgqbiktMTtVKHRoaXMsdCxlLG4sbywwKX12YXIgaT0xLGE9MDtmb3IodGhpc1tlXT0yNTUmdDsrK2E8biYmKGkqPTI1Nik7KXRoaXNbZSthXT10L2kmMjU1O3JldHVybiBlK259LGEucHJvdG90eXBlLndyaXRlVUludEJFPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHQ9K3QsZXw9MCxufD0wLCFyKXt2YXIgbz1NYXRoLnBvdygyLDgqbiktMTtVKHRoaXMsdCxlLG4sbywwKX12YXIgaT1uLTEsYT0xO2Zvcih0aGlzW2UraV09MjU1JnQ7LS1pPj0wJiYoYSo9MjU2KTspdGhpc1tlK2ldPXQvYSYyNTU7cmV0dXJuIGUrbn0sYS5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHQ9K3QsZXw9MCxufHxVKHRoaXMsdCxlLDEsMjU1LDApLGEuVFlQRURfQVJSQVlfU1VQUE9SVHx8KHQ9TWF0aC5mbG9vcih0KSksdGhpc1tlXT0yNTUmdCxlKzF9LGEucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0PSt0LGV8PTAsbnx8VSh0aGlzLHQsZSwyLDY1NTM1LDApLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT0yNTUmdCx0aGlzW2UrMV09dD4+PjgpOkYodGhpcyx0LGUsITApLGUrMn0sYS5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHQ9K3QsZXw9MCxufHxVKHRoaXMsdCxlLDIsNjU1MzUsMCksYS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2VdPXQ+Pj44LHRoaXNbZSsxXT0yNTUmdCk6Rih0aGlzLHQsZSwhMSksZSsyfSxhLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdD0rdCxlfD0wLG58fFUodGhpcyx0LGUsNCw0Mjk0OTY3Mjk1LDApLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlKzNdPXQ+Pj4yNCx0aGlzW2UrMl09dD4+PjE2LHRoaXNbZSsxXT10Pj4+OCx0aGlzW2VdPTI1NSZ0KTpMKHRoaXMsdCxlLCEwKSxlKzR9LGEucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0PSt0LGV8PTAsbnx8VSh0aGlzLHQsZSw0LDQyOTQ5NjcyOTUsMCksYS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2VdPXQ+Pj4yNCx0aGlzW2UrMV09dD4+PjE2LHRoaXNbZSsyXT10Pj4+OCx0aGlzW2UrM109MjU1JnQpOkwodGhpcyx0LGUsITEpLGUrNH0sYS5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbih0LGUsbixyKXtpZih0PSt0LGV8PTAsIXIpe3ZhciBvPU1hdGgucG93KDIsOCpuLTEpO1UodGhpcyx0LGUsbixvLTEsLW8pfXZhciBpPTAsYT0xLHM9MDtmb3IodGhpc1tlXT0yNTUmdDsrK2k8biYmKGEqPTI1Nik7KXQ8MCYmMD09PXMmJjAhPT10aGlzW2UraS0xXSYmKHM9MSksdGhpc1tlK2ldPSh0L2E+PjApLXMmMjU1O3JldHVybiBlK259LGEucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24odCxlLG4scil7aWYodD0rdCxlfD0wLCFyKXt2YXIgbz1NYXRoLnBvdygyLDgqbi0xKTtVKHRoaXMsdCxlLG4sby0xLC1vKX12YXIgaT1uLTEsYT0xLHM9MDtmb3IodGhpc1tlK2ldPTI1NSZ0Oy0taT49MCYmKGEqPTI1Nik7KXQ8MCYmMD09PXMmJjAhPT10aGlzW2UraSsxXSYmKHM9MSksdGhpc1tlK2ldPSh0L2E+PjApLXMmMjU1O3JldHVybiBlK259LGEucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHQ9K3QsZXw9MCxufHxVKHRoaXMsdCxlLDEsMTI3LC0xMjgpLGEuVFlQRURfQVJSQVlfU1VQUE9SVHx8KHQ9TWF0aC5mbG9vcih0KSksdDwwJiYodD0yNTUrdCsxKSx0aGlzW2VdPTI1NSZ0LGUrMX0sYS5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdD0rdCxlfD0wLG58fFUodGhpcyx0LGUsMiwzMjc2NywtMzI3NjgpLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT0yNTUmdCx0aGlzW2UrMV09dD4+PjgpOkYodGhpcyx0LGUsITApLGUrMn0sYS5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdD0rdCxlfD0wLG58fFUodGhpcyx0LGUsMiwzMjc2NywtMzI3NjgpLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQpOkYodGhpcyx0LGUsITEpLGUrMn0sYS5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdD0rdCxlfD0wLG58fFUodGhpcyx0LGUsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44LHRoaXNbZSsyXT10Pj4+MTYsdGhpc1tlKzNdPXQ+Pj4yNCk6TCh0aGlzLHQsZSwhMCksZSs0fSxhLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0PSt0LGV8PTAsbnx8VSh0aGlzLHQsZSw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLHQ8MCYmKHQ9NDI5NDk2NzI5NSt0KzEpLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+MjQsdGhpc1tlKzFdPXQ+Pj4xNix0aGlzW2UrMl09dD4+PjgsdGhpc1tlKzNdPTI1NSZ0KTpMKHRoaXMsdCxlLCExKSxlKzR9LGEucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIEIodGhpcyx0LGUsITAsbil9LGEucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIEIodGhpcyx0LGUsITEsbil9LGEucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBWKHRoaXMsdCxlLCEwLG4pfSxhLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gVih0aGlzLHQsZSwhMSxuKX0sYS5wcm90b3R5cGUuY29weT1mdW5jdGlvbih0LGUsbixyKXtpZihufHwobj0wKSxyfHwwPT09cnx8KHI9dGhpcy5sZW5ndGgpLGU+PXQubGVuZ3RoJiYoZT10Lmxlbmd0aCksZXx8KGU9MCkscj4wJiZyPG4mJihyPW4pLHI9PT1uKXJldHVybiAwO2lmKDA9PT10Lmxlbmd0aHx8MD09PXRoaXMubGVuZ3RoKXJldHVybiAwO2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYocjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7cj50aGlzLmxlbmd0aCYmKHI9dGhpcy5sZW5ndGgpLHQubGVuZ3RoLWU8ci1uJiYocj10Lmxlbmd0aC1lK24pO3ZhciBvLGk9ci1uO2lmKHRoaXM9PT10JiZuPGUmJmU8cilmb3Iobz1pLTE7bz49MDstLW8pdFtvK2VdPXRoaXNbbytuXTtlbHNlIGlmKGk8MWUzfHwhYS5UWVBFRF9BUlJBWV9TVVBQT1JUKWZvcihvPTA7bzxpOysrbyl0W28rZV09dGhpc1tvK25dO2Vsc2UgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodCx0aGlzLnN1YmFycmF5KG4sbitpKSxlKTtyZXR1cm4gaX0sYS5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbixyKXtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGU/KHI9ZSxlPTAsbj10aGlzLmxlbmd0aCk6XCJzdHJpbmdcIj09dHlwZW9mIG4mJihyPW4sbj10aGlzLmxlbmd0aCksMT09PXQubGVuZ3RoKXt2YXIgbz10LmNoYXJDb2RlQXQoMCk7bzwyNTYmJih0PW8pfWlmKHZvaWQgMCE9PXImJlwic3RyaW5nXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByJiYhYS5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIityKX1lbHNlXCJudW1iZXJcIj09dHlwZW9mIHQmJih0Jj0yNTUpO2lmKGU8MHx8dGhpcy5sZW5ndGg8ZXx8dGhpcy5sZW5ndGg8bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPD1lKXJldHVybiB0aGlzO2U+Pj49MCxuPXZvaWQgMD09PW4/dGhpcy5sZW5ndGg6bj4+PjAsdHx8KHQ9MCk7dmFyIGk7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpZm9yKGk9ZTtpPG47KytpKXRoaXNbaV09dDtlbHNle3ZhciBzPWEuaXNCdWZmZXIodCk/dDpHKG5ldyBhKHQscikudG9TdHJpbmcoKSksdT1zLmxlbmd0aDtmb3IoaT0wO2k8bi1lOysraSl0aGlzW2krZV09c1tpJXVdfXJldHVybiB0aGlzfTt2YXIgZXQ9L1teK1xcLzAtOUEtWmEtei1fXS9nfSkuY2FsbChlLG4oMzgpKX0sZnVuY3Rpb24odCxlKXt2YXIgbj17fS50b1N0cmluZzt0LmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24odCl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT1uLmNhbGwodCl9fSxmdW5jdGlvbih0LGUsbil7bigyNzYpLHQuZXhwb3J0cz1uKDMxKS5SZWdFeHAuZXNjYXBlfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3KSxvPW4oMTAxKSxpPW4oOCkoXCJzcGVjaWVzXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gbyh0KSYmKGU9dC5jb25zdHJ1Y3RvcixcImZ1bmN0aW9uXCIhPXR5cGVvZiBlfHxlIT09QXJyYXkmJiFvKGUucHJvdG90eXBlKXx8KGU9dm9pZCAwKSxyKGUpJiYoZT1lW2ldLG51bGw9PT1lJiYoZT12b2lkIDApKSksdm9pZCAwPT09ZT9BcnJheTplfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjY4KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3KHIodCkpKGUpfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNCksbz1uKDI4KSxpPVwibnVtYmVyXCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCIhPT10JiZ0IT09aSYmXCJkZWZhdWx0XCIhPT10KXRocm93IFR5cGVFcnJvcihcIkluY29ycmVjdCBoaW50XCIpO3JldHVybiBvKHIodGhpcyksdCE9aSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0Myksbz1uKDc3KSxpPW4oNjApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1yKHQpLG49by5mO2lmKG4pZm9yKHZhciBhLHM9bih0KSx1PWkuZixsPTA7cy5sZW5ndGg+bDspdS5jYWxsKHQsYT1zW2wrK10pJiZlLnB1c2goYSk7cmV0dXJuIGV9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0Myksbz1uKDE4KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4saT1vKHQpLGE9cihpKSxzPWEubGVuZ3RoLHU9MDtzPnU7KWlmKGlbbj1hW3UrK11dPT09ZSlyZXR1cm4gbn19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDI3NCksbz1uKDczKSxpPW4oMTQpO3QuZXhwb3J0cz1mdW5jdGlvbigpe2Zvcih2YXIgdD1pKHRoaXMpLGU9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KGUpLGE9MCxzPXIuXyx1PSExO2U+YTspKG5bYV09YXJndW1lbnRzW2ErK10pPT09cyYmKHU9ITApO3JldHVybiBmdW5jdGlvbigpe3ZhciByLGk9dGhpcyxhPWFyZ3VtZW50cy5sZW5ndGgsbD0wLGM9MDtpZighdSYmIWEpcmV0dXJuIG8odCxuLGkpO2lmKHI9bi5zbGljZSgpLHUpZm9yKDtlPmw7bCsrKXJbbF09PT1zJiYocltsXT1hcmd1bWVudHNbYysrXSk7Zm9yKDthPmM7KXIucHVzaChhcmd1bWVudHNbYysrXSk7cmV0dXJuIG8odCxyLGkpfX19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9big1KX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgbj1lPT09T2JqZWN0KGUpP2Z1bmN0aW9uKHQpe3JldHVybiBlW3RdfTplO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nKGUpLnJlcGxhY2UodCxuKX19fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMjc1KSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csXCJcXFxcJCZcIik7cihyLlMsXCJSZWdFeHBcIix7ZXNjYXBlOmZ1bmN0aW9uKHQpe3JldHVybiBvKHQpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUCxcIkFycmF5XCIse2NvcHlXaXRoaW46bigxMzkpfSksbig1MCkoXCJjb3B5V2l0aGluXCIpfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMjYpKDQpO3Ioci5QK3IuRiohbigyNCkoW10uZXZlcnksITApLFwiQXJyYXlcIix7ZXZlcnk6ZnVuY3Rpb24odCl7cmV0dXJuIG8odGhpcyx0LGFyZ3VtZW50c1sxXSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5QLFwiQXJyYXlcIix7ZmlsbDpuKDkzKX0pLG4oNTApKFwiZmlsbFwiKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksbz1uKDI2KSgyKTtyKHIuUCtyLkYqIW4oMjQpKFtdLmZpbHRlciwhMCksXCJBcnJheVwiLHtmaWx0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odGhpcyx0LGFyZ3VtZW50c1sxXSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigyNikoNiksaT1cImZpbmRJbmRleFwiLGE9ITA7aSBpbltdJiZBcnJheSgxKVtpXShmdW5jdGlvbigpe2E9ITF9KSxyKHIuUCtyLkYqYSxcIkFycmF5XCIse2ZpbmRJbmRleDpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG4oNTApKGkpfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMjYpKDUpLGk9XCJmaW5kXCIsYT0hMDtpIGluW10mJkFycmF5KDEpW2ldKGZ1bmN0aW9uKCl7YT0hMX0pLHIoci5QK3IuRiphLFwiQXJyYXlcIix7ZmluZDpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG4oNTApKGkpfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMjYpKDApLGk9bigyNCkoW10uZm9yRWFjaCwhMCk7cihyLlArci5GKiFpLFwiQXJyYXlcIix7Zm9yRWFjaDpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQsYXJndW1lbnRzWzFdKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMzIpLG89bigwKSxpPW4oMTIpLGE9bigxNDgpLHM9bigxMDApLHU9bigxMSksbD1uKDk0KSxjPW4oMTE3KTtvKG8uUytvLkYqIW4oNzUpKGZ1bmN0aW9uKHQpe0FycmF5LmZyb20odCl9KSxcIkFycmF5XCIse2Zyb206ZnVuY3Rpb24odCl7dmFyIGUsbixvLGYscD1pKHQpLGg9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcz90aGlzOkFycmF5LGQ9YXJndW1lbnRzLmxlbmd0aCx2PWQ+MT9hcmd1bWVudHNbMV06dm9pZCAwLG09dm9pZCAwIT09dixfPTAsZz1jKHApO2lmKG0mJih2PXIodixkPjI/YXJndW1lbnRzWzJdOnZvaWQgMCwyKSksdm9pZCAwPT1nfHxoPT1BcnJheSYmcyhnKSlmb3IoZT11KHAubGVuZ3RoKSxuPW5ldyBoKGUpO2U+XztfKyspbChuLF8sbT92KHBbX10sXyk6cFtfXSk7ZWxzZSBmb3IoZj1nLmNhbGwocCksbj1uZXcgaDshKG89Zi5uZXh0KCkpLmRvbmU7XysrKWwobixfLG0/YShmLHYsW28udmFsdWUsX10sITApOm8udmFsdWUpO3JldHVybiBuLmxlbmd0aD1fLG59fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89big2OSkoITEpLGk9W10uaW5kZXhPZixhPSEhaSYmMS9bMV0uaW5kZXhPZigxLC0wKTwwO3Ioci5QK3IuRiooYXx8IW4oMjQpKGkpKSxcIkFycmF5XCIse2luZGV4T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIGE/aS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fDA6byh0aGlzLHQsYXJndW1lbnRzWzFdKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlMsXCJBcnJheVwiLHtpc0FycmF5Om4oMTAxKX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMTgpLGk9W10uam9pbjtyKHIuUCtyLkYqKG4oNTkpIT1PYmplY3R8fCFuKDI0KShpKSksXCJBcnJheVwiLHtqb2luOmZ1bmN0aW9uKHQpe3JldHVybiBpLmNhbGwobyh0aGlzKSx2b2lkIDA9PT10P1wiLFwiOnQpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMTgpLGk9bigzNyksYT1uKDExKSxzPVtdLmxhc3RJbmRleE9mLHU9ISFzJiYxL1sxXS5sYXN0SW5kZXhPZigxLC0wKTwwO3Ioci5QK3IuRioodXx8IW4oMjQpKHMpKSxcIkFycmF5XCIse2xhc3RJbmRleE9mOmZ1bmN0aW9uKHQpe2lmKHUpcmV0dXJuIHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfHwwO3ZhciBlPW8odGhpcyksbj1hKGUubGVuZ3RoKSxyPW4tMTtmb3IoYXJndW1lbnRzLmxlbmd0aD4xJiYocj1NYXRoLm1pbihyLGkoYXJndW1lbnRzWzFdKSkpLHI8MCYmKHI9bityKTtyPj0wO3ItLSlpZihyIGluIGUmJmVbcl09PT10KXJldHVybiByfHwwO3JldHVybi0xfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMjYpKDEpO3Ioci5QK3IuRiohbigyNCkoW10ubWFwLCEwKSxcIkFycmF5XCIse21hcDpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQsYXJndW1lbnRzWzFdKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksbz1uKDk0KTtyKHIuUytyLkYqbig2KShmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIShBcnJheS5vZi5jYWxsKHQpaW5zdGFuY2VvZiB0KX0pLFwiQXJyYXlcIix7b2Y6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcoXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcz90aGlzOkFycmF5KShlKTtlPnQ7KW8obix0LGFyZ3VtZW50c1t0KytdKTtyZXR1cm4gbi5sZW5ndGg9ZSxufX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMTQxKTtyKHIuUCtyLkYqIW4oMjQpKFtdLnJlZHVjZVJpZ2h0LCEwKSxcIkFycmF5XCIse3JlZHVjZVJpZ2h0OmZ1bmN0aW9uKHQpe3JldHVybiBvKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoLGFyZ3VtZW50c1sxXSwhMCl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxNDEpO3Ioci5QK3IuRiohbigyNCkoW10ucmVkdWNlLCEwKSxcIkFycmF5XCIse3JlZHVjZTpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aCxhcmd1bWVudHNbMV0sITEpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oOTgpLGk9bigyMiksYT1uKDQ2KSxzPW4oMTEpLHU9W10uc2xpY2U7cihyLlArci5GKm4oNikoZnVuY3Rpb24oKXtvJiZ1LmNhbGwobyl9KSxcIkFycmF5XCIse3NsaWNlOmZ1bmN0aW9uKHQsZSl7dmFyIG49cyh0aGlzLmxlbmd0aCkscj1pKHRoaXMpO2lmKGU9dm9pZCAwPT09ZT9uOmUsXCJBcnJheVwiPT1yKXJldHVybiB1LmNhbGwodGhpcyx0LGUpO2Zvcih2YXIgbz1hKHQsbiksbD1hKGUsbiksYz1zKGwtbyksZj1BcnJheShjKSxwPTA7cDxjO3ArKylmW3BdPVwiU3RyaW5nXCI9PXI/dGhpcy5jaGFyQXQobytwKTp0aGlzW28rcF07cmV0dXJuIGZ9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigyNikoMyk7cihyLlArci5GKiFuKDI0KShbXS5zb21lLCEwKSxcIkFycmF5XCIse3NvbWU6ZnVuY3Rpb24odCl7cmV0dXJuIG8odGhpcyx0LGFyZ3VtZW50c1sxXSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxNCksaT1uKDEyKSxhPW4oNikscz1bXS5zb3J0LHU9WzEsMiwzXTtyKHIuUCtyLkYqKGEoZnVuY3Rpb24oKXt1LnNvcnQodm9pZCAwKX0pfHwhYShmdW5jdGlvbigpe3Uuc29ydChudWxsKX0pfHwhbigyNCkocykpLFwiQXJyYXlcIix7c29ydDpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dD9zLmNhbGwoaSh0aGlzKSk6cy5jYWxsKGkodGhpcyksbyh0KSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtuKDQ1KShcIkFycmF5XCIpfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIkRhdGVcIix7bm93OmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89big2KSxpPURhdGUucHJvdG90eXBlLmdldFRpbWUsYT1mdW5jdGlvbih0KXtyZXR1cm4gdD45P3Q6XCIwXCIrdH07cihyLlArci5GKihvKGZ1bmN0aW9uKCl7cmV0dXJuXCIwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVpcIiE9bmV3IERhdGUoLTVlMTMtMSkudG9JU09TdHJpbmcoKX0pfHwhbyhmdW5jdGlvbigpe25ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKX0pKSxcIkRhdGVcIix7dG9JU09TdHJpbmc6ZnVuY3Rpb24oKXtpZighaXNGaW5pdGUoaS5jYWxsKHRoaXMpKSl0aHJvdyBSYW5nZUVycm9yKFwiSW52YWxpZCB0aW1lIHZhbHVlXCIpO1xudmFyIHQ9dGhpcyxlPXQuZ2V0VVRDRnVsbFllYXIoKSxuPXQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkscj1lPDA/XCItXCI6ZT45OTk5P1wiK1wiOlwiXCI7cmV0dXJuIHIrKFwiMDAwMDBcIitNYXRoLmFicyhlKSkuc2xpY2Uocj8tNjotNCkrXCItXCIrYSh0LmdldFVUQ01vbnRoKCkrMSkrXCItXCIrYSh0LmdldFVUQ0RhdGUoKSkrXCJUXCIrYSh0LmdldFVUQ0hvdXJzKCkpK1wiOlwiK2EodC5nZXRVVENNaW51dGVzKCkpK1wiOlwiK2EodC5nZXRVVENTZWNvbmRzKCkpK1wiLlwiKyhuPjk5P246XCIwXCIrYShuKSkrXCJaXCJ9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMiksaT1uKDI4KTtyKHIuUCtyLkYqbig2KShmdW5jdGlvbigpe3JldHVybiBudWxsIT09bmV3IERhdGUoTmFOKS50b0pTT04oKXx8MSE9PURhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHt0b0lTT1N0cmluZzpmdW5jdGlvbigpe3JldHVybiAxfX0pfSksXCJEYXRlXCIse3RvSlNPTjpmdW5jdGlvbih0KXt2YXIgZT1vKHRoaXMpLG49aShlKTtyZXR1cm5cIm51bWJlclwiIT10eXBlb2Ygbnx8aXNGaW5pdGUobik/ZS50b0lTT1N0cmluZygpOm51bGx9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDgpKFwidG9QcmltaXRpdmVcIiksbz1EYXRlLnByb3RvdHlwZTtyIGluIG98fG4oMTUpKG8scixuKDI3MCkpfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9RGF0ZS5wcm90b3R5cGUsbz1cIkludmFsaWQgRGF0ZVwiLGk9XCJ0b1N0cmluZ1wiLGE9cltpXSxzPXIuZ2V0VGltZTtuZXcgRGF0ZShOYU4pK1wiXCIhPW8mJm4oMTYpKHIsaSxmdW5jdGlvbigpe3ZhciB0PXMuY2FsbCh0aGlzKTtyZXR1cm4gdD09PXQ/YS5jYWxsKHRoaXMpOm99KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlAsXCJGdW5jdGlvblwiLHtiaW5kOm4oMTQyKX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big3KSxvPW4oMjEpLGk9big4KShcImhhc0luc3RhbmNlXCIpLGE9RnVuY3Rpb24ucHJvdG90eXBlO2kgaW4gYXx8bigxMCkuZihhLGkse3ZhbHVlOmZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXN8fCFyKHQpKXJldHVybiExO2lmKCFyKHRoaXMucHJvdG90eXBlKSlyZXR1cm4gdCBpbnN0YW5jZW9mIHRoaXM7Zm9yKDt0PW8odCk7KWlmKHRoaXMucHJvdG90eXBlPT09dClyZXR1cm4hMDtyZXR1cm4hMX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTApLmYsbz1uKDM2KSxpPW4oMTMpLGE9RnVuY3Rpb24ucHJvdG90eXBlLHM9L15cXHMqZnVuY3Rpb24gKFteIChdKikvLHU9XCJuYW1lXCIsbD1PYmplY3QuaXNFeHRlbnNpYmxlfHxmdW5jdGlvbigpe3JldHVybiEwfTt1IGluIGF8fG4oOSkmJnIoYSx1LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXRoaXMsZT0oXCJcIit0KS5tYXRjaChzKVsxXTtyZXR1cm4gaSh0LHUpfHwhbCh0KXx8cih0LHUsbyg1LGUpKSxlfWNhdGNoKHQpe3JldHVyblwiXCJ9fX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMTUwKSxpPU1hdGguc3FydCxhPU1hdGguYWNvc2g7cihyLlMrci5GKiEoYSYmNzEwPT1NYXRoLmZsb29yKGEoTnVtYmVyLk1BWF9WQUxVRSkpJiZhKDEvMCk9PTEvMCksXCJNYXRoXCIse2Fjb3NoOmZ1bmN0aW9uKHQpe3JldHVybih0PSt0KTwxP05hTjp0Pjk0OTA2MjY1LjYyNDI1MTU2P01hdGgubG9nKHQpK01hdGguTE4yOm8odC0xK2kodC0xKSppKHQrMSkpfX0pfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gaXNGaW5pdGUodD0rdCkmJjAhPXQ/dDwwPy1yKC10KTpNYXRoLmxvZyh0K01hdGguc3FydCh0KnQrMSkpOnR9dmFyIG89bigwKSxpPU1hdGguYXNpbmg7byhvLlMrby5GKiEoaSYmMS9pKDApPjApLFwiTWF0aFwiLHthc2luaDpyfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89TWF0aC5hdGFuaDtyKHIuUytyLkYqIShvJiYxL28oLTApPDApLFwiTWF0aFwiLHthdGFuaDpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9K3QpP3Q6TWF0aC5sb2coKDErdCkvKDEtdCkpLzJ9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxMDUpO3Ioci5TLFwiTWF0aFwiLHtjYnJ0OmZ1bmN0aW9uKHQpe3JldHVybiBvKHQ9K3QpKk1hdGgucG93KE1hdGguYWJzKHQpLDEvMyl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiTWF0aFwiLHtjbHozMjpmdW5jdGlvbih0KXtyZXR1cm4odD4+Pj0wKT8zMS1NYXRoLmZsb29yKE1hdGgubG9nKHQrLjUpKk1hdGguTE9HMkUpOjMyfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPU1hdGguZXhwO3Ioci5TLFwiTWF0aFwiLHtjb3NoOmZ1bmN0aW9uKHQpe3JldHVybihvKHQ9K3QpK28oLXQpKS8yfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMTA0KTtyKHIuUytyLkYqKG8hPU1hdGguZXhwbTEpLFwiTWF0aFwiLHtleHBtMTpvfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxMDUpLGk9TWF0aC5wb3csYT1pKDIsLTUyKSxzPWkoMiwtMjMpLHU9aSgyLDEyNykqKDItcyksbD1pKDIsLTEyNiksYz1mdW5jdGlvbih0KXtyZXR1cm4gdCsxL2EtMS9hfTtyKHIuUyxcIk1hdGhcIix7ZnJvdW5kOmZ1bmN0aW9uKHQpe3ZhciBlLG4scj1NYXRoLmFicyh0KSxpPW8odCk7cmV0dXJuIHI8bD9pKmMoci9sL3MpKmwqczooZT0oMStzL2EpKnIsbj1lLShlLXIpLG4+dXx8biE9bj9pKigxLzApOmkqbil9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89TWF0aC5hYnM7cihyLlMsXCJNYXRoXCIse2h5cG90OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuLHIsaT0wLGE9MCxzPWFyZ3VtZW50cy5sZW5ndGgsdT0wO2E8czspbj1vKGFyZ3VtZW50c1thKytdKSx1PG4/KHI9dS9uLGk9aSpyKnIrMSx1PW4pOm4+MD8ocj1uL3UsaSs9cipyKTppKz1uO3JldHVybiB1PT09MS8wPzEvMDp1Kk1hdGguc3FydChpKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1NYXRoLmltdWw7cihyLlMrci5GKm4oNikoZnVuY3Rpb24oKXtyZXR1cm4gbyg0Mjk0OTY3Mjk1LDUpIT0tNXx8MiE9by5sZW5ndGh9KSxcIk1hdGhcIix7aW11bDpmdW5jdGlvbih0LGUpe3ZhciBuPTY1NTM1LHI9K3Qsbz0rZSxpPW4mcixhPW4mbztyZXR1cm4gMHxpKmErKChuJnI+Pj4xNikqYStpKihuJm8+Pj4xNik8PDE2Pj4+MCl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiTWF0aFwiLHtsb2cxMDpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5sb2codCkvTWF0aC5MTjEwfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIk1hdGhcIix7bG9nMXA6bigxNTApfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiTWF0aFwiLHtsb2cyOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmxvZyh0KS9NYXRoLkxOMn19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlMsXCJNYXRoXCIse3NpZ246bigxMDUpfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxMDQpLGk9TWF0aC5leHA7cihyLlMrci5GKm4oNikoZnVuY3Rpb24oKXtyZXR1cm4hTWF0aC5zaW5oKC0yZS0xNykhPS0yZS0xN30pLFwiTWF0aFwiLHtzaW5oOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmFicyh0PSt0KTwxPyhvKHQpLW8oLXQpKS8yOihpKHQtMSktaSgtdC0xKSkqKE1hdGguRS8yKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDEwNCksaT1NYXRoLmV4cDtyKHIuUyxcIk1hdGhcIix7dGFuaDpmdW5jdGlvbih0KXt2YXIgZT1vKHQ9K3QpLG49bygtdCk7cmV0dXJuIGU9PTEvMD8xOm49PTEvMD8tMTooZS1uKS8oaSh0KStpKC10KSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiTWF0aFwiLHt0cnVuYzpmdW5jdGlvbih0KXtyZXR1cm4odD4wP01hdGguZmxvb3I6TWF0aC5jZWlsKSh0KX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNSksbz1uKDEzKSxpPW4oMjIpLGE9big5OSkscz1uKDI4KSx1PW4oNiksbD1uKDQyKS5mLGM9bigyMCkuZixmPW4oMTApLmYscD1uKDU0KS50cmltLGg9XCJOdW1iZXJcIixkPXJbaF0sdj1kLG09ZC5wcm90b3R5cGUsXz1pKG4oNDEpKG0pKT09aCxnPVwidHJpbVwiaW4gU3RyaW5nLnByb3RvdHlwZSx5PWZ1bmN0aW9uKHQpe3ZhciBlPXModCwhMSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJmUubGVuZ3RoPjIpe2U9Zz9lLnRyaW0oKTpwKGUsMyk7dmFyIG4scixvLGk9ZS5jaGFyQ29kZUF0KDApO2lmKDQzPT09aXx8NDU9PT1pKXtpZihuPWUuY2hhckNvZGVBdCgyKSw4OD09PW58fDEyMD09PW4pcmV0dXJuIE5hTn1lbHNlIGlmKDQ4PT09aSl7c3dpdGNoKGUuY2hhckNvZGVBdCgxKSl7Y2FzZSA2NjpjYXNlIDk4OnI9MixvPTQ5O2JyZWFrO2Nhc2UgNzk6Y2FzZSAxMTE6cj04LG89NTU7YnJlYWs7ZGVmYXVsdDpyZXR1cm4rZX1mb3IodmFyIGEsdT1lLnNsaWNlKDIpLGw9MCxjPXUubGVuZ3RoO2w8YztsKyspaWYoYT11LmNoYXJDb2RlQXQobCksYTw0OHx8YT5vKXJldHVybiBOYU47cmV0dXJuIHBhcnNlSW50KHUscil9fXJldHVybitlfTtpZighZChcIiAwbzFcIil8fCFkKFwiMGIxXCIpfHxkKFwiKzB4MVwiKSl7ZD1mdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPDE/MDp0LG49dGhpcztyZXR1cm4gbiBpbnN0YW5jZW9mIGQmJihfP3UoZnVuY3Rpb24oKXttLnZhbHVlT2YuY2FsbChuKX0pOmkobikhPWgpP2EobmV3IHYoeShlKSksbixkKTp5KGUpfTtmb3IodmFyIGIsdz1uKDkpP2wodik6XCJNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSxFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlclwiLnNwbGl0KFwiLFwiKSx4PTA7dy5sZW5ndGg+eDt4Kyspbyh2LGI9d1t4XSkmJiFvKGQsYikmJmYoZCxiLGModixiKSk7ZC5wcm90b3R5cGU9bSxtLmNvbnN0cnVjdG9yPWQsbigxNikocixoLGQpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlMsXCJOdW1iZXJcIix7RVBTSUxPTjpNYXRoLnBvdygyLC01Mil9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDUpLmlzRmluaXRlO3Ioci5TLFwiTnVtYmVyXCIse2lzRmluaXRlOmZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZvKHQpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIk51bWJlclwiLHtpc0ludGVnZXI6bigxNDcpfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiTnVtYmVyXCIse2lzTmFOOmZ1bmN0aW9uKHQpe3JldHVybiB0IT10fX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMTQ3KSxpPU1hdGguYWJzO3Ioci5TLFwiTnVtYmVyXCIse2lzU2FmZUludGVnZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odCkmJmkodCk8PTkwMDcxOTkyNTQ3NDA5OTF9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiTnVtYmVyXCIse01BWF9TQUZFX0lOVEVHRVI6OTAwNzE5OTI1NDc0MDk5MX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIk51bWJlclwiLHtNSU5fU0FGRV9JTlRFR0VSOi05MDA3MTk5MjU0NzQwOTkxfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxNTcpO3Ioci5TK3IuRiooTnVtYmVyLnBhcnNlRmxvYXQhPW8pLFwiTnVtYmVyXCIse3BhcnNlRmxvYXQ6b30pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMTU4KTtyKHIuUytyLkYqKE51bWJlci5wYXJzZUludCE9byksXCJOdW1iZXJcIix7cGFyc2VJbnQ6b30pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMzcpLGk9bigxMzgpLGE9bigxMTIpLHM9MS4udG9GaXhlZCx1PU1hdGguZmxvb3IsbD1bMCwwLDAsMCwwLDBdLGM9XCJOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hXCIsZj1cIjBcIixwPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPS0xLHI9ZTsrK248Njspcis9dCpsW25dLGxbbl09ciUxZTcscj11KHIvMWU3KX0saD1mdW5jdGlvbih0KXtmb3IodmFyIGU9NixuPTA7LS1lPj0wOyluKz1sW2VdLGxbZV09dShuL3QpLG49biV0KjFlN30sZD1mdW5jdGlvbigpe2Zvcih2YXIgdD02LGU9XCJcIjstLXQ+PTA7KWlmKFwiXCIhPT1lfHwwPT09dHx8MCE9PWxbdF0pe3ZhciBuPVN0cmluZyhsW3RdKTtlPVwiXCI9PT1lP246ZSthLmNhbGwoZiw3LW4ubGVuZ3RoKStufXJldHVybiBlfSx2PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gMD09PWU/bjplJTI9PT0xP3YodCxlLTEsbip0KTp2KHQqdCxlLzIsbil9LG09ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10O24+PTQwOTY7KWUrPTEyLG4vPTQwOTY7Zm9yKDtuPj0yOyllKz0xLG4vPTI7cmV0dXJuIGV9O3Ioci5QK3IuRiooISFzJiYoXCIwLjAwMFwiIT09OGUtNS50b0ZpeGVkKDMpfHxcIjFcIiE9PS45LnRvRml4ZWQoMCl8fFwiMS4yNVwiIT09MS4yNTUudG9GaXhlZCgyKXx8XCIxMDAwMDAwMDAwMDAwMDAwMTI4XCIhPT0oMHhkZTBiNmIzYTc2NDAwODApLnRvRml4ZWQoMCkpfHwhbig2KShmdW5jdGlvbigpe3MuY2FsbCh7fSl9KSksXCJOdW1iZXJcIix7dG9GaXhlZDpmdW5jdGlvbih0KXt2YXIgZSxuLHIscyx1PWkodGhpcyxjKSxsPW8odCksXz1cIlwiLGc9ZjtpZihsPDB8fGw+MjApdGhyb3cgUmFuZ2VFcnJvcihjKTtpZih1IT11KXJldHVyblwiTmFOXCI7aWYodTw9LTFlMjF8fHU+PTFlMjEpcmV0dXJuIFN0cmluZyh1KTtpZih1PDAmJihfPVwiLVwiLHU9LXUpLHU+MWUtMjEpaWYoZT1tKHUqdigyLDY5LDEpKS02OSxuPWU8MD91KnYoMiwtZSwxKTp1L3YoMixlLDEpLG4qPTQ1MDM1OTk2MjczNzA0OTYsZT01Mi1lLGU+MCl7Zm9yKHAoMCxuKSxyPWw7cj49NzspcCgxZTcsMCksci09Nztmb3IocCh2KDEwLHIsMSksMCkscj1lLTE7cj49MjM7KWgoMTw8MjMpLHItPTIzO2goMTw8cikscCgxLDEpLGgoMiksZz1kKCl9ZWxzZSBwKDAsbikscCgxPDwtZSwwKSxnPWQoKSthLmNhbGwoZixsKTtyZXR1cm4gbD4wPyhzPWcubGVuZ3RoLGc9Xysoczw9bD9cIjAuXCIrYS5jYWxsKGYsbC1zKStnOmcuc2xpY2UoMCxzLWwpK1wiLlwiK2cuc2xpY2Uocy1sKSkpOmc9XytnLGd9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89big2KSxpPW4oMTM4KSxhPTEuLnRvUHJlY2lzaW9uO3Ioci5QK3IuRioobyhmdW5jdGlvbigpe3JldHVyblwiMVwiIT09YS5jYWxsKDEsdm9pZCAwKX0pfHwhbyhmdW5jdGlvbigpe2EuY2FsbCh7fSl9KSksXCJOdW1iZXJcIix7dG9QcmVjaXNpb246ZnVuY3Rpb24odCl7dmFyIGU9aSh0aGlzLFwiTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiFcIik7cmV0dXJuIHZvaWQgMD09PXQ/YS5jYWxsKGUpOmEuY2FsbChlLHQpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUytyLkYsXCJPYmplY3RcIix7YXNzaWduOm4oMTUxKX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIk9iamVjdFwiLHtjcmVhdGU6big0MSl9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlMrci5GKiFuKDkpLFwiT2JqZWN0XCIse2RlZmluZVByb3BlcnRpZXM6bigxNTIpfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TK3IuRiohbig5KSxcIk9iamVjdFwiLHtkZWZpbmVQcm9wZXJ0eTpuKDEwKS5mfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpLG89bigzNSkub25GcmVlemU7bigyNykoXCJmcmVlemVcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHQmJnIoZSk/dChvKGUpKTplfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxOCksbz1uKDIwKS5mO24oMjcpKFwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXCIsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtyZXR1cm4gbyhyKHQpLGUpfX0pfSxmdW5jdGlvbih0LGUsbil7bigyNykoXCJnZXRPd25Qcm9wZXJ0eU5hbWVzXCIsZnVuY3Rpb24oKXtyZXR1cm4gbigxNTMpLmZ9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTIpLG89bigyMSk7bigyNykoXCJnZXRQcm90b3R5cGVPZlwiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBvKHIodCkpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3KTtuKDI3KShcImlzRXh0ZW5zaWJsZVwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4hIXIoZSkmJighdHx8dChlKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpO24oMjcpKFwiaXNGcm96ZW5cIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIXIoZSl8fCEhdCYmdChlKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNyk7bigyNykoXCJpc1NlYWxlZFwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4hcihlKXx8ISF0JiZ0KGUpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIk9iamVjdFwiLHtpczpuKDE1OSl9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTIpLG89big0Myk7bigyNykoXCJrZXlzXCIsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG8ocih0KSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpLG89bigzNSkub25GcmVlemU7bigyNykoXCJwcmV2ZW50RXh0ZW5zaW9uc1wiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdCYmcihlKT90KG8oZSkpOmV9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpLG89bigzNSkub25GcmVlemU7bigyNykoXCJzZWFsXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0JiZyKGUpP3QobyhlKSk6ZX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlMsXCJPYmplY3RcIix7c2V0UHJvdG90eXBlT2Y6bigxMDcpLnNldH0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big1OCksbz17fTtvW24oOCkoXCJ0b1N0cmluZ1RhZ1wiKV09XCJ6XCIsbytcIlwiIT1cIltvYmplY3Qgel1cIiYmbigxNikoT2JqZWN0LnByb3RvdHlwZSxcInRvU3RyaW5nXCIsZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgXCIrcih0aGlzKStcIl1cIn0sITApfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMTU3KTtyKHIuRytyLkYqKHBhcnNlRmxvYXQhPW8pLHtwYXJzZUZsb2F0Om99KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDE1OCk7cihyLkcrci5GKihwYXJzZUludCE9bykse3BhcnNlSW50Om99KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByLG8saSxhPW4oNDApLHM9big1KSx1PW4oMzIpLGw9big1OCksYz1uKDApLGY9big3KSxwPW4oMTQpLGg9bigzOSksZD1uKDUxKSx2PW4oMTA5KSxtPW4oMTE0KS5zZXQsXz1uKDEwNikoKSxnPVwiUHJvbWlzZVwiLHk9cy5UeXBlRXJyb3IsYj1zLnByb2Nlc3Msdz1zW2ddLGI9cy5wcm9jZXNzLHg9XCJwcm9jZXNzXCI9PWwoYiksRT1mdW5jdGlvbigpe30sVD0hIWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXcucmVzb2x2ZSgxKSxlPSh0LmNvbnN0cnVjdG9yPXt9KVtuKDgpKFwic3BlY2llc1wiKV09ZnVuY3Rpb24odCl7dChFLEUpfTtyZXR1cm4oeHx8XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50KSYmdC50aGVuKEUpaW5zdGFuY2VvZiBlfWNhdGNoKHQpe319KCksTz1mdW5jdGlvbih0LGUpe3JldHVybiB0PT09ZXx8dD09PXcmJmU9PT1pfSxTPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiEoIWYodCl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mKGU9dC50aGVuKSkmJmV9LFA9ZnVuY3Rpb24odCl7cmV0dXJuIE8odyx0KT9uZXcgTSh0KTpuZXcgbyh0KX0sTT1vPWZ1bmN0aW9uKHQpe3ZhciBlLG47dGhpcy5wcm9taXNlPW5ldyB0KGZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ZXx8dm9pZCAwIT09bil0aHJvdyB5KFwiQmFkIFByb21pc2UgY29uc3RydWN0b3JcIik7ZT10LG49cn0pLHRoaXMucmVzb2x2ZT1wKGUpLHRoaXMucmVqZWN0PXAobil9LGo9ZnVuY3Rpb24odCl7dHJ5e3QoKX1jYXRjaCh0KXtyZXR1cm57ZXJyb3I6dH19fSxBPWZ1bmN0aW9uKHQsZSl7aWYoIXQuX24pe3QuX249ITA7dmFyIG49dC5fYztfKGZ1bmN0aW9uKCl7Zm9yKHZhciByPXQuX3Ysbz0xPT10Ll9zLGk9MCxhPWZ1bmN0aW9uKGUpe3ZhciBuLGksYT1vP2Uub2s6ZS5mYWlsLHM9ZS5yZXNvbHZlLHU9ZS5yZWplY3QsbD1lLmRvbWFpbjt0cnl7YT8ob3x8KDI9PXQuX2gmJlIodCksdC5faD0xKSxhPT09ITA/bj1yOihsJiZsLmVudGVyKCksbj1hKHIpLGwmJmwuZXhpdCgpKSxuPT09ZS5wcm9taXNlP3UoeShcIlByb21pc2UtY2hhaW4gY3ljbGVcIikpOihpPVMobikpP2kuY2FsbChuLHMsdSk6cyhuKSk6dShyKX1jYXRjaCh0KXt1KHQpfX07bi5sZW5ndGg+aTspYShuW2krK10pO3QuX2M9W10sdC5fbj0hMSxlJiYhdC5faCYmQyh0KX0pfX0sQz1mdW5jdGlvbih0KXttLmNhbGwocyxmdW5jdGlvbigpe3ZhciBlLG4scixvPXQuX3Y7aWYoayh0KSYmKGU9aihmdW5jdGlvbigpe3g/Yi5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsbyx0KToobj1zLm9udW5oYW5kbGVkcmVqZWN0aW9uKT9uKHtwcm9taXNlOnQscmVhc29uOm99KToocj1zLmNvbnNvbGUpJiZyLmVycm9yJiZyLmVycm9yKFwiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uXCIsbyl9KSx0Ll9oPXh8fGsodCk/MjoxKSx0Ll9hPXZvaWQgMCxlKXRocm93IGUuZXJyb3J9KX0saz1mdW5jdGlvbih0KXtpZigxPT10Ll9oKXJldHVybiExO2Zvcih2YXIgZSxuPXQuX2F8fHQuX2Mscj0wO24ubGVuZ3RoPnI7KWlmKGU9bltyKytdLGUuZmFpbHx8IWsoZS5wcm9taXNlKSlyZXR1cm4hMTtyZXR1cm4hMH0sUj1mdW5jdGlvbih0KXttLmNhbGwocyxmdW5jdGlvbigpe3ZhciBlO3g/Yi5lbWl0KFwicmVqZWN0aW9uSGFuZGxlZFwiLHQpOihlPXMub25yZWplY3Rpb25oYW5kbGVkKSYmZSh7cHJvbWlzZTp0LHJlYXNvbjp0Ll92fSl9KX0sST1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2UuX2R8fChlLl9kPSEwLGU9ZS5fd3x8ZSxlLl92PXQsZS5fcz0yLGUuX2F8fChlLl9hPWUuX2Muc2xpY2UoKSksQShlLCEwKSl9LE49ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzO2lmKCFuLl9kKXtuLl9kPSEwLG49bi5fd3x8bjt0cnl7aWYobj09PXQpdGhyb3cgeShcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpOyhlPVModCkpP18oZnVuY3Rpb24oKXt2YXIgcj17X3c6bixfZDohMX07dHJ5e2UuY2FsbCh0LHUoTixyLDEpLHUoSSxyLDEpKX1jYXRjaCh0KXtJLmNhbGwocix0KX19KToobi5fdj10LG4uX3M9MSxBKG4sITEpKX1jYXRjaCh0KXtJLmNhbGwoe193Om4sX2Q6ITF9LHQpfX19O1R8fCh3PWZ1bmN0aW9uKHQpe2godGhpcyx3LGcsXCJfaFwiKSxwKHQpLHIuY2FsbCh0aGlzKTt0cnl7dCh1KE4sdGhpcywxKSx1KEksdGhpcywxKSl9Y2F0Y2godCl7SS5jYWxsKHRoaXMsdCl9fSxyPWZ1bmN0aW9uKHQpe3RoaXMuX2M9W10sdGhpcy5fYT12b2lkIDAsdGhpcy5fcz0wLHRoaXMuX2Q9ITEsdGhpcy5fdj12b2lkIDAsdGhpcy5faD0wLHRoaXMuX249ITF9LHIucHJvdG90eXBlPW4oNDQpKHcucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHQsZSl7dmFyIG49UCh2KHRoaXMsdykpO3JldHVybiBuLm9rPVwiZnVuY3Rpb25cIiE9dHlwZW9mIHR8fHQsbi5mYWlsPVwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUsbi5kb21haW49eD9iLmRvbWFpbjp2b2lkIDAsdGhpcy5fYy5wdXNoKG4pLHRoaXMuX2EmJnRoaXMuX2EucHVzaChuKSx0aGlzLl9zJiZBKHRoaXMsITEpLG4ucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsdCl9fSksTT1mdW5jdGlvbigpe3ZhciB0PW5ldyByO3RoaXMucHJvbWlzZT10LHRoaXMucmVzb2x2ZT11KE4sdCwxKSx0aGlzLnJlamVjdD11KEksdCwxKX0pLGMoYy5HK2MuVytjLkYqIVQse1Byb21pc2U6d30pLG4oNTMpKHcsZyksbig0NSkoZyksaT1uKDMxKVtnXSxjKGMuUytjLkYqIVQsZyx7cmVqZWN0OmZ1bmN0aW9uKHQpe3ZhciBlPVAodGhpcyksbj1lLnJlamVjdDtyZXR1cm4gbih0KSxlLnByb21pc2V9fSksYyhjLlMrYy5GKihhfHwhVCksZyx7cmVzb2x2ZTpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgdyYmTyh0LmNvbnN0cnVjdG9yLHRoaXMpKXJldHVybiB0O3ZhciBlPVAodGhpcyksbj1lLnJlc29sdmU7cmV0dXJuIG4odCksZS5wcm9taXNlfX0pLGMoYy5TK2MuRiohKFQmJm4oNzUpKGZ1bmN0aW9uKHQpe3cuYWxsKHQpLmNhdGNoKEUpfSkpLGcse2FsbDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49UChlKSxyPW4ucmVzb2x2ZSxvPW4ucmVqZWN0LGk9aihmdW5jdGlvbigpe3ZhciBuPVtdLGk9MCxhPTE7ZCh0LCExLGZ1bmN0aW9uKHQpe3ZhciBzPWkrKyx1PSExO24ucHVzaCh2b2lkIDApLGErKyxlLnJlc29sdmUodCkudGhlbihmdW5jdGlvbih0KXt1fHwodT0hMCxuW3NdPXQsLS1hfHxyKG4pKX0sbyl9KSwtLWF8fHIobil9KTtyZXR1cm4gaSYmbyhpLmVycm9yKSxuLnByb21pc2V9LHJhY2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPVAoZSkscj1uLnJlamVjdCxvPWooZnVuY3Rpb24oKXtkKHQsITEsZnVuY3Rpb24odCl7ZS5yZXNvbHZlKHQpLnRoZW4obi5yZXNvbHZlLHIpfSl9KTtyZXR1cm4gbyYmcihvLmVycm9yKSxuLnByb21pc2V9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxNCksaT1uKDQpLGE9KG4oNSkuUmVmbGVjdHx8e30pLmFwcGx5LHM9RnVuY3Rpb24uYXBwbHk7cihyLlMrci5GKiFuKDYpKGZ1bmN0aW9uKCl7YShmdW5jdGlvbigpe30pfSksXCJSZWZsZWN0XCIse2FwcGx5OmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1vKHQpLHU9aShuKTtyZXR1cm4gYT9hKHIsZSx1KTpzLmNhbGwocixlLHUpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oNDEpLGk9bigxNCksYT1uKDQpLHM9big3KSx1PW4oNiksbD1uKDE0MiksYz0obig1KS5SZWZsZWN0fHx7fSkuY29uc3RydWN0LGY9dShmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIShjKGZ1bmN0aW9uKCl7fSxbXSx0KWluc3RhbmNlb2YgdCl9KSxwPSF1KGZ1bmN0aW9uKCl7YyhmdW5jdGlvbigpe30pfSk7cihyLlMrci5GKihmfHxwKSxcIlJlZmxlY3RcIix7Y29uc3RydWN0OmZ1bmN0aW9uKHQsZSl7aSh0KSxhKGUpO3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg8Mz90OmkoYXJndW1lbnRzWzJdKTtpZihwJiYhZilyZXR1cm4gYyh0LGUsbik7aWYodD09bil7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyB0O2Nhc2UgMTpyZXR1cm4gbmV3IHQoZVswXSk7Y2FzZSAyOnJldHVybiBuZXcgdChlWzBdLGVbMV0pO2Nhc2UgMzpyZXR1cm4gbmV3IHQoZVswXSxlWzFdLGVbMl0pO2Nhc2UgNDpyZXR1cm4gbmV3IHQoZVswXSxlWzFdLGVbMl0sZVszXSl9dmFyIHI9W251bGxdO3JldHVybiByLnB1c2guYXBwbHkocixlKSxuZXcobC5hcHBseSh0LHIpKX12YXIgdT1uLnByb3RvdHlwZSxoPW8ocyh1KT91Ok9iamVjdC5wcm90b3R5cGUpLGQ9RnVuY3Rpb24uYXBwbHkuY2FsbCh0LGgsZSk7cmV0dXJuIHMoZCk/ZDpofX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxMCksbz1uKDApLGk9big0KSxhPW4oMjgpO28oby5TK28uRipuKDYpKGZ1bmN0aW9uKCl7UmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShyLmYoe30sMSx7dmFsdWU6MX0pLDEse3ZhbHVlOjJ9KX0pLFwiUmVmbGVjdFwiLHtkZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbih0LGUsbil7aSh0KSxlPWEoZSwhMCksaShuKTt0cnl7cmV0dXJuIHIuZih0LGUsbiksITB9Y2F0Y2godCl7cmV0dXJuITF9fX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oMjApLmYsaT1uKDQpO3Ioci5TLFwiUmVmbGVjdFwiLHtkZWxldGVQcm9wZXJ0eTpmdW5jdGlvbih0LGUpe3ZhciBuPW8oaSh0KSxlKTtyZXR1cm4hKG4mJiFuLmNvbmZpZ3VyYWJsZSkmJmRlbGV0ZSB0W2VdfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oNCksaT1mdW5jdGlvbih0KXt0aGlzLl90PW8odCksdGhpcy5faT0wO3ZhciBlLG49dGhpcy5faz1bXTtmb3IoZSBpbiB0KW4ucHVzaChlKX07bigxMDIpKGksXCJPYmplY3RcIixmdW5jdGlvbigpe3ZhciB0LGU9dGhpcyxuPWUuX2s7ZG8gaWYoZS5faT49bi5sZW5ndGgpcmV0dXJue3ZhbHVlOnZvaWQgMCxkb25lOiEwfTt3aGlsZSghKCh0PW5bZS5faSsrXSlpbiBlLl90KSk7cmV0dXJue3ZhbHVlOnQsZG9uZTohMX19KSxyKHIuUyxcIlJlZmxlY3RcIix7ZW51bWVyYXRlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgaSh0KX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjApLG89bigwKSxpPW4oNCk7byhvLlMsXCJSZWZsZWN0XCIse2dldE93blByb3BlcnR5RGVzY3JpcHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiByLmYoaSh0KSxlKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDIxKSxpPW4oNCk7cihyLlMsXCJSZWZsZWN0XCIse2dldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiBvKGkodCkpfX0pfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3ZhciBuLHMsYz1hcmd1bWVudHMubGVuZ3RoPDM/dDphcmd1bWVudHNbMl07cmV0dXJuIGwodCk9PT1jP3RbZV06KG49by5mKHQsZSkpP2EobixcInZhbHVlXCIpP24udmFsdWU6dm9pZCAwIT09bi5nZXQ/bi5nZXQuY2FsbChjKTp2b2lkIDA6dShzPWkodCkpP3IocyxlLGMpOnZvaWQgMH12YXIgbz1uKDIwKSxpPW4oMjEpLGE9bigxMykscz1uKDApLHU9big3KSxsPW4oNCk7cyhzLlMsXCJSZWZsZWN0XCIse2dldDpyfSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiUmVmbGVjdFwiLHtoYXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSBpbiB0fX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oNCksaT1PYmplY3QuaXNFeHRlbnNpYmxlO3Ioci5TLFwiUmVmbGVjdFwiLHtpc0V4dGVuc2libGU6ZnVuY3Rpb24odCl7cmV0dXJuIG8odCksIWl8fGkodCl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiUmVmbGVjdFwiLHtvd25LZXlzOm4oMTU2KX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKSxvPW4oNCksaT1PYmplY3QucHJldmVudEV4dGVuc2lvbnM7cihyLlMsXCJSZWZsZWN0XCIse3ByZXZlbnRFeHRlbnNpb25zOmZ1bmN0aW9uKHQpe28odCk7dHJ5e3JldHVybiBpJiZpKHQpLCEwfWNhdGNoKHQpe3JldHVybiExfX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDEwNyk7byYmcihyLlMsXCJSZWZsZWN0XCIse3NldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQsZSl7by5jaGVjayh0LGUpO3RyeXtyZXR1cm4gby5zZXQodCxlKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19fSl9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuKXt2YXIgdSxwLGg9YXJndW1lbnRzLmxlbmd0aDw0P3Q6YXJndW1lbnRzWzNdLGQ9aS5mKGModCksZSk7aWYoIWQpe2lmKGYocD1hKHQpKSlyZXR1cm4gcihwLGUsbixoKTtkPWwoMCl9cmV0dXJuIHMoZCxcInZhbHVlXCIpPyEoZC53cml0YWJsZT09PSExfHwhZihoKSkmJih1PWkuZihoLGUpfHxsKDApLHUudmFsdWU9bixvLmYoaCxlLHUpLCEwKTp2b2lkIDAhPT1kLnNldCYmKGQuc2V0LmNhbGwoaCxuKSwhMCl9dmFyIG89bigxMCksaT1uKDIwKSxhPW4oMjEpLHM9bigxMyksdT1uKDApLGw9bigzNiksYz1uKDQpLGY9big3KTt1KHUuUyxcIlJlZmxlY3RcIix7c2V0OnJ9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNSksbz1uKDk5KSxpPW4oMTApLmYsYT1uKDQyKS5mLHM9big3NCksdT1uKDcyKSxsPXIuUmVnRXhwLGM9bCxmPWwucHJvdG90eXBlLHA9L2EvZyxoPS9hL2csZD1uZXcgbChwKSE9PXA7aWYobig5KSYmKCFkfHxuKDYpKGZ1bmN0aW9uKCl7cmV0dXJuIGhbbig4KShcIm1hdGNoXCIpXT0hMSxsKHApIT1wfHxsKGgpPT1ofHxcIi9hL2lcIiE9bChwLFwiaVwiKX0pKSl7bD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMgaW5zdGFuY2VvZiBsLHI9cyh0KSxpPXZvaWQgMD09PWU7cmV0dXJuIW4mJnImJnQuY29uc3RydWN0b3I9PT1sJiZpP3Q6byhkP25ldyBjKHImJiFpP3Quc291cmNlOnQsZSk6Yygocj10IGluc3RhbmNlb2YgbCk/dC5zb3VyY2U6dCxyJiZpP3UuY2FsbCh0KTplKSxuP3RoaXM6ZixsKX07Zm9yKHZhciB2PShmdW5jdGlvbih0KXt0IGluIGx8fGkobCx0LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGNbdF19LHNldDpmdW5jdGlvbihlKXtjW3RdPWV9fSl9KSxtPWEoYyksXz0wO20ubGVuZ3RoPl87KXYobVtfKytdKTtmLmNvbnN0cnVjdG9yPWwsbC5wcm90b3R5cGU9ZixuKDE2KShyLFwiUmVnRXhwXCIsbCl9big0NSkoXCJSZWdFeHBcIil9LGZ1bmN0aW9uKHQsZSxuKXtuKDcxKShcIm1hdGNoXCIsMSxmdW5jdGlvbih0LGUsbil7cmV0dXJuW2Z1bmN0aW9uKG4pe1widXNlIHN0cmljdFwiO3ZhciByPXQodGhpcyksbz12b2lkIDA9PW4/dm9pZCAwOm5bZV07cmV0dXJuIHZvaWQgMCE9PW8/by5jYWxsKG4scik6bmV3IFJlZ0V4cChuKVtlXShTdHJpbmcocikpfSxuXX0pfSxmdW5jdGlvbih0LGUsbil7big3MSkoXCJyZXBsYWNlXCIsMixmdW5jdGlvbih0LGUsbil7cmV0dXJuW2Z1bmN0aW9uKHIsbyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dCh0aGlzKSxhPXZvaWQgMD09cj92b2lkIDA6cltlXTtyZXR1cm4gdm9pZCAwIT09YT9hLmNhbGwocixpLG8pOm4uY2FsbChTdHJpbmcoaSkscixvKX0sbl19KX0sZnVuY3Rpb24odCxlLG4pe24oNzEpKFwic2VhcmNoXCIsMSxmdW5jdGlvbih0LGUsbil7cmV0dXJuW2Z1bmN0aW9uKG4pe1widXNlIHN0cmljdFwiO3ZhciByPXQodGhpcyksbz12b2lkIDA9PW4/dm9pZCAwOm5bZV07cmV0dXJuIHZvaWQgMCE9PW8/by5jYWxsKG4scik6bmV3IFJlZ0V4cChuKVtlXShTdHJpbmcocikpfSxuXX0pfSxmdW5jdGlvbih0LGUsbil7big3MSkoXCJzcGxpdFwiLDIsZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBvPW4oNzQpLGk9cixhPVtdLnB1c2gscz1cInNwbGl0XCIsdT1cImxlbmd0aFwiLGw9XCJsYXN0SW5kZXhcIjtpZihcImNcIj09XCJhYmJjXCJbc10oLyhiKSovKVsxXXx8NCE9XCJ0ZXN0XCJbc10oLyg/OikvLC0xKVt1XXx8MiE9XCJhYlwiW3NdKC8oPzphYikqLylbdV18fDQhPVwiLlwiW3NdKC8oLj8pKC4/KS8pW3VdfHxcIi5cIltzXSgvKCkoKS8pW3VdPjF8fFwiXCJbc10oLy4/LylbdV0pe3ZhciBjPXZvaWQgMD09PS8oKT8/Ly5leGVjKFwiXCIpWzFdO3I9ZnVuY3Rpb24odCxlKXt2YXIgbj1TdHJpbmcodGhpcyk7aWYodm9pZCAwPT09dCYmMD09PWUpcmV0dXJuW107aWYoIW8odCkpcmV0dXJuIGkuY2FsbChuLHQsZSk7dmFyIHIscyxmLHAsaCxkPVtdLHY9KHQuaWdub3JlQ2FzZT9cImlcIjpcIlwiKSsodC5tdWx0aWxpbmU/XCJtXCI6XCJcIikrKHQudW5pY29kZT9cInVcIjpcIlwiKSsodC5zdGlja3k/XCJ5XCI6XCJcIiksbT0wLF89dm9pZCAwPT09ZT80Mjk0OTY3Mjk1OmU+Pj4wLGc9bmV3IFJlZ0V4cCh0LnNvdXJjZSx2K1wiZ1wiKTtmb3IoY3x8KHI9bmV3IFJlZ0V4cChcIl5cIitnLnNvdXJjZStcIiQoPyFcXFxccylcIix2KSk7KHM9Zy5leGVjKG4pKSYmKGY9cy5pbmRleCtzWzBdW3VdLCEoZj5tJiYoZC5wdXNoKG4uc2xpY2UobSxzLmluZGV4KSksIWMmJnNbdV0+MSYmc1swXS5yZXBsYWNlKHIsZnVuY3Rpb24oKXtmb3IoaD0xO2g8YXJndW1lbnRzW3VdLTI7aCsrKXZvaWQgMD09PWFyZ3VtZW50c1toXSYmKHNbaF09dm9pZCAwKX0pLHNbdV0+MSYmcy5pbmRleDxuW3VdJiZhLmFwcGx5KGQscy5zbGljZSgxKSkscD1zWzBdW3VdLG09ZixkW3VdPj1fKSkpOylnW2xdPT09cy5pbmRleCYmZ1tsXSsrO3JldHVybiBtPT09blt1XT8hcCYmZy50ZXN0KFwiXCIpfHxkLnB1c2goXCJcIik6ZC5wdXNoKG4uc2xpY2UobSkpLGRbdV0+Xz9kLnNsaWNlKDAsXyk6ZH19ZWxzZVwiMFwiW3NdKHZvaWQgMCwwKVt1XSYmKHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmMD09PWU/W106aS5jYWxsKHRoaXMsdCxlKX0pO3JldHVybltmdW5jdGlvbihuLG8pe3ZhciBpPXQodGhpcyksYT12b2lkIDA9PW4/dm9pZCAwOm5bZV07cmV0dXJuIHZvaWQgMCE9PWE/YS5jYWxsKG4saSxvKTpyLmNhbGwoU3RyaW5nKGkpLG4sbyl9LHJdfSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuKDE2Myk7dmFyIHI9big0KSxvPW4oNzIpLGk9big5KSxhPVwidG9TdHJpbmdcIixzPS8uL1thXSx1PWZ1bmN0aW9uKHQpe24oMTYpKFJlZ0V4cC5wcm90b3R5cGUsYSx0LCEwKX07big2KShmdW5jdGlvbigpe3JldHVyblwiL2EvYlwiIT1zLmNhbGwoe3NvdXJjZTpcImFcIixmbGFnczpcImJcIn0pfSk/dShmdW5jdGlvbigpe3ZhciB0PXIodGhpcyk7cmV0dXJuXCIvXCIuY29uY2F0KHQuc291cmNlLFwiL1wiLFwiZmxhZ3NcImluIHQ/dC5mbGFnczohaSYmdCBpbnN0YW5jZW9mIFJlZ0V4cD9vLmNhbGwodCk6dm9pZCAwKX0pOnMubmFtZSE9YSYmdShmdW5jdGlvbigpe3JldHVybiBzLmNhbGwodGhpcyl9KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24oMTcpKFwiYW5jaG9yXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0KHRoaXMsXCJhXCIsXCJuYW1lXCIsZSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuKDE3KShcImJpZ1wiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsXCJiaWdcIixcIlwiLFwiXCIpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bigxNykoXCJibGlua1wiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsXCJibGlua1wiLFwiXCIsXCJcIil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuKDE3KShcImJvbGRcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLFwiYlwiLFwiXCIsXCJcIil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMTApKCExKTtyKHIuUCxcIlN0cmluZ1wiLHtjb2RlUG9pbnRBdDpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMTEpLGk9bigxMTEpLGE9XCJlbmRzV2l0aFwiLHM9XCJcIlthXTtyKHIuUCtyLkYqbig5NykoYSksXCJTdHJpbmdcIix7ZW5kc1dpdGg6ZnVuY3Rpb24odCl7dmFyIGU9aSh0aGlzLHQsYSksbj1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxyPW8oZS5sZW5ndGgpLHU9dm9pZCAwPT09bj9yOk1hdGgubWluKG8obiksciksbD1TdHJpbmcodCk7cmV0dXJuIHM/cy5jYWxsKGUsbCx1KTplLnNsaWNlKHUtbC5sZW5ndGgsdSk9PT1sfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bigxNykoXCJmaXhlZFwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsXCJ0dFwiLFwiXCIsXCJcIil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuKDE3KShcImZvbnRjb2xvclwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdCh0aGlzLFwiZm9udFwiLFwiY29sb3JcIixlKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24oMTcpKFwiZm9udHNpemVcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHQodGhpcyxcImZvbnRcIixcInNpemVcIixlKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDQ2KSxpPVN0cmluZy5mcm9tQ2hhckNvZGUsYT1TdHJpbmcuZnJvbUNvZGVQb2ludDtyKHIuUytyLkYqKCEhYSYmMSE9YS5sZW5ndGgpLFwiU3RyaW5nXCIse2Zyb21Db2RlUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49W10scj1hcmd1bWVudHMubGVuZ3RoLGE9MDtyPmE7KXtpZihlPSthcmd1bWVudHNbYSsrXSxvKGUsMTExNDExMSkhPT1lKXRocm93IFJhbmdlRXJyb3IoZStcIiBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50XCIpO24ucHVzaChlPDY1NTM2P2koZSk6aSgoKGUtPTY1NTM2KT4+MTApKzU1Mjk2LGUlMTAyNCs1NjMyMCkpfXJldHVybiBuLmpvaW4oXCJcIil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMTEpLGk9XCJpbmNsdWRlc1wiO3Ioci5QK3IuRipuKDk3KShpKSxcIlN0cmluZ1wiLHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4hIX5vKHRoaXMsdCxpKS5pbmRleE9mKHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bigxNykoXCJpdGFsaWNzXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxcImlcIixcIlwiLFwiXCIpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMTApKCEwKTtuKDEwMykoU3RyaW5nLFwiU3RyaW5nXCIsZnVuY3Rpb24odCl7dGhpcy5fdD1TdHJpbmcodCksdGhpcy5faT0wfSxmdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5fdCxuPXRoaXMuX2k7cmV0dXJuIG4+PWUubGVuZ3RoP3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06KHQ9cihlLG4pLHRoaXMuX2krPXQubGVuZ3RoLHt2YWx1ZTp0LGRvbmU6ITF9KX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bigxNykoXCJsaW5rXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0KHRoaXMsXCJhXCIsXCJocmVmXCIsZSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxOCksaT1uKDExKTtyKHIuUyxcIlN0cmluZ1wiLHtyYXc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW8odC5yYXcpLG49aShlLmxlbmd0aCkscj1hcmd1bWVudHMubGVuZ3RoLGE9W10scz0wO24+czspYS5wdXNoKFN0cmluZyhlW3MrK10pKSxzPHImJmEucHVzaChTdHJpbmcoYXJndW1lbnRzW3NdKSk7cmV0dXJuIGEuam9pbihcIlwiKX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlAsXCJTdHJpbmdcIix7cmVwZWF0Om4oMTEyKX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bigxNykoXCJzbWFsbFwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsXCJzbWFsbFwiLFwiXCIsXCJcIil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMSksaT1uKDExMSksYT1cInN0YXJ0c1dpdGhcIixzPVwiXCJbYV07cihyLlArci5GKm4oOTcpKGEpLFwiU3RyaW5nXCIse3N0YXJ0c1dpdGg6ZnVuY3Rpb24odCl7dmFyIGU9aSh0aGlzLHQsYSksbj1vKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLGUubGVuZ3RoKSkscj1TdHJpbmcodCk7cmV0dXJuIHM/cy5jYWxsKGUscixuKTplLnNsaWNlKG4sbityLmxlbmd0aCk9PT1yfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bigxNykoXCJzdHJpa2VcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLFwic3RyaWtlXCIsXCJcIixcIlwiKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24oMTcpKFwic3ViXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcyxcInN1YlwiLFwiXCIsXCJcIil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuKDE3KShcInN1cFwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsXCJzdXBcIixcIlwiLFwiXCIpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7big1NCkoXCJ0cmltXCIsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcywzKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNSksbz1uKDEzKSxpPW4oOSksYT1uKDApLHM9bigxNiksdT1uKDM1KS5LRVksbD1uKDYpLGM9big3OCksZj1uKDUzKSxwPW4oNDcpLGg9big4KSxkPW4oMTYxKSx2PW4oMTE2KSxtPW4oMjcyKSxfPW4oMjcxKSxnPW4oMTAxKSx5PW4oNCksYj1uKDE4KSx3PW4oMjgpLHg9bigzNiksRT1uKDQxKSxUPW4oMTUzKSxPPW4oMjApLFM9bigxMCksUD1uKDQzKSxNPU8uZixqPVMuZixBPVQuZixDPXIuU3ltYm9sLGs9ci5KU09OLFI9ayYmay5zdHJpbmdpZnksST1cInByb3RvdHlwZVwiLE49aChcIl9oaWRkZW5cIiksVT1oKFwidG9QcmltaXRpdmVcIiksRj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxMPWMoXCJzeW1ib2wtcmVnaXN0cnlcIiksRD1jKFwic3ltYm9sc1wiKSxCPWMoXCJvcC1zeW1ib2xzXCIpLFY9T2JqZWN0W0ldLFc9XCJmdW5jdGlvblwiPT10eXBlb2YgQyxYPXIuUU9iamVjdCx6PSFYfHwhWFtJXXx8IVhbSV0uZmluZENoaWxkLEc9aSYmbChmdW5jdGlvbigpe3JldHVybiA3IT1FKGooe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBqKHRoaXMsXCJhXCIse3ZhbHVlOjd9KS5hfX0pKS5hfSk/ZnVuY3Rpb24odCxlLG4pe3ZhciByPU0oVixlKTtyJiZkZWxldGUgVltlXSxqKHQsZSxuKSxyJiZ0IT09ViYmaihWLGUscil9OmoscT1mdW5jdGlvbih0KXt2YXIgZT1EW3RdPUUoQ1tJXSk7cmV0dXJuIGUuX2s9dCxlfSxIPVcmJlwic3ltYm9sXCI9PXR5cGVvZiBDLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEN9LFk9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0PT09ViYmWShCLGUsbikseSh0KSxlPXcoZSwhMCkseShuKSxvKEQsZSk/KG4uZW51bWVyYWJsZT8obyh0LE4pJiZ0W05dW2VdJiYodFtOXVtlXT0hMSksbj1FKG4se2VudW1lcmFibGU6eCgwLCExKX0pKToobyh0LE4pfHxqKHQsTix4KDEse30pKSx0W05dW2VdPSEwKSxHKHQsZSxuKSk6aih0LGUsbil9LEs9ZnVuY3Rpb24odCxlKXt5KHQpO2Zvcih2YXIgbixyPV8oZT1iKGUpKSxvPTAsaT1yLmxlbmd0aDtpPm87KVkodCxuPXJbbysrXSxlW25dKTtyZXR1cm4gdH0sJD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lP0UodCk6SyhFKHQpLGUpfSxaPWZ1bmN0aW9uKHQpe3ZhciBlPUYuY2FsbCh0aGlzLHQ9dyh0LCEwKSk7cmV0dXJuISh0aGlzPT09ViYmbyhELHQpJiYhbyhCLHQpKSYmKCEoZXx8IW8odGhpcyx0KXx8IW8oRCx0KXx8byh0aGlzLE4pJiZ0aGlzW05dW3RdKXx8ZSl9LFE9ZnVuY3Rpb24odCxlKXtpZih0PWIodCksZT13KGUsITApLHQhPT1WfHwhbyhELGUpfHxvKEIsZSkpe3ZhciBuPU0odCxlKTtyZXR1cm4hbnx8IW8oRCxlKXx8byh0LE4pJiZ0W05dW2VdfHwobi5lbnVtZXJhYmxlPSEwKSxufX0sSj1mdW5jdGlvbih0KXtmb3IodmFyIGUsbj1BKGIodCkpLHI9W10saT0wO24ubGVuZ3RoPmk7KW8oRCxlPW5baSsrXSl8fGU9PU58fGU9PXV8fHIucHVzaChlKTtyZXR1cm4gcn0sdHQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49dD09PVYscj1BKG4/QjpiKHQpKSxpPVtdLGE9MDtyLmxlbmd0aD5hOykhbyhELGU9clthKytdKXx8biYmIW8oVixlKXx8aS5wdXNoKERbZV0pO3JldHVybiBpfTtXfHwoQz1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBDKXRocm93IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciFcIik7dmFyIHQ9cChhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCksZT1mdW5jdGlvbihuKXt0aGlzPT09ViYmZS5jYWxsKEIsbiksbyh0aGlzLE4pJiZvKHRoaXNbTl0sdCkmJih0aGlzW05dW3RdPSExKSxHKHRoaXMsdCx4KDEsbikpfTtyZXR1cm4gaSYmeiYmRyhWLHQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6ZX0pLHEodCl9LHMoQ1tJXSxcInRvU3RyaW5nXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa30pLE8uZj1RLFMuZj1ZLG4oNDIpLmY9VC5mPUosbig2MCkuZj1aLG4oNzcpLmY9dHQsaSYmIW4oNDApJiZzKFYsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLFosITApLGQuZj1mdW5jdGlvbih0KXtyZXR1cm4gcShoKHQpKX0pLGEoYS5HK2EuVythLkYqIVcse1N5bWJvbDpDfSk7Zm9yKHZhciBldD1cImhhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzXCIuc3BsaXQoXCIsXCIpLG50PTA7ZXQubGVuZ3RoPm50OyloKGV0W250KytdKTtmb3IodmFyIGV0PVAoaC5zdG9yZSksbnQ9MDtldC5sZW5ndGg+bnQ7KXYoZXRbbnQrK10pO2EoYS5TK2EuRiohVyxcIlN5bWJvbFwiLHtmb3I6ZnVuY3Rpb24odCl7cmV0dXJuIG8oTCx0Kz1cIlwiKT9MW3RdOkxbdF09Qyh0KX0sa2V5Rm9yOmZ1bmN0aW9uKHQpe2lmKEgodCkpcmV0dXJuIG0oTCx0KTt0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgYSBzeW1ib2whXCIpfSx1c2VTZXR0ZXI6ZnVuY3Rpb24oKXt6PSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXt6PSExfX0pLGEoYS5TK2EuRiohVyxcIk9iamVjdFwiLHtjcmVhdGU6JCxkZWZpbmVQcm9wZXJ0eTpZLGRlZmluZVByb3BlcnRpZXM6SyxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6USxnZXRPd25Qcm9wZXJ0eU5hbWVzOkosZ2V0T3duUHJvcGVydHlTeW1ib2xzOnR0fSksayYmYShhLlMrYS5GKighV3x8bChmdW5jdGlvbigpe3ZhciB0PUMoKTtyZXR1cm5cIltudWxsXVwiIT1SKFt0XSl8fFwie31cIiE9Uih7YTp0fSl8fFwie31cIiE9UihPYmplY3QodCkpfSkpLFwiSlNPTlwiLHtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCYmIUgodCkpe2Zvcih2YXIgZSxuLHI9W3RdLG89MTthcmd1bWVudHMubGVuZ3RoPm87KXIucHVzaChhcmd1bWVudHNbbysrXSk7cmV0dXJuIGU9clsxXSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYobj1lKSwhbiYmZyhlKXx8KGU9ZnVuY3Rpb24odCxlKXtpZihuJiYoZT1uLmNhbGwodGhpcyx0LGUpKSwhSChlKSlyZXR1cm4gZX0pLHJbMV09ZSxSLmFwcGx5KGsscil9fX0pLENbSV1bVV18fG4oMTUpKENbSV0sVSxDW0ldLnZhbHVlT2YpLGYoQyxcIlN5bWJvbFwiKSxmKE1hdGgsXCJNYXRoXCIsITApLGYoci5KU09OLFwiSlNPTlwiLCEwKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksbz1uKDc5KSxpPW4oMTE1KSxhPW4oNCkscz1uKDQ2KSx1PW4oMTEpLGw9big3KSxjPW4oNSkuQXJyYXlCdWZmZXIsZj1uKDEwOSkscD1pLkFycmF5QnVmZmVyLGg9aS5EYXRhVmlldyxkPW8uQUJWJiZjLmlzVmlldyx2PXAucHJvdG90eXBlLnNsaWNlLG09by5WSUVXLF89XCJBcnJheUJ1ZmZlclwiO3Ioci5HK3IuVytyLkYqKGMhPT1wKSx7QXJyYXlCdWZmZXI6cH0pLHIoci5TK3IuRiohby5DT05TVFIsXyx7aXNWaWV3OmZ1bmN0aW9uKHQpe3JldHVybiBkJiZkKHQpfHxsKHQpJiZtIGluIHR9fSkscihyLlArci5VK3IuRipuKDYpKGZ1bmN0aW9uKCl7cmV0dXJuIW5ldyBwKDIpLnNsaWNlKDEsdm9pZCAwKS5ieXRlTGVuZ3RofSksXyx7c2xpY2U6ZnVuY3Rpb24odCxlKXtpZih2b2lkIDAhPT12JiZ2b2lkIDA9PT1lKXJldHVybiB2LmNhbGwoYSh0aGlzKSx0KTtmb3IodmFyIG49YSh0aGlzKS5ieXRlTGVuZ3RoLHI9cyh0LG4pLG89cyh2b2lkIDA9PT1lP246ZSxuKSxpPW5ldyhmKHRoaXMscCkpKHUoby1yKSksbD1uZXcgaCh0aGlzKSxjPW5ldyBoKGkpLGQ9MDtyPG87KWMuc2V0VWludDgoZCsrLGwuZ2V0VWludDgocisrKSk7cmV0dXJuIGl9fSksbig0NSkoXyl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5HK3IuVytyLkYqIW4oNzkpLkFCVix7RGF0YVZpZXc6bigxMTUpLkRhdGFWaWV3fSl9LGZ1bmN0aW9uKHQsZSxuKXtuKDM0KShcIkZsb2F0MzJcIiw0LGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIHQodGhpcyxlLG4scil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtuKDM0KShcIkZsb2F0NjRcIiw4LGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIHQodGhpcyxlLG4scil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtuKDM0KShcIkludDE2XCIsMixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0KHRoaXMsZSxuLHIpfX0pfSxmdW5jdGlvbih0LGUsbil7bigzNCkoXCJJbnQzMlwiLDQsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gdCh0aGlzLGUsbixyKX19KX0sZnVuY3Rpb24odCxlLG4pe24oMzQpKFwiSW50OFwiLDEsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gdCh0aGlzLGUsbixyKX19KX0sZnVuY3Rpb24odCxlLG4pe24oMzQpKFwiVWludDE2XCIsMixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0KHRoaXMsZSxuLHIpfX0pfSxmdW5jdGlvbih0LGUsbil7bigzNCkoXCJVaW50MzJcIiw0LGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIHQodGhpcyxlLG4scil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtuKDM0KShcIlVpbnQ4XCIsMSxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0KHRoaXMsZSxuLHIpfX0pfSxmdW5jdGlvbih0LGUsbil7bigzNCkoXCJVaW50OFwiLDEsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gdCh0aGlzLGUsbixyKX19LCEwKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMTQ1KTtuKDcwKShcIldlYWtTZXRcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKX19LHthZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHIuZGVmKHRoaXMsdCwhMCl9fSxyLCExLCEwKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksbz1uKDY5KSghMCk7cihyLlAsXCJBcnJheVwiLHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG4oNTApKFwiaW5jbHVkZXNcIil9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxMDYpKCksaT1uKDUpLnByb2Nlc3MsYT1cInByb2Nlc3NcIj09bigyMikoaSk7cihyLkcse2FzYXA6ZnVuY3Rpb24odCl7dmFyIGU9YSYmaS5kb21haW47byhlP2UuYmluZCh0KTp0KX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDIyKTtyKHIuUyxcIkVycm9yXCIse2lzRXJyb3I6ZnVuY3Rpb24odCl7cmV0dXJuXCJFcnJvclwiPT09byh0KX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlArci5SLFwiTWFwXCIse3RvSlNPTjpuKDE0NCkoXCJNYXBcIil9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlMsXCJNYXRoXCIse2lhZGRoOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXQ+Pj4wLGk9ZT4+PjAsYT1uPj4+MDtyZXR1cm4gaSsocj4+PjApKygobyZhfChvfGEpJn4obythPj4+MCkpPj4+MzEpfDB9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5TLFwiTWF0aFwiLHtpbXVsaDpmdW5jdGlvbih0LGUpe3ZhciBuPTY1NTM1LHI9K3Qsbz0rZSxpPXImbixhPW8mbixzPXI+PjE2LHU9bz4+MTYsbD0ocyphPj4+MCkrKGkqYT4+PjE2KTtyZXR1cm4gcyp1KyhsPj4xNikrKChpKnU+Pj4wKSsobCZuKT4+MTYpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIk1hdGhcIix7aXN1Ymg6ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dD4+PjAsaT1lPj4+MCxhPW4+Pj4wO3JldHVybiBpLShyPj4+MCktKCh+byZhfH4ob15hKSZvLWE+Pj4wKT4+PjMxKXwwfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigwKTtyKHIuUyxcIk1hdGhcIix7dW11bGg6ZnVuY3Rpb24odCxlKXt2YXIgbj02NTUzNSxyPSt0LG89K2UsaT1yJm4sYT1vJm4scz1yPj4+MTYsdT1vPj4+MTYsbD0ocyphPj4+MCkrKGkqYT4+PjE2KTtyZXR1cm4gcyp1KyhsPj4+MTYpKygoaSp1Pj4+MCkrKGwmbik+Pj4xNil9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMiksaT1uKDE0KSxhPW4oMTApO24oOSkmJnIoci5QK24oNzYpLFwiT2JqZWN0XCIse19fZGVmaW5lR2V0dGVyX186ZnVuY3Rpb24odCxlKXthLmYobyh0aGlzKSx0LHtnZXQ6aShlKSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMTIpLGk9bigxNCksYT1uKDEwKTtuKDkpJiZyKHIuUCtuKDc2KSxcIk9iamVjdFwiLHtfX2RlZmluZVNldHRlcl9fOmZ1bmN0aW9uKHQsZSl7YS5mKG8odGhpcyksdCx7c2V0OmkoZSksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KX19KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCksbz1uKDE1NSkoITApO3Ioci5TLFwiT2JqZWN0XCIse2VudHJpZXM6ZnVuY3Rpb24odCl7cmV0dXJuIG8odCl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxNTYpLGk9bigxOCksYT1uKDIwKSxzPW4oOTQpO3Ioci5TLFwiT2JqZWN0XCIse2dldE93blByb3BlcnR5RGVzY3JpcHRvcnM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49aSh0KSxyPWEuZix1PW8obiksbD17fSxjPTA7dS5sZW5ndGg+YzspcyhsLGU9dVtjKytdLHIobixlKSk7cmV0dXJuIGx9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMiksaT1uKDI4KSxhPW4oMjEpLHM9bigyMCkuZjtuKDkpJiZyKHIuUCtuKDc2KSxcIk9iamVjdFwiLHtfX2xvb2t1cEdldHRlcl9fOmZ1bmN0aW9uKHQpe3ZhciBlLG49byh0aGlzKSxyPWkodCwhMCk7ZG8gaWYoZT1zKG4scikpcmV0dXJuIGUuZ2V0O3doaWxlKG49YShuKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMiksaT1uKDI4KSxhPW4oMjEpLHM9bigyMCkuZjtuKDkpJiZyKHIuUCtuKDc2KSxcIk9iamVjdFwiLHtfX2xvb2t1cFNldHRlcl9fOmZ1bmN0aW9uKHQpe3ZhciBlLG49byh0aGlzKSxyPWkodCwhMCk7ZG8gaWYoZT1zKG4scikpcmV0dXJuIGUuc2V0O3doaWxlKG49YShuKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxNTUpKCExKTtyKHIuUyxcIk9iamVjdFwiLHt2YWx1ZXM6ZnVuY3Rpb24odCl7cmV0dXJuIG8odCl9fSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89big1KSxpPW4oMzEpLGE9bigxMDYpKCkscz1uKDgpKFwib2JzZXJ2YWJsZVwiKSx1PW4oMTQpLGw9big0KSxjPW4oMzkpLGY9big0NCkscD1uKDE1KSxoPW4oNTEpLGQ9aC5SRVRVUk4sdj1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dD92b2lkIDA6dSh0KX0sbT1mdW5jdGlvbih0KXt2YXIgZT10Ll9jO2UmJih0Ll9jPXZvaWQgMCxlKCkpfSxfPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10Ll9vfSxnPWZ1bmN0aW9uKHQpe18odCl8fCh0Ll9vPXZvaWQgMCxtKHQpKX0seT1mdW5jdGlvbih0LGUpe2wodCksdGhpcy5fYz12b2lkIDAsdGhpcy5fbz10LHQ9bmV3IGIodGhpcyk7dHJ5e3ZhciBuPWUodCkscj1uO251bGwhPW4mJihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnVuc3Vic2NyaWJlP249ZnVuY3Rpb24oKXtyLnVuc3Vic2NyaWJlKCl9OnUobiksdGhpcy5fYz1uKX1jYXRjaChlKXtyZXR1cm4gdm9pZCB0LmVycm9yKGUpfV8odGhpcykmJm0odGhpcyl9O3kucHJvdG90eXBlPWYoe30se3Vuc3Vic2NyaWJlOmZ1bmN0aW9uKCl7Zyh0aGlzKX19KTt2YXIgYj1mdW5jdGlvbih0KXt0aGlzLl9zPXR9O2IucHJvdG90eXBlPWYoe30se25leHQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fcztpZighXyhlKSl7dmFyIG49ZS5fbzt0cnl7dmFyIHI9dihuLm5leHQpO2lmKHIpcmV0dXJuIHIuY2FsbChuLHQpfWNhdGNoKHQpe3RyeXtnKGUpfWZpbmFsbHl7dGhyb3cgdH19fX0sZXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fcztpZihfKGUpKXRocm93IHQ7dmFyIG49ZS5fbztlLl9vPXZvaWQgMDt0cnl7dmFyIHI9dihuLmVycm9yKTtpZighcil0aHJvdyB0O3Q9ci5jYWxsKG4sdCl9Y2F0Y2godCl7dHJ5e20oZSl9ZmluYWxseXt0aHJvdyB0fX1yZXR1cm4gbShlKSx0fSxjb21wbGV0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9zO2lmKCFfKGUpKXt2YXIgbj1lLl9vO2UuX289dm9pZCAwO3RyeXt2YXIgcj12KG4uY29tcGxldGUpO3Q9cj9yLmNhbGwobix0KTp2b2lkIDB9Y2F0Y2godCl7dHJ5e20oZSl9ZmluYWxseXt0aHJvdyB0fX1yZXR1cm4gbShlKSx0fX19KTt2YXIgdz1mdW5jdGlvbih0KXtjKHRoaXMsdyxcIk9ic2VydmFibGVcIixcIl9mXCIpLl9mPXUodCl9O2Yody5wcm90b3R5cGUse3N1YnNjcmliZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHkodCx0aGlzLl9mKX0sZm9yRWFjaDpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBuZXcoaS5Qcm9taXNlfHxvLlByb21pc2UpKGZ1bmN0aW9uKG4scil7dSh0KTt2YXIgbz1lLnN1YnNjcmliZSh7bmV4dDpmdW5jdGlvbihlKXt0cnl7cmV0dXJuIHQoZSl9Y2F0Y2godCl7cih0KSxvLnVuc3Vic2NyaWJlKCl9fSxlcnJvcjpyLGNvbXBsZXRlOm59KX0pfX0pLGYodyx7ZnJvbTpmdW5jdGlvbih0KXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzP3RoaXM6dyxuPXYobCh0KVtzXSk7aWYobil7dmFyIHI9bChuLmNhbGwodCkpO3JldHVybiByLmNvbnN0cnVjdG9yPT09ZT9yOm5ldyBlKGZ1bmN0aW9uKHQpe3JldHVybiByLnN1YnNjcmliZSh0KX0pfXJldHVybiBuZXcgZShmdW5jdGlvbihlKXt2YXIgbj0hMTtyZXR1cm4gYShmdW5jdGlvbigpe2lmKCFuKXt0cnl7aWYoaCh0LCExLGZ1bmN0aW9uKHQpe2lmKGUubmV4dCh0KSxuKXJldHVybiBkfSk9PT1kKXJldHVybn1jYXRjaCh0KXtpZihuKXRocm93IHQ7cmV0dXJuIHZvaWQgZS5lcnJvcih0KX1lLmNvbXBsZXRlKCl9fSksZnVuY3Rpb24oKXtuPSEwfX0pfSxvZjpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9YXJndW1lbnRzLmxlbmd0aCxuPUFycmF5KGUpO3Q8ZTspblt0XT1hcmd1bWVudHNbdCsrXTtyZXR1cm4gbmV3KFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXM/dGhpczp3KShmdW5jdGlvbih0KXt2YXIgZT0hMTtyZXR1cm4gYShmdW5jdGlvbigpe2lmKCFlKXtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoOysrcilpZih0Lm5leHQobltyXSksZSlyZXR1cm47dC5jb21wbGV0ZSgpfX0pLGZ1bmN0aW9uKCl7ZT0hMH19KX19KSxwKHcucHJvdG90eXBlLHMsZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHIoci5HLHtPYnNlcnZhYmxlOnd9KSxuKDQ1KShcIk9ic2VydmFibGVcIil9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDMzKSxvPW4oNCksaT1yLmtleSxhPXIuc2V0O3IuZXhwKHtkZWZpbmVNZXRhZGF0YTpmdW5jdGlvbih0LGUsbixyKXthKHQsZSxvKG4pLGkocikpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigzMyksbz1uKDQpLGk9ci5rZXksYT1yLm1hcCxzPXIuc3RvcmU7ci5leHAoe2RlbGV0ZU1ldGFkYXRhOmZ1bmN0aW9uKHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aDwzP3ZvaWQgMDppKGFyZ3VtZW50c1syXSkscj1hKG8oZSksbiwhMSk7aWYodm9pZCAwPT09cnx8IXIuZGVsZXRlKHQpKXJldHVybiExO2lmKHIuc2l6ZSlyZXR1cm4hMDt2YXIgdT1zLmdldChlKTtyZXR1cm4gdS5kZWxldGUobiksISF1LnNpemV8fHMuZGVsZXRlKGUpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNjQpLG89bigxNDApLGk9bigzMyksYT1uKDQpLHM9bigyMSksdT1pLmtleXMsbD1pLmtleSxjPWZ1bmN0aW9uKHQsZSl7dmFyIG49dSh0LGUpLGk9cyh0KTtpZihudWxsPT09aSlyZXR1cm4gbjt2YXIgYT1jKGksZSk7cmV0dXJuIGEubGVuZ3RoP24ubGVuZ3RoP28obmV3IHIobi5jb25jYXQoYSkpKTphOm59O2kuZXhwKHtnZXRNZXRhZGF0YUtleXM6ZnVuY3Rpb24odCl7cmV0dXJuIGMoYSh0KSxhcmd1bWVudHMubGVuZ3RoPDI/dm9pZCAwOmwoYXJndW1lbnRzWzFdKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDMzKSxvPW4oNCksaT1uKDIxKSxhPXIuaGFzLHM9ci5nZXQsdT1yLmtleSxsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1hKHQsZSxuKTtpZihyKXJldHVybiBzKHQsZSxuKTt2YXIgbz1pKGUpO3JldHVybiBudWxsIT09bz9sKHQsbyxuKTp2b2lkIDB9O3IuZXhwKHtnZXRNZXRhZGF0YTpmdW5jdGlvbih0LGUpe3JldHVybiBsKHQsbyhlKSxhcmd1bWVudHMubGVuZ3RoPDM/dm9pZCAwOnUoYXJndW1lbnRzWzJdKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDMzKSxvPW4oNCksaT1yLmtleXMsYT1yLmtleTtyLmV4cCh7Z2V0T3duTWV0YWRhdGFLZXlzOmZ1bmN0aW9uKHQpe3JldHVybiBpKG8odCksYXJndW1lbnRzLmxlbmd0aDwyP3ZvaWQgMDphKGFyZ3VtZW50c1sxXSkpfX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigzMyksbz1uKDQpLGk9ci5nZXQsYT1yLmtleTtcbnIuZXhwKHtnZXRPd25NZXRhZGF0YTpmdW5jdGlvbih0LGUpe3JldHVybiBpKHQsbyhlKSxhcmd1bWVudHMubGVuZ3RoPDM/dm9pZCAwOmEoYXJndW1lbnRzWzJdKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDMzKSxvPW4oNCksaT1uKDIxKSxhPXIuaGFzLHM9ci5rZXksdT1mdW5jdGlvbih0LGUsbil7dmFyIHI9YSh0LGUsbik7aWYocilyZXR1cm4hMDt2YXIgbz1pKGUpO3JldHVybiBudWxsIT09byYmdSh0LG8sbil9O3IuZXhwKHtoYXNNZXRhZGF0YTpmdW5jdGlvbih0LGUpe3JldHVybiB1KHQsbyhlKSxhcmd1bWVudHMubGVuZ3RoPDM/dm9pZCAwOnMoYXJndW1lbnRzWzJdKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDMzKSxvPW4oNCksaT1yLmhhcyxhPXIua2V5O3IuZXhwKHtoYXNPd25NZXRhZGF0YTpmdW5jdGlvbih0LGUpe3JldHVybiBpKHQsbyhlKSxhcmd1bWVudHMubGVuZ3RoPDM/dm9pZCAwOmEoYXJndW1lbnRzWzJdKSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDMzKSxvPW4oNCksaT1uKDE0KSxhPXIua2V5LHM9ci5zZXQ7ci5leHAoe21ldGFkYXRhOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7cyh0LGUsKHZvaWQgMCE9PXI/bzppKShuKSxhKHIpKX19fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApO3Ioci5QK3IuUixcIlNldFwiLHt0b0pTT046bigxNDQpKFwiU2V0XCIpfSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLG89bigxMTApKCEwKTtyKHIuUCxcIlN0cmluZ1wiLHthdDpmdW5jdGlvbih0KXtyZXR1cm4gbyh0aGlzLHQpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMjMpLGk9bigxMSksYT1uKDc0KSxzPW4oNzIpLHU9UmVnRXhwLnByb3RvdHlwZSxsPWZ1bmN0aW9uKHQsZSl7dGhpcy5fcj10LHRoaXMuX3M9ZX07bigxMDIpKGwsXCJSZWdFeHAgU3RyaW5nXCIsZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9yLmV4ZWModGhpcy5fcyk7cmV0dXJue3ZhbHVlOnQsZG9uZTpudWxsPT09dH19KSxyKHIuUCxcIlN0cmluZ1wiLHttYXRjaEFsbDpmdW5jdGlvbih0KXtpZihvKHRoaXMpLCFhKHQpKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIHJlZ2V4cCFcIik7dmFyIGU9U3RyaW5nKHRoaXMpLG49XCJmbGFnc1wiaW4gdT9TdHJpbmcodC5mbGFncyk6cy5jYWxsKHQpLHI9bmV3IFJlZ0V4cCh0LnNvdXJjZSx+bi5pbmRleE9mKFwiZ1wiKT9uOlwiZ1wiK24pO3JldHVybiByLmxhc3RJbmRleD1pKHQubGFzdEluZGV4KSxuZXcgbChyLGUpfX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxvPW4oMTYwKTtyKHIuUCxcIlN0cmluZ1wiLHtwYWRFbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIG8odGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLCExKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksbz1uKDE2MCk7cihyLlAsXCJTdHJpbmdcIix7cGFkU3RhcnQ6ZnVuY3Rpb24odCl7cmV0dXJuIG8odGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLCEwKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24oNTQpKFwidHJpbUxlZnRcIixmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzLDEpfX0sXCJ0cmltU3RhcnRcIil9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuKDU0KShcInRyaW1SaWdodFwiLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0KHRoaXMsMil9fSxcInRyaW1FbmRcIil9LGZ1bmN0aW9uKHQsZSxuKXtuKDExNikoXCJhc3luY0l0ZXJhdG9yXCIpfSxmdW5jdGlvbih0LGUsbil7bigxMTYpKFwib2JzZXJ2YWJsZVwiKX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMCk7cihyLlMsXCJTeXN0ZW1cIix7Z2xvYmFsOm4oNSl9KX0sZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uKDExOCksbz1uKDE2KSxpPW4oNSksYT1uKDE1KSxzPW4oNTIpLHU9big4KSxsPXUoXCJpdGVyYXRvclwiKSxjPXUoXCJ0b1N0cmluZ1RhZ1wiKSxmPXMuQXJyYXkscD1bXCJOb2RlTGlzdFwiLFwiRE9NVG9rZW5MaXN0XCIsXCJNZWRpYUxpc3RcIixcIlN0eWxlU2hlZXRMaXN0XCIsXCJDU1NSdWxlTGlzdFwiXSxoPTA7aDw1O2grKyl7dmFyIGQsdj1wW2hdLG09aVt2XSxfPW0mJm0ucHJvdG90eXBlO2lmKF8pe19bbF18fGEoXyxsLGYpLF9bY118fGEoXyxjLHYpLHNbdl09Zjtmb3IoZCBpbiByKV9bZF18fG8oXyxkLHJbZF0sITApfX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDApLG89bigxMTQpO3Ioci5HK3IuQix7c2V0SW1tZWRpYXRlOm8uc2V0LGNsZWFySW1tZWRpYXRlOm8uY2xlYXJ9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNSksbz1uKDApLGk9big3MyksYT1uKDI3Mykscz1yLm5hdmlnYXRvcix1PSEhcyYmL01TSUUgLlxcLi8udGVzdChzLnVzZXJBZ2VudCksbD1mdW5jdGlvbih0KXtyZXR1cm4gdT9mdW5jdGlvbihlLG4pe3JldHVybiB0KGkoYSxbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6RnVuY3Rpb24oZSkpLG4pfTp0fTtvKG8uRytvLkIrby5GKnUse3NldFRpbWVvdXQ6bChyLnNldFRpbWVvdXQpLHNldEludGVydmFsOmwoci5zZXRJbnRlcnZhbCl9KX0sZnVuY3Rpb24odCxlLG4pe24oMzk2KSxuKDMzNSksbigzMzcpLG4oMzM2KSxuKDMzOSksbigzNDEpLG4oMzQ2KSxuKDM0MCksbigzMzgpLG4oMzQ4KSxuKDM0NyksbigzNDMpLG4oMzQ0KSxuKDM0MiksbigzMzQpLG4oMzQ1KSxuKDM0OSksbigzNTApLG4oMzAyKSxuKDMwNCksbigzMDMpLG4oMzUyKSxuKDM1MSksbigzMjIpLG4oMzMyKSxuKDMzMyksbigzMjMpLG4oMzI0KSxuKDMyNSksbigzMjYpLG4oMzI3KSxuKDMyOCksbigzMjkpLG4oMzMwKSxuKDMzMSksbigzMDUpLG4oMzA2KSxuKDMwNyksbigzMDgpLG4oMzA5KSxuKDMxMCksbigzMTEpLG4oMzEyKSxuKDMxMyksbigzMTQpLG4oMzE1KSxuKDMxNiksbigzMTcpLG4oMzE4KSxuKDMxOSksbigzMjApLG4oMzIxKSxuKDM4MyksbigzODgpLG4oMzk1KSxuKDM4NiksbigzNzgpLG4oMzc5KSxuKDM4NCksbigzODkpLG4oMzkxKSxuKDM3NCksbigzNzUpLG4oMzc2KSxuKDM3NyksbigzODApLG4oMzgxKSxuKDM4MiksbigzODUpLG4oMzg3KSxuKDM5MCksbigzOTIpLG4oMzkzKSxuKDM5NCksbigyOTcpLG4oMjk5KSxuKDI5OCksbigzMDEpLG4oMzAwKSxuKDI4NiksbigyODQpLG4oMjkwKSxuKDI4NyksbigyOTMpLG4oMjk1KSxuKDI4MyksbigyODkpLG4oMjgwKSxuKDI5NCksbigyNzgpLG4oMjkyKSxuKDI5MSksbigyODUpLG4oMjg4KSxuKDI3NyksbigyNzkpLG4oMjgyKSxuKDI4MSksbigyOTYpLG4oMTE4KSxuKDM2OCksbigzNzMpLG4oMTYzKSxuKDM2OSksbigzNzApLG4oMzcxKSxuKDM3MiksbigzNTMpLG4oMTYyKSxuKDE2NCksbigxNjUpLG4oNDA4KSxuKDM5NyksbigzOTgpLG4oNDAzKSxuKDQwNiksbig0MDcpLG4oNDAxKSxuKDQwNCksbig0MDIpLG4oNDA1KSxuKDM5OSksbig0MDApLG4oMzU0KSxuKDM1NSksbigzNTYpLG4oMzU3KSxuKDM1OCksbigzNjEpLG4oMzU5KSxuKDM2MCksbigzNjIpLG4oMzYzKSxuKDM2NCksbigzNjUpLG4oMzY3KSxuKDM2Niksbig0MDkpLG4oNDM1KSxuKDQzOCksbig0MzcpLG4oNDM5KSxuKDQ0MCksbig0MzYpLG4oNDQxKSxuKDQ0Miksbig0MjApLG4oNDIzKSxuKDQxOSksbig0MTcpLG4oNDE4KSxuKDQyMSksbig0MjIpLG4oNDEyKSxuKDQzNCksbig0NDMpLG4oNDExKSxuKDQxMyksbig0MTUpLG4oNDE0KSxuKDQxNiksbig0MjUpLG4oNDI2KSxuKDQyOCksbig0MjcpLG4oNDMwKSxuKDQyOSksbig0MzEpLG4oNDMyKSxuKDQzMyksbig0MTApLG4oNDI0KSxuKDQ0Niksbig0NDUpLG4oNDQ0KSx0LmV4cG9ydHM9bigzMSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSxuKXt2YXIgcixvLGk9dC5sZW5ndGgsYT1lLmFycmF5QXJncy5sZW5ndGgscz1lLmluZGV4QXJncy5sZW5ndGg+MCx1PVtdLGw9W10sYz0wLGY9MDtmb3Iocj0wO3I8aTsrK3IpbC5wdXNoKFtcImlcIixyLFwiPTBcIl0uam9pbihcIlwiKSk7Zm9yKG89MDtvPGE7KytvKWZvcihyPTA7cjxpOysrcilmPWMsYz10W3JdLDA9PT1yP2wucHVzaChbXCJkXCIsbyxcInNcIixyLFwiPXRcIixvLFwicFwiLGNdLmpvaW4oXCJcIikpOmwucHVzaChbXCJkXCIsbyxcInNcIixyLFwiPSh0XCIsbyxcInBcIixjLFwiLXNcIixmLFwiKnRcIixvLFwicFwiLGYsXCIpXCJdLmpvaW4oXCJcIikpO2Zvcih1LnB1c2goXCJ2YXIgXCIrbC5qb2luKFwiLFwiKSkscj1pLTE7cj49MDstLXIpYz10W3JdLHUucHVzaChbXCJmb3IoaVwiLHIsXCI9MDtpXCIscixcIjxzXCIsYyxcIjsrK2lcIixyLFwiKXtcIl0uam9pbihcIlwiKSk7Zm9yKHUucHVzaChuKSxyPTA7cjxpOysrcil7Zm9yKGY9YyxjPXRbcl0sbz0wO288YTsrK28pdS5wdXNoKFtcInBcIixvLFwiKz1kXCIsbyxcInNcIixyXS5qb2luKFwiXCIpKTtzJiYocj4wJiZ1LnB1c2goW1wiaW5kZXhbXCIsZixcIl0tPXNcIixmXS5qb2luKFwiXCIpKSx1LnB1c2goW1wiKytpbmRleFtcIixjLFwiXVwiXS5qb2luKFwiXCIpKSksdS5wdXNoKFwifVwiKX1yZXR1cm4gdS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIG8odCxlLG4sbyl7Zm9yKHZhciBpPWUubGVuZ3RoLGE9bi5hcnJheUFyZ3MubGVuZ3RoLHM9bi5ibG9ja1NpemUsdT1uLmluZGV4QXJncy5sZW5ndGg+MCxsPVtdLGM9MDtjPGE7KytjKWwucHVzaChbXCJ2YXIgb2Zmc2V0XCIsYyxcIj1wXCIsY10uam9pbihcIlwiKSk7Zm9yKHZhciBjPXQ7YzxpOysrYylsLnB1c2goW1wiZm9yKHZhciBqXCIrYytcIj1TU1tcIixlW2NdLFwiXXwwO2pcIixjLFwiPjA7KXtcIl0uam9pbihcIlwiKSksbC5wdXNoKFtcImlmKGpcIixjLFwiPFwiLHMsXCIpe1wiXS5qb2luKFwiXCIpKSxsLnB1c2goW1wic1wiLGVbY10sXCI9alwiLGNdLmpvaW4oXCJcIikpLGwucHVzaChbXCJqXCIsYyxcIj0wXCJdLmpvaW4oXCJcIikpLGwucHVzaChbXCJ9ZWxzZXtzXCIsZVtjXSxcIj1cIixzXS5qb2luKFwiXCIpKSxsLnB1c2goW1wialwiLGMsXCItPVwiLHMsXCJ9XCJdLmpvaW4oXCJcIikpLHUmJmwucHVzaChbXCJpbmRleFtcIixlW2NdLFwiXT1qXCIsY10uam9pbihcIlwiKSk7Zm9yKHZhciBjPTA7YzxhOysrYyl7Zm9yKHZhciBmPVtcIm9mZnNldFwiK2NdLHA9dDtwPGk7KytwKWYucHVzaChbXCJqXCIscCxcIip0XCIsYyxcInBcIixlW3BdXS5qb2luKFwiXCIpKTtsLnB1c2goW1wicFwiLGMsXCI9KFwiLGYuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpfWwucHVzaChyKGUsbixvKSk7Zm9yKHZhciBjPXQ7YzxpOysrYylsLnB1c2goXCJ9XCIpO3JldHVybiBsLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gaSh0KXtmb3IodmFyIGU9MCxuPXRbMF0ubGVuZ3RoO2U8bjspe2Zvcih2YXIgcj0xO3I8dC5sZW5ndGg7KytyKWlmKHRbcl1bZV0hPT10WzBdW2VdKXJldHVybiBlOysrZX1yZXR1cm4gZX1mdW5jdGlvbiBhKHQsZSxuKXtmb3IodmFyIHI9dC5ib2R5LG89W10saT1bXSxhPTA7YTx0LmFyZ3MubGVuZ3RoOysrYSl7dmFyIHM9dC5hcmdzW2FdO2lmKCEocy5jb3VudDw9MCkpe3ZhciB1PW5ldyBSZWdFeHAocy5uYW1lLFwiZ1wiKSxsPVwiXCIsYz1lLmFycmF5QXJncy5pbmRleE9mKGEpO3N3aXRjaChlLmFyZ1R5cGVzW2FdKXtjYXNlXCJvZmZzZXRcIjp2YXIgZj1lLm9mZnNldEFyZ0luZGV4LmluZGV4T2YoYSkscD1lLm9mZnNldEFyZ3NbZl07Yz1wLmFycmF5LGw9XCIrcVwiK2Y7Y2FzZVwiYXJyYXlcIjpsPVwicFwiK2MrbDt2YXIgaD1cImxcIithLGQ9XCJhXCIrYztpZigwPT09ZS5hcnJheUJsb2NrSW5kaWNlc1tjXSkxPT09cy5jb3VudD9cImdlbmVyaWNcIj09PW5bY10/cy5sdmFsdWU/KG8ucHVzaChbXCJ2YXIgXCIsaCxcIj1cIixkLFwiLmdldChcIixsLFwiKVwiXS5qb2luKFwiXCIpKSxyPXIucmVwbGFjZSh1LGgpLGkucHVzaChbZCxcIi5zZXQoXCIsbCxcIixcIixoLFwiKVwiXS5qb2luKFwiXCIpKSk6cj1yLnJlcGxhY2UodSxbZCxcIi5nZXQoXCIsbCxcIilcIl0uam9pbihcIlwiKSk6cj1yLnJlcGxhY2UodSxbZCxcIltcIixsLFwiXVwiXS5qb2luKFwiXCIpKTpcImdlbmVyaWNcIj09PW5bY10/KG8ucHVzaChbXCJ2YXIgXCIsaCxcIj1cIixkLFwiLmdldChcIixsLFwiKVwiXS5qb2luKFwiXCIpKSxyPXIucmVwbGFjZSh1LGgpLHMubHZhbHVlJiZpLnB1c2goW2QsXCIuc2V0KFwiLGwsXCIsXCIsaCxcIilcIl0uam9pbihcIlwiKSkpOihvLnB1c2goW1widmFyIFwiLGgsXCI9XCIsZCxcIltcIixsLFwiXVwiXS5qb2luKFwiXCIpKSxyPXIucmVwbGFjZSh1LGgpLHMubHZhbHVlJiZpLnB1c2goW2QsXCJbXCIsbCxcIl09XCIsaF0uam9pbihcIlwiKSkpO2Vsc2V7Zm9yKHZhciB2PVtzLm5hbWVdLG09W2xdLF89MDtfPE1hdGguYWJzKGUuYXJyYXlCbG9ja0luZGljZXNbY10pO18rKyl2LnB1c2goXCJcXFxccypcXFxcWyhbXlxcXFxdXSspXFxcXF1cIiksbS5wdXNoKFwiJFwiKyhfKzEpK1wiKnRcIitjK1wiYlwiK18pO2lmKHU9bmV3IFJlZ0V4cCh2LmpvaW4oXCJcIiksXCJnXCIpLGw9bS5qb2luKFwiK1wiKSxcImdlbmVyaWNcIj09PW5bY10pdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IEdlbmVyaWMgYXJyYXlzIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBibG9ja3MhXCIpO3I9ci5yZXBsYWNlKHUsW2QsXCJbXCIsbCxcIl1cIl0uam9pbihcIlwiKSl9YnJlYWs7Y2FzZVwic2NhbGFyXCI6cj1yLnJlcGxhY2UodSxcIllcIitlLnNjYWxhckFyZ3MuaW5kZXhPZihhKSk7YnJlYWs7Y2FzZVwiaW5kZXhcIjpyPXIucmVwbGFjZSh1LFwiaW5kZXhcIik7YnJlYWs7Y2FzZVwic2hhcGVcIjpyPXIucmVwbGFjZSh1LFwic2hhcGVcIil9fX1yZXR1cm5bby5qb2luKFwiXFxuXCIpLHIsaS5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKX1mdW5jdGlvbiBzKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5sZW5ndGgpLG49ITAscj0wO3I8dC5sZW5ndGg7KytyKXt2YXIgbz10W3JdLGk9by5tYXRjaCgvXFxkKy8pO2k9aT9pWzBdOlwiXCIsMD09PW8uY2hhckF0KDApP2Vbcl09XCJ1XCIrby5jaGFyQXQoMSkraTplW3JdPW8uY2hhckF0KDApK2kscj4wJiYobj1uJiZlW3JdPT09ZVtyLTFdKX1yZXR1cm4gbj9lWzBdOmUuam9pbihcIlwiKX1mdW5jdGlvbiB1KHQsZSl7Zm9yKHZhciBuPWVbMV0ubGVuZ3RoLU1hdGguYWJzKHQuYXJyYXlCbG9ja0luZGljZXNbMF0pfDAsdT1uZXcgQXJyYXkodC5hcnJheUFyZ3MubGVuZ3RoKSxjPW5ldyBBcnJheSh0LmFycmF5QXJncy5sZW5ndGgpLGY9MDtmPHQuYXJyYXlBcmdzLmxlbmd0aDsrK2YpY1tmXT1lWzIqZl0sdVtmXT1lWzIqZisxXTtmb3IodmFyIHA9W10saD1bXSxkPVtdLHY9W10sbT1bXSxmPTA7Zjx0LmFycmF5QXJncy5sZW5ndGg7KytmKXt0LmFycmF5QmxvY2tJbmRpY2VzW2ZdPDA/KGQucHVzaCgwKSx2LnB1c2gobikscC5wdXNoKG4pLGgucHVzaChuK3QuYXJyYXlCbG9ja0luZGljZXNbZl0pKTooZC5wdXNoKHQuYXJyYXlCbG9ja0luZGljZXNbZl0pLHYucHVzaCh0LmFycmF5QmxvY2tJbmRpY2VzW2ZdK24pLHAucHVzaCgwKSxoLnB1c2godC5hcnJheUJsb2NrSW5kaWNlc1tmXSkpO2Zvcih2YXIgXz1bXSxnPTA7Zzx1W2ZdLmxlbmd0aDtnKyspZFtmXTw9dVtmXVtnXSYmdVtmXVtnXTx2W2ZdJiZfLnB1c2godVtmXVtnXS1kW2ZdKTttLnB1c2goXyl9Zm9yKHZhciB5PVtcIlNTXCJdLGI9W1wiJ3VzZSBzdHJpY3QnXCJdLHc9W10sZz0wO2c8bjsrK2cpdy5wdXNoKFtcInNcIixnLFwiPVNTW1wiLGcsXCJdXCJdLmpvaW4oXCJcIikpO2Zvcih2YXIgZj0wO2Y8dC5hcnJheUFyZ3MubGVuZ3RoOysrZil7eS5wdXNoKFwiYVwiK2YpLHkucHVzaChcInRcIitmKSx5LnB1c2goXCJwXCIrZik7Zm9yKHZhciBnPTA7ZzxuOysrZyl3LnB1c2goW1widFwiLGYsXCJwXCIsZyxcIj10XCIsZixcIltcIixkW2ZdK2csXCJdXCJdLmpvaW4oXCJcIikpO2Zvcih2YXIgZz0wO2c8TWF0aC5hYnModC5hcnJheUJsb2NrSW5kaWNlc1tmXSk7KytnKXcucHVzaChbXCJ0XCIsZixcImJcIixnLFwiPXRcIixmLFwiW1wiLHBbZl0rZyxcIl1cIl0uam9pbihcIlwiKSl9Zm9yKHZhciBmPTA7Zjx0LnNjYWxhckFyZ3MubGVuZ3RoOysrZil5LnB1c2goXCJZXCIrZik7aWYodC5zaGFwZUFyZ3MubGVuZ3RoPjAmJncucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpLHQuaW5kZXhBcmdzLmxlbmd0aD4wKXtmb3IodmFyIHg9bmV3IEFycmF5KG4pLGY9MDtmPG47KytmKXhbZl09XCIwXCI7dy5wdXNoKFtcImluZGV4PVtcIix4LmpvaW4oXCIsXCIpLFwiXVwiXS5qb2luKFwiXCIpKX1mb3IodmFyIGY9MDtmPHQub2Zmc2V0QXJncy5sZW5ndGg7KytmKXtmb3IodmFyIEU9dC5vZmZzZXRBcmdzW2ZdLFQ9W10sZz0wO2c8RS5vZmZzZXQubGVuZ3RoOysrZykwIT09RS5vZmZzZXRbZ10mJigxPT09RS5vZmZzZXRbZ10/VC5wdXNoKFtcInRcIixFLmFycmF5LFwicFwiLGddLmpvaW4oXCJcIikpOlQucHVzaChbRS5vZmZzZXRbZ10sXCIqdFwiLEUuYXJyYXksXCJwXCIsZ10uam9pbihcIlwiKSkpOzA9PT1ULmxlbmd0aD93LnB1c2goXCJxXCIrZitcIj0wXCIpOncucHVzaChbXCJxXCIsZixcIj1cIixULmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKX12YXIgTz1sKFtdLmNvbmNhdCh0LnByZS50aGlzVmFycykuY29uY2F0KHQuYm9keS50aGlzVmFycykuY29uY2F0KHQucG9zdC50aGlzVmFycykpO3c9dy5jb25jYXQoTyksYi5wdXNoKFwidmFyIFwiK3cuam9pbihcIixcIikpO2Zvcih2YXIgZj0wO2Y8dC5hcnJheUFyZ3MubGVuZ3RoOysrZiliLnB1c2goXCJwXCIrZitcInw9MFwiKTt0LnByZS5ib2R5Lmxlbmd0aD4zJiZiLnB1c2goYSh0LnByZSx0LGMpKTt2YXIgUz1hKHQuYm9keSx0LGMpLFA9aShtKTtQPG4/Yi5wdXNoKG8oUCxtWzBdLHQsUykpOmIucHVzaChyKG1bMF0sdCxTKSksdC5wb3N0LmJvZHkubGVuZ3RoPjMmJmIucHVzaChhKHQucG9zdCx0LGMpKSx0LmRlYnVnJiZjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIGN3aXNlIHJvdXRpbmUgZm9yIFwiLGUsXCI6XFxuXCIrYi5qb2luKFwiXFxuXCIpK1wiXFxuLS0tLS0tLS0tLVwiKTt2YXIgTT1bdC5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIsXCJfY3dpc2VfbG9vcF9cIix1WzBdLmpvaW4oXCJzXCIpLFwibVwiLFAscyhjKV0uam9pbihcIlwiKSxqPW5ldyBGdW5jdGlvbihbXCJmdW5jdGlvbiBcIixNLFwiKFwiLHkuam9pbihcIixcIiksXCIpe1wiLGIuam9pbihcIlxcblwiKSxcIn0gcmV0dXJuIFwiLE1dLmpvaW4oXCJcIikpO3JldHVybiBqKCl9dmFyIGw9bigxOTMpO3QuZXhwb3J0cz11fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXt2YXIgZT1bXCIndXNlIHN0cmljdCdcIixcInZhciBDQUNIRUQ9e31cIl0sbj1bXSxyPXQuZnVuY05hbWUrXCJfY3dpc2VfdGh1bmtcIjtlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLHIsXCIoXCIsdC5zaGltQXJncy5qb2luKFwiLFwiKSxcIil7XCJdLmpvaW4oXCJcIikpO2Zvcih2YXIgaT1bXSxhPVtdLHM9W1tcImFycmF5XCIsdC5hcnJheUFyZ3NbMF0sXCIuc2hhcGUuc2xpY2UoXCIsTWF0aC5tYXgoMCx0LmFycmF5QmxvY2tJbmRpY2VzWzBdKSx0LmFycmF5QmxvY2tJbmRpY2VzWzBdPDA/XCIsXCIrdC5hcnJheUJsb2NrSW5kaWNlc1swXStcIilcIjpcIilcIl0uam9pbihcIlwiKV0sdT1bXSxsPVtdLGM9MDtjPHQuYXJyYXlBcmdzLmxlbmd0aDsrK2Mpe3ZhciBmPXQuYXJyYXlBcmdzW2NdO24ucHVzaChbXCJ0XCIsZixcIj1hcnJheVwiLGYsXCIuZHR5cGUsXCIsXCJyXCIsZixcIj1hcnJheVwiLGYsXCIub3JkZXJcIl0uam9pbihcIlwiKSksaS5wdXNoKFwidFwiK2YpLGkucHVzaChcInJcIitmKSxhLnB1c2goXCJ0XCIrZiksYS5wdXNoKFwiclwiK2YrXCIuam9pbigpXCIpLHMucHVzaChcImFycmF5XCIrZitcIi5kYXRhXCIpLHMucHVzaChcImFycmF5XCIrZitcIi5zdHJpZGVcIikscy5wdXNoKFwiYXJyYXlcIitmK1wiLm9mZnNldHwwXCIpLGM+MCYmKHUucHVzaChcImFycmF5XCIrdC5hcnJheUFyZ3NbMF0rXCIuc2hhcGUubGVuZ3RoPT09YXJyYXlcIitmK1wiLnNoYXBlLmxlbmd0aCtcIisoTWF0aC5hYnModC5hcnJheUJsb2NrSW5kaWNlc1swXSktTWF0aC5hYnModC5hcnJheUJsb2NrSW5kaWNlc1tjXSkpKSxsLnB1c2goXCJhcnJheVwiK3QuYXJyYXlBcmdzWzBdK1wiLnNoYXBlW3NoYXBlSW5kZXgrXCIrTWF0aC5tYXgoMCx0LmFycmF5QmxvY2tJbmRpY2VzWzBdKStcIl09PT1hcnJheVwiK2YrXCIuc2hhcGVbc2hhcGVJbmRleCtcIitNYXRoLm1heCgwLHQuYXJyYXlCbG9ja0luZGljZXNbY10pK1wiXVwiKSl9dC5hcnJheUFyZ3MubGVuZ3RoPjEmJihlLnB1c2goXCJpZiAoIShcIit1LmpvaW4oXCIgJiYgXCIpK1wiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25hbGl0eSEnKVwiKSxlLnB1c2goXCJmb3IodmFyIHNoYXBlSW5kZXg9YXJyYXlcIit0LmFycmF5QXJnc1swXStcIi5zaGFwZS5sZW5ndGgtXCIrTWF0aC5hYnModC5hcnJheUJsb2NrSW5kaWNlc1swXSkrXCI7IHNoYXBlSW5kZXgtLT4wOykge1wiKSxlLnB1c2goXCJpZiAoIShcIitsLmpvaW4oXCIgJiYgXCIpK1wiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBzaGFwZSEnKVwiKSxlLnB1c2goXCJ9XCIpKTtmb3IodmFyIGM9MDtjPHQuc2NhbGFyQXJncy5sZW5ndGg7KytjKXMucHVzaChcInNjYWxhclwiK3Quc2NhbGFyQXJnc1tjXSk7bi5wdXNoKFtcInR5cGU9W1wiLGEuam9pbihcIixcIiksXCJdLmpvaW4oKVwiXS5qb2luKFwiXCIpKSxuLnB1c2goXCJwcm9jPUNBQ0hFRFt0eXBlXVwiKSxlLnB1c2goXCJ2YXIgXCIrbi5qb2luKFwiLFwiKSksZS5wdXNoKFtcImlmKCFwcm9jKXtcIixcIkNBQ0hFRFt0eXBlXT1wcm9jPWNvbXBpbGUoW1wiLGkuam9pbihcIixcIiksXCJdKX1cIixcInJldHVybiBwcm9jKFwiLHMuam9pbihcIixcIiksXCIpfVwiXS5qb2luKFwiXCIpKSx0LmRlYnVnJiZjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIHRodW5rOlxcblwiK2Uuam9pbihcIlxcblwiKStcIlxcbi0tLS0tLS0tLS1cIik7dmFyIHA9bmV3IEZ1bmN0aW9uKFwiY29tcGlsZVwiLGUuam9pbihcIlxcblwiKSk7cmV0dXJuIHAoby5iaW5kKHZvaWQgMCx0KSl9dmFyIG89big0NDgpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIodCxlLG4pe3RoaXMubmFtZT10LHRoaXMubHZhbHVlPWUsdGhpcy5ydmFsdWU9bix0aGlzLmNvdW50PTB9ZnVuY3Rpb24gbyh0LGUsbixyKXt0aGlzLmJvZHk9dCx0aGlzLmFyZ3M9ZSx0aGlzLnRoaXNWYXJzPW4sdGhpcy5sb2NhbFZhcnM9cn1mdW5jdGlvbiBpKHQpe2lmKFwiZXZhbFwiPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZS1wYXJzZXI6IGV2YWwoKSBub3QgYWxsb3dlZFwiKTtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3QgaW4gd2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBlP3QgaW4gZTpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmdCBpbiBzZWxmfWZ1bmN0aW9uIGEodCl7Zm9yKHZhciBlPXQuYm9keVswXS5leHByZXNzaW9uLmNhbGxlZS5wYXJhbXMsbj1uZXcgQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPWVbcl0ubmFtZTtyZXR1cm4gbn1mdW5jdGlvbiBzKHQpe2Z1bmN0aW9uIGUodCl7dmFyIGU9bSt0LnJlcGxhY2UoL1xcXy9nLFwiX19cIik7cmV0dXJuIHgucHVzaChlKSxlfWZ1bmN0aW9uIG4odCl7dmFyIGU9XCJ0aGlzX1wiK3QucmVwbGFjZSgvXFxfL2csXCJfX1wiKTtyZXR1cm4gRS5wdXNoKGUpLGV9ZnVuY3Rpb24gcyh0LGUpe2Zvcih2YXIgbj10LnJhbmdlWzBdLHI9dC5yYW5nZVsxXSxvPW4rMTtvPHI7KytvKWJbb109XCJcIjtiW25dPWV9ZnVuY3Rpb24gZih0KXtyZXR1cm5cIidcIit0LnJlcGxhY2UoL1xcXy9nLFwiXFxcXF9cIikucmVwbGFjZSgvXFwnL2csXCInXCIpK1wiJ1wifWZ1bmN0aW9uIHAodCl7cmV0dXJuIGIuc2xpY2UodC5yYW5nZVswXSx0LnJhbmdlWzFdKS5qb2luKFwiXCIpfWZ1bmN0aW9uIGgodCl7cmV0dXJuXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiPT09dC5wYXJlbnQudHlwZSYmdC5wYXJlbnQubGVmdD09PXQ/XCI9XCI9PT10LnBhcmVudC5vcGVyYXRvcj9UOlR8TzpcIlVwZGF0ZUV4cHJlc3Npb25cIj09PXQucGFyZW50LnR5cGU/VHxPOk99Zm9yKHZhciBkPVtcIihcIix0LFwiKSgpXCJdLmpvaW4oXCJcIiksdj11LnBhcnNlKGQse3JhbmdlOiEwfSksbT1cIl9pbmxpbmVfXCIrYysrICtcIl9cIixfPWEodiksZz1uZXcgQXJyYXkoXy5sZW5ndGgpLHk9MDt5PF8ubGVuZ3RoOysreSlnW3ldPW5ldyByKFttLFwiYXJnXCIseSxcIl9cIl0uam9pbihcIlwiKSwhMSwhMSk7Zm9yKHZhciBiPW5ldyBBcnJheShkLmxlbmd0aCkseT0wLHc9ZC5sZW5ndGg7eTx3OysreSliW3ldPWQuY2hhckF0KHkpO3ZhciB4PVtdLEU9W10sVD0xLE89MjshZnVuY3Rpb24gdChyLG8pe2lmKHIucGFyZW50PW8sXCJNZW1iZXJFeHByZXNzaW9uXCI9PT1yLnR5cGUpci5jb21wdXRlZD8odChyLm9iamVjdCxyKSx0KHIucHJvcGVydHkscikpOlwiVGhpc0V4cHJlc3Npb25cIj09PXIub2JqZWN0LnR5cGU/cyhyLG4oci5wcm9wZXJ0eS5uYW1lKSk6dChyLm9iamVjdCxyKTtlbHNle2lmKFwiVGhpc0V4cHJlc3Npb25cIj09PXIudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZS1wYXJzZXI6IENvbXB1dGVkIHRoaXMgaXMgbm90IGFsbG93ZWRcIik7aWYoXCJJZGVudGlmaWVyXCI9PT1yLnR5cGUpe3ZhciBhPXIubmFtZSx1PV8uaW5kZXhPZihhKTtpZih1Pj0wKXt2YXIgbD1nW3VdLGM9aChyKTtjJlQmJihsLmx2YWx1ZT0hMCksYyZPJiYobC5ydmFsdWU9ITApLCsrbC5jb3VudCxzKHIsbC5uYW1lKX1lbHNlIGkoYSl8fHMocixlKGEpKX1lbHNlIGlmKFwiTGl0ZXJhbFwiPT09ci50eXBlKVwic3RyaW5nXCI9PXR5cGVvZiByLnZhbHVlJiZzKHIsZihyLnZhbHVlKSk7ZWxzZXtpZihcIldpdGhTdGF0ZW1lbnRcIj09PXIudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZS1wYXJzZXI6IHdpdGgoKSBzdGF0ZW1lbnRzIG5vdCBhbGxvd2VkXCIpO2Zvcih2YXIgcD1PYmplY3Qua2V5cyhyKSxkPTAsdj1wLmxlbmd0aDtkPHY7KytkKWlmKFwicGFyZW50XCIhPT1wW2RdKXt2YXIgbT1yW3BbZF1dO2lmKG0paWYobSBpbnN0YW5jZW9mIEFycmF5KWZvcih2YXIgeT0wO3k8bS5sZW5ndGg7Kyt5KW1beV0mJlwic3RyaW5nXCI9PXR5cGVvZiBtW3ldLnR5cGUmJnQobVt5XSxyKTtlbHNlXCJzdHJpbmdcIj09dHlwZW9mIG0udHlwZSYmdChtLHIpfX19fSh2LmJvZHlbMF0uZXhwcmVzc2lvbi5jYWxsZWUuYm9keSx2b2lkIDApLGwoeCksbChFKTt2YXIgUz1uZXcgbyhwKHYuYm9keVswXS5leHByZXNzaW9uLmNhbGxlZS5ib2R5KSxnLEUseCk7cmV0dXJuIFN9dmFyIHU9big0NTEpLGw9bigxOTMpLGM9MDt0LmV4cG9ydHM9c30pLmNhbGwoZSxuKDM4KSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvLGk7IWZ1bmN0aW9uKG4sYSl7XCJ1c2Ugc3RyaWN0XCI7bz1bZV0scj1hLGk9XCJmdW5jdGlvblwiPT10eXBlb2Ygcj9yLmFwcGx5KGUsbyk6ciwhKHZvaWQgMCE9PWkmJih0LmV4cG9ydHM9aSkpfSh0aGlzLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUodCxlKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJBU1NFUlQ6IFwiK2UpfWZ1bmN0aW9uIG4odCl7cmV0dXJuIHQ+PTQ4JiZ0PD01N31mdW5jdGlvbiByKHQpe3JldHVyblwiMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRlwiLmluZGV4T2YodCk+PTB9ZnVuY3Rpb24gbyh0KXtyZXR1cm5cIjAxMjM0NTY3XCIuaW5kZXhPZih0KT49MH1mdW5jdGlvbiBpKHQpe3JldHVybiAzMj09PXR8fDk9PT10fHwxMT09PXR8fDEyPT09dHx8MTYwPT09dHx8dD49NTc2MCYmWzU3NjAsNjE1OCw4MTkyLDgxOTMsODE5NCw4MTk1LDgxOTYsODE5Nyw4MTk4LDgxOTksODIwMCw4MjAxLDgyMDIsODIzOSw4Mjg3LDEyMjg4LDY1Mjc5XS5pbmRleE9mKHQpPj0wfWZ1bmN0aW9uIGEodCl7cmV0dXJuIDEwPT09dHx8MTM9PT10fHw4MjMyPT09dHx8ODIzMz09PXR9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gMzY9PT10fHw5NT09PXR8fHQ+PTY1JiZ0PD05MHx8dD49OTcmJnQ8PTEyMnx8OTI9PT10fHx0Pj0xMjgmJmllLk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZSh0KSl9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gMzY9PT10fHw5NT09PXR8fHQ+PTY1JiZ0PD05MHx8dD49OTcmJnQ8PTEyMnx8dD49NDgmJnQ8PTU3fHw5Mj09PXR8fHQ+PTEyOCYmaWUuTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUodCkpfWZ1bmN0aW9uIGwodCl7c3dpdGNoKHQpe2Nhc2VcImNsYXNzXCI6Y2FzZVwiZW51bVwiOmNhc2VcImV4cG9ydFwiOmNhc2VcImV4dGVuZHNcIjpjYXNlXCJpbXBvcnRcIjpjYXNlXCJzdXBlclwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGModCl7c3dpdGNoKHQpe2Nhc2VcImltcGxlbWVudHNcIjpjYXNlXCJpbnRlcmZhY2VcIjpjYXNlXCJwYWNrYWdlXCI6Y2FzZVwicHJpdmF0ZVwiOmNhc2VcInByb3RlY3RlZFwiOmNhc2VcInB1YmxpY1wiOmNhc2VcInN0YXRpY1wiOmNhc2VcInlpZWxkXCI6Y2FzZVwibGV0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZih0KXtyZXR1cm5cImV2YWxcIj09PXR8fFwiYXJndW1lbnRzXCI9PT10fWZ1bmN0aW9uIHAodCl7aWYodWUmJmModCkpcmV0dXJuITA7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDI6cmV0dXJuXCJpZlwiPT09dHx8XCJpblwiPT09dHx8XCJkb1wiPT09dDtjYXNlIDM6cmV0dXJuXCJ2YXJcIj09PXR8fFwiZm9yXCI9PT10fHxcIm5ld1wiPT09dHx8XCJ0cnlcIj09PXR8fFwibGV0XCI9PT10O2Nhc2UgNDpyZXR1cm5cInRoaXNcIj09PXR8fFwiZWxzZVwiPT09dHx8XCJjYXNlXCI9PT10fHxcInZvaWRcIj09PXR8fFwid2l0aFwiPT09dHx8XCJlbnVtXCI9PT10O2Nhc2UgNTpyZXR1cm5cIndoaWxlXCI9PT10fHxcImJyZWFrXCI9PT10fHxcImNhdGNoXCI9PT10fHxcInRocm93XCI9PT10fHxcImNvbnN0XCI9PT10fHxcInlpZWxkXCI9PT10fHxcImNsYXNzXCI9PT10fHxcInN1cGVyXCI9PT10O2Nhc2UgNjpyZXR1cm5cInJldHVyblwiPT09dHx8XCJ0eXBlb2ZcIj09PXR8fFwiZGVsZXRlXCI9PT10fHxcInN3aXRjaFwiPT09dHx8XCJleHBvcnRcIj09PXR8fFwiaW1wb3J0XCI9PT10O2Nhc2UgNzpyZXR1cm5cImRlZmF1bHRcIj09PXR8fFwiZmluYWxseVwiPT09dHx8XCJleHRlbmRzXCI9PT10O2Nhc2UgODpyZXR1cm5cImZ1bmN0aW9uXCI9PT10fHxcImNvbnRpbnVlXCI9PT10fHxcImRlYnVnZ2VyXCI9PT10O2Nhc2UgMTA6cmV0dXJuXCJpbnN0YW5jZW9mXCI9PT10O2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGgodCxuLHIsbyxpKXt2YXIgYTtlKFwibnVtYmVyXCI9PXR5cGVvZiByLFwiQ29tbWVudCBtdXN0IGhhdmUgdmFsaWQgcG9zaXRpb25cIiksdmUubGFzdENvbW1lbnRTdGFydD49cnx8KHZlLmxhc3RDb21tZW50U3RhcnQ9cixhPXt0eXBlOnQsdmFsdWU6bn0sbWUucmFuZ2UmJihhLnJhbmdlPVtyLG9dKSxtZS5sb2MmJihhLmxvYz1pKSxtZS5jb21tZW50cy5wdXNoKGEpLG1lLmF0dGFjaENvbW1lbnQmJihtZS5sZWFkaW5nQ29tbWVudHMucHVzaChhKSxtZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goYSkpKX1mdW5jdGlvbiBkKHQpe3ZhciBlLG4scixvO2ZvcihlPWxlLXQsbj17c3RhcnQ6e2xpbmU6Y2UsY29sdW1uOmxlLWZlLXR9fTtsZTxwZTspaWYocj1zZS5jaGFyQ29kZUF0KGxlKSwrK2xlLGEocikpcmV0dXJuIG1lLmNvbW1lbnRzJiYobz1zZS5zbGljZShlK3QsbGUtMSksbi5lbmQ9e2xpbmU6Y2UsY29sdW1uOmxlLWZlLTF9LGgoXCJMaW5lXCIsbyxlLGxlLTEsbikpLDEzPT09ciYmMTA9PT1zZS5jaGFyQ29kZUF0KGxlKSYmKytsZSwrK2NlLHZvaWQoZmU9bGUpO21lLmNvbW1lbnRzJiYobz1zZS5zbGljZShlK3QsbGUpLG4uZW5kPXtsaW5lOmNlLGNvbHVtbjpsZS1mZX0saChcIkxpbmVcIixvLGUsbGUsbikpfWZ1bmN0aW9uIHYoKXt2YXIgdCxlLG4scjtmb3IobWUuY29tbWVudHMmJih0PWxlLTIsZT17c3RhcnQ6e2xpbmU6Y2UsY29sdW1uOmxlLWZlLTJ9fSk7bGU8cGU7KWlmKG49c2UuY2hhckNvZGVBdChsZSksYShuKSkxMz09PW4mJjEwPT09c2UuY2hhckNvZGVBdChsZSsxKSYmKytsZSwrK2NlLCsrbGUsZmU9bGUsbGU+PXBlJiZWKHt9LG9lLlVuZXhwZWN0ZWRUb2tlbixcIklMTEVHQUxcIik7ZWxzZSBpZig0Mj09PW4pe2lmKDQ3PT09c2UuY2hhckNvZGVBdChsZSsxKSlyZXR1cm4rK2xlLCsrbGUsdm9pZChtZS5jb21tZW50cyYmKHI9c2Uuc2xpY2UodCsyLGxlLTIpLGUuZW5kPXtsaW5lOmNlLGNvbHVtbjpsZS1mZX0saChcIkJsb2NrXCIscix0LGxlLGUpKSk7KytsZX1lbHNlKytsZTtWKHt9LG9lLlVuZXhwZWN0ZWRUb2tlbixcIklMTEVHQUxcIil9ZnVuY3Rpb24gbSgpe3ZhciB0LGU7Zm9yKGU9MD09PWxlO2xlPHBlOylpZih0PXNlLmNoYXJDb2RlQXQobGUpLGkodCkpKytsZTtlbHNlIGlmKGEodCkpKytsZSwxMz09PXQmJjEwPT09c2UuY2hhckNvZGVBdChsZSkmJisrbGUsKytjZSxmZT1sZSxlPSEwO2Vsc2UgaWYoNDc9PT10KWlmKHQ9c2UuY2hhckNvZGVBdChsZSsxKSw0Nz09PXQpKytsZSwrK2xlLGQoMiksZT0hMDtlbHNle2lmKDQyIT09dClicmVhazsrK2xlLCsrbGUsdigpfWVsc2UgaWYoZSYmNDU9PT10KXtpZig0NSE9PXNlLmNoYXJDb2RlQXQobGUrMSl8fDYyIT09c2UuY2hhckNvZGVBdChsZSsyKSlicmVhaztsZSs9MyxkKDMpfWVsc2V7aWYoNjAhPT10KWJyZWFrO2lmKFwiIS0tXCIhPT1zZS5zbGljZShsZSsxLGxlKzQpKWJyZWFrOysrbGUsKytsZSwrK2xlLCsrbGUsZCg0KX19ZnVuY3Rpb24gXyh0KXt2YXIgZSxuLG8saT0wO2ZvcihuPVwidVwiPT09dD80OjIsZT0wO2U8bjsrK2Upe2lmKCEobGU8cGUmJnIoc2VbbGVdKSkpcmV0dXJuXCJcIjtvPXNlW2xlKytdLGk9MTYqaStcIjAxMjM0NTY3ODlhYmNkZWZcIi5pbmRleE9mKG8udG9Mb3dlckNhc2UoKSl9cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaSl9ZnVuY3Rpb24gZygpe3ZhciB0LGU7Zm9yKHQ9c2UuY2hhckNvZGVBdChsZSsrKSxlPVN0cmluZy5mcm9tQ2hhckNvZGUodCksOTI9PT10JiYoMTE3IT09c2UuY2hhckNvZGVBdChsZSkmJlYoe30sb2UuVW5leHBlY3RlZFRva2VuLFwiSUxMRUdBTFwiKSwrK2xlLHQ9XyhcInVcIiksdCYmXCJcXFxcXCIhPT10JiZzKHQuY2hhckNvZGVBdCgwKSl8fFYoe30sb2UuVW5leHBlY3RlZFRva2VuLFwiSUxMRUdBTFwiKSxlPXQpO2xlPHBlJiYodD1zZS5jaGFyQ29kZUF0KGxlKSx1KHQpKTspKytsZSxlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpLDkyPT09dCYmKGU9ZS5zdWJzdHIoMCxlLmxlbmd0aC0xKSwxMTchPT1zZS5jaGFyQ29kZUF0KGxlKSYmVih7fSxvZS5VbmV4cGVjdGVkVG9rZW4sXCJJTExFR0FMXCIpLCsrbGUsdD1fKFwidVwiKSx0JiZcIlxcXFxcIiE9PXQmJnUodC5jaGFyQ29kZUF0KDApKXx8Vih7fSxvZS5VbmV4cGVjdGVkVG9rZW4sXCJJTExFR0FMXCIpLGUrPXQpO3JldHVybiBlfWZ1bmN0aW9uIHkoKXt2YXIgdCxlO2Zvcih0PWxlKys7bGU8cGU7KXtpZihlPXNlLmNoYXJDb2RlQXQobGUpLDkyPT09ZSlyZXR1cm4gbGU9dCxnKCk7aWYoIXUoZSkpYnJlYWs7KytsZX1yZXR1cm4gc2Uuc2xpY2UodCxsZSl9ZnVuY3Rpb24gYigpe3ZhciB0LGUsbjtyZXR1cm4gdD1sZSxlPTkyPT09c2UuY2hhckNvZGVBdChsZSk/ZygpOnkoKSxuPTE9PT1lLmxlbmd0aD9KdC5JZGVudGlmaWVyOnAoZSk/SnQuS2V5d29yZDpcIm51bGxcIj09PWU/SnQuTnVsbExpdGVyYWw6XCJ0cnVlXCI9PT1lfHxcImZhbHNlXCI9PT1lP0p0LkJvb2xlYW5MaXRlcmFsOkp0LklkZW50aWZpZXIse3R5cGU6bix2YWx1ZTplLGxpbmVOdW1iZXI6Y2UsbGluZVN0YXJ0OmZlLHN0YXJ0OnQsZW5kOmxlfX1mdW5jdGlvbiB3KCl7dmFyIHQsZSxuLHIsbz1sZSxpPXNlLmNoYXJDb2RlQXQobGUpLGE9c2VbbGVdO3N3aXRjaChpKXtjYXNlIDQ2OmNhc2UgNDA6Y2FzZSA0MTpjYXNlIDU5OmNhc2UgNDQ6Y2FzZSAxMjM6Y2FzZSAxMjU6Y2FzZSA5MTpjYXNlIDkzOmNhc2UgNTg6Y2FzZSA2MzpjYXNlIDEyNjpyZXR1cm4rK2xlLG1lLnRva2VuaXplJiYoNDA9PT1pP21lLm9wZW5QYXJlblRva2VuPW1lLnRva2Vucy5sZW5ndGg6MTIzPT09aSYmKG1lLm9wZW5DdXJseVRva2VuPW1lLnRva2Vucy5sZW5ndGgpKSx7dHlwZTpKdC5QdW5jdHVhdG9yLHZhbHVlOlN0cmluZy5mcm9tQ2hhckNvZGUoaSksbGluZU51bWJlcjpjZSxsaW5lU3RhcnQ6ZmUsc3RhcnQ6byxlbmQ6bGV9O2RlZmF1bHQ6aWYodD1zZS5jaGFyQ29kZUF0KGxlKzEpLDYxPT09dClzd2l0Y2goaSl7Y2FzZSA0MzpjYXNlIDQ1OmNhc2UgNDc6Y2FzZSA2MDpjYXNlIDYyOmNhc2UgOTQ6Y2FzZSAxMjQ6Y2FzZSAzNzpjYXNlIDM4OmNhc2UgNDI6cmV0dXJuIGxlKz0yLHt0eXBlOkp0LlB1bmN0dWF0b3IsdmFsdWU6U3RyaW5nLmZyb21DaGFyQ29kZShpKStTdHJpbmcuZnJvbUNoYXJDb2RlKHQpLGxpbmVOdW1iZXI6Y2UsbGluZVN0YXJ0OmZlLHN0YXJ0Om8sZW5kOmxlfTtjYXNlIDMzOmNhc2UgNjE6cmV0dXJuIGxlKz0yLDYxPT09c2UuY2hhckNvZGVBdChsZSkmJisrbGUse3R5cGU6SnQuUHVuY3R1YXRvcix2YWx1ZTpzZS5zbGljZShvLGxlKSxsaW5lTnVtYmVyOmNlLGxpbmVTdGFydDpmZSxzdGFydDpvLGVuZDpsZX19fXJldHVybiByPXNlLnN1YnN0cihsZSw0KSxcIj4+Pj1cIj09PXI/KGxlKz00LHt0eXBlOkp0LlB1bmN0dWF0b3IsdmFsdWU6cixsaW5lTnVtYmVyOmNlLGxpbmVTdGFydDpmZSxzdGFydDpvLGVuZDpsZX0pOihuPXIuc3Vic3RyKDAsMyksXCI+Pj5cIj09PW58fFwiPDw9XCI9PT1ufHxcIj4+PVwiPT09bj8obGUrPTMse3R5cGU6SnQuUHVuY3R1YXRvcix2YWx1ZTpuLGxpbmVOdW1iZXI6Y2UsbGluZVN0YXJ0OmZlLHN0YXJ0Om8sZW5kOmxlfSk6KGU9bi5zdWJzdHIoMCwyKSxhPT09ZVsxXSYmXCIrLTw+JnxcIi5pbmRleE9mKGEpPj0wfHxcIj0+XCI9PT1lPyhsZSs9Mix7dHlwZTpKdC5QdW5jdHVhdG9yLHZhbHVlOmUsbGluZU51bWJlcjpjZSxsaW5lU3RhcnQ6ZmUsc3RhcnQ6byxlbmQ6bGV9KTpcIjw+PSErLSolJnxeL1wiLmluZGV4T2YoYSk+PTA/KCsrbGUse3R5cGU6SnQuUHVuY3R1YXRvcix2YWx1ZTphLGxpbmVOdW1iZXI6Y2UsbGluZVN0YXJ0OmZlLHN0YXJ0Om8sZW5kOmxlfSk6dm9pZCBWKHt9LG9lLlVuZXhwZWN0ZWRUb2tlbixcIklMTEVHQUxcIikpKX1mdW5jdGlvbiB4KHQpe2Zvcih2YXIgZT1cIlwiO2xlPHBlJiZyKHNlW2xlXSk7KWUrPXNlW2xlKytdO3JldHVybiAwPT09ZS5sZW5ndGgmJlYoe30sb2UuVW5leHBlY3RlZFRva2VuLFwiSUxMRUdBTFwiKSxzKHNlLmNoYXJDb2RlQXQobGUpKSYmVih7fSxvZS5VbmV4cGVjdGVkVG9rZW4sXCJJTExFR0FMXCIpLHt0eXBlOkp0Lk51bWVyaWNMaXRlcmFsLHZhbHVlOnBhcnNlSW50KFwiMHhcIitlLDE2KSxsaW5lTnVtYmVyOmNlLGxpbmVTdGFydDpmZSxzdGFydDp0LGVuZDpsZX19ZnVuY3Rpb24gRSh0KXtmb3IodmFyIGU9XCIwXCIrc2VbbGUrK107bGU8cGUmJm8oc2VbbGVdKTspZSs9c2VbbGUrK107cmV0dXJuKHMoc2UuY2hhckNvZGVBdChsZSkpfHxuKHNlLmNoYXJDb2RlQXQobGUpKSkmJlYoe30sb2UuVW5leHBlY3RlZFRva2VuLFwiSUxMRUdBTFwiKSx7dHlwZTpKdC5OdW1lcmljTGl0ZXJhbCx2YWx1ZTpwYXJzZUludChlLDgpLG9jdGFsOiEwLGxpbmVOdW1iZXI6Y2UsbGluZVN0YXJ0OmZlLHN0YXJ0OnQsZW5kOmxlfX1mdW5jdGlvbiBUKCl7dmFyIHQsZTtmb3IodD1sZSsxO3Q8cGU7Kyt0KXtpZihlPXNlW3RdLFwiOFwiPT09ZXx8XCI5XCI9PT1lKXJldHVybiExO2lmKCFvKGUpKXJldHVybiEwfXJldHVybiEwfWZ1bmN0aW9uIE8oKXt2YXIgdCxyLGk7aWYoaT1zZVtsZV0sZShuKGkuY2hhckNvZGVBdCgwKSl8fFwiLlwiPT09aSxcIk51bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludFwiKSxyPWxlLHQ9XCJcIixcIi5cIiE9PWkpe2lmKHQ9c2VbbGUrK10saT1zZVtsZV0sXCIwXCI9PT10KXtpZihcInhcIj09PWl8fFwiWFwiPT09aSlyZXR1cm4rK2xlLHgocik7aWYobyhpKSYmVCgpKXJldHVybiBFKHIpfWZvcig7bihzZS5jaGFyQ29kZUF0KGxlKSk7KXQrPXNlW2xlKytdO2k9c2VbbGVdfWlmKFwiLlwiPT09aSl7Zm9yKHQrPXNlW2xlKytdO24oc2UuY2hhckNvZGVBdChsZSkpOyl0Kz1zZVtsZSsrXTtpPXNlW2xlXX1pZihcImVcIj09PWl8fFwiRVwiPT09aSlpZih0Kz1zZVtsZSsrXSxpPXNlW2xlXSxcIitcIiE9PWkmJlwiLVwiIT09aXx8KHQrPXNlW2xlKytdKSxuKHNlLmNoYXJDb2RlQXQobGUpKSlmb3IoO24oc2UuY2hhckNvZGVBdChsZSkpOyl0Kz1zZVtsZSsrXTtlbHNlIFYoe30sb2UuVW5leHBlY3RlZFRva2VuLFwiSUxMRUdBTFwiKTtyZXR1cm4gcyhzZS5jaGFyQ29kZUF0KGxlKSkmJlYoe30sb2UuVW5leHBlY3RlZFRva2VuLFwiSUxMRUdBTFwiKSx7dHlwZTpKdC5OdW1lcmljTGl0ZXJhbCx2YWx1ZTpwYXJzZUZsb2F0KHQpLGxpbmVOdW1iZXI6Y2UsbGluZVN0YXJ0OmZlLHN0YXJ0OnIsZW5kOmxlfX1mdW5jdGlvbiBTKCl7dmFyIHQsbixyLGkscyx1LGwsYyxmPVwiXCIscD0hMTtmb3IobD1jZSxjPWZlLHQ9c2VbbGVdLGUoXCInXCI9PT10fHwnXCInPT09dCxcIlN0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZVwiKSxuPWxlLCsrbGU7bGU8cGU7KXtpZihyPXNlW2xlKytdLHI9PT10KXt0PVwiXCI7YnJlYWt9aWYoXCJcXFxcXCI9PT1yKWlmKHI9c2VbbGUrK10sciYmYShyLmNoYXJDb2RlQXQoMCkpKSsrY2UsXCJcXHJcIj09PXImJlwiXFxuXCI9PT1zZVtsZV0mJisrbGUsZmU9bGU7ZWxzZSBzd2l0Y2gocil7Y2FzZVwidVwiOmNhc2VcInhcIjp1PWxlLHM9XyhyKSxzP2YrPXM6KGxlPXUsZis9cik7YnJlYWs7Y2FzZVwiblwiOmYrPVwiXFxuXCI7YnJlYWs7Y2FzZVwiclwiOmYrPVwiXFxyXCI7YnJlYWs7Y2FzZVwidFwiOmYrPVwiXFx0XCI7YnJlYWs7Y2FzZVwiYlwiOmYrPVwiXFxiXCI7YnJlYWs7Y2FzZVwiZlwiOmYrPVwiXFxmXCI7YnJlYWs7Y2FzZVwidlwiOmYrPVwiXFx2XCI7YnJlYWs7ZGVmYXVsdDpvKHIpPyhpPVwiMDEyMzQ1NjdcIi5pbmRleE9mKHIpLDAhPT1pJiYocD0hMCksbGU8cGUmJm8oc2VbbGVdKSYmKHA9ITAsaT04KmkrXCIwMTIzNDU2N1wiLmluZGV4T2Yoc2VbbGUrK10pLFwiMDEyM1wiLmluZGV4T2Yocik+PTAmJmxlPHBlJiZvKHNlW2xlXSkmJihpPTgqaStcIjAxMjM0NTY3XCIuaW5kZXhPZihzZVtsZSsrXSkpKSxmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTpmKz1yfWVsc2V7aWYoYShyLmNoYXJDb2RlQXQoMCkpKWJyZWFrO2YrPXJ9fXJldHVyblwiXCIhPT10JiZWKHt9LG9lLlVuZXhwZWN0ZWRUb2tlbixcIklMTEVHQUxcIikse3R5cGU6SnQuU3RyaW5nTGl0ZXJhbCx2YWx1ZTpmLG9jdGFsOnAsc3RhcnRMaW5lTnVtYmVyOmwsc3RhcnRMaW5lU3RhcnQ6YyxsaW5lTnVtYmVyOmNlLGxpbmVTdGFydDpmZSxzdGFydDpuLGVuZDpsZX19ZnVuY3Rpb24gUCh0LGUpe3ZhciBuO3RyeXtuPW5ldyBSZWdFeHAodCxlKX1jYXRjaCh0KXtWKHt9LG9lLkludmFsaWRSZWdFeHApfXJldHVybiBufWZ1bmN0aW9uIE0oKXt2YXIgdCxuLHIsbyxpO2Zvcih0PXNlW2xlXSxlKFwiL1wiPT09dCxcIlJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoXCIpLG49c2VbbGUrK10scj0hMSxvPSExO2xlPHBlOylpZih0PXNlW2xlKytdLG4rPXQsXCJcXFxcXCI9PT10KXQ9c2VbbGUrK10sYSh0LmNoYXJDb2RlQXQoMCkpJiZWKHt9LG9lLlVudGVybWluYXRlZFJlZ0V4cCksbis9dDtlbHNlIGlmKGEodC5jaGFyQ29kZUF0KDApKSlWKHt9LG9lLlVudGVybWluYXRlZFJlZ0V4cCk7ZWxzZSBpZihyKVwiXVwiPT09dCYmKHI9ITEpO2Vsc2V7aWYoXCIvXCI9PT10KXtvPSEwO2JyZWFrfVwiW1wiPT09dCYmKHI9ITApfXJldHVybiBvfHxWKHt9LG9lLlVudGVybWluYXRlZFJlZ0V4cCksaT1uLnN1YnN0cigxLG4ubGVuZ3RoLTIpLHt2YWx1ZTppLGxpdGVyYWw6bn19ZnVuY3Rpb24gaigpe3ZhciB0LGUsbixyO2ZvcihlPVwiXCIsbj1cIlwiO2xlPHBlJiYodD1zZVtsZV0sdSh0LmNoYXJDb2RlQXQoMCkpKTspaWYoKytsZSxcIlxcXFxcIj09PXQmJmxlPHBlKWlmKHQ9c2VbbGVdLFwidVwiPT09dCl7aWYoKytsZSxyPWxlLHQ9XyhcInVcIikpZm9yKG4rPXQsZSs9XCJcXFxcdVwiO3I8bGU7KytyKWUrPXNlW3JdO2Vsc2UgbGU9cixuKz1cInVcIixlKz1cIlxcXFx1XCI7Vyh7fSxvZS5VbmV4cGVjdGVkVG9rZW4sXCJJTExFR0FMXCIpfWVsc2UgZSs9XCJcXFxcXCIsVyh7fSxvZS5VbmV4cGVjdGVkVG9rZW4sXCJJTExFR0FMXCIpO2Vsc2Ugbis9dCxlKz10O3JldHVybnt2YWx1ZTpuLGxpdGVyYWw6ZX19ZnVuY3Rpb24gQSgpe3ZhciB0LGUsbixyO3JldHVybiBkZT1udWxsLG0oKSx0PWxlLGU9TSgpLG49aigpLHI9UChlLnZhbHVlLG4udmFsdWUpLG1lLnRva2VuaXplP3t0eXBlOkp0LlJlZ3VsYXJFeHByZXNzaW9uLHZhbHVlOnIsbGluZU51bWJlcjpjZSxsaW5lU3RhcnQ6ZmUsc3RhcnQ6dCxlbmQ6bGV9OntsaXRlcmFsOmUubGl0ZXJhbCtuLmxpdGVyYWwsdmFsdWU6cixzdGFydDp0LGVuZDpsZX19ZnVuY3Rpb24gQygpe3ZhciB0LGUsbixyO3JldHVybiBtKCksdD1sZSxlPXtzdGFydDp7bGluZTpjZSxjb2x1bW46bGUtZmV9fSxuPUEoKSxlLmVuZD17bGluZTpjZSxjb2x1bW46bGUtZmV9LG1lLnRva2VuaXplfHwobWUudG9rZW5zLmxlbmd0aD4wJiYocj1tZS50b2tlbnNbbWUudG9rZW5zLmxlbmd0aC0xXSxyLnJhbmdlWzBdPT09dCYmXCJQdW5jdHVhdG9yXCI9PT1yLnR5cGUmJihcIi9cIiE9PXIudmFsdWUmJlwiLz1cIiE9PXIudmFsdWV8fG1lLnRva2Vucy5wb3AoKSkpLG1lLnRva2Vucy5wdXNoKHt0eXBlOlwiUmVndWxhckV4cHJlc3Npb25cIix2YWx1ZTpuLmxpdGVyYWwscmFuZ2U6W3QsbGVdLGxvYzplfSkpLG59ZnVuY3Rpb24gayh0KXtyZXR1cm4gdC50eXBlPT09SnQuSWRlbnRpZmllcnx8dC50eXBlPT09SnQuS2V5d29yZHx8dC50eXBlPT09SnQuQm9vbGVhbkxpdGVyYWx8fHQudHlwZT09PUp0Lk51bGxMaXRlcmFsfWZ1bmN0aW9uIFIoKXt2YXIgdCxlO2lmKHQ9bWUudG9rZW5zW21lLnRva2Vucy5sZW5ndGgtMV0sIXQpcmV0dXJuIEMoKTtpZihcIlB1bmN0dWF0b3JcIj09PXQudHlwZSl7aWYoXCJdXCI9PT10LnZhbHVlKXJldHVybiB3KCk7aWYoXCIpXCI9PT10LnZhbHVlKXJldHVybiBlPW1lLnRva2Vuc1ttZS5vcGVuUGFyZW5Ub2tlbi0xXSwhZXx8XCJLZXl3b3JkXCIhPT1lLnR5cGV8fFwiaWZcIiE9PWUudmFsdWUmJlwid2hpbGVcIiE9PWUudmFsdWUmJlwiZm9yXCIhPT1lLnZhbHVlJiZcIndpdGhcIiE9PWUudmFsdWU/dygpOkMoKTtpZihcIn1cIj09PXQudmFsdWUpe2lmKG1lLnRva2Vuc1ttZS5vcGVuQ3VybHlUb2tlbi0zXSYmXCJLZXl3b3JkXCI9PT1tZS50b2tlbnNbbWUub3BlbkN1cmx5VG9rZW4tM10udHlwZSl7aWYoZT1tZS50b2tlbnNbbWUub3BlbkN1cmx5VG9rZW4tNF0sIWUpcmV0dXJuIHcoKX1lbHNle2lmKCFtZS50b2tlbnNbbWUub3BlbkN1cmx5VG9rZW4tNF18fFwiS2V5d29yZFwiIT09bWUudG9rZW5zW21lLm9wZW5DdXJseVRva2VuLTRdLnR5cGUpcmV0dXJuIHcoKTtpZihlPW1lLnRva2Vuc1ttZS5vcGVuQ3VybHlUb2tlbi01XSwhZSlyZXR1cm4gQygpfXJldHVybiBlZS5pbmRleE9mKGUudmFsdWUpPj0wP3coKTpDKCl9cmV0dXJuIEMoKX1yZXR1cm5cIktleXdvcmRcIj09PXQudHlwZSYmXCJ0aGlzXCIhPT10LnZhbHVlP0MoKTp3KCl9ZnVuY3Rpb24gSSgpe3ZhciB0O3JldHVybiBtKCksbGU+PXBlP3t0eXBlOkp0LkVPRixsaW5lTnVtYmVyOmNlLGxpbmVTdGFydDpmZSxzdGFydDpsZSxlbmQ6bGV9Oih0PXNlLmNoYXJDb2RlQXQobGUpLHModCk/YigpOjQwPT09dHx8NDE9PT10fHw1OT09PXQ/dygpOjM5PT09dHx8MzQ9PT10P1MoKTo0Nj09PXQ/bihzZS5jaGFyQ29kZUF0KGxlKzEpKT9PKCk6dygpOm4odCk/TygpOm1lLnRva2VuaXplJiY0Nz09PXQ/UigpOncoKSl9ZnVuY3Rpb24gTigpe3ZhciB0LGUsbjtyZXR1cm4gbSgpLHQ9e3N0YXJ0OntsaW5lOmNlLGNvbHVtbjpsZS1mZX19LGU9SSgpLHQuZW5kPXtsaW5lOmNlLGNvbHVtbjpsZS1mZX0sZS50eXBlIT09SnQuRU9GJiYobj1zZS5zbGljZShlLnN0YXJ0LGUuZW5kKSxtZS50b2tlbnMucHVzaCh7dHlwZTp0ZVtlLnR5cGVdLHZhbHVlOm4scmFuZ2U6W2Uuc3RhcnQsZS5lbmRdLGxvYzp0fSkpLGV9ZnVuY3Rpb24gVSgpe3ZhciB0O3JldHVybiB0PWRlLGxlPXQuZW5kLGNlPXQubGluZU51bWJlcixmZT10LmxpbmVTdGFydCxkZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgbWUudG9rZW5zP04oKTpJKCksbGU9dC5lbmQsY2U9dC5saW5lTnVtYmVyLGZlPXQubGluZVN0YXJ0LHR9ZnVuY3Rpb24gRigpe3ZhciB0LGUsbjt0PWxlLGU9Y2Usbj1mZSxkZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgbWUudG9rZW5zP04oKTpJKCksbGU9dCxjZT1lLGZlPW59ZnVuY3Rpb24gTCh0LGUpe3RoaXMubGluZT10LHRoaXMuY29sdW1uPWV9ZnVuY3Rpb24gRCh0LGUsbixyKXt0aGlzLnN0YXJ0PW5ldyBMKHQsZSksdGhpcy5lbmQ9bmV3IEwobixyKX1mdW5jdGlvbiBCKCl7dmFyIHQsZSxuLHI7cmV0dXJuIHQ9bGUsZT1jZSxuPWZlLG0oKSxyPWNlIT09ZSxsZT10LGNlPWUsZmU9bixyfWZ1bmN0aW9uIFYodCxuKXt2YXIgcixvPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSxpPW4ucmVwbGFjZSgvJShcXGQpL2csZnVuY3Rpb24odCxuKXtyZXR1cm4gZShuPG8ubGVuZ3RoLFwiTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZVwiKSxvW25dfSk7dGhyb3dcIm51bWJlclwiPT10eXBlb2YgdC5saW5lTnVtYmVyPyhyPW5ldyBFcnJvcihcIkxpbmUgXCIrdC5saW5lTnVtYmVyK1wiOiBcIitpKSxyLmluZGV4PXQuc3RhcnQsci5saW5lTnVtYmVyPXQubGluZU51bWJlcixyLmNvbHVtbj10LnN0YXJ0LWZlKzEpOihyPW5ldyBFcnJvcihcIkxpbmUgXCIrY2UrXCI6IFwiK2kpLHIuaW5kZXg9bGUsci5saW5lTnVtYmVyPWNlLHIuY29sdW1uPWxlLWZlKzEpLHIuZGVzY3JpcHRpb249aSxyfWZ1bmN0aW9uIFcoKXt0cnl7Vi5hcHBseShudWxsLGFyZ3VtZW50cyl9Y2F0Y2godCl7aWYoIW1lLmVycm9ycyl0aHJvdyB0O21lLmVycm9ycy5wdXNoKHQpfX1mdW5jdGlvbiBYKHQpe2lmKHQudHlwZT09PUp0LkVPRiYmVih0LG9lLlVuZXhwZWN0ZWRFT1MpLHQudHlwZT09PUp0Lk51bWVyaWNMaXRlcmFsJiZWKHQsb2UuVW5leHBlY3RlZE51bWJlciksdC50eXBlPT09SnQuU3RyaW5nTGl0ZXJhbCYmVih0LG9lLlVuZXhwZWN0ZWRTdHJpbmcpLHQudHlwZT09PUp0LklkZW50aWZpZXImJlYodCxvZS5VbmV4cGVjdGVkSWRlbnRpZmllciksdC50eXBlPT09SnQuS2V5d29yZCl7aWYobCh0LnZhbHVlKSlWKHQsb2UuVW5leHBlY3RlZFJlc2VydmVkKTtlbHNlIGlmKHVlJiZjKHQudmFsdWUpKXJldHVybiB2b2lkIFcodCxvZS5TdHJpY3RSZXNlcnZlZFdvcmQpO1YodCxvZS5VbmV4cGVjdGVkVG9rZW4sdC52YWx1ZSl9Vih0LG9lLlVuZXhwZWN0ZWRUb2tlbix0LnZhbHVlKX1mdW5jdGlvbiB6KHQpe3ZhciBlPVUoKTtlLnR5cGU9PT1KdC5QdW5jdHVhdG9yJiZlLnZhbHVlPT09dHx8WChlKX1mdW5jdGlvbiBHKHQpe3ZhciBlPVUoKTtlLnR5cGU9PT1KdC5LZXl3b3JkJiZlLnZhbHVlPT09dHx8WChlKX1mdW5jdGlvbiBxKHQpe3JldHVybiBkZS50eXBlPT09SnQuUHVuY3R1YXRvciYmZGUudmFsdWU9PT10fWZ1bmN0aW9uIEgodCl7cmV0dXJuIGRlLnR5cGU9PT1KdC5LZXl3b3JkJiZkZS52YWx1ZT09PXR9ZnVuY3Rpb24gWSgpe3ZhciB0O3JldHVybiBkZS50eXBlPT09SnQuUHVuY3R1YXRvciYmKHQ9ZGUudmFsdWUsXCI9XCI9PT10fHxcIio9XCI9PT10fHxcIi89XCI9PT10fHxcIiU9XCI9PT10fHxcIis9XCI9PT10fHxcIi09XCI9PT10fHxcIjw8PVwiPT09dHx8XCI+Pj1cIj09PXR8fFwiPj4+PVwiPT09dHx8XCImPVwiPT09dHx8XCJePVwiPT09dHx8XCJ8PVwiPT09dCl9ZnVuY3Rpb24gSygpe3ZhciB0LGU9bGUsbj1jZSxyPWZlLG89ZGU7cmV0dXJuIDU5PT09c2UuY2hhckNvZGVBdChsZSl8fHEoXCI7XCIpP3ZvaWQgVSgpOih0PWNlLG0oKSxjZSE9PXQ/KGxlPWUsY2U9bixmZT1yLHZvaWQoZGU9bykpOnZvaWQoZGUudHlwZT09PUp0LkVPRnx8cShcIn1cIil8fFgoZGUpKSl9ZnVuY3Rpb24gJCh0KXtyZXR1cm4gdC50eXBlPT09bmUuSWRlbnRpZmllcnx8dC50eXBlPT09bmUuTWVtYmVyRXhwcmVzc2lvbn1mdW5jdGlvbiBaKCl7dmFyIHQsZT1bXTtmb3IodD1kZSx6KFwiW1wiKTshcShcIl1cIik7KXEoXCIsXCIpPyhVKCksZS5wdXNoKG51bGwpKTooZS5wdXNoKG10KCkpLHEoXCJdXCIpfHx6KFwiLFwiKSk7cmV0dXJuIFUoKSxoZS5tYXJrRW5kKGhlLmNyZWF0ZUFycmF5RXhwcmVzc2lvbihlKSx0KX1mdW5jdGlvbiBRKHQsZSl7dmFyIG4scixvO3JldHVybiBuPXVlLG89ZGUscj1YdCgpLGUmJnVlJiZmKHRbMF0ubmFtZSkmJlcoZSxvZS5TdHJpY3RQYXJhbU5hbWUpLHVlPW4saGUubWFya0VuZChoZS5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24obnVsbCx0LFtdLHIpLG8pfWZ1bmN0aW9uIEooKXt2YXIgdCxlO3JldHVybiBlPWRlLHQ9VSgpLHQudHlwZT09PUp0LlN0cmluZ0xpdGVyYWx8fHQudHlwZT09PUp0Lk51bWVyaWNMaXRlcmFsPyh1ZSYmdC5vY3RhbCYmVyh0LG9lLlN0cmljdE9jdGFsTGl0ZXJhbCksaGUubWFya0VuZChoZS5jcmVhdGVMaXRlcmFsKHQpLGUpKTpoZS5tYXJrRW5kKGhlLmNyZWF0ZUlkZW50aWZpZXIodC52YWx1ZSksZSl9ZnVuY3Rpb24gdHQoKXt2YXIgdCxlLG4scixvLGk7cmV0dXJuIHQ9ZGUsaT1kZSx0LnR5cGU9PT1KdC5JZGVudGlmaWVyPyhuPUooKSxcImdldFwiIT09dC52YWx1ZXx8cShcIjpcIik/XCJzZXRcIiE9PXQudmFsdWV8fHEoXCI6XCIpPyh6KFwiOlwiKSxyPW10KCksaGUubWFya0VuZChoZS5jcmVhdGVQcm9wZXJ0eShcImluaXRcIixuLHIpLGkpKTooZT1KKCkseihcIihcIiksdD1kZSx0LnR5cGUhPT1KdC5JZGVudGlmaWVyPyh6KFwiKVwiKSxXKHQsb2UuVW5leHBlY3RlZFRva2VuLHQudmFsdWUpLHI9UShbXSkpOihvPVtidCgpXSx6KFwiKVwiKSxyPVEobyx0KSksaGUubWFya0VuZChoZS5jcmVhdGVQcm9wZXJ0eShcInNldFwiLGUsciksaSkpOihlPUooKSx6KFwiKFwiKSx6KFwiKVwiKSxyPVEoW10pLGhlLm1hcmtFbmQoaGUuY3JlYXRlUHJvcGVydHkoXCJnZXRcIixlLHIpLGkpKSk6dC50eXBlIT09SnQuRU9GJiZ0LnR5cGUhPT1KdC5QdW5jdHVhdG9yPyhlPUooKSx6KFwiOlwiKSxyPW10KCksaGUubWFya0VuZChoZS5jcmVhdGVQcm9wZXJ0eShcImluaXRcIixlLHIpLGkpKTp2b2lkIFgodCl9ZnVuY3Rpb24gZXQoKXt2YXIgdCxlLG4scixvLGk9W10sYT17fSxzPVN0cmluZztmb3Iobz1kZSx6KFwie1wiKTshcShcIn1cIik7KXQ9dHQoKSxlPXQua2V5LnR5cGU9PT1uZS5JZGVudGlmaWVyP3Qua2V5Lm5hbWU6cyh0LmtleS52YWx1ZSkscj1cImluaXRcIj09PXQua2luZD9yZS5EYXRhOlwiZ2V0XCI9PT10LmtpbmQ/cmUuR2V0OnJlLlNldCxuPVwiJFwiK2UsT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsbik/KGFbbl09PT1yZS5EYXRhP3VlJiZyPT09cmUuRGF0YT9XKHt9LG9lLlN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTpyIT09cmUuRGF0YSYmVyh7fSxvZS5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk6cj09PXJlLkRhdGE/Vyh7fSxvZS5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk6YVtuXSZyJiZXKHt9LG9lLkFjY2Vzc29yR2V0U2V0KSxhW25dfD1yKTphW25dPXIsaS5wdXNoKHQpLHEoXCJ9XCIpfHx6KFwiLFwiKTtyZXR1cm4geihcIn1cIiksaGUubWFya0VuZChoZS5jcmVhdGVPYmplY3RFeHByZXNzaW9uKGkpLG8pfWZ1bmN0aW9uIG50KCl7dmFyIHQ7cmV0dXJuIHooXCIoXCIpLHQ9X3QoKSx6KFwiKVwiKSx0fWZ1bmN0aW9uIHJ0KCl7dmFyIHQsZSxuLHI7aWYocShcIihcIikpcmV0dXJuIG50KCk7aWYocShcIltcIikpcmV0dXJuIFooKTtpZihxKFwie1wiKSlyZXR1cm4gZXQoKTtpZih0PWRlLnR5cGUscj1kZSx0PT09SnQuSWRlbnRpZmllciluPWhlLmNyZWF0ZUlkZW50aWZpZXIoVSgpLnZhbHVlKTtlbHNlIGlmKHQ9PT1KdC5TdHJpbmdMaXRlcmFsfHx0PT09SnQuTnVtZXJpY0xpdGVyYWwpdWUmJmRlLm9jdGFsJiZXKGRlLG9lLlN0cmljdE9jdGFsTGl0ZXJhbCksbj1oZS5jcmVhdGVMaXRlcmFsKFUoKSk7ZWxzZSBpZih0PT09SnQuS2V5d29yZCl7aWYoSChcImZ1bmN0aW9uXCIpKXJldHVybiBxdCgpO0goXCJ0aGlzXCIpPyhVKCksbj1oZS5jcmVhdGVUaGlzRXhwcmVzc2lvbigpKTpYKFUoKSl9ZWxzZSB0PT09SnQuQm9vbGVhbkxpdGVyYWw/KGU9VSgpLGUudmFsdWU9XCJ0cnVlXCI9PT1lLnZhbHVlLG49aGUuY3JlYXRlTGl0ZXJhbChlKSk6dD09PUp0Lk51bGxMaXRlcmFsPyhlPVUoKSxlLnZhbHVlPW51bGwsbj1oZS5jcmVhdGVMaXRlcmFsKGUpKTpxKFwiL1wiKXx8cShcIi89XCIpPyhuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtZS50b2tlbnM/aGUuY3JlYXRlTGl0ZXJhbChDKCkpOmhlLmNyZWF0ZUxpdGVyYWwoQSgpKSxGKCkpOlgoVSgpKTtyZXR1cm4gaGUubWFya0VuZChuLHIpfWZ1bmN0aW9uIG90KCl7dmFyIHQ9W107aWYoeihcIihcIiksIXEoXCIpXCIpKWZvcig7bGU8cGUmJih0LnB1c2gobXQoKSksIXEoXCIpXCIpKTspeihcIixcIik7cmV0dXJuIHooXCIpXCIpLHR9ZnVuY3Rpb24gaXQoKXt2YXIgdCxlO3JldHVybiBlPWRlLHQ9VSgpLGsodCl8fFgodCksaGUubWFya0VuZChoZS5jcmVhdGVJZGVudGlmaWVyKHQudmFsdWUpLGUpfWZ1bmN0aW9uIGF0KCl7cmV0dXJuIHooXCIuXCIpLGl0KCl9ZnVuY3Rpb24gc3QoKXt2YXIgdDtyZXR1cm4geihcIltcIiksdD1fdCgpLHooXCJdXCIpLHR9ZnVuY3Rpb24gdXQoKXt2YXIgdCxlLG47cmV0dXJuIG49ZGUsRyhcIm5ld1wiKSx0PWN0KCksZT1xKFwiKFwiKT9vdCgpOltdLGhlLm1hcmtFbmQoaGUuY3JlYXRlTmV3RXhwcmVzc2lvbih0LGUpLG4pfWZ1bmN0aW9uIGx0KCl7dmFyIHQsZSxuLHIsbz12ZS5hbGxvd0luO2ZvcihyPWRlLHZlLmFsbG93SW49ITAsdD1IKFwibmV3XCIpP3V0KCk6cnQoKTs7KXtpZihxKFwiLlwiKSluPWF0KCksdD1oZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKFwiLlwiLHQsbik7ZWxzZSBpZihxKFwiKFwiKSllPW90KCksdD1oZS5jcmVhdGVDYWxsRXhwcmVzc2lvbih0LGUpO2Vsc2V7aWYoIXEoXCJbXCIpKWJyZWFrO249c3QoKSx0PWhlLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24oXCJbXCIsdCxuKX1oZS5tYXJrRW5kKHQscil9cmV0dXJuIHZlLmFsbG93SW49byx0fWZ1bmN0aW9uIGN0KCl7dmFyIHQsbixyO2ZvcihlKHZlLmFsbG93SW4sXCJjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuXCIpLHI9ZGUsdD1IKFwibmV3XCIpP3V0KCk6cnQoKTtxKFwiLlwiKXx8cShcIltcIik7KXEoXCJbXCIpPyhuPXN0KCksdD1oZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKFwiW1wiLHQsbikpOihuPWF0KCksdD1oZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKFwiLlwiLHQsbikpLGhlLm1hcmtFbmQodCxyKTtyZXR1cm4gdH1mdW5jdGlvbiBmdCgpe3ZhciB0LGUsbj1kZTtyZXR1cm4gdD1sdCgpLGRlLnR5cGU9PT1KdC5QdW5jdHVhdG9yJiYoIXEoXCIrK1wiKSYmIXEoXCItLVwiKXx8QigpfHwodWUmJnQudHlwZT09PW5lLklkZW50aWZpZXImJmYodC5uYW1lKSYmVyh7fSxvZS5TdHJpY3RMSFNQb3N0Zml4KSwkKHQpfHxXKHt9LG9lLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpLGU9VSgpLHQ9aGUubWFya0VuZChoZS5jcmVhdGVQb3N0Zml4RXhwcmVzc2lvbihlLnZhbHVlLHQpLG4pKSksdH1mdW5jdGlvbiBwdCgpe3ZhciB0LGUsbjtyZXR1cm4gZGUudHlwZSE9PUp0LlB1bmN0dWF0b3ImJmRlLnR5cGUhPT1KdC5LZXl3b3JkP2U9ZnQoKTpxKFwiKytcIil8fHEoXCItLVwiKT8obj1kZSx0PVUoKSxlPXB0KCksdWUmJmUudHlwZT09PW5lLklkZW50aWZpZXImJmYoZS5uYW1lKSYmVyh7fSxvZS5TdHJpY3RMSFNQcmVmaXgpLCQoZSl8fFcoe30sb2UuSW52YWxpZExIU0luQXNzaWdubWVudCksZT1oZS5jcmVhdGVVbmFyeUV4cHJlc3Npb24odC52YWx1ZSxlKSxlPWhlLm1hcmtFbmQoZSxuKSk6cShcIitcIil8fHEoXCItXCIpfHxxKFwiflwiKXx8cShcIiFcIik/KG49ZGUsdD1VKCksZT1wdCgpLGU9aGUuY3JlYXRlVW5hcnlFeHByZXNzaW9uKHQudmFsdWUsZSksZT1oZS5tYXJrRW5kKGUsbikpOkgoXCJkZWxldGVcIil8fEgoXCJ2b2lkXCIpfHxIKFwidHlwZW9mXCIpPyhuPWRlLHQ9VSgpLGU9cHQoKSxlPWhlLmNyZWF0ZVVuYXJ5RXhwcmVzc2lvbih0LnZhbHVlLGUpLGU9aGUubWFya0VuZChlLG4pLHVlJiZcImRlbGV0ZVwiPT09ZS5vcGVyYXRvciYmZS5hcmd1bWVudC50eXBlPT09bmUuSWRlbnRpZmllciYmVyh7fSxvZS5TdHJpY3REZWxldGUpKTplPWZ0KCksZX1mdW5jdGlvbiBodCh0LGUpe3ZhciBuPTA7aWYodC50eXBlIT09SnQuUHVuY3R1YXRvciYmdC50eXBlIT09SnQuS2V5d29yZClyZXR1cm4gMDtzd2l0Y2godC52YWx1ZSl7Y2FzZVwifHxcIjpuPTE7YnJlYWs7Y2FzZVwiJiZcIjpuPTI7YnJlYWs7Y2FzZVwifFwiOm49MzticmVhaztjYXNlXCJeXCI6bj00O2JyZWFrO2Nhc2VcIiZcIjpuPTU7YnJlYWs7Y2FzZVwiPT1cIjpjYXNlXCIhPVwiOmNhc2VcIj09PVwiOmNhc2VcIiE9PVwiOm49NjticmVhaztjYXNlXCI8XCI6Y2FzZVwiPlwiOmNhc2VcIjw9XCI6Y2FzZVwiPj1cIjpjYXNlXCJpbnN0YW5jZW9mXCI6bj03O2JyZWFrO2Nhc2VcImluXCI6bj1lPzc6MDticmVhaztjYXNlXCI8PFwiOmNhc2VcIj4+XCI6Y2FzZVwiPj4+XCI6bj04O2JyZWFrO2Nhc2VcIitcIjpjYXNlXCItXCI6bj05O2JyZWFrO2Nhc2VcIipcIjpjYXNlXCIvXCI6Y2FzZVwiJVwiOm49MTF9cmV0dXJuIG59ZnVuY3Rpb24gZHQoKXt2YXIgdCxlLG4scixvLGksYSxzLHUsbDtpZih0PWRlLHU9cHQoKSxyPWRlLG89aHQocix2ZS5hbGxvd0luKSwwPT09bylyZXR1cm4gdTtmb3Ioci5wcmVjPW8sVSgpLGU9W3QsZGVdLGE9cHQoKSxpPVt1LHIsYV07KG89aHQoZGUsdmUuYWxsb3dJbikpPjA7KXtmb3IoO2kubGVuZ3RoPjImJm88PWlbaS5sZW5ndGgtMl0ucHJlYzspYT1pLnBvcCgpLHM9aS5wb3AoKS52YWx1ZSx1PWkucG9wKCksbj1oZS5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKHMsdSxhKSxlLnBvcCgpLHQ9ZVtlLmxlbmd0aC0xXSxoZS5tYXJrRW5kKG4sdCksaS5wdXNoKG4pO3I9VSgpLHIucHJlYz1vLGkucHVzaChyKSxlLnB1c2goZGUpLG49cHQoKSxpLnB1c2gobil9Zm9yKGw9aS5sZW5ndGgtMSxuPWlbbF0sZS5wb3AoKTtsPjE7KW49aGUuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihpW2wtMV0udmFsdWUsaVtsLTJdLG4pLGwtPTIsdD1lLnBvcCgpLGhlLm1hcmtFbmQobix0KTtyZXR1cm4gbn1mdW5jdGlvbiB2dCgpe3ZhciB0LGUsbixyLG87cmV0dXJuIG89ZGUsdD1kdCgpLHEoXCI/XCIpJiYoVSgpLGU9dmUuYWxsb3dJbix2ZS5hbGxvd0luPSEwLG49bXQoKSx2ZS5hbGxvd0luPWUseihcIjpcIikscj1tdCgpLHQ9aGUuY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHQsbixyKSxoZS5tYXJrRW5kKHQsbykpLHR9ZnVuY3Rpb24gbXQoKXt2YXIgdCxlLG4scixvO3JldHVybiB0PWRlLG89ZGUscj1lPXZ0KCksWSgpJiYoJChlKXx8Vyh7fSxvZS5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KSx1ZSYmZS50eXBlPT09bmUuSWRlbnRpZmllciYmZihlLm5hbWUpJiZXKHQsb2UuU3RyaWN0TEhTQXNzaWdubWVudCksdD1VKCksbj1tdCgpLHI9aGUubWFya0VuZChoZS5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0LnZhbHVlLGUsbiksbykpLHJ9ZnVuY3Rpb24gX3QoKXt2YXIgdCxlPWRlO2lmKHQ9bXQoKSxxKFwiLFwiKSl7Zm9yKHQ9aGUuY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uKFt0XSk7bGU8cGUmJnEoXCIsXCIpOylVKCksdC5leHByZXNzaW9ucy5wdXNoKG10KCkpO2hlLm1hcmtFbmQodCxlKX1yZXR1cm4gdH1mdW5jdGlvbiBndCgpe2Zvcih2YXIgdCxlPVtdO2xlPHBlJiYhcShcIn1cIikmJih0PUh0KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQpOyllLnB1c2godCk7cmV0dXJuIGV9ZnVuY3Rpb24geXQoKXt2YXIgdCxlO3JldHVybiBlPWRlLHooXCJ7XCIpLHQ9Z3QoKSx6KFwifVwiKSxoZS5tYXJrRW5kKGhlLmNyZWF0ZUJsb2NrU3RhdGVtZW50KHQpLGUpfWZ1bmN0aW9uIGJ0KCl7dmFyIHQsZTtyZXR1cm4gZT1kZSx0PVUoKSx0LnR5cGUhPT1KdC5JZGVudGlmaWVyJiZYKHQpLGhlLm1hcmtFbmQoaGUuY3JlYXRlSWRlbnRpZmllcih0LnZhbHVlKSxlKX1mdW5jdGlvbiB3dCh0KXt2YXIgZSxuLHI9bnVsbDtyZXR1cm4gbj1kZSxlPWJ0KCksdWUmJmYoZS5uYW1lKSYmVyh7fSxvZS5TdHJpY3RWYXJOYW1lKSxcImNvbnN0XCI9PT10Pyh6KFwiPVwiKSxyPW10KCkpOnEoXCI9XCIpJiYoVSgpLHI9bXQoKSksaGUubWFya0VuZChoZS5jcmVhdGVWYXJpYWJsZURlY2xhcmF0b3IoZSxyKSxuKX1mdW5jdGlvbiB4dCh0KXt2YXIgZT1bXTtkb3tpZihlLnB1c2god3QodCkpLCFxKFwiLFwiKSlicmVhaztVKCl9d2hpbGUobGU8cGUpO3JldHVybiBlfWZ1bmN0aW9uIEV0KCl7dmFyIHQ7cmV0dXJuIEcoXCJ2YXJcIiksdD14dCgpLEsoKSxoZS5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHQsXCJ2YXJcIil9ZnVuY3Rpb24gVHQodCl7dmFyIGUsbjtyZXR1cm4gbj1kZSxHKHQpLGU9eHQodCksSygpLGhlLm1hcmtFbmQoaGUuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihlLHQpLG4pfWZ1bmN0aW9uIE90KCl7cmV0dXJuIHooXCI7XCIpLGhlLmNyZWF0ZUVtcHR5U3RhdGVtZW50KCl9ZnVuY3Rpb24gU3QoKXt2YXIgdD1fdCgpO3JldHVybiBLKCksaGUuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCh0KX1mdW5jdGlvbiBQdCgpe3ZhciB0LGUsbjtcbnJldHVybiBHKFwiaWZcIikseihcIihcIiksdD1fdCgpLHooXCIpXCIpLGU9V3QoKSxIKFwiZWxzZVwiKT8oVSgpLG49V3QoKSk6bj1udWxsLGhlLmNyZWF0ZUlmU3RhdGVtZW50KHQsZSxuKX1mdW5jdGlvbiBNdCgpe3ZhciB0LGUsbjtyZXR1cm4gRyhcImRvXCIpLG49dmUuaW5JdGVyYXRpb24sdmUuaW5JdGVyYXRpb249ITAsdD1XdCgpLHZlLmluSXRlcmF0aW9uPW4sRyhcIndoaWxlXCIpLHooXCIoXCIpLGU9X3QoKSx6KFwiKVwiKSxxKFwiO1wiKSYmVSgpLGhlLmNyZWF0ZURvV2hpbGVTdGF0ZW1lbnQodCxlKX1mdW5jdGlvbiBqdCgpe3ZhciB0LGUsbjtyZXR1cm4gRyhcIndoaWxlXCIpLHooXCIoXCIpLHQ9X3QoKSx6KFwiKVwiKSxuPXZlLmluSXRlcmF0aW9uLHZlLmluSXRlcmF0aW9uPSEwLGU9V3QoKSx2ZS5pbkl0ZXJhdGlvbj1uLGhlLmNyZWF0ZVdoaWxlU3RhdGVtZW50KHQsZSl9ZnVuY3Rpb24gQXQoKXt2YXIgdCxlLG47cmV0dXJuIG49ZGUsdD1VKCksZT14dCgpLGhlLm1hcmtFbmQoaGUuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihlLHQudmFsdWUpLG4pfWZ1bmN0aW9uIEN0KCl7dmFyIHQsZSxuLHIsbyxpLGEscz12ZS5hbGxvd0luO3JldHVybiB0PWU9bj1udWxsLEcoXCJmb3JcIikseihcIihcIikscShcIjtcIik/VSgpOihIKFwidmFyXCIpfHxIKFwibGV0XCIpPyh2ZS5hbGxvd0luPSExLHQ9QXQoKSx2ZS5hbGxvd0luPXMsMT09PXQuZGVjbGFyYXRpb25zLmxlbmd0aCYmSChcImluXCIpJiYoVSgpLHI9dCxvPV90KCksdD1udWxsKSk6KHZlLmFsbG93SW49ITEsdD1fdCgpLHZlLmFsbG93SW49cyxIKFwiaW5cIikmJigkKHQpfHxXKHt9LG9lLkludmFsaWRMSFNJbkZvckluKSxVKCkscj10LG89X3QoKSx0PW51bGwpKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgciYmeihcIjtcIikpLFwidW5kZWZpbmVkXCI9PXR5cGVvZiByJiYocShcIjtcIil8fChlPV90KCkpLHooXCI7XCIpLHEoXCIpXCIpfHwobj1fdCgpKSkseihcIilcIiksYT12ZS5pbkl0ZXJhdGlvbix2ZS5pbkl0ZXJhdGlvbj0hMCxpPVd0KCksdmUuaW5JdGVyYXRpb249YSxcInVuZGVmaW5lZFwiPT10eXBlb2Ygcj9oZS5jcmVhdGVGb3JTdGF0ZW1lbnQodCxlLG4saSk6aGUuY3JlYXRlRm9ySW5TdGF0ZW1lbnQocixvLGkpfWZ1bmN0aW9uIGt0KCl7dmFyIHQsZT1udWxsO3JldHVybiBHKFwiY29udGludWVcIiksNTk9PT1zZS5jaGFyQ29kZUF0KGxlKT8oVSgpLHZlLmluSXRlcmF0aW9ufHxWKHt9LG9lLklsbGVnYWxDb250aW51ZSksaGUuY3JlYXRlQ29udGludWVTdGF0ZW1lbnQobnVsbCkpOkIoKT8odmUuaW5JdGVyYXRpb258fFYoe30sb2UuSWxsZWdhbENvbnRpbnVlKSxoZS5jcmVhdGVDb250aW51ZVN0YXRlbWVudChudWxsKSk6KGRlLnR5cGU9PT1KdC5JZGVudGlmaWVyJiYoZT1idCgpLHQ9XCIkXCIrZS5uYW1lLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2ZS5sYWJlbFNldCx0KXx8Vih7fSxvZS5Vbmtub3duTGFiZWwsZS5uYW1lKSksSygpLG51bGwhPT1lfHx2ZS5pbkl0ZXJhdGlvbnx8Vih7fSxvZS5JbGxlZ2FsQ29udGludWUpLGhlLmNyZWF0ZUNvbnRpbnVlU3RhdGVtZW50KGUpKX1mdW5jdGlvbiBSdCgpe3ZhciB0LGU9bnVsbDtyZXR1cm4gRyhcImJyZWFrXCIpLDU5PT09c2UuY2hhckNvZGVBdChsZSk/KFUoKSx2ZS5pbkl0ZXJhdGlvbnx8dmUuaW5Td2l0Y2h8fFYoe30sb2UuSWxsZWdhbEJyZWFrKSxoZS5jcmVhdGVCcmVha1N0YXRlbWVudChudWxsKSk6QigpPyh2ZS5pbkl0ZXJhdGlvbnx8dmUuaW5Td2l0Y2h8fFYoe30sb2UuSWxsZWdhbEJyZWFrKSxoZS5jcmVhdGVCcmVha1N0YXRlbWVudChudWxsKSk6KGRlLnR5cGU9PT1KdC5JZGVudGlmaWVyJiYoZT1idCgpLHQ9XCIkXCIrZS5uYW1lLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2ZS5sYWJlbFNldCx0KXx8Vih7fSxvZS5Vbmtub3duTGFiZWwsZS5uYW1lKSksSygpLG51bGwhPT1lfHx2ZS5pbkl0ZXJhdGlvbnx8dmUuaW5Td2l0Y2h8fFYoe30sb2UuSWxsZWdhbEJyZWFrKSxoZS5jcmVhdGVCcmVha1N0YXRlbWVudChlKSl9ZnVuY3Rpb24gSXQoKXt2YXIgdD1udWxsO3JldHVybiBHKFwicmV0dXJuXCIpLHZlLmluRnVuY3Rpb25Cb2R5fHxXKHt9LG9lLklsbGVnYWxSZXR1cm4pLDMyPT09c2UuY2hhckNvZGVBdChsZSkmJnMoc2UuY2hhckNvZGVBdChsZSsxKSk/KHQ9X3QoKSxLKCksaGUuY3JlYXRlUmV0dXJuU3RhdGVtZW50KHQpKTpCKCk/aGUuY3JlYXRlUmV0dXJuU3RhdGVtZW50KG51bGwpOihxKFwiO1wiKXx8cShcIn1cIil8fGRlLnR5cGU9PT1KdC5FT0Z8fCh0PV90KCkpLEsoKSxoZS5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQodCkpfWZ1bmN0aW9uIE50KCl7dmFyIHQsZTtyZXR1cm4gdWUmJihtKCksVyh7fSxvZS5TdHJpY3RNb2RlV2l0aCkpLEcoXCJ3aXRoXCIpLHooXCIoXCIpLHQ9X3QoKSx6KFwiKVwiKSxlPVd0KCksaGUuY3JlYXRlV2l0aFN0YXRlbWVudCh0LGUpfWZ1bmN0aW9uIFV0KCl7dmFyIHQsZSxuLHI9W107Zm9yKG49ZGUsSChcImRlZmF1bHRcIik/KFUoKSx0PW51bGwpOihHKFwiY2FzZVwiKSx0PV90KCkpLHooXCI6XCIpO2xlPHBlJiYhKHEoXCJ9XCIpfHxIKFwiZGVmYXVsdFwiKXx8SChcImNhc2VcIikpOyllPVd0KCksci5wdXNoKGUpO3JldHVybiBoZS5tYXJrRW5kKGhlLmNyZWF0ZVN3aXRjaENhc2UodCxyKSxuKX1mdW5jdGlvbiBGdCgpe3ZhciB0LGUsbixyLG87aWYoRyhcInN3aXRjaFwiKSx6KFwiKFwiKSx0PV90KCkseihcIilcIikseihcIntcIiksZT1bXSxxKFwifVwiKSlyZXR1cm4gVSgpLGhlLmNyZWF0ZVN3aXRjaFN0YXRlbWVudCh0LGUpO2ZvcihyPXZlLmluU3dpdGNoLHZlLmluU3dpdGNoPSEwLG89ITE7bGU8cGUmJiFxKFwifVwiKTspbj1VdCgpLG51bGw9PT1uLnRlc3QmJihvJiZWKHt9LG9lLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCksbz0hMCksZS5wdXNoKG4pO3JldHVybiB2ZS5pblN3aXRjaD1yLHooXCJ9XCIpLGhlLmNyZWF0ZVN3aXRjaFN0YXRlbWVudCh0LGUpfWZ1bmN0aW9uIEx0KCl7dmFyIHQ7cmV0dXJuIEcoXCJ0aHJvd1wiKSxCKCkmJlYoe30sb2UuTmV3bGluZUFmdGVyVGhyb3cpLHQ9X3QoKSxLKCksaGUuY3JlYXRlVGhyb3dTdGF0ZW1lbnQodCl9ZnVuY3Rpb24gRHQoKXt2YXIgdCxlLG47cmV0dXJuIG49ZGUsRyhcImNhdGNoXCIpLHooXCIoXCIpLHEoXCIpXCIpJiZYKGRlKSx0PWJ0KCksdWUmJmYodC5uYW1lKSYmVyh7fSxvZS5TdHJpY3RDYXRjaFZhcmlhYmxlKSx6KFwiKVwiKSxlPXl0KCksaGUubWFya0VuZChoZS5jcmVhdGVDYXRjaENsYXVzZSh0LGUpLG4pfWZ1bmN0aW9uIEJ0KCl7dmFyIHQsZT1bXSxuPW51bGw7cmV0dXJuIEcoXCJ0cnlcIiksdD15dCgpLEgoXCJjYXRjaFwiKSYmZS5wdXNoKER0KCkpLEgoXCJmaW5hbGx5XCIpJiYoVSgpLG49eXQoKSksMCE9PWUubGVuZ3RofHxufHxWKHt9LG9lLk5vQ2F0Y2hPckZpbmFsbHkpLGhlLmNyZWF0ZVRyeVN0YXRlbWVudCh0LFtdLGUsbil9ZnVuY3Rpb24gVnQoKXtyZXR1cm4gRyhcImRlYnVnZ2VyXCIpLEsoKSxoZS5jcmVhdGVEZWJ1Z2dlclN0YXRlbWVudCgpfWZ1bmN0aW9uIFd0KCl7dmFyIHQsZSxuLHIsbz1kZS50eXBlO2lmKG89PT1KdC5FT0YmJlgoZGUpLG89PT1KdC5QdW5jdHVhdG9yJiZcIntcIj09PWRlLnZhbHVlKXJldHVybiB5dCgpO2lmKHI9ZGUsbz09PUp0LlB1bmN0dWF0b3Ipc3dpdGNoKGRlLnZhbHVlKXtjYXNlXCI7XCI6cmV0dXJuIGhlLm1hcmtFbmQoT3QoKSxyKTtjYXNlXCIoXCI6cmV0dXJuIGhlLm1hcmtFbmQoU3QoKSxyKX1pZihvPT09SnQuS2V5d29yZClzd2l0Y2goZGUudmFsdWUpe2Nhc2VcImJyZWFrXCI6cmV0dXJuIGhlLm1hcmtFbmQoUnQoKSxyKTtjYXNlXCJjb250aW51ZVwiOnJldHVybiBoZS5tYXJrRW5kKGt0KCkscik7Y2FzZVwiZGVidWdnZXJcIjpyZXR1cm4gaGUubWFya0VuZChWdCgpLHIpO2Nhc2VcImRvXCI6cmV0dXJuIGhlLm1hcmtFbmQoTXQoKSxyKTtjYXNlXCJmb3JcIjpyZXR1cm4gaGUubWFya0VuZChDdCgpLHIpO2Nhc2VcImZ1bmN0aW9uXCI6cmV0dXJuIGhlLm1hcmtFbmQoR3QoKSxyKTtjYXNlXCJpZlwiOnJldHVybiBoZS5tYXJrRW5kKFB0KCkscik7Y2FzZVwicmV0dXJuXCI6cmV0dXJuIGhlLm1hcmtFbmQoSXQoKSxyKTtjYXNlXCJzd2l0Y2hcIjpyZXR1cm4gaGUubWFya0VuZChGdCgpLHIpO2Nhc2VcInRocm93XCI6cmV0dXJuIGhlLm1hcmtFbmQoTHQoKSxyKTtjYXNlXCJ0cnlcIjpyZXR1cm4gaGUubWFya0VuZChCdCgpLHIpO2Nhc2VcInZhclwiOnJldHVybiBoZS5tYXJrRW5kKEV0KCkscik7Y2FzZVwid2hpbGVcIjpyZXR1cm4gaGUubWFya0VuZChqdCgpLHIpO2Nhc2VcIndpdGhcIjpyZXR1cm4gaGUubWFya0VuZChOdCgpLHIpfXJldHVybiB0PV90KCksdC50eXBlPT09bmUuSWRlbnRpZmllciYmcShcIjpcIik/KFUoKSxuPVwiJFwiK3QubmFtZSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmUubGFiZWxTZXQsbikmJlYoe30sb2UuUmVkZWNsYXJhdGlvbixcIkxhYmVsXCIsdC5uYW1lKSx2ZS5sYWJlbFNldFtuXT0hMCxlPVd0KCksZGVsZXRlIHZlLmxhYmVsU2V0W25dLGhlLm1hcmtFbmQoaGUuY3JlYXRlTGFiZWxlZFN0YXRlbWVudCh0LGUpLHIpKTooSygpLGhlLm1hcmtFbmQoaGUuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCh0KSxyKSl9ZnVuY3Rpb24gWHQoKXt2YXIgdCxlLG4scixvLGksYSxzLHUsbD1bXTtmb3IodT1kZSx6KFwie1wiKTtsZTxwZSYmZGUudHlwZT09PUp0LlN0cmluZ0xpdGVyYWwmJihlPWRlLHQ9SHQoKSxsLnB1c2godCksdC5leHByZXNzaW9uLnR5cGU9PT1uZS5MaXRlcmFsKTspbj1zZS5zbGljZShlLnN0YXJ0KzEsZS5lbmQtMSksXCJ1c2Ugc3RyaWN0XCI9PT1uPyh1ZT0hMCxyJiZXKHIsb2UuU3RyaWN0T2N0YWxMaXRlcmFsKSk6IXImJmUub2N0YWwmJihyPWUpO2ZvcihvPXZlLmxhYmVsU2V0LGk9dmUuaW5JdGVyYXRpb24sYT12ZS5pblN3aXRjaCxzPXZlLmluRnVuY3Rpb25Cb2R5LHZlLmxhYmVsU2V0PXt9LHZlLmluSXRlcmF0aW9uPSExLHZlLmluU3dpdGNoPSExLHZlLmluRnVuY3Rpb25Cb2R5PSEwO2xlPHBlJiYhcShcIn1cIikmJih0PUh0KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQpOylsLnB1c2godCk7cmV0dXJuIHooXCJ9XCIpLHZlLmxhYmVsU2V0PW8sdmUuaW5JdGVyYXRpb249aSx2ZS5pblN3aXRjaD1hLHZlLmluRnVuY3Rpb25Cb2R5PXMsaGUubWFya0VuZChoZS5jcmVhdGVCbG9ja1N0YXRlbWVudChsKSx1KX1mdW5jdGlvbiB6dCh0KXt2YXIgZSxuLHIsbyxpLGEscz1bXTtpZih6KFwiKFwiKSwhcShcIilcIikpZm9yKG89e307bGU8cGUmJihuPWRlLGU9YnQoKSxpPVwiJFwiK24udmFsdWUsdWU/KGYobi52YWx1ZSkmJihyPW4sYT1vZS5TdHJpY3RQYXJhbU5hbWUpLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLGkpJiYocj1uLGE9b2UuU3RyaWN0UGFyYW1EdXBlKSk6dHx8KGYobi52YWx1ZSk/KHQ9bixhPW9lLlN0cmljdFBhcmFtTmFtZSk6YyhuLnZhbHVlKT8odD1uLGE9b2UuU3RyaWN0UmVzZXJ2ZWRXb3JkKTpPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxpKSYmKHQ9bixhPW9lLlN0cmljdFBhcmFtRHVwZSkpLHMucHVzaChlKSxvW2ldPSEwLCFxKFwiKVwiKSk7KXooXCIsXCIpO3JldHVybiB6KFwiKVwiKSx7cGFyYW1zOnMsc3RyaWN0ZWQ6cixmaXJzdFJlc3RyaWN0ZWQ6dCxtZXNzYWdlOmF9fWZ1bmN0aW9uIEd0KCl7dmFyIHQsZSxuLHIsbyxpLGEscyx1LGw9W107cmV0dXJuIHU9ZGUsRyhcImZ1bmN0aW9uXCIpLG49ZGUsdD1idCgpLHVlP2Yobi52YWx1ZSkmJlcobixvZS5TdHJpY3RGdW5jdGlvbk5hbWUpOmYobi52YWx1ZSk/KGk9bixhPW9lLlN0cmljdEZ1bmN0aW9uTmFtZSk6YyhuLnZhbHVlKSYmKGk9bixhPW9lLlN0cmljdFJlc2VydmVkV29yZCksbz16dChpKSxsPW8ucGFyYW1zLHI9by5zdHJpY3RlZCxpPW8uZmlyc3RSZXN0cmljdGVkLG8ubWVzc2FnZSYmKGE9by5tZXNzYWdlKSxzPXVlLGU9WHQoKSx1ZSYmaSYmVihpLGEpLHVlJiZyJiZXKHIsYSksdWU9cyxoZS5tYXJrRW5kKGhlLmNyZWF0ZUZ1bmN0aW9uRGVjbGFyYXRpb24odCxsLFtdLGUpLHUpfWZ1bmN0aW9uIHF0KCl7dmFyIHQsZSxuLHIsbyxpLGEscyx1PW51bGwsbD1bXTtyZXR1cm4gcz1kZSxHKFwiZnVuY3Rpb25cIikscShcIihcIil8fCh0PWRlLHU9YnQoKSx1ZT9mKHQudmFsdWUpJiZXKHQsb2UuU3RyaWN0RnVuY3Rpb25OYW1lKTpmKHQudmFsdWUpPyhuPXQscj1vZS5TdHJpY3RGdW5jdGlvbk5hbWUpOmModC52YWx1ZSkmJihuPXQscj1vZS5TdHJpY3RSZXNlcnZlZFdvcmQpKSxvPXp0KG4pLGw9by5wYXJhbXMsZT1vLnN0cmljdGVkLG49by5maXJzdFJlc3RyaWN0ZWQsby5tZXNzYWdlJiYocj1vLm1lc3NhZ2UpLGE9dWUsaT1YdCgpLHVlJiZuJiZWKG4sciksdWUmJmUmJlcoZSxyKSx1ZT1hLGhlLm1hcmtFbmQoaGUuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHUsbCxbXSxpKSxzKX1mdW5jdGlvbiBIdCgpe2lmKGRlLnR5cGU9PT1KdC5LZXl3b3JkKXN3aXRjaChkZS52YWx1ZSl7Y2FzZVwiY29uc3RcIjpjYXNlXCJsZXRcIjpyZXR1cm4gVHQoZGUudmFsdWUpO2Nhc2VcImZ1bmN0aW9uXCI6cmV0dXJuIEd0KCk7ZGVmYXVsdDpyZXR1cm4gV3QoKX1pZihkZS50eXBlIT09SnQuRU9GKXJldHVybiBXdCgpfWZ1bmN0aW9uIFl0KCl7Zm9yKHZhciB0LGUsbixyLG89W107bGU8cGUmJihlPWRlLGUudHlwZT09PUp0LlN0cmluZ0xpdGVyYWwpJiYodD1IdCgpLG8ucHVzaCh0KSx0LmV4cHJlc3Npb24udHlwZT09PW5lLkxpdGVyYWwpOyluPXNlLnNsaWNlKGUuc3RhcnQrMSxlLmVuZC0xKSxcInVzZSBzdHJpY3RcIj09PW4/KHVlPSEwLHImJlcocixvZS5TdHJpY3RPY3RhbExpdGVyYWwpKTohciYmZS5vY3RhbCYmKHI9ZSk7Zm9yKDtsZTxwZSYmKHQ9SHQoKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgdCk7KW8ucHVzaCh0KTtyZXR1cm4gb31mdW5jdGlvbiBLdCgpe3ZhciB0LGU7cmV0dXJuIG0oKSxGKCksZT1kZSx1ZT0hMSx0PVl0KCksaGUubWFya0VuZChoZS5jcmVhdGVQcm9ncmFtKHQpLGUpfWZ1bmN0aW9uICR0KCl7dmFyIHQsZSxuLHI9W107Zm9yKHQ9MDt0PG1lLnRva2Vucy5sZW5ndGg7Kyt0KWU9bWUudG9rZW5zW3RdLG49e3R5cGU6ZS50eXBlLHZhbHVlOmUudmFsdWV9LG1lLnJhbmdlJiYobi5yYW5nZT1lLnJhbmdlKSxtZS5sb2MmJihuLmxvYz1lLmxvYyksci5wdXNoKG4pO21lLnRva2Vucz1yfWZ1bmN0aW9uIFp0KHQsZSl7dmFyIG4scixvO249U3RyaW5nLFwic3RyaW5nXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgU3RyaW5nfHwodD1uKHQpKSxoZT1hZSxzZT10LGxlPTAsY2U9c2UubGVuZ3RoPjA/MTowLGZlPTAscGU9c2UubGVuZ3RoLGRlPW51bGwsdmU9e2FsbG93SW46ITAsbGFiZWxTZXQ6e30saW5GdW5jdGlvbkJvZHk6ITEsaW5JdGVyYXRpb246ITEsaW5Td2l0Y2g6ITEsbGFzdENvbW1lbnRTdGFydDotMX0sbWU9e30sZT1lfHx7fSxlLnRva2Vucz0hMCxtZS50b2tlbnM9W10sbWUudG9rZW5pemU9ITAsbWUub3BlblBhcmVuVG9rZW49LTEsbWUub3BlbkN1cmx5VG9rZW49LTEsbWUucmFuZ2U9XCJib29sZWFuXCI9PXR5cGVvZiBlLnJhbmdlJiZlLnJhbmdlLG1lLmxvYz1cImJvb2xlYW5cIj09dHlwZW9mIGUubG9jJiZlLmxvYyxcImJvb2xlYW5cIj09dHlwZW9mIGUuY29tbWVudCYmZS5jb21tZW50JiYobWUuY29tbWVudHM9W10pLFwiYm9vbGVhblwiPT10eXBlb2YgZS50b2xlcmFudCYmZS50b2xlcmFudCYmKG1lLmVycm9ycz1bXSk7dHJ5e2lmKEYoKSxkZS50eXBlPT09SnQuRU9GKXJldHVybiBtZS50b2tlbnM7Zm9yKHI9VSgpO2RlLnR5cGUhPT1KdC5FT0Y7KXRyeXtyPVUoKX1jYXRjaCh0KXtpZihyPWRlLG1lLmVycm9ycyl7bWUuZXJyb3JzLnB1c2godCk7YnJlYWt9dGhyb3cgdH0kdCgpLG89bWUudG9rZW5zLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtZS5jb21tZW50cyYmKG8uY29tbWVudHM9bWUuY29tbWVudHMpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtZS5lcnJvcnMmJihvLmVycm9ycz1tZS5lcnJvcnMpfWNhdGNoKHQpe3Rocm93IHR9ZmluYWxseXttZT17fX1yZXR1cm4gb31mdW5jdGlvbiBRdCh0LGUpe3ZhciBuLHI7cj1TdHJpbmcsXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd8fCh0PXIodCkpLGhlPWFlLHNlPXQsbGU9MCxjZT1zZS5sZW5ndGg+MD8xOjAsZmU9MCxwZT1zZS5sZW5ndGgsZGU9bnVsbCx2ZT17YWxsb3dJbjohMCxsYWJlbFNldDp7fSxpbkZ1bmN0aW9uQm9keTohMSxpbkl0ZXJhdGlvbjohMSxpblN3aXRjaDohMSxsYXN0Q29tbWVudFN0YXJ0Oi0xfSxtZT17fSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZSYmKG1lLnJhbmdlPVwiYm9vbGVhblwiPT10eXBlb2YgZS5yYW5nZSYmZS5yYW5nZSxtZS5sb2M9XCJib29sZWFuXCI9PXR5cGVvZiBlLmxvYyYmZS5sb2MsbWUuYXR0YWNoQ29tbWVudD1cImJvb2xlYW5cIj09dHlwZW9mIGUuYXR0YWNoQ29tbWVudCYmZS5hdHRhY2hDb21tZW50LG1lLmxvYyYmbnVsbCE9PWUuc291cmNlJiZ2b2lkIDAhPT1lLnNvdXJjZSYmKG1lLnNvdXJjZT1yKGUuc291cmNlKSksXCJib29sZWFuXCI9PXR5cGVvZiBlLnRva2VucyYmZS50b2tlbnMmJihtZS50b2tlbnM9W10pLFwiYm9vbGVhblwiPT10eXBlb2YgZS5jb21tZW50JiZlLmNvbW1lbnQmJihtZS5jb21tZW50cz1bXSksXCJib29sZWFuXCI9PXR5cGVvZiBlLnRvbGVyYW50JiZlLnRvbGVyYW50JiYobWUuZXJyb3JzPVtdKSxtZS5hdHRhY2hDb21tZW50JiYobWUucmFuZ2U9ITAsbWUuY29tbWVudHM9W10sbWUuYm90dG9tUmlnaHRTdGFjaz1bXSxtZS50cmFpbGluZ0NvbW1lbnRzPVtdLG1lLmxlYWRpbmdDb21tZW50cz1bXSkpO3RyeXtuPUt0KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1lLmNvbW1lbnRzJiYobi5jb21tZW50cz1tZS5jb21tZW50cyksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1lLnRva2VucyYmKCR0KCksbi50b2tlbnM9bWUudG9rZW5zKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgbWUuZXJyb3JzJiYobi5lcnJvcnM9bWUuZXJyb3JzKX1jYXRjaCh0KXt0aHJvdyB0fWZpbmFsbHl7bWU9e319cmV0dXJuIG59dmFyIEp0LHRlLGVlLG5lLHJlLG9lLGllLGFlLHNlLHVlLGxlLGNlLGZlLHBlLGhlLGRlLHZlLG1lO0p0PXtCb29sZWFuTGl0ZXJhbDoxLEVPRjoyLElkZW50aWZpZXI6MyxLZXl3b3JkOjQsTnVsbExpdGVyYWw6NSxOdW1lcmljTGl0ZXJhbDo2LFB1bmN0dWF0b3I6NyxTdHJpbmdMaXRlcmFsOjgsUmVndWxhckV4cHJlc3Npb246OX0sdGU9e30sdGVbSnQuQm9vbGVhbkxpdGVyYWxdPVwiQm9vbGVhblwiLHRlW0p0LkVPRl09XCI8ZW5kPlwiLHRlW0p0LklkZW50aWZpZXJdPVwiSWRlbnRpZmllclwiLHRlW0p0LktleXdvcmRdPVwiS2V5d29yZFwiLHRlW0p0Lk51bGxMaXRlcmFsXT1cIk51bGxcIix0ZVtKdC5OdW1lcmljTGl0ZXJhbF09XCJOdW1lcmljXCIsdGVbSnQuUHVuY3R1YXRvcl09XCJQdW5jdHVhdG9yXCIsdGVbSnQuU3RyaW5nTGl0ZXJhbF09XCJTdHJpbmdcIix0ZVtKdC5SZWd1bGFyRXhwcmVzc2lvbl09XCJSZWd1bGFyRXhwcmVzc2lvblwiLGVlPVtcIihcIixcIntcIixcIltcIixcImluXCIsXCJ0eXBlb2ZcIixcImluc3RhbmNlb2ZcIixcIm5ld1wiLFwicmV0dXJuXCIsXCJjYXNlXCIsXCJkZWxldGVcIixcInRocm93XCIsXCJ2b2lkXCIsXCI9XCIsXCIrPVwiLFwiLT1cIixcIio9XCIsXCIvPVwiLFwiJT1cIixcIjw8PVwiLFwiPj49XCIsXCI+Pj49XCIsXCImPVwiLFwifD1cIixcIl49XCIsXCIsXCIsXCIrXCIsXCItXCIsXCIqXCIsXCIvXCIsXCIlXCIsXCIrK1wiLFwiLS1cIixcIjw8XCIsXCI+PlwiLFwiPj4+XCIsXCImXCIsXCJ8XCIsXCJeXCIsXCIhXCIsXCJ+XCIsXCImJlwiLFwifHxcIixcIj9cIixcIjpcIixcIj09PVwiLFwiPT1cIixcIj49XCIsXCI8PVwiLFwiPFwiLFwiPlwiLFwiIT1cIixcIiE9PVwiXSxuZT17QXNzaWdubWVudEV4cHJlc3Npb246XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLEFycmF5RXhwcmVzc2lvbjpcIkFycmF5RXhwcmVzc2lvblwiLEJsb2NrU3RhdGVtZW50OlwiQmxvY2tTdGF0ZW1lbnRcIixCaW5hcnlFeHByZXNzaW9uOlwiQmluYXJ5RXhwcmVzc2lvblwiLEJyZWFrU3RhdGVtZW50OlwiQnJlYWtTdGF0ZW1lbnRcIixDYWxsRXhwcmVzc2lvbjpcIkNhbGxFeHByZXNzaW9uXCIsQ2F0Y2hDbGF1c2U6XCJDYXRjaENsYXVzZVwiLENvbmRpdGlvbmFsRXhwcmVzc2lvbjpcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLENvbnRpbnVlU3RhdGVtZW50OlwiQ29udGludWVTdGF0ZW1lbnRcIixEb1doaWxlU3RhdGVtZW50OlwiRG9XaGlsZVN0YXRlbWVudFwiLERlYnVnZ2VyU3RhdGVtZW50OlwiRGVidWdnZXJTdGF0ZW1lbnRcIixFbXB0eVN0YXRlbWVudDpcIkVtcHR5U3RhdGVtZW50XCIsRXhwcmVzc2lvblN0YXRlbWVudDpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixGb3JTdGF0ZW1lbnQ6XCJGb3JTdGF0ZW1lbnRcIixGb3JJblN0YXRlbWVudDpcIkZvckluU3RhdGVtZW50XCIsRnVuY3Rpb25EZWNsYXJhdGlvbjpcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixGdW5jdGlvbkV4cHJlc3Npb246XCJGdW5jdGlvbkV4cHJlc3Npb25cIixJZGVudGlmaWVyOlwiSWRlbnRpZmllclwiLElmU3RhdGVtZW50OlwiSWZTdGF0ZW1lbnRcIixMaXRlcmFsOlwiTGl0ZXJhbFwiLExhYmVsZWRTdGF0ZW1lbnQ6XCJMYWJlbGVkU3RhdGVtZW50XCIsTG9naWNhbEV4cHJlc3Npb246XCJMb2dpY2FsRXhwcmVzc2lvblwiLE1lbWJlckV4cHJlc3Npb246XCJNZW1iZXJFeHByZXNzaW9uXCIsTmV3RXhwcmVzc2lvbjpcIk5ld0V4cHJlc3Npb25cIixPYmplY3RFeHByZXNzaW9uOlwiT2JqZWN0RXhwcmVzc2lvblwiLFByb2dyYW06XCJQcm9ncmFtXCIsUHJvcGVydHk6XCJQcm9wZXJ0eVwiLFJldHVyblN0YXRlbWVudDpcIlJldHVyblN0YXRlbWVudFwiLFNlcXVlbmNlRXhwcmVzc2lvbjpcIlNlcXVlbmNlRXhwcmVzc2lvblwiLFN3aXRjaFN0YXRlbWVudDpcIlN3aXRjaFN0YXRlbWVudFwiLFN3aXRjaENhc2U6XCJTd2l0Y2hDYXNlXCIsVGhpc0V4cHJlc3Npb246XCJUaGlzRXhwcmVzc2lvblwiLFRocm93U3RhdGVtZW50OlwiVGhyb3dTdGF0ZW1lbnRcIixUcnlTdGF0ZW1lbnQ6XCJUcnlTdGF0ZW1lbnRcIixVbmFyeUV4cHJlc3Npb246XCJVbmFyeUV4cHJlc3Npb25cIixVcGRhdGVFeHByZXNzaW9uOlwiVXBkYXRlRXhwcmVzc2lvblwiLFZhcmlhYmxlRGVjbGFyYXRpb246XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsVmFyaWFibGVEZWNsYXJhdG9yOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsV2hpbGVTdGF0ZW1lbnQ6XCJXaGlsZVN0YXRlbWVudFwiLFdpdGhTdGF0ZW1lbnQ6XCJXaXRoU3RhdGVtZW50XCJ9LHJlPXtEYXRhOjEsR2V0OjIsU2V0OjR9LG9lPXtVbmV4cGVjdGVkVG9rZW46XCJVbmV4cGVjdGVkIHRva2VuICUwXCIsVW5leHBlY3RlZE51bWJlcjpcIlVuZXhwZWN0ZWQgbnVtYmVyXCIsVW5leHBlY3RlZFN0cmluZzpcIlVuZXhwZWN0ZWQgc3RyaW5nXCIsVW5leHBlY3RlZElkZW50aWZpZXI6XCJVbmV4cGVjdGVkIGlkZW50aWZpZXJcIixVbmV4cGVjdGVkUmVzZXJ2ZWQ6XCJVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmRcIixVbmV4cGVjdGVkRU9TOlwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIixOZXdsaW5lQWZ0ZXJUaHJvdzpcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiLEludmFsaWRSZWdFeHA6XCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvblwiLFVudGVybWluYXRlZFJlZ0V4cDpcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC9cIixJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OlwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50XCIsSW52YWxpZExIU0luRm9ySW46XCJJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pblwiLE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDpcIk1vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudFwiLE5vQ2F0Y2hPckZpbmFsbHk6XCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5XCIsVW5rbm93bkxhYmVsOlwiVW5kZWZpbmVkIGxhYmVsICclMCdcIixSZWRlY2xhcmF0aW9uOlwiJTAgJyUxJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIsSWxsZWdhbENvbnRpbnVlOlwiSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnRcIixJbGxlZ2FsQnJlYWs6XCJJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudFwiLElsbGVnYWxSZXR1cm46XCJJbGxlZ2FsIHJldHVybiBzdGF0ZW1lbnRcIixTdHJpY3RNb2RlV2l0aDpcIlN0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnRcIixTdHJpY3RDYXRjaFZhcmlhYmxlOlwiQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZVwiLFN0cmljdFZhck5hbWU6XCJWYXJpYWJsZSBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGVcIixTdHJpY3RQYXJhbU5hbWU6XCJQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZVwiLFN0cmljdFBhcmFtRHVwZTpcIlN0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzXCIsU3RyaWN0RnVuY3Rpb25OYW1lOlwiRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlXCIsU3RyaWN0T2N0YWxMaXRlcmFsOlwiT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLlwiLFN0cmljdERlbGV0ZTpcIkRlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLlwiLFN0cmljdER1cGxpY2F0ZVByb3BlcnR5OlwiRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGVcIixBY2Nlc3NvckRhdGFQcm9wZXJ0eTpcIk9iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBkYXRhIGFuZCBhY2Nlc3NvciBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWVcIixBY2Nlc3NvckdldFNldDpcIk9iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBtdWx0aXBsZSBnZXQvc2V0IGFjY2Vzc29ycyB3aXRoIHRoZSBzYW1lIG5hbWVcIixTdHJpY3RMSFNBc3NpZ25tZW50OlwiQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZVwiLFN0cmljdExIU1Bvc3RmaXg6XCJQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGVcIixTdHJpY3RMSFNQcmVmaXg6XCJQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZVwiLFN0cmljdFJlc2VydmVkV29yZDpcIlVzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZVwifSxpZT17Tm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6bmV3IFJlZ0V4cChcIlvCqsK1wrrDgC3DlsOYLcO2w7gty4HLhi3LkcugLcuky6zLrs2wLc20zbbNt826Lc29zobOiC3Ois6Mzo4tzqHOoy3Ptc+3LdKB0oot1KfUsS3VltWZ1aEt1ofXkC3XqtewLdey2KAt2YrZrtmv2bEt25Pbldul26bbrtuv27ot27zbv9yQ3JIt3K/djS3epd6x34ot36rftN+137rgoIAt4KCV4KCa4KCk4KCo4KGALeChmOCioOCioi3goqzgpIQt4KS54KS94KWQ4KWYLeCloeClsS3gpbfgpbkt4KW/4KaFLeCmjOCmj+CmkOCmky3gpqjgpqot4Kaw4Kay4Ka2LeCmueCmveCnjuCnnOCnneCnny3gp6Hgp7Dgp7HgqIUt4KiK4KiP4KiQ4KiTLeCoqOCoqi3gqLDgqLLgqLPgqLXgqLbgqLjgqLngqZkt4Kmc4Kme4KmyLeCptOCqhS3gqo3gqo8t4KqR4KqTLeCqqOCqqi3gqrDgqrLgqrPgqrUt4Kq54Kq94KuQ4Kug4Kuh4KyFLeCsjOCsj+CskOCsky3grKjgrKot4Kyw4Kyy4Kyz4Ky1LeCsueCsveCtnOCtneCtny3graHgrbHgroPgroUt4K6K4K6OLeCukOCuki3grpXgrpngrprgrpzgrp7grp/grqPgrqTgrqgt4K6q4K6uLeCuueCvkOCwhS3gsIzgsI4t4LCQ4LCSLeCwqOCwqi3gsLPgsLUt4LC54LC94LGY4LGZ4LGg4LGh4LKFLeCyjOCyji3gspDgspIt4LKo4LKqLeCys+CytS3gsrngsr3gs57gs6Dgs6Hgs7Hgs7LgtIUt4LSM4LSOLeC0kOC0ki3gtLrgtL3gtY7gtaDgtaHgtbot4LW/4LaFLeC2luC2mi3gtrHgtrMt4La74La94LeALeC3huC4gS3guLDguLLguLPguYAt4LmG4LqB4LqC4LqE4LqH4LqI4LqK4LqN4LqULeC6l+C6mS3gup/guqEt4Lqj4Lql4Lqn4Lqq4Lqr4LqtLeC6sOC6suC6s+C6veC7gC3gu4Tgu4bgu5wt4Luf4LyA4L2ALeC9h+C9iS3gvazgvogt4L6M4YCALeGAquGAv+GBkC3hgZXhgZot4YGd4YGh4YGl4YGm4YGuLeGBsOGBtS3hgoHhgo7hgqAt4YOF4YOH4YON4YOQLeGDuuGDvC3hiYjhiYot4YmN4YmQLeGJluGJmOGJmi3hiZ3hiaAt4YqI4YqKLeGKjeGKkC3hirDhirIt4Yq14Yq4LeGKvuGLgOGLgi3hi4Xhi4gt4YuW4YuYLeGMkOGMki3hjJXhjJgt4Y2a4Y6ALeGOj+GOoC3hj7ThkIEt4Zms4ZmvLeGZv+GagS3hmprhmqAt4Zuq4ZuuLeGbsOGcgC3hnIzhnI4t4ZyR4ZygLeGcseGdgC3hnZHhnaAt4Z2s4Z2uLeGdsOGegC3hnrPhn5fhn5zhoKAt4aG34aKALeGiqOGiquGisC3ho7XhpIAt4aSc4aWQLeGlreGlsC3hpbThpoAt4aar4aeBLeGnh+GogC3hqJbhqKAt4amU4aqn4ayFLeGss+GthS3hrYvhroMt4a6g4a6u4a6v4a66LeGvpeGwgC3hsKPhsY0t4bGP4bGaLeGxveGzqS3hs6zhs64t4bOx4bO14bO24bSALeG2v+G4gC3hvJXhvJgt4byd4bygLeG9heG9iC3hvY3hvZAt4b2X4b2Z4b2b4b2d4b2fLeG9veG+gC3hvrThvrYt4b684b6+4b+CLeG/hOG/hi3hv4zhv5At4b+T4b+WLeG/m+G/oC3hv6zhv7It4b+04b+2LeG/vOKBseKBv+KCkC3igpzihILihIfihIot4oST4oSV4oSZLeKEneKEpOKEpuKEqOKEqi3ihK3ihK8t4oS54oS8LeKEv+KFhS3ihYnihY7ihaAt4oaI4rCALeKwruKwsC3isZ7isaAt4rOk4rOrLeKzruKzsuKzs+K0gC3itKXitKfitK3itLAt4rWn4rWv4raALeK2luK2oC3itqbitqgt4rau4rawLeK2tuK2uC3itr7it4At4reG4reILeK3juK3kC3it5bit5gt4ree4riv44CFLeOAh+OAoS3jgKnjgLEt44C144C4LeOAvOOBgS3jgpbjgp0t44Kf44KhLeODuuODvC3jg7/jhIUt44St44SxLeOGjuOGoC3jhrrjh7At44e/45CALeS2teS4gC3pv4zqgIAt6pKM6pOQLeqTveqUgC3qmIzqmJAt6pif6piq6pir6pmALeqZruqZvy3qmpfqmqAt6puv6pyXLeqcn+qcoi3qnojqnost6p6O6p6QLeqek+qeoC3qnqrqn7gt6qCB6qCDLeqgheqghy3qoIrqoIwt6qCi6qGALeqhs+qigi3qorPqo7It6qO36qO76qSKLeqkpeqksC3qpYbqpaAt6qW86qaELeqmsuqnj+qogC3qqKjqqYAt6qmC6qmELeqpi+qpoC3qqbbqqbrqqoAt6qqv6qqx6qq16qq26qq5LeqqveqrgOqrguqrmy3qq53qq6At6quq6quyLeqrtOqsgS3qrIbqrIkt6qyO6qyRLeqsluqsoC3qrKbqrKgt6qyu6q+ALeqvouqwgC3tnqPtnrAt7Z+G7Z+LLe2fu++kgC3vqa3vqbAt76uZ76yALe+shu+sky3vrJfvrJ3vrJ8t76yo76yqLe+stu+suC3vrLzvrL7vrYDvrYHvrYPvrYTvrYYt766x76+TLe+0ve+1kC3vto/vtpIt77eH77ewLe+3u++5sC3vubTvubYt77u877yhLe+8uu+9gS3vvZrvvaYt776+77+CLe+/h++/ii3vv4/vv5It77+X77+aLe+/nF1cIiksTm9uQXNjaWlJZGVudGlmaWVyUGFydDpuZXcgUmVnRXhwKFwiW8KqwrXCusOALcOWw5gtw7bDuC3LgcuGLcuRy6Aty6TLrMuuzIAtzbTNts23zbotzb3Ohs6ILc6KzozOji3Ooc6jLc+1z7ct0oHSgy3Sh9KKLdSn1LEt1ZbVmdWhLdaH1pEt1r3Wv9eB14LXhNeF14fXkC3XqtewLdey2JAt2JrYoC3ZqdmuLduT25Ut25zbny3bqNuqLdu827/ckC3dit2NLd6x34At37XfuuCggC3goK3goYAt4KGb4KKg4KKiLeCirOCjpC3go77gpIAt4KWj4KWmLeClr+ClsS3gpbfgpbkt4KW/4KaBLeCmg+CmhS3gpozgpo/gppDgppMt4Kao4KaqLeCmsOCmsuCmti3gprngprwt4KeE4KeH4KeI4KeLLeCnjuCnl+CnnOCnneCnny3gp6Pgp6Yt4Kex4KiBLeCog+CohS3gqIrgqI/gqJDgqJMt4Kio4KiqLeCosOCosuCos+CoteCotuCouOCoueCovOCovi3gqYLgqYfgqYjgqYst4KmN4KmR4KmZLeCpnOCpnuCppi3gqbXgqoEt4KqD4KqFLeCqjeCqjy3gqpHgqpMt4Kqo4KqqLeCqsOCqsuCqs+CqtS3gqrngqrwt4KuF4KuHLeCrieCriy3gq43gq5Dgq6At4Kuj4KumLeCrr+CsgS3grIPgrIUt4KyM4KyP4KyQ4KyTLeCsqOCsqi3grLDgrLLgrLPgrLUt4Ky54Ky8LeCthOCth+CtiOCtiy3grY3grZbgrZfgrZzgrZ3grZ8t4K2j4K2mLeCtr+CtseCuguCug+CuhS3grorgro4t4K6Q4K6SLeCuleCumeCumuCunOCunuCun+Cuo+CupOCuqC3grqrgrq4t4K654K6+LeCvguCvhi3gr4jgr4ot4K+N4K+Q4K+X4K+mLeCvr+CwgS3gsIPgsIUt4LCM4LCOLeCwkOCwki3gsKjgsKot4LCz4LC1LeCwueCwvS3gsYTgsYYt4LGI4LGKLeCxjeCxleCxluCxmOCxmeCxoC3gsaPgsaYt4LGv4LKC4LKD4LKFLeCyjOCyji3gspDgspIt4LKo4LKqLeCys+CytS3gsrngsrwt4LOE4LOGLeCziOCzii3gs43gs5Xgs5bgs57gs6At4LOj4LOmLeCzr+CzseCzsuC0guC0g+C0hS3gtIzgtI4t4LSQ4LSSLeC0uuC0vS3gtYTgtYYt4LWI4LWKLeC1juC1l+C1oC3gtaPgtaYt4LWv4LW6LeC1v+C2guC2g+C2hS3gtpbgtpot4Lax4LazLeC2u+C2veC3gC3gt4bgt4rgt48t4LeU4LeW4LeYLeC3n+C3suC3s+C4gS3guLrguYAt4LmO4LmQLeC5meC6geC6guC6hOC6h+C6iOC6iuC6jeC6lC3gupfgupkt4Lqf4LqhLeC6o+C6peC6p+C6quC6q+C6rS3gurngurst4Lq94LuALeC7hOC7huC7iC3gu43gu5At4LuZ4LucLeC7n+C8gOC8mOC8meC8oC3gvKngvLXgvLfgvLngvL4t4L2H4L2JLeC9rOC9sS3gvoTgvoYt4L6X4L6ZLeC+vOC/huGAgC3hgYnhgZAt4YKd4YKgLeGDheGDh+GDjeGDkC3hg7rhg7wt4YmI4YmKLeGJjeGJkC3hiZbhiZjhiZot4Ymd4YmgLeGKiOGKii3hio3hipAt4Yqw4YqyLeGKteGKuC3hir7hi4Dhi4It4YuF4YuILeGLluGLmC3hjJDhjJIt4YyV4YyYLeGNmuGNnS3hjZ/hjoAt4Y6P4Y6gLeGPtOGQgS3hmazhma8t4Zm/4ZqBLeGamuGaoC3hm6rhm64t4Zuw4ZyALeGcjOGcji3hnJThnKAt4Zy04Z2ALeGdk+GdoC3hnazhna4t4Z2w4Z2y4Z2z4Z6ALeGfk+Gfl+GfnOGfneGfoC3hn6nhoIst4aCN4aCQLeGgmeGgoC3hobfhooAt4aKq4aKwLeGjteGkgC3hpJzhpKAt4aSr4aSwLeGku+Glhi3hpa3hpbAt4aW04aaALeGmq+GmsC3hp4nhp5At4aeZ4aiALeGom+GooC3hqZ7hqaAt4am84am/LeGqieGqkC3hqpnhqqfhrIAt4a2L4a2QLeGtmeGtqy3hrbPhroAt4a+z4bCALeGwt+GxgC3hsYnhsY0t4bG94bOQLeGzkuGzlC3hs7bhtIAt4bem4be8LeG8leG8mC3hvJ3hvKAt4b2F4b2ILeG9jeG9kC3hvZfhvZnhvZvhvZ3hvZ8t4b294b6ALeG+tOG+ti3hvrzhvr7hv4It4b+E4b+GLeG/jOG/kC3hv5Phv5Yt4b+b4b+gLeG/rOG/si3hv7Thv7Yt4b+84oCM4oCN4oC/4oGA4oGU4oGx4oG/4oKQLeKCnOKDkC3ig5zig6Hig6Ut4oOw4oSC4oSH4oSKLeKEk+KEleKEmS3ihJ3ihKTihKbihKjihKot4oSt4oSvLeKEueKEvC3ihL/ihYUt4oWJ4oWO4oWgLeKGiOKwgC3isK7isLAt4rGe4rGgLeKzpOKzqy3is7PitIAt4rSl4rSn4rSt4rSwLeK1p+K1r+K1vy3itpbitqAt4ram4raoLeK2ruK2sC3itrbitrgt4ra+4reALeK3huK3iC3it47it5At4reW4reYLeK3nuK3oC3it7/iuK/jgIUt44CH44ChLeOAr+OAsS3jgLXjgLgt44C844GBLeOCluOCmeOCmuOCnS3jgp/jgqEt44O644O8LeODv+OEhS3jhK3jhLEt44aO44agLeOGuuOHsC3jh7/jkIAt5La15LiALem/jOqAgC3qkozqk5At6pO96pSALeqYjOqYkC3qmKvqmYAt6pmv6pm0LeqZveqZvy3qmpfqmp8t6pux6pyXLeqcn+qcoi3qnojqnost6p6O6p6QLeqek+qeoC3qnqrqn7gt6qCn6qGALeqhs+qigC3qo4Tqo5At6qOZ6qOgLeqjt+qju+qkgC3qpK3qpLAt6qWT6qWgLeqlvOqmgC3qp4Dqp48t6qeZ6qiALeqotuqpgC3qqY3qqZAt6qmZ6qmgLeqptuqpuuqpu+qqgC3qq4Lqq5st6qud6qugLeqrr+qrsi3qq7bqrIEt6qyG6qyJLeqsjuqskS3qrJbqrKAt6qym6qyoLeqsruqvgC3qr6rqr6zqr63qr7At6q+56rCALe2eo+2esC3tn4btn4st7Z+776SALe+pre+psC3vq5nvrIAt76yG76yTLe+sl++snS3vrKjvrKot76y276y4Le+svO+svu+tgO+tge+tg++thO+thi3vrrHvr5Mt77S977WQLe+2j++2ki3vt4fvt7At77e777iALe+4j++4oC3vuKbvuLPvuLTvuY0t77mP77mwLe+5tO+5ti3vu7zvvJAt77yZ77yhLe+8uu+8v++9gS3vvZrvvaYt776+77+CLe+/h++/ii3vv4/vv5It77+X77+aLe+/nF1cIil9LGFlPXtuYW1lOlwiU3ludGF4VHJlZVwiLHByb2Nlc3NDb21tZW50OmZ1bmN0aW9uKHQpe3ZhciBlLG47aWYoISh0LnR5cGU9PT1uZS5Qcm9ncmFtJiZ0LmJvZHkubGVuZ3RoPjApKXtmb3IobWUudHJhaWxpbmdDb21tZW50cy5sZW5ndGg+MD9tZS50cmFpbGluZ0NvbW1lbnRzWzBdLnJhbmdlWzBdPj10LnJhbmdlWzFdPyhuPW1lLnRyYWlsaW5nQ29tbWVudHMsbWUudHJhaWxpbmdDb21tZW50cz1bXSk6bWUudHJhaWxpbmdDb21tZW50cy5sZW5ndGg9MDptZS5ib3R0b21SaWdodFN0YWNrLmxlbmd0aD4wJiZtZS5ib3R0b21SaWdodFN0YWNrW21lLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoLTFdLnRyYWlsaW5nQ29tbWVudHMmJm1lLmJvdHRvbVJpZ2h0U3RhY2tbbWUuYm90dG9tUmlnaHRTdGFjay5sZW5ndGgtMV0udHJhaWxpbmdDb21tZW50c1swXS5yYW5nZVswXT49dC5yYW5nZVsxXSYmKG49bWUuYm90dG9tUmlnaHRTdGFja1ttZS5ib3R0b21SaWdodFN0YWNrLmxlbmd0aC0xXS50cmFpbGluZ0NvbW1lbnRzLGRlbGV0ZSBtZS5ib3R0b21SaWdodFN0YWNrW21lLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoLTFdLnRyYWlsaW5nQ29tbWVudHMpO21lLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoPjAmJm1lLmJvdHRvbVJpZ2h0U3RhY2tbbWUuYm90dG9tUmlnaHRTdGFjay5sZW5ndGgtMV0ucmFuZ2VbMF0+PXQucmFuZ2VbMF07KWU9bWUuYm90dG9tUmlnaHRTdGFjay5wb3AoKTtlP2UubGVhZGluZ0NvbW1lbnRzJiZlLmxlYWRpbmdDb21tZW50c1tlLmxlYWRpbmdDb21tZW50cy5sZW5ndGgtMV0ucmFuZ2VbMV08PXQucmFuZ2VbMF0mJih0LmxlYWRpbmdDb21tZW50cz1lLmxlYWRpbmdDb21tZW50cyxkZWxldGUgZS5sZWFkaW5nQ29tbWVudHMpOm1lLmxlYWRpbmdDb21tZW50cy5sZW5ndGg+MCYmbWUubGVhZGluZ0NvbW1lbnRzW21lLmxlYWRpbmdDb21tZW50cy5sZW5ndGgtMV0ucmFuZ2VbMV08PXQucmFuZ2VbMF0mJih0LmxlYWRpbmdDb21tZW50cz1tZS5sZWFkaW5nQ29tbWVudHMsbWUubGVhZGluZ0NvbW1lbnRzPVtdKSxuJiYodC50cmFpbGluZ0NvbW1lbnRzPW4pLG1lLmJvdHRvbVJpZ2h0U3RhY2sucHVzaCh0KX19LG1hcmtFbmQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbWUucmFuZ2UmJih0LnJhbmdlPVtlLnN0YXJ0LGxlXSksbWUubG9jJiYodC5sb2M9bmV3IEQodm9pZCAwPT09ZS5zdGFydExpbmVOdW1iZXI/ZS5saW5lTnVtYmVyOmUuc3RhcnRMaW5lTnVtYmVyLGUuc3RhcnQtKHZvaWQgMD09PWUuc3RhcnRMaW5lU3RhcnQ/ZS5saW5lU3RhcnQ6ZS5zdGFydExpbmVTdGFydCksY2UsbGUtZmUpLHRoaXMucG9zdFByb2Nlc3ModCkpLG1lLmF0dGFjaENvbW1lbnQmJnRoaXMucHJvY2Vzc0NvbW1lbnQodCksdH0scG9zdFByb2Nlc3M6ZnVuY3Rpb24odCl7cmV0dXJuIG1lLnNvdXJjZSYmKHQubG9jLnNvdXJjZT1tZS5zb3VyY2UpLHR9LGNyZWF0ZUFycmF5RXhwcmVzc2lvbjpmdW5jdGlvbih0KXtyZXR1cm57dHlwZTpuZS5BcnJheUV4cHJlc3Npb24sZWxlbWVudHM6dH19LGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm57dHlwZTpuZS5Bc3NpZ25tZW50RXhwcmVzc2lvbixvcGVyYXRvcjp0LGxlZnQ6ZSxyaWdodDpufX0sY3JlYXRlQmluYXJ5RXhwcmVzc2lvbjpmdW5jdGlvbih0LGUsbil7dmFyIHI9XCJ8fFwiPT09dHx8XCImJlwiPT09dD9uZS5Mb2dpY2FsRXhwcmVzc2lvbjpuZS5CaW5hcnlFeHByZXNzaW9uO3JldHVybnt0eXBlOnIsb3BlcmF0b3I6dCxsZWZ0OmUscmlnaHQ6bn19LGNyZWF0ZUJsb2NrU3RhdGVtZW50OmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLkJsb2NrU3RhdGVtZW50LGJvZHk6dH19LGNyZWF0ZUJyZWFrU3RhdGVtZW50OmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLkJyZWFrU3RhdGVtZW50LGxhYmVsOnR9fSxjcmVhdGVDYWxsRXhwcmVzc2lvbjpmdW5jdGlvbih0LGUpe3JldHVybnt0eXBlOm5lLkNhbGxFeHByZXNzaW9uLGNhbGxlZTp0LGFyZ3VtZW50czplfX0sY3JlYXRlQ2F0Y2hDbGF1c2U6ZnVuY3Rpb24odCxlKXtyZXR1cm57dHlwZTpuZS5DYXRjaENsYXVzZSxwYXJhbTp0LGJvZHk6ZX19LGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbjpmdW5jdGlvbih0LGUsbil7cmV0dXJue3R5cGU6bmUuQ29uZGl0aW9uYWxFeHByZXNzaW9uLHRlc3Q6dCxjb25zZXF1ZW50OmUsYWx0ZXJuYXRlOm59fSxjcmVhdGVDb250aW51ZVN0YXRlbWVudDpmdW5jdGlvbih0KXtyZXR1cm57dHlwZTpuZS5Db250aW51ZVN0YXRlbWVudCxsYWJlbDp0fX0sY3JlYXRlRGVidWdnZXJTdGF0ZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpuZS5EZWJ1Z2dlclN0YXRlbWVudH19LGNyZWF0ZURvV2hpbGVTdGF0ZW1lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm57dHlwZTpuZS5Eb1doaWxlU3RhdGVtZW50LGJvZHk6dCx0ZXN0OmV9fSxjcmVhdGVFbXB0eVN0YXRlbWVudDpmdW5jdGlvbigpe3JldHVybnt0eXBlOm5lLkVtcHR5U3RhdGVtZW50fX0sY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudDpmdW5jdGlvbih0KXtyZXR1cm57dHlwZTpuZS5FeHByZXNzaW9uU3RhdGVtZW50LGV4cHJlc3Npb246dH19LGNyZWF0ZUZvclN0YXRlbWVudDpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm57dHlwZTpuZS5Gb3JTdGF0ZW1lbnQsaW5pdDp0LHRlc3Q6ZSx1cGRhdGU6bixib2R5OnJ9fSxjcmVhdGVGb3JJblN0YXRlbWVudDpmdW5jdGlvbih0LGUsbil7cmV0dXJue3R5cGU6bmUuRm9ySW5TdGF0ZW1lbnQsbGVmdDp0LHJpZ2h0OmUsYm9keTpuLGVhY2g6ITF9fSxjcmVhdGVGdW5jdGlvbkRlY2xhcmF0aW9uOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybnt0eXBlOm5lLkZ1bmN0aW9uRGVjbGFyYXRpb24saWQ6dCxwYXJhbXM6ZSxkZWZhdWx0czpuLGJvZHk6cixyZXN0Om51bGwsZ2VuZXJhdG9yOiExLGV4cHJlc3Npb246ITF9fSxjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb246ZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3R5cGU6bmUuRnVuY3Rpb25FeHByZXNzaW9uLGlkOnQscGFyYW1zOmUsZGVmYXVsdHM6bixib2R5OnIscmVzdDpudWxsLGdlbmVyYXRvcjohMSxleHByZXNzaW9uOiExfX0sY3JlYXRlSWRlbnRpZmllcjpmdW5jdGlvbih0KXtyZXR1cm57dHlwZTpuZS5JZGVudGlmaWVyLG5hbWU6dH19LGNyZWF0ZUlmU3RhdGVtZW50OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm57dHlwZTpuZS5JZlN0YXRlbWVudCx0ZXN0OnQsY29uc2VxdWVudDplLGFsdGVybmF0ZTpufX0sY3JlYXRlTGFiZWxlZFN0YXRlbWVudDpmdW5jdGlvbih0LGUpe3JldHVybnt0eXBlOm5lLkxhYmVsZWRTdGF0ZW1lbnQsbGFiZWw6dCxib2R5OmV9fSxjcmVhdGVMaXRlcmFsOmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLkxpdGVyYWwsdmFsdWU6dC52YWx1ZSxyYXc6c2Uuc2xpY2UodC5zdGFydCx0LmVuZCl9fSxjcmVhdGVNZW1iZXJFeHByZXNzaW9uOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm57dHlwZTpuZS5NZW1iZXJFeHByZXNzaW9uLGNvbXB1dGVkOlwiW1wiPT09dCxvYmplY3Q6ZSxwcm9wZXJ0eTpufX0sY3JlYXRlTmV3RXhwcmVzc2lvbjpmdW5jdGlvbih0LGUpe3JldHVybnt0eXBlOm5lLk5ld0V4cHJlc3Npb24sY2FsbGVlOnQsYXJndW1lbnRzOmV9fSxjcmVhdGVPYmplY3RFeHByZXNzaW9uOmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLk9iamVjdEV4cHJlc3Npb24scHJvcGVydGllczp0fX0sY3JlYXRlUG9zdGZpeEV4cHJlc3Npb246ZnVuY3Rpb24odCxlKXtyZXR1cm57dHlwZTpuZS5VcGRhdGVFeHByZXNzaW9uLG9wZXJhdG9yOnQsYXJndW1lbnQ6ZSxwcmVmaXg6ITF9fSxjcmVhdGVQcm9ncmFtOmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLlByb2dyYW0sYm9keTp0fX0sY3JlYXRlUHJvcGVydHk6ZnVuY3Rpb24odCxlLG4pe3JldHVybnt0eXBlOm5lLlByb3BlcnR5LGtleTplLHZhbHVlOm4sa2luZDp0fX0sY3JlYXRlUmV0dXJuU3RhdGVtZW50OmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLlJldHVyblN0YXRlbWVudCxhcmd1bWVudDp0fX0sY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uOmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLlNlcXVlbmNlRXhwcmVzc2lvbixleHByZXNzaW9uczp0fX0sY3JlYXRlU3dpdGNoQ2FzZTpmdW5jdGlvbih0LGUpe3JldHVybnt0eXBlOm5lLlN3aXRjaENhc2UsdGVzdDp0LGNvbnNlcXVlbnQ6ZX19LGNyZWF0ZVN3aXRjaFN0YXRlbWVudDpmdW5jdGlvbih0LGUpe3JldHVybnt0eXBlOm5lLlN3aXRjaFN0YXRlbWVudCxkaXNjcmltaW5hbnQ6dCxjYXNlczplfX0sY3JlYXRlVGhpc0V4cHJlc3Npb246ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpuZS5UaGlzRXhwcmVzc2lvbn19LGNyZWF0ZVRocm93U3RhdGVtZW50OmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOm5lLlRocm93U3RhdGVtZW50LGFyZ3VtZW50OnR9fSxjcmVhdGVUcnlTdGF0ZW1lbnQ6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3R5cGU6bmUuVHJ5U3RhdGVtZW50LGJsb2NrOnQsZ3VhcmRlZEhhbmRsZXJzOmUsaGFuZGxlcnM6bixmaW5hbGl6ZXI6cn19LGNyZWF0ZVVuYXJ5RXhwcmVzc2lvbjpmdW5jdGlvbih0LGUpe3JldHVyblwiKytcIj09PXR8fFwiLS1cIj09PXQ/e3R5cGU6bmUuVXBkYXRlRXhwcmVzc2lvbixvcGVyYXRvcjp0LGFyZ3VtZW50OmUscHJlZml4OiEwfTp7dHlwZTpuZS5VbmFyeUV4cHJlc3Npb24sb3BlcmF0b3I6dCxhcmd1bWVudDplLHByZWZpeDohMH19LGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb246ZnVuY3Rpb24odCxlKXtyZXR1cm57dHlwZTpuZS5WYXJpYWJsZURlY2xhcmF0aW9uLGRlY2xhcmF0aW9uczp0LGtpbmQ6ZX19LGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRvcjpmdW5jdGlvbih0LGUpe3JldHVybnt0eXBlOm5lLlZhcmlhYmxlRGVjbGFyYXRvcixpZDp0LGluaXQ6ZX19LGNyZWF0ZVdoaWxlU3RhdGVtZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJue3R5cGU6bmUuV2hpbGVTdGF0ZW1lbnQsdGVzdDp0LGJvZHk6ZX19LGNyZWF0ZVdpdGhTdGF0ZW1lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm57dHlwZTpuZS5XaXRoU3RhdGVtZW50LG9iamVjdDp0LGJvZHk6ZX19fSx0LnZlcnNpb249XCIxLjIuNVwiLHQudG9rZW5pemU9WnQsdC5wYXJzZT1RdCx0LlN5bnRheD1mdW5jdGlvbigpe3ZhciB0LGU9e307XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmNyZWF0ZSYmKGU9T2JqZWN0LmNyZWF0ZShudWxsKSk7Zm9yKHQgaW4gbmUpbmUuaGFzT3duUHJvcGVydHkodCkmJihlW3RdPW5lW3RdKTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZnJlZXplJiZPYmplY3QuZnJlZXplKGUpLGV9KCl9KX0sZnVuY3Rpb24odCxlKXtlLnJlYWQ9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgaSxhLHM9OCpvLXItMSx1PSgxPDxzKS0xLGw9dT4+MSxjPS03LGY9bj9vLTE6MCxwPW4/LTE6MSxoPXRbZStmXTtmb3IoZis9cCxpPWgmKDE8PC1jKS0xLGg+Pj0tYyxjKz1zO2M+MDtpPTI1NippK3RbZStmXSxmKz1wLGMtPTgpO2ZvcihhPWkmKDE8PC1jKS0xLGk+Pj0tYyxjKz1yO2M+MDthPTI1NiphK3RbZStmXSxmKz1wLGMtPTgpO2lmKDA9PT1pKWk9MS1sO2Vsc2V7aWYoaT09PXUpcmV0dXJuIGE/TmFOOihoPy0xOjEpKigxLzApO2ErPU1hdGgucG93KDIsciksaS09bH1yZXR1cm4oaD8tMToxKSphKk1hdGgucG93KDIsaS1yKX0sZS53cml0ZT1mdW5jdGlvbih0LGUsbixyLG8saSl7dmFyIGEscyx1LGw9OCppLW8tMSxjPSgxPDxsKS0xLGY9Yz4+MSxwPTIzPT09bz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAsaD1yPzA6aS0xLGQ9cj8xOi0xLHY9ZTwwfHwwPT09ZSYmMS9lPDA/MTowO2ZvcihlPU1hdGguYWJzKGUpLGlzTmFOKGUpfHxlPT09MS8wPyhzPWlzTmFOKGUpPzE6MCxhPWMpOihhPU1hdGguZmxvb3IoTWF0aC5sb2coZSkvTWF0aC5MTjIpLGUqKHU9TWF0aC5wb3coMiwtYSkpPDEmJihhLS0sdSo9MiksZSs9YStmPj0xP3AvdTpwKk1hdGgucG93KDIsMS1mKSxlKnU+PTImJihhKyssdS89MiksYStmPj1jPyhzPTAsYT1jKTphK2Y+PTE/KHM9KGUqdS0xKSpNYXRoLnBvdygyLG8pLGErPWYpOihzPWUqTWF0aC5wb3coMixmLTEpKk1hdGgucG93KDIsbyksYT0wKSk7bz49ODt0W24raF09MjU1JnMsaCs9ZCxzLz0yNTYsby09OCk7Zm9yKGE9YTw8b3xzLGwrPW87bD4wO3RbbitoXT0yNTUmYSxoKz1kLGEvPTI1NixsLT04KTt0W24raC1kXXw9MTI4KnZ9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQpLG49MDtuPHQ7KytuKWVbbl09bjtyZXR1cm4gZX10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiEhdC5jb25zdHJ1Y3RvciYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciYmdC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih0KX1mdW5jdGlvbiByKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQucmVhZEZsb2F0TEUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuc2xpY2UmJm4odC5zbGljZSgwLDApKX10LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXQmJihuKHQpfHxyKHQpfHwhIXQuX2lzQnVmZmVyKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQ4KSxvPW4oMjkpLGk9cihvLFwiRGF0YVZpZXdcIik7dC5leHBvcnRzPWl9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPS0xLG49bnVsbD09dD8wOnQubGVuZ3RoO2Zvcih0aGlzLmNsZWFyKCk7KytlPG47KXt2YXIgcj10W2VdO3RoaXMuc2V0KHJbMF0sclsxXSl9fXZhciBvPW4oNTIxKSxpPW4oNTIyKSxhPW4oNTIzKSxzPW4oNTI0KSx1PW4oNTI1KTtyLnByb3RvdHlwZS5jbGVhcj1vLHIucHJvdG90eXBlLmRlbGV0ZT1pLHIucHJvdG90eXBlLmdldD1hLHIucHJvdG90eXBlLmhhcz1zLHIucHJvdG90eXBlLnNldD11LHQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0OCksbz1uKDI5KSxpPXIobyxcIlByb21pc2VcIik7dC5leHBvcnRzPWl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQ4KSxvPW4oMjkpLGk9cihvLFwiU2V0XCIpO3QuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT0tMSxuPW51bGw9PXQ/MDp0Lmxlbmd0aDtmb3IodGhpcy5fX2RhdGFfXz1uZXcgbzsrK2U8bjspdGhpcy5hZGQodFtlXSl9dmFyIG89bigxMjApLGk9big1NDYpLGE9big1NDcpO3IucHJvdG90eXBlLmFkZD1yLnByb3RvdHlwZS5wdXNoPWksci5wcm90b3R5cGUuaGFzPWEsdC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDI5KSxvPXIuVWludDhBcnJheTt0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNDgpLG89bigyOSksaT1yKG8sXCJXZWFrTWFwXCIpO3QuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlLG4pe3N3aXRjaChuLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0LmNhbGwoZSk7Y2FzZSAxOnJldHVybiB0LmNhbGwoZSxuWzBdKTtjYXNlIDI6cmV0dXJuIHQuY2FsbChlLG5bMF0sblsxXSk7Y2FzZSAzOnJldHVybiB0LmNhbGwoZSxuWzBdLG5bMV0sblsyXSl9cmV0dXJuIHQuYXBwbHkoZSxuKX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSl7Zm9yKHZhciBuPS0xLHI9bnVsbD09dD8wOnQubGVuZ3RoOysrbjxyOylpZighZSh0W25dLG4sdCkpcmV0dXJuITE7cmV0dXJuITB9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2Zvcih2YXIgbj0tMSxyPW51bGw9PXQ/MDp0Lmxlbmd0aCxvPTAsaT1bXTsrK248cjspe3ZhciBhPXRbbl07ZShhLG4sdCkmJihpW28rK109YSl9cmV0dXJuIGl9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dmFyIG49YSh0KSxyPSFuJiZpKHQpLGM9IW4mJiFyJiZzKHQpLHA9IW4mJiFyJiYhYyYmbCh0KSxoPW58fHJ8fGN8fHAsZD1oP28odC5sZW5ndGgsU3RyaW5nKTpbXSx2PWQubGVuZ3RoO2Zvcih2YXIgbSBpbiB0KSFlJiYhZi5jYWxsKHQsbSl8fGgmJihcImxlbmd0aFwiPT1tfHxjJiYoXCJvZmZzZXRcIj09bXx8XCJwYXJlbnRcIj09bSl8fHAmJihcImJ1ZmZlclwiPT1tfHxcImJ5dGVMZW5ndGhcIj09bXx8XCJieXRlT2Zmc2V0XCI9PW0pfHx1KG0sdikpfHxkLnB1c2gobSk7cmV0dXJuIGR9dmFyIG89big0OTUpLGk9bigxMjYpLGE9bigzMCkscz1uKDE4NSksdT1uKDg1KSxsPW4oMTg3KSxjPU9iamVjdC5wcm90b3R5cGUsZj1jLmhhc093blByb3BlcnR5O3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlLG4scil7dmFyIG89LTEsaT1udWxsPT10PzA6dC5sZW5ndGg7Zm9yKHImJmkmJihuPXRbKytvXSk7KytvPGk7KW49ZShuLHRbb10sbyx0KTtyZXR1cm4gbn10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSl7Zm9yKHZhciBuPS0xLHI9bnVsbD09dD8wOnQubGVuZ3RoOysrbjxyOylpZihlKHRbbl0sbix0KSlyZXR1cm4hMDtyZXR1cm4hMX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiB0LnNwbGl0KFwiXCIpfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIHQubWF0Y2gocil8fFtdfXZhciByPS9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZzt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe3ZhciByPXRbZV07cy5jYWxsKHQsZSkmJmkocixuKSYmKHZvaWQgMCE9PW58fGUgaW4gdCl8fG8odCxlLG4pfXZhciBvPW4oMTcwKSxpPW4oODcpLGE9T2JqZWN0LnByb3RvdHlwZSxzPWEuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE3Miksbz1uKDUwMyksaT1vKHIpO3QuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3ZhciBuPSEwO3JldHVybiBvKHQsZnVuY3Rpb24odCxyLG8pe3JldHVybiBuPSEhZSh0LHIsbyl9KSxufXZhciBvPW4oNDcxKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSxuLHIpe2Zvcih2YXIgbz10Lmxlbmd0aCxpPW4rKHI/MTotMSk7cj9pLS06KytpPG87KWlmKGUodFtpXSxpLHQpKXJldHVybiBpO3JldHVybi0xfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1MDQpLG89cigpO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7dmFyIHI9ZSh0KTtyZXR1cm4gaSh0KT9yOm8ocixuKHQpKX12YXIgbz1uKDE2OSksaT1uKDMwKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIG51bGwhPXQmJmUgaW4gT2JqZWN0KHQpfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gaSh0KSYmbyh0KT09YX12YXIgbz1uKDYyKSxpPW4oNjQpLGE9XCJbb2JqZWN0IEFyZ3VtZW50c11cIjt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4scixtLGcpe3ZhciB5PWwodCksYj1sKGUpLHc9eT9kOnUodCkseD1iP2Q6dShlKTt3PXc9PWg/djp3LHg9eD09aD92Ong7dmFyIEU9dz09dixUPXg9PXYsTz13PT14O2lmKE8mJmModCkpe2lmKCFjKGUpKXJldHVybiExO3k9ITAsRT0hMX1pZihPJiYhRSlyZXR1cm4gZ3x8KGc9bmV3IG8pLHl8fGYodCk/aSh0LGUsbixyLG0sZyk6YSh0LGUsdyxuLHIsbSxnKTtpZighKG4mcCkpe3ZhciBTPUUmJl8uY2FsbCh0LFwiX193cmFwcGVkX19cIiksUD1UJiZfLmNhbGwoZSxcIl9fd3JhcHBlZF9fXCIpO2lmKFN8fFApe3ZhciBNPVM/dC52YWx1ZSgpOnQsaj1QP2UudmFsdWUoKTplO3JldHVybiBnfHwoZz1uZXcgbyksbShNLGosbixyLGcpfX1yZXR1cm4hIU8mJihnfHwoZz1uZXcgbykscyh0LGUsbixyLG0sZykpfXZhciBvPW4oMTY4KSxpPW4oMTc0KSxhPW4oNTExKSxzPW4oNTEyKSx1PW4oMTc2KSxsPW4oMzApLGM9bigxODUpLGY9bigxODcpLHA9MSxoPVwiW29iamVjdCBBcmd1bWVudHNdXCIsZD1cIltvYmplY3QgQXJyYXldXCIsdj1cIltvYmplY3QgT2JqZWN0XVwiLG09T2JqZWN0LnByb3RvdHlwZSxfPW0uaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuLHIpe3ZhciB1PW4ubGVuZ3RoLGw9dSxjPSFyO2lmKG51bGw9PXQpcmV0dXJuIWw7Zm9yKHQ9T2JqZWN0KHQpO3UtLTspe3ZhciBmPW5bdV07aWYoYyYmZlsyXT9mWzFdIT09dFtmWzBdXTohKGZbMF1pbiB0KSlyZXR1cm4hMX1mb3IoOysrdTxsOyl7Zj1uW3VdO3ZhciBwPWZbMF0saD10W3BdLGQ9ZlsxXTtpZihjJiZmWzJdKXtpZih2b2lkIDA9PT1oJiYhKHAgaW4gdCkpcmV0dXJuITF9ZWxzZXt2YXIgdj1uZXcgbztpZihyKXZhciBtPXIoaCxkLHAsdCxlLHYpO2lmKCEodm9pZCAwPT09bT9pKGQsaCxhfHMscix2KTptKSlyZXR1cm4hMX19cmV0dXJuITB9dmFyIG89bigxNjgpLGk9bigxMjMpLGE9MSxzPTI7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe2lmKCFhKHQpfHxpKHQpKXJldHVybiExO3ZhciBlPW8odCk/ZDpsO3JldHVybiBlLnRlc3Qocyh0KSl9dmFyIG89bigxODYpLGk9big1MjgpLGE9big1NSkscz1uKDE4MiksdT0vW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csbD0vXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvLGM9RnVuY3Rpb24ucHJvdG90eXBlLGY9T2JqZWN0LnByb3RvdHlwZSxwPWMudG9TdHJpbmcsaD1mLmhhc093blByb3BlcnR5LGQ9UmVnRXhwKFwiXlwiK3AuY2FsbChoKS5yZXBsYWNlKHUsXCJcXFxcJCZcIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZyxcIiQxLio/XCIpK1wiJFwiKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGEodCkmJmkodC5sZW5ndGgpJiYhIUNbbyh0KV19dmFyIG89big2MiksaT1uKDEyOCksYT1uKDY0KSxzPVwiW29iamVjdCBBcmd1bWVudHNdXCIsdT1cIltvYmplY3QgQXJyYXldXCIsbD1cIltvYmplY3QgQm9vbGVhbl1cIixjPVwiW29iamVjdCBEYXRlXVwiLGY9XCJbb2JqZWN0IEVycm9yXVwiLHA9XCJbb2JqZWN0IEZ1bmN0aW9uXVwiLGg9XCJbb2JqZWN0IE1hcF1cIixkPVwiW29iamVjdCBOdW1iZXJdXCIsdj1cIltvYmplY3QgT2JqZWN0XVwiLG09XCJbb2JqZWN0IFJlZ0V4cF1cIixfPVwiW29iamVjdCBTZXRdXCIsZz1cIltvYmplY3QgU3RyaW5nXVwiLHk9XCJbb2JqZWN0IFdlYWtNYXBdXCIsYj1cIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsdz1cIltvYmplY3QgRGF0YVZpZXddXCIseD1cIltvYmplY3QgRmxvYXQzMkFycmF5XVwiLEU9XCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIixUPVwiW29iamVjdCBJbnQ4QXJyYXldXCIsTz1cIltvYmplY3QgSW50MTZBcnJheV1cIixTPVwiW29iamVjdCBJbnQzMkFycmF5XVwiLFA9XCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIsTT1cIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsaj1cIltvYmplY3QgVWludDE2QXJyYXldXCIsQT1cIltvYmplY3QgVWludDMyQXJyYXldXCIsQz17fTtDW3hdPUNbRV09Q1tUXT1DW09dPUNbU109Q1tQXT1DW01dPUNbal09Q1tBXT0hMCxDW3NdPUNbdV09Q1tiXT1DW2xdPUNbd109Q1tjXT1DW2ZdPUNbcF09Q1toXT1DW2RdPUNbdl09Q1ttXT1DW19dPUNbZ109Q1t5XT0hMSx0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7aWYoIW8odCkpcmV0dXJuIGkodCk7dmFyIGU9W107Zm9yKHZhciBuIGluIE9iamVjdCh0KSlzLmNhbGwodCxuKSYmXCJjb25zdHJ1Y3RvclwiIT1uJiZlLnB1c2gobik7cmV0dXJuIGV9dmFyIG89big1MjkpLGk9big1NDEpLGE9T2JqZWN0LnByb3RvdHlwZSxzPWEuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPWkodCk7cmV0dXJuIDE9PWUubGVuZ3RoJiZlWzBdWzJdP2EoZVswXVswXSxlWzBdWzFdKTpmdW5jdGlvbihuKXtyZXR1cm4gbj09PXR8fG8obix0LGUpfX12YXIgbz1uKDQ3OSksaT1uKDUxNSksYT1uKDE4MSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIHModCkmJnUoZSk/bChjKHQpLGUpOmZ1bmN0aW9uKG4pe3ZhciByPWkobix0KTtyZXR1cm4gdm9pZCAwPT09ciYmcj09PWU/YShuLHQpOm8oZSxyLGZ8cCl9fXZhciBvPW4oMTIzKSxpPW4oNTY5KSxhPW4oMTg0KSxzPW4oMTI0KSx1PW4oMTc5KSxsPW4oMTgxKSxjPW4oNjMpLGY9MSxwPTI7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIG8odCxlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIGkodCxuKX0pfXZhciBvPW4oNDg2KSxpPW4oMTg0KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe2Zvcih2YXIgcj0tMSxzPWUubGVuZ3RoLHU9e307KytyPHM7KXt2YXIgbD1lW3JdLGM9byh0LGwpO24oYyxsKSYmaSh1LGEobCx0KSxjKX1yZXR1cm4gdX12YXIgbz1uKDEyMiksaT1uKDQ5MSksYT1uKDgzKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT92b2lkIDA6ZVt0XX19dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbyhlLHQpfX12YXIgbz1uKDEyMik7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PXQ/dm9pZCAwOnRbZV19fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlLG4saSl7Zm9yKHZhciBhPS0xLHM9byhyKChlLXQpLyhufHwxKSksMCksdT1BcnJheShzKTtzLS07KXVbaT9zOisrYV09dCx0Kz1uO3JldHVybiB1fXZhciByPU1hdGguY2VpbCxvPU1hdGgubWF4O3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbixyKXtpZighcyh0KSlyZXR1cm4gdDtlPWkoZSx0KTtmb3IodmFyIGw9LTEsYz1lLmxlbmd0aCxmPWMtMSxwPXQ7bnVsbCE9cCYmKytsPGM7KXt2YXIgaD11KGVbbF0pLGQ9bjtpZihsIT1mKXt2YXIgdj1wW2hdO2Q9cj9yKHYsaCxwKTp2b2lkIDAsdm9pZCAwPT09ZCYmKGQ9cyh2KT92OmEoZVtsKzFdKT9bXTp7fSl9byhwLGgsZCkscD1wW2hdfXJldHVybiB0fXZhciBvPW4oNDcwKSxpPW4oODMpLGE9big4NSkscz1uKDU1KSx1PW4oNjMpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1NjMpLG89bigxNzMpLGk9bigxMjUpLGE9bz9mdW5jdGlvbih0LGUpe3JldHVybiBvKHQsXCJ0b1N0cmluZ1wiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx2YWx1ZTpyKGUpLHdyaXRhYmxlOiEwfSl9Omk7dC5leHBvcnRzPWF9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUsbil7dmFyIHI9LTEsbz10Lmxlbmd0aDtlPDAmJihlPS1lPm8/MDpvK2UpLG49bj5vP286bixuPDAmJihuKz1vKSxvPWU+bj8wOm4tZT4+PjAsZT4+Pj0wO2Zvcih2YXIgaT1BcnJheShvKTsrK3I8bzspaVtyXT10W3IrZV07cmV0dXJuIGl9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe2Zvcih2YXIgbixyPS0xLG89dC5sZW5ndGg7KytyPG87KXt2YXIgaT1lKHRbcl0pO3ZvaWQgMCE9PWkmJihuPXZvaWQgMD09PW4/aTpuK2kpfXJldHVybiBufXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtmb3IodmFyIG49LTEscj1BcnJheSh0KTsrK248dDspcltuXT1lKG4pO3JldHVybiByfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3JldHVybiBvKGUsZnVuY3Rpb24oZSl7cmV0dXJuW2UsdFtlXV19KX12YXIgbz1uKDEyMSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiB0O2lmKGEodCkpcmV0dXJuIGkodCxyKStcIlwiO2lmKHModCkpcmV0dXJuIGM/Yy5jYWxsKHQpOlwiXCI7dmFyIGU9dCtcIlwiO3JldHVyblwiMFwiPT1lJiYxL3Q9PS11P1wiLTBcIjplfXZhciBvPW4oNjEpLGk9bigxMjEpLGE9bigzMCkscz1uKDg5KSx1PTEvMCxsPW8/by5wcm90b3R5cGU6dm9pZCAwLGM9bD9sLnRvU3RyaW5nOnZvaWQgMDt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdChlKX19dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIG8oZSxmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0pfXZhciBvPW4oMTIxKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIHQuaGFzKGUpfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7dmFyIHI9dC5sZW5ndGg7cmV0dXJuIG49dm9pZCAwPT09bj9yOm4sIWUmJm4+PXI/dDpvKHQsZSxuKX12YXIgbz1uKDQ5Myk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDI5KSxvPXJbXCJfX2NvcmUtanNfc2hhcmVkX19cIl07dC5leHBvcnRzPW99LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKG4scil7aWYobnVsbD09bilyZXR1cm4gbjtpZighbyhuKSlyZXR1cm4gdChuLHIpO2Zvcih2YXIgaT1uLmxlbmd0aCxhPWU/aTotMSxzPU9iamVjdChuKTsoZT9hLS06KythPGkpJiZyKHNbYV0sYSxzKSE9PSExOyk7cmV0dXJuIG59fXZhciBvPW4oODgpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbixyKXtmb3IodmFyIG89LTEsaT1PYmplY3QoZSksYT1yKGUpLHM9YS5sZW5ndGg7cy0tOyl7dmFyIHU9YVt0P3M6KytvXTtpZihuKGlbdV0sdSxpKT09PSExKWJyZWFrfXJldHVybiBlfX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2U9cyhlKTt2YXIgbj1pKGUpP2EoZSk6dm9pZCAwLHI9bj9uWzBdOmUuY2hhckF0KDApLHU9bj9vKG4sMSkuam9pbihcIlwiKTplLnNsaWNlKDEpO3JldHVybiByW3RdKCkrdX19dmFyIG89big1MDEpLGk9bigxNzcpLGE9big1NTcpLHM9big2NSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbyhhKGkoZSkucmVwbGFjZSh1LFwiXCIpKSx0LFwiXCIpfX12YXIgbz1uKDQ2NiksaT1uKDU2NCksYT1uKDU4Mikscz1cIlsn4oCZXVwiLHU9UmVnRXhwKHMsXCJnXCIpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3ZhciBzPU9iamVjdChlKTtpZighaShlKSl7dmFyIHU9byhuLDMpO2U9YShlKSxuPWZ1bmN0aW9uKHQpe3JldHVybiB1KHNbdF0sdCxzKX19dmFyIGw9dChlLG4scik7cmV0dXJuIGw+LTE/c1t1P2VbbF06bF06dm9pZCAwfX12YXIgbz1uKDgyKSxpPW4oODgpLGE9big0OSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIHImJlwibnVtYmVyXCIhPXR5cGVvZiByJiZpKGUsbixyKSYmKG49cj12b2lkIDApLGU9YShlKSx2b2lkIDA9PT1uPyhuPWUsZT0wKTpuPWEobikscj12b2lkIDA9PT1yP2U8bj8xOi0xOmEociksbyhlLG4scix0KX19dmFyIG89big0OTApLGk9bigxNzgpLGE9bigxODkpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49aShlKTtyZXR1cm4gbj09dT9hKGUpOm49PWw/cyhlKTpvKGUsdChlKSl9fXZhciBvPW4oNDk2KSxpPW4oMTc2KSxhPW4oMTgwKSxzPW4oNTQ5KSx1PVwiW29iamVjdCBNYXBdXCIsbD1cIltvYmplY3QgU2V0XVwiO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0ODkpLG89e1wiw4BcIjpcIkFcIixcIsOBXCI6XCJBXCIsXCLDglwiOlwiQVwiLFwiw4NcIjpcIkFcIixcIsOEXCI6XCJBXCIsXCLDhVwiOlwiQVwiLFwiw6BcIjpcImFcIixcIsOhXCI6XCJhXCIsXCLDolwiOlwiYVwiLFwiw6NcIjpcImFcIixcIsOkXCI6XCJhXCIsXCLDpVwiOlwiYVwiLFwiw4dcIjpcIkNcIixcIsOnXCI6XCJjXCIsXCLDkFwiOlwiRFwiLFwiw7BcIjpcImRcIixcIsOIXCI6XCJFXCIsXCLDiVwiOlwiRVwiLFwiw4pcIjpcIkVcIixcIsOLXCI6XCJFXCIsXCLDqFwiOlwiZVwiLFwiw6lcIjpcImVcIixcIsOqXCI6XCJlXCIsXCLDq1wiOlwiZVwiLFwiw4xcIjpcIklcIixcIsONXCI6XCJJXCIsXCLDjlwiOlwiSVwiLFwiw49cIjpcIklcIixcIsOsXCI6XCJpXCIsXCLDrVwiOlwiaVwiLFwiw65cIjpcImlcIixcIsOvXCI6XCJpXCIsXCLDkVwiOlwiTlwiLFwiw7FcIjpcIm5cIixcIsOSXCI6XCJPXCIsXCLDk1wiOlwiT1wiLFwiw5RcIjpcIk9cIixcIsOVXCI6XCJPXCIsXCLDllwiOlwiT1wiLFwiw5hcIjpcIk9cIixcIsOyXCI6XCJvXCIsXCLDs1wiOlwib1wiLFwiw7RcIjpcIm9cIixcIsO1XCI6XCJvXCIsXCLDtlwiOlwib1wiLFwiw7hcIjpcIm9cIixcIsOZXCI6XCJVXCIsXCLDmlwiOlwiVVwiLFwiw5tcIjpcIlVcIixcIsOcXCI6XCJVXCIsXCLDuVwiOlwidVwiLFwiw7pcIjpcInVcIixcIsO7XCI6XCJ1XCIsXCLDvFwiOlwidVwiLFwiw51cIjpcIllcIixcIsO9XCI6XCJ5XCIsXCLDv1wiOlwieVwiLFwiw4ZcIjpcIkFlXCIsXCLDplwiOlwiYWVcIixcIsOeXCI6XCJUaFwiLFwiw75cIjpcInRoXCIsXCLDn1wiOlwic3NcIixcIsSAXCI6XCJBXCIsXCLEglwiOlwiQVwiLFwixIRcIjpcIkFcIixcIsSBXCI6XCJhXCIsXCLEg1wiOlwiYVwiLFwixIVcIjpcImFcIixcIsSGXCI6XCJDXCIsXCLEiFwiOlwiQ1wiLFwixIpcIjpcIkNcIixcIsSMXCI6XCJDXCIsXCLEh1wiOlwiY1wiLFwixIlcIjpcImNcIixcIsSLXCI6XCJjXCIsXCLEjVwiOlwiY1wiLFwixI5cIjpcIkRcIixcIsSQXCI6XCJEXCIsXCLEj1wiOlwiZFwiLFwixJFcIjpcImRcIixcIsSSXCI6XCJFXCIsXCLElFwiOlwiRVwiLFwixJZcIjpcIkVcIixcIsSYXCI6XCJFXCIsXCLEmlwiOlwiRVwiLFwixJNcIjpcImVcIixcIsSVXCI6XCJlXCIsXCLEl1wiOlwiZVwiLFwixJlcIjpcImVcIixcIsSbXCI6XCJlXCIsXCLEnFwiOlwiR1wiLFwixJ5cIjpcIkdcIixcIsSgXCI6XCJHXCIsXCLEolwiOlwiR1wiLFwixJ1cIjpcImdcIixcIsSfXCI6XCJnXCIsXCLEoVwiOlwiZ1wiLFwixKNcIjpcImdcIixcIsSkXCI6XCJIXCIsXCLEplwiOlwiSFwiLFwixKVcIjpcImhcIixcIsSnXCI6XCJoXCIsXCLEqFwiOlwiSVwiLFwixKpcIjpcIklcIixcIsSsXCI6XCJJXCIsXCLErlwiOlwiSVwiLFwixLBcIjpcIklcIixcIsSpXCI6XCJpXCIsXCLEq1wiOlwiaVwiLFwixK1cIjpcImlcIixcIsSvXCI6XCJpXCIsXG5cIsSxXCI6XCJpXCIsXCLEtFwiOlwiSlwiLFwixLVcIjpcImpcIixcIsS2XCI6XCJLXCIsXCLEt1wiOlwia1wiLFwixLhcIjpcImtcIixcIsS5XCI6XCJMXCIsXCLEu1wiOlwiTFwiLFwixL1cIjpcIkxcIixcIsS/XCI6XCJMXCIsXCLFgVwiOlwiTFwiLFwixLpcIjpcImxcIixcIsS8XCI6XCJsXCIsXCLEvlwiOlwibFwiLFwixYBcIjpcImxcIixcIsWCXCI6XCJsXCIsXCLFg1wiOlwiTlwiLFwixYVcIjpcIk5cIixcIsWHXCI6XCJOXCIsXCLFilwiOlwiTlwiLFwixYRcIjpcIm5cIixcIsWGXCI6XCJuXCIsXCLFiFwiOlwiblwiLFwixYtcIjpcIm5cIixcIsWMXCI6XCJPXCIsXCLFjlwiOlwiT1wiLFwixZBcIjpcIk9cIixcIsWNXCI6XCJvXCIsXCLFj1wiOlwib1wiLFwixZFcIjpcIm9cIixcIsWUXCI6XCJSXCIsXCLFllwiOlwiUlwiLFwixZhcIjpcIlJcIixcIsWVXCI6XCJyXCIsXCLFl1wiOlwiclwiLFwixZlcIjpcInJcIixcIsWaXCI6XCJTXCIsXCLFnFwiOlwiU1wiLFwixZ5cIjpcIlNcIixcIsWgXCI6XCJTXCIsXCLFm1wiOlwic1wiLFwixZ1cIjpcInNcIixcIsWfXCI6XCJzXCIsXCLFoVwiOlwic1wiLFwixaJcIjpcIlRcIixcIsWkXCI6XCJUXCIsXCLFplwiOlwiVFwiLFwixaNcIjpcInRcIixcIsWlXCI6XCJ0XCIsXCLFp1wiOlwidFwiLFwixahcIjpcIlVcIixcIsWqXCI6XCJVXCIsXCLFrFwiOlwiVVwiLFwixa5cIjpcIlVcIixcIsWwXCI6XCJVXCIsXCLFslwiOlwiVVwiLFwixalcIjpcInVcIixcIsWrXCI6XCJ1XCIsXCLFrVwiOlwidVwiLFwixa9cIjpcInVcIixcIsWxXCI6XCJ1XCIsXCLFs1wiOlwidVwiLFwixbRcIjpcIldcIixcIsW1XCI6XCJ3XCIsXCLFtlwiOlwiWVwiLFwixbdcIjpcInlcIixcIsW4XCI6XCJZXCIsXCLFuVwiOlwiWlwiLFwixbtcIjpcIlpcIixcIsW9XCI6XCJaXCIsXCLFulwiOlwielwiLFwixbxcIjpcInpcIixcIsW+XCI6XCJ6XCIsXCLEslwiOlwiSUpcIixcIsSzXCI6XCJpalwiLFwixZJcIjpcIk9lXCIsXCLFk1wiOlwib2VcIixcIsWJXCI6XCInblwiLFwixb9cIjpcInNcIn0saT1yKG8pO3QuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbixyLG8sRSxPKXtzd2l0Y2gobil7Y2FzZSB4OmlmKHQuYnl0ZUxlbmd0aCE9ZS5ieXRlTGVuZ3RofHx0LmJ5dGVPZmZzZXQhPWUuYnl0ZU9mZnNldClyZXR1cm4hMTt0PXQuYnVmZmVyLGU9ZS5idWZmZXI7Y2FzZSB3OnJldHVybiEodC5ieXRlTGVuZ3RoIT1lLmJ5dGVMZW5ndGh8fCFFKG5ldyBpKHQpLG5ldyBpKGUpKSk7Y2FzZSBwOmNhc2UgaDpjYXNlIG06cmV0dXJuIGEoK3QsK2UpO2Nhc2UgZDpyZXR1cm4gdC5uYW1lPT1lLm5hbWUmJnQubWVzc2FnZT09ZS5tZXNzYWdlO2Nhc2UgXzpjYXNlIHk6cmV0dXJuIHQ9PWUrXCJcIjtjYXNlIHY6dmFyIFM9dTtjYXNlIGc6dmFyIFA9ciZjO2lmKFN8fChTPWwpLHQuc2l6ZSE9ZS5zaXplJiYhUClyZXR1cm4hMTt2YXIgTT1PLmdldCh0KTtpZihNKXJldHVybiBNPT1lO3J8PWYsTy5zZXQodCxlKTt2YXIgaj1zKFModCksUyhlKSxyLG8sRSxPKTtyZXR1cm4gTy5kZWxldGUodCksajtjYXNlIGI6aWYoVClyZXR1cm4gVC5jYWxsKHQpPT1ULmNhbGwoZSl9cmV0dXJuITF9dmFyIG89big2MSksaT1uKDQ2MCksYT1uKDg3KSxzPW4oMTc0KSx1PW4oMTgwKSxsPW4oNTQ4KSxjPTEsZj0yLHA9XCJbb2JqZWN0IEJvb2xlYW5dXCIsaD1cIltvYmplY3QgRGF0ZV1cIixkPVwiW29iamVjdCBFcnJvcl1cIix2PVwiW29iamVjdCBNYXBdXCIsbT1cIltvYmplY3QgTnVtYmVyXVwiLF89XCJbb2JqZWN0IFJlZ0V4cF1cIixnPVwiW29iamVjdCBTZXRdXCIseT1cIltvYmplY3QgU3RyaW5nXVwiLGI9XCJbb2JqZWN0IFN5bWJvbF1cIix3PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIix4PVwiW29iamVjdCBEYXRhVmlld11cIixFPW8/by5wcm90b3R5cGU6dm9pZCAwLFQ9RT9FLnZhbHVlT2Y6dm9pZCAwO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbixyLGEsdSl7dmFyIGw9biZpLGM9byh0KSxmPWMubGVuZ3RoLHA9byhlKSxoPXAubGVuZ3RoO2lmKGYhPWgmJiFsKXJldHVybiExO2Zvcih2YXIgZD1mO2QtLTspe3ZhciB2PWNbZF07aWYoIShsP3YgaW4gZTpzLmNhbGwoZSx2KSkpcmV0dXJuITF9dmFyIG09dS5nZXQodCk7aWYobSYmdS5nZXQoZSkpcmV0dXJuIG09PWU7dmFyIF89ITA7dS5zZXQodCxlKSx1LnNldChlLHQpO2Zvcih2YXIgZz1sOysrZDxmOyl7dj1jW2RdO3ZhciB5PXRbdl0sYj1lW3ZdO2lmKHIpdmFyIHc9bD9yKGIseSx2LGUsdCx1KTpyKHksYix2LHQsZSx1KTtpZighKHZvaWQgMD09PXc/eT09PWJ8fGEoeSxiLG4scix1KTp3KSl7Xz0hMTticmVha31nfHwoZz1cImNvbnN0cnVjdG9yXCI9PXYpfWlmKF8mJiFnKXt2YXIgeD10LmNvbnN0cnVjdG9yLEU9ZS5jb25zdHJ1Y3Rvcjt4IT1FJiZcImNvbnN0cnVjdG9yXCJpbiB0JiZcImNvbnN0cnVjdG9yXCJpbiBlJiYhKFwiZnVuY3Rpb25cIj09dHlwZW9mIHgmJnggaW5zdGFuY2VvZiB4JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBFJiZFIGluc3RhbmNlb2YgRSkmJihfPSExKX1yZXR1cm4gdS5kZWxldGUodCksdS5kZWxldGUoZSksX312YXIgbz1uKDUxNCksaT0xLGE9T2JqZWN0LnByb3RvdHlwZSxzPWEuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBhKGkodCx2b2lkIDAsbyksdCtcIlwiKX12YXIgbz1uKDU2OCksaT1uKDU0NSksYT1uKDU1MCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBvKHQsYSxpKX12YXIgbz1uKDQ3NSksaT1uKDUxNyksYT1uKDQ5KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7Zm9yKHZhciBlPWkodCksbj1lLmxlbmd0aDtuLS07KXt2YXIgcj1lW25dLGE9dFtyXTtlW25dPVtyLGEsbyhhKV19cmV0dXJuIGV9dmFyIG89bigxNzkpLGk9big0OSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPWEuY2FsbCh0LHUpLG49dFt1XTt0cnl7dFt1XT12b2lkIDA7dmFyIHI9ITB9Y2F0Y2godCl7fXZhciBvPXMuY2FsbCh0KTtyZXR1cm4gciYmKGU/dFt1XT1uOmRlbGV0ZSB0W3VdKSxvfXZhciBvPW4oNjEpLGk9T2JqZWN0LnByb3RvdHlwZSxhPWkuaGFzT3duUHJvcGVydHkscz1pLnRvU3RyaW5nLHU9bz9vLnRvU3RyaW5nVGFnOnZvaWQgMDt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNDY0KSxvPW4oNTc1KSxpPU9iamVjdC5wcm90b3R5cGUsYT1pLnByb3BlcnR5SXNFbnVtZXJhYmxlLHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyx1PXM/ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/W106KHQ9T2JqZWN0KHQpLHIocyh0KSxmdW5jdGlvbihlKXtyZXR1cm4gYS5jYWxsKHQsZSl9KSl9Om87dC5leHBvcnRzPXV9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBudWxsPT10P3ZvaWQgMDp0W2VdfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7ZT1vKGUsdCk7Zm9yKHZhciByPS0xLGM9ZS5sZW5ndGgsZj0hMTsrK3I8Yzspe3ZhciBwPWwoZVtyXSk7aWYoIShmPW51bGwhPXQmJm4odCxwKSkpYnJlYWs7dD10W3BdfXJldHVybiBmfHwrK3IhPWM/ZjooYz1udWxsPT10PzA6dC5sZW5ndGgsISFjJiZ1KGMpJiZzKHAsYykmJihhKHQpfHxpKHQpKSl9dmFyIG89big4MyksaT1uKDEyNiksYT1uKDMwKSxzPW4oODUpLHU9bigxMjgpLGw9big2Myk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gci50ZXN0KHQpfXZhciByPS9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLzt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIoKXt0aGlzLl9fZGF0YV9fPW8/byhudWxsKTp7fSx0aGlzLnNpemU9MH12YXIgbz1uKDg2KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3ZhciBlPXRoaXMuaGFzKHQpJiZkZWxldGUgdGhpcy5fX2RhdGFfX1t0XTtyZXR1cm4gdGhpcy5zaXplLT1lPzE6MCxlfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLl9fZGF0YV9fO2lmKG8pe3ZhciBuPWVbdF07cmV0dXJuIG49PT1pP3ZvaWQgMDpufXJldHVybiBzLmNhbGwoZSx0KT9lW3RdOnZvaWQgMH12YXIgbz1uKDg2KSxpPVwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiLGE9T2JqZWN0LnByb3RvdHlwZSxzPWEuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMuX19kYXRhX187cmV0dXJuIG8/dm9pZCAwIT09ZVt0XTphLmNhbGwoZSx0KX12YXIgbz1uKDg2KSxpPU9iamVjdC5wcm90b3R5cGUsYT1pLmhhc093blByb3BlcnR5O3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3ZhciBuPXRoaXMuX19kYXRhX187cmV0dXJuIHRoaXMuc2l6ZSs9dGhpcy5oYXModCk/MDoxLG5bdF09byYmdm9pZCAwPT09ZT9pOmUsdGhpc312YXIgbz1uKDg2KSxpPVwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gYSh0KXx8aSh0KXx8ISEocyYmdCYmdFtzXSl9dmFyIG89big2MSksaT1uKDEyNiksYT1uKDMwKSxzPW8/by5pc0NvbmNhdFNwcmVhZGFibGU6dm9pZCAwO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7dmFyIGU9dHlwZW9mIHQ7cmV0dXJuXCJzdHJpbmdcIj09ZXx8XCJudW1iZXJcIj09ZXx8XCJzeW1ib2xcIj09ZXx8XCJib29sZWFuXCI9PWU/XCJfX3Byb3RvX19cIiE9PXQ6bnVsbD09PXR9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiEhaSYmaSBpbiB0fXZhciBvPW4oNTAyKSxpPWZ1bmN0aW9uKCl7dmFyIHQ9L1teLl0rJC8uZXhlYyhvJiZvLmtleXMmJm8ua2V5cy5JRV9QUk9UT3x8XCJcIik7cmV0dXJuIHQ/XCJTeW1ib2woc3JjKV8xLlwiK3Q6XCJcIn0oKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3ZhciBlPXQmJnQuY29uc3RydWN0b3Isbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLnByb3RvdHlwZXx8cjtyZXR1cm4gdD09PW59dmFyIHI9T2JqZWN0LnByb3RvdHlwZTt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5fX2RhdGFfXz1bXSx0aGlzLnNpemU9MH10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcy5fX2RhdGFfXyxuPW8oZSx0KTtpZihuPDApcmV0dXJuITE7dmFyIHI9ZS5sZW5ndGgtMTtyZXR1cm4gbj09cj9lLnBvcCgpOmEuY2FsbChlLG4sMSksLS10aGlzLnNpemUsITB9dmFyIG89big4MSksaT1BcnJheS5wcm90b3R5cGUsYT1pLnNwbGljZTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcy5fX2RhdGFfXyxuPW8oZSx0KTtyZXR1cm4gbjwwP3ZvaWQgMDplW25dWzFdfXZhciBvPW4oODEpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gbyh0aGlzLl9fZGF0YV9fLHQpPi0xfXZhciBvPW4oODEpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3ZhciBuPXRoaXMuX19kYXRhX18scj1vKG4sdCk7cmV0dXJuIHI8MD8oKyt0aGlzLnNpemUsbi5wdXNoKFt0LGVdKSk6bltyXVsxXT1lLHRoaXN9dmFyIG89big4MSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKCl7dGhpcy5zaXplPTAsdGhpcy5fX2RhdGFfXz17aGFzaDpuZXcgbyxtYXA6bmV3KGF8fGkpLHN0cmluZzpuZXcgb319dmFyIG89big0NTYpLGk9big4MCksYT1uKDExOSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPW8odGhpcyx0KS5kZWxldGUodCk7cmV0dXJuIHRoaXMuc2l6ZS09ZT8xOjAsZX12YXIgbz1uKDg0KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIG8odGhpcyx0KS5nZXQodCl9dmFyIG89big4NCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiBvKHRoaXMsdCkuaGFzKHQpfXZhciBvPW4oODQpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3ZhciBuPW8odGhpcyx0KSxyPW4uc2l6ZTtyZXR1cm4gbi5zZXQodCxlKSx0aGlzLnNpemUrPW4uc2l6ZT09cj8wOjEsdGhpc312YXIgbz1uKDg0KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9byh0LGZ1bmN0aW9uKHQpe3JldHVybiBuLnNpemU9PT1pJiZuLmNsZWFyKCksdH0pLG49ZS5jYWNoZTtyZXR1cm4gZX12YXIgbz1uKDU3MiksaT01MDA7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDU0NCksbz1yKE9iamVjdC5rZXlzLE9iamVjdCk7dC5leHBvcnRzPW99LGZ1bmN0aW9uKHQsZSxuKXsoZnVuY3Rpb24odCl7dmFyIHI9bigxNzUpLG89XCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJiFlLm5vZGVUeXBlJiZlLGk9byYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJiF0Lm5vZGVUeXBlJiZ0LGE9aSYmaS5leHBvcnRzPT09byxzPWEmJnIucHJvY2Vzcyx1PWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBzJiZzLmJpbmRpbmcmJnMuYmluZGluZyhcInV0aWxcIil9Y2F0Y2godCl7fX0oKTt0LmV4cG9ydHM9dX0pLmNhbGwoZSxuKDkyKSh0KSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gby5jYWxsKHQpfXZhciByPU9iamVjdC5wcm90b3R5cGUsbz1yLnRvU3RyaW5nO3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHQoZShuKSl9fXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7cmV0dXJuIGU9aSh2b2lkIDA9PT1lP3QubGVuZ3RoLTE6ZSwwKSxmdW5jdGlvbigpe2Zvcih2YXIgcj1hcmd1bWVudHMsYT0tMSxzPWkoci5sZW5ndGgtZSwwKSx1PUFycmF5KHMpOysrYTxzOyl1W2FdPXJbZSthXTthPS0xO2Zvcih2YXIgbD1BcnJheShlKzEpOysrYTxlOylsW2FdPXJbYV07cmV0dXJuIGxbZV09bih1KSxvKHQsdGhpcyxsKX19dmFyIG89big0NjIpLGk9TWF0aC5tYXg7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5zZXQodCxyKSx0aGlzfXZhciByPVwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiO3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHQpfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7dmFyIGU9LTEsbj1BcnJheSh0LnNpemUpO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7blsrK2VdPXR9KSxufXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7dmFyIGU9LTEsbj1BcnJheSh0LnNpemUpO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7blsrK2VdPVt0LHRdfSksbn10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNDkyKSxvPW4oNTUxKSxpPW8ocik7dC5leHBvcnRzPWl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXt2YXIgZT0wLG49MDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYT1pKCkscz1vLShhLW4pO2lmKG49YSxzPjApe2lmKCsrZT49cilyZXR1cm4gYXJndW1lbnRzWzBdfWVsc2UgZT0wO3JldHVybiB0LmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpfX12YXIgcj04MDAsbz0xNixpPURhdGUubm93O3QuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcigpe3RoaXMuX19kYXRhX189bmV3IG8sdGhpcy5zaXplPTB9dmFyIG89big4MCk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXt2YXIgZT10aGlzLl9fZGF0YV9fLG49ZS5kZWxldGUodCk7cmV0dXJuIHRoaXMuc2l6ZT1lLnNpemUsbn10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiB0aGlzLl9fZGF0YV9fLmdldCh0KX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh0KX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlKXt2YXIgbj10aGlzLl9fZGF0YV9fO2lmKG4gaW5zdGFuY2VvZiBvKXt2YXIgcj1uLl9fZGF0YV9fO2lmKCFpfHxyLmxlbmd0aDxzLTEpcmV0dXJuIHIucHVzaChbdCxlXSksdGhpcy5zaXplPSsrbi5zaXplLHRoaXM7bj10aGlzLl9fZGF0YV9fPW5ldyBhKHIpfXJldHVybiBuLnNldCh0LGUpLHRoaXMuc2l6ZT1uLnNpemUsdGhpc312YXIgbz1uKDgwKSxpPW4oMTE5KSxhPW4oMTIwKSxzPTIwMDt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGkodCk/YSh0KTpvKHQpfXZhciBvPW4oNDY4KSxpPW4oMTc3KSxhPW4oNTU5KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNTQwKSxvPS9eXFwuLyxpPS9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZyxhPS9cXFxcKFxcXFwpPy9nLHM9cihmdW5jdGlvbih0KXt2YXIgZT1bXTtyZXR1cm4gby50ZXN0KHQpJiZlLnB1c2goXCJcIiksdC5yZXBsYWNlKGksZnVuY3Rpb24odCxuLHIsbyl7ZS5wdXNoKHI/by5yZXBsYWNlKGEsXCIkMVwiKTpufHx0KX0pLGV9KTt0LmV4cG9ydHM9c30sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiB0Lm1hdGNoKHgpfHxbXX12YXIgcj1cIlxcXFx1ZDgwMC1cXFxcdWRmZmZcIixvPVwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLGk9XCJcXFxcdWZlMjAtXFxcXHVmZTJmXCIsYT1cIlxcXFx1MjBkMC1cXFxcdTIwZmZcIixzPW8raSthLHU9XCJcXFxcdWZlMGVcXFxcdWZlMGZcIixsPVwiW1wiK3IrXCJdXCIsYz1cIltcIitzK1wiXVwiLGY9XCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIixwPVwiKD86XCIrYytcInxcIitmK1wiKVwiLGg9XCJbXlwiK3IrXCJdXCIsZD1cIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIix2PVwiW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdXCIsbT1cIlxcXFx1MjAwZFwiLF89cCtcIj9cIixnPVwiW1wiK3UrXCJdP1wiLHk9XCIoPzpcIittK1wiKD86XCIrW2gsZCx2XS5qb2luKFwifFwiKStcIilcIitnK18rXCIpKlwiLGI9ZytfK3ksdz1cIig/OlwiK1toK2MrXCI/XCIsYyxkLHYsbF0uam9pbihcInxcIikrXCIpXCIseD1SZWdFeHAoZitcIig/PVwiK2YrXCIpfFwiK3crYixcImdcIik7dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdC5tYXRjaChXKXx8W119dmFyIHI9XCJcXFxcdWQ4MDAtXFxcXHVkZmZmXCIsbz1cIlxcXFx1MDMwMC1cXFxcdTAzNmZcIixpPVwiXFxcXHVmZTIwLVxcXFx1ZmUyZlwiLGE9XCJcXFxcdTIwZDAtXFxcXHUyMGZmXCIscz1vK2krYSx1PVwiXFxcXHUyNzAwLVxcXFx1MjdiZlwiLGw9XCJhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmZcIixjPVwiXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmN1wiLGY9XCJcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmZcIixwPVwiXFxcXHUyMDAwLVxcXFx1MjA2ZlwiLGg9XCIgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMFwiLGQ9XCJBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVcIix2PVwiXFxcXHVmZTBlXFxcXHVmZTBmXCIsbT1jK2YrcCtoLF89XCJbJ+KAmV1cIixnPVwiW1wiK20rXCJdXCIseT1cIltcIitzK1wiXVwiLGI9XCJcXFxcZCtcIix3PVwiW1wiK3UrXCJdXCIseD1cIltcIitsK1wiXVwiLEU9XCJbXlwiK3IrbStiK3UrbCtkK1wiXVwiLFQ9XCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIixPPVwiKD86XCIreStcInxcIitUK1wiKVwiLFM9XCJbXlwiK3IrXCJdXCIsUD1cIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIixNPVwiW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdXCIsaj1cIltcIitkK1wiXVwiLEE9XCJcXFxcdTIwMGRcIixDPVwiKD86XCIreCtcInxcIitFK1wiKVwiLGs9XCIoPzpcIitqK1wifFwiK0UrXCIpXCIsUj1cIig/OlwiK18rXCIoPzpkfGxsfG18cmV8c3x0fHZlKSk/XCIsST1cIig/OlwiK18rXCIoPzpEfExMfE18UkV8U3xUfFZFKSk/XCIsTj1PK1wiP1wiLFU9XCJbXCIrditcIl0/XCIsRj1cIig/OlwiK0ErXCIoPzpcIitbUyxQLE1dLmpvaW4oXCJ8XCIpK1wiKVwiK1UrTitcIikqXCIsTD1cIlxcXFxkKig/Oig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpXFxcXGIpXCIsRD1cIlxcXFxkKig/Oig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpXFxcXGIpXCIsQj1VK04rRixWPVwiKD86XCIrW3csUCxNXS5qb2luKFwifFwiKStcIilcIitCLFc9UmVnRXhwKFtqK1wiP1wiK3grXCIrXCIrUitcIig/PVwiK1tnLGosXCIkXCJdLmpvaW4oXCJ8XCIpK1wiKVwiLGsrXCIrXCIrSStcIig/PVwiK1tnLGorQyxcIiRcIl0uam9pbihcInxcIikrXCIpXCIsaitcIj9cIitDK1wiK1wiK1IsaitcIitcIitJLEQsTCxiLFZdLmpvaW4oXCJ8XCIpLFwiZ1wiKTt0LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNTYyKSxvPW4oNTA2KSxpPW8oZnVuY3Rpb24odCxlLG4pe3JldHVybiBlPWUudG9Mb3dlckNhc2UoKSx0KyhuP3IoZSk6ZSl9KTt0LmV4cG9ydHM9aX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGkobyh0KS50b0xvd2VyQ2FzZSgpKX12YXIgbz1uKDY1KSxpPW4oNTgwKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQ9aSh0KSx0JiZ0LnJlcGxhY2UoYSxvKS5yZXBsYWNlKHAsXCJcIil9dmFyIG89big1MTApLGk9big2NSksYT0vW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZyxzPVwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLHU9XCJcXFxcdWZlMjAtXFxcXHVmZTJmXCIsbD1cIlxcXFx1MjBkMC1cXFxcdTIwZmZcIixjPXMrdStsLGY9XCJbXCIrYytcIl1cIixwPVJlZ0V4cChmLFwiZ1wiKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe3ZhciByPXModCk/bzppO3JldHVybiBuJiZ1KHQsZSxuKSYmKGU9dm9pZCAwKSxyKHQsYShlLDMpKX12YXIgbz1uKDQ2MyksaT1uKDQ3MiksYT1uKDgyKSxzPW4oMzApLHU9bigxNzgpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1MDcpLG89big1NjcpLGk9cihvKTt0LmV4cG9ydHM9aX0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe3ZhciByPW51bGw9PXQ/MDp0Lmxlbmd0aDtpZighcilyZXR1cm4tMTt2YXIgdT1udWxsPT1uPzA6YShuKTtyZXR1cm4gdTwwJiYodT1zKHIrdSwwKSksbyh0LGkoZSwzKSx1KX12YXIgbz1uKDQ3MyksaT1uKDgyKSxhPW4oNTc3KSxzPU1hdGgubWF4O3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT1udWxsPT10PzA6dC5sZW5ndGg7cmV0dXJuIGU/byh0LDEpOltdfXZhciBvPW4oMTcxKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe3ZhciByPW51bGw9PXQ/dm9pZCAwOm8odCxlKTtyZXR1cm4gdm9pZCAwPT09cj9uOnJ9dmFyIG89bigxMjIpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaSh0KX12YXIgbz1uKDI5KSxpPW8uaXNGaW5pdGU7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dmFyIG49e307cmV0dXJuIGU9YShlLDMpLGkodCxmdW5jdGlvbih0LHIsaSl7byhuLGUodCxyLGkpLHQpfSksbn12YXIgbz1uKDE3MCksaT1uKDE3MiksYT1uKDgyKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHxudWxsIT1lJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoaSk7dmFyIG49ZnVuY3Rpb24oKXt2YXIgcj1hcmd1bWVudHMsbz1lP2UuYXBwbHkodGhpcyxyKTpyWzBdLGk9bi5jYWNoZTtpZihpLmhhcyhvKSlyZXR1cm4gaS5nZXQobyk7dmFyIGE9dC5hcHBseSh0aGlzLHIpO3JldHVybiBuLmNhY2hlPWkuc2V0KG8sYSl8fGksYX07cmV0dXJuIG4uY2FjaGU9bmV3KHIuQ2FjaGV8fG8pLG59dmFyIG89bigxMjApLGk9XCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCI7ci5DYWNoZT1vLHQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0ODUpLG89big1MTMpLGk9byhmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT10P3t9OnIodCxlKX0pO3QuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gYSh0KT9vKHModCkpOmkodCl9dmFyIG89big0ODcpLGk9big0ODgpLGE9bigxMjQpLHM9big2Myk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3JldHVybltdfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXtyZXR1cm4hMX10LmV4cG9ydHM9bn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9byh0KSxuPWUlMTtyZXR1cm4gZT09PWU/bj9lLW46ZTowfXZhciBvPW4oMTg5KTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIHQ7aWYoaSh0KSlyZXR1cm4gYTtpZihvKHQpKXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnZhbHVlT2Y/dC52YWx1ZU9mKCk6dDt0PW8oZSk/ZStcIlwiOmV9aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQpcmV0dXJuIDA9PT10P3Q6K3Q7dD10LnJlcGxhY2UocyxcIlwiKTt2YXIgbj1sLnRlc3QodCk7cmV0dXJuIG58fGMudGVzdCh0KT9mKHQuc2xpY2UoMiksbj8yOjgpOnUudGVzdCh0KT9hOit0fXZhciBvPW4oNTUpLGk9big4OSksYT1OYU4scz0vXlxccyt8XFxzKyQvZyx1PS9eWy0rXTB4WzAtOWEtZl0rJC9pLGw9L14wYlswMV0rJC9pLGM9L14wb1swLTddKyQvaSxmPXBhcnNlSW50O3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1MDkpLG89big0OSksaT1yKG8pO3QuZXhwb3J0cz1pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1MDUpLG89cihcInRvVXBwZXJDYXNlXCIpO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gbnVsbD09dD9bXTpvKHQsaSh0KSl9dmFyIG89big0OTkpLGk9big0OSk7dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuKXtyZXR1cm4gdD1hKHQpLGU9bj92b2lkIDA6ZSx2b2lkIDA9PT1lP2kodCk/cyh0KTpvKHQpOnQubWF0Y2goZSl8fFtdfXZhciBvPW4oNDY5KSxpPW4oNTIwKSxhPW4oNjUpLHM9big1NjApO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlLG49dC5kYXRhLHI9dC5zdHJpZGVbMF0sbz10Lm9mZnNldCxpPTA7Zm9yKGU9dC5zaGFwZVswXS0xO2U+PTA7ZS0tLG8rPXIpaSs9TWF0aC5hYnMobltvXSk7cmV0dXJuIGl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPWUuZGF0YSxpPW4uZGF0YSxhPWUuc3RyaWRlWzBdLHM9bi5zdHJpZGVbMF0sdT1lLm9mZnNldCxsPW4ub2Zmc2V0O2ZvcihyPWUuc2hhcGVbMF0tMTtyPj0wO3ItLSx1Kz1hLGwrPXMpaVtsXSs9dCpvW3VdfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuLHI9dC5kYXRhLG89ZS5kYXRhLGk9dC5zdHJpZGVbMF0sYT1lLnN0cmlkZVswXSxzPXQub2Zmc2V0LHU9ZS5vZmZzZXQ7Zm9yKG49dC5zaGFwZVswXS0xO24+PTA7bi0tLHMrPWksdSs9YSlvW3VdPXJbc119fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPWUuZGF0YSxpPW4uZGF0YSxhPWUuc3RyaWRlWzBdLHM9bi5zdHJpZGVbMF0sdT1lLm9mZnNldCxsPW4ub2Zmc2V0O2ZvcihyPWUuc2hhcGVbMF0tMTtyPj0wO3ItLSx1Kz1hLGwrPXMpaVtsXT10Km9bdV19fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scixvPXQuZGF0YSxpPXQuc3RyaWRlWzBdLGE9dC5vZmZzZXQscz0wO2lmKHQ9PT1lKWZvcihuPXQuc2hhcGVbMF0tMTtuPj0wO24tLSxhKz1pKXI9b1thXSxzKz1yKnI7ZWxzZXt2YXIgdT1lLmRhdGEsbD1lLnN0cmlkZVswXSxjPWUub2Zmc2V0O2ZvcihuPXQuc2hhcGVbMF0tMTtuPj0wO24tLSxhKz1pLGMrPWwpcys9dVtjXSpvW2FdfXJldHVybiBzfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZSxuLHIsbz0tKDEvMCksaT10LmRhdGEsYT10LnN0cmlkZVswXSxzPXQub2Zmc2V0LHU9dC5zaGFwZVswXTtmb3IoZT0wO2U8dTtlKysscys9YSluPU1hdGguYWJzKGlbc10pLG4+byYmKG89bixyPWUpO3JldHVybiByfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPWZ1bmN0aW9uKHQsZSl7aWYoMD09PXQmJjA9PT1lKXJldHVybiAwO3ZhciBuPU1hdGguYWJzKHQpLHI9TWF0aC5hYnMoZSksbz1NYXRoLm1pbihuLHIpLGk9TWF0aC5tYXgobixyKTtyZXR1cm4gby89aSxpKk1hdGguc3FydCgxK28qbyl9O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZSxuLG89dC5kYXRhLGk9dC5zdHJpZGVbMF0sYT10Lm9mZnNldCxzPTA7Zm9yKGU9dC5zaGFwZVswXS0xO2U+PTA7ZS0tLGErPWkpbj1vW2FdLHM9cihzLG4pO3JldHVybiBzfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO01hdGguc2lnbj1NYXRoLnNpZ258fGZ1bmN0aW9uKHQpe3JldHVybiB0PSt0LDA9PT10fHxpc05hTih0KT90OnQ+MD8xOi0xfSx0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPTAsbz0wLGk9MCxhPTAscz0wO3JldHVybiAwPT09ZT8ocj1NYXRoLnNpZ24odCksbz0wLGk9TWF0aC5hYnModCkpOjA9PT10PyhyPTAsbz1NYXRoLnNpZ24oZSksaT1NYXRoLmFicyhlKSk6TWF0aC5hYnModCk+TWF0aC5hYnMoZSk/KGE9ZS90LHM9TWF0aC5zaWduKHQpKk1hdGguc3FydCgxK2EqYSkscj0xL3Msbz1hKnIsaT10KnMpOihhPXQvZSxzPU1hdGguc2lnbih0KSpNYXRoLnNxcnQoMSthKmEpLG89MS9zLHI9YSpvLGk9ZSpzKSx2b2lkIDAhPT1uJiZuLmxlbmd0aD4yPyhuWzBdPXIsblsxXT1vLG5bMl09aSx2b2lkIDApOltyLG8saV19fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scj1lLmRhdGEsbz1lLnN0cmlkZVswXSxpPWUub2Zmc2V0O2ZvcihuPWUuc2hhcGVbMF0tMTtuPj0wO24tLSxpKz1vKXJbaV0qPXR9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scixvPXQuZGF0YSxpPWUuZGF0YSxhPXQuc3RyaWRlWzBdLHM9ZS5zdHJpZGVbMF0sdT10Lm9mZnNldCxsPWUub2Zmc2V0O2ZvcihuPXQuc2hhcGVbMF0tMTtuPj0wO24tLSx1Kz1hLGwrPXMpcj1vW3VdLG9bdV09aVtsXSxpW2xdPXJ9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0LGUsbixyLG8saSxhKXtmb3IodmFyIHM9MCx1PTAsbD0wLGM9MCxmPTAscD10LnNoYXBlWzBdLGg9dC5zaGFwZVsxXSxkPU1hdGgubWluKGUscC0xKSx2PU1hdGgubWluKG4saC0xKSxtPXZvaWQgMD09PWk/MTppLF89dm9pZCAwPT09YT8wOmE7czw9ZDspe2M9MDt2YXIgZz1NYXRoLm1pbihzK3YsaC0xKTtmb3IobD0wO2w8PWc7bCsrKWMrPXQuZ2V0KHMsbCkqci5nZXQobCk7by5zZXQocyxjKm0rXypvLmdldChzKSkscysrfWlmKHM8cClmb3IodT0wO3MrdjxoOyl7Zm9yKGM9MCxsPTA7bDw9ZCt2O2wrKylmPXUrbCsxLGMrPXQuZ2V0KHMsZikqci5nZXQoZik7aWYoby5zZXQocyxjKm0rXypvLmdldChzKSkscysrLHUrKyxzPT09cClicmVha31pZihzPHApZm9yKHUrKztzLWQ8aDspe2ZvcihjPTAsbD11O2w8aDtsKyspYys9dC5nZXQocyxsKSpyLmdldChsKTtpZihvLnNldChzLGMqbStfKm8uZ2V0KHMpKSxzKyssdSsrLHM9PT1wKWJyZWFrfXJldHVybiEwfXQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0LGUsbixyLGkpe2Zvcih2YXIgYT1vLmRvdCxzPWUuc2hhcGVbMF0tMTtzPj0wO3MtLSlpLnNldChzLGkuZ2V0KHMpKnIrdCphKGUucGljayhzLG51bGwpLG4pKTtyZXR1cm4hMH12YXIgbz1uKDkwKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXtjb25zb2xlLmVycm9yKFwiR0VSIChyYW5rIDEgb3BlcmF0aW9uIEEgOj0gYWxwaGEqeCp5JyArIEEpIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7Y29uc29sZS5lcnJvcihcIlNCTVYgKHN5bW1ldHJpYyBiYW5kZWQgbWF0cml4IHZlY3RvciBtdWx0aXBseSkgbm90IHlldCBpbXBsZW1lbnRlZFwiKX10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7Y29uc29sZS5lcnJvcihcIlNQTVYgKHN5bW1ldHJpYyBwYWNrZWQgbWF0cml4IHZlY3RvciBtdWx0aXBseSkgbm90IHlldCBpbXBsZW1lbnRlZFwiKX10LmV4cG9yc3Q9ZX0pLmNhbGwoZSxuKDkyKSh0KSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7Y29uc29sZS5lcnJvcihcIlNQUiAoc3ltbWV0cmljIHBhY2tlZCByYW5rIDEgb3BlcmF0aW9uIEEgOj0gYWxwaGEqeCp5JyArIEEpIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7Y29uc29sZS5lcnJvcihcIlNQUiAoc3ltbWV0cmljIHBhY2tlZCByYW5rIDIgb3BlcmF0aW9uIEEgOj0gYWxwaGEqeCp5JyArIGFscGhhKnkqeCcgKyBBKSBub3QgeWV0IGltcGxlbWVudGVkXCIpfXQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0LGUsbixyLGksYSl7dmFyIHM9dC5zaGFwZVswXSx1PXJ8fCEwLGw9dm9pZCAwPT09aT8xOmksYz12b2lkIDA9PT1hPzA6YSxmPTAscD0wLGg9MCxkPTA7aWYoMD09PWMpZm9yKGY9MDtmPG4uc2hhcGVbMF07KytmKW4uc2V0KGYsMCk7ZWxzZSAxIT09YyYmby5zY2FsKGMsbik7aWYoMD09PWwpcmV0dXJuITA7aWYoMT09PWwpaWYodSlmb3IocD0wO3A8czsrK3Ape2ZvcihoPWUuZ2V0KHApLGQ9MCxuLnNldChwLG4uZ2V0KHApK2gqdC5nZXQocCxwKSksZj1wKzE7ZjxzOysrZiluLnNldChmLG4uZ2V0KGYpK2gqdC5nZXQoZixwKSksZCs9dC5nZXQoZixwKSplLmdldChmKTtuLnNldChwLG4uZ2V0KHApK2QpfWVsc2UgZm9yKHA9MDtwPHM7KytwKXtmb3IoaD1lLmdldChwKSxkPTAsZj0wO2Y8PXAtMTsrK2Ypbi5zZXQoZixuLmdldChmKStoKnQuZ2V0KGYscCkpLGQrPXQuZ2V0KGYscCkqZS5nZXQoZik7bi5zZXQocCxuLmdldChwKStoKnQuZ2V0KHAscCkrZCl9ZWxzZSBpZih1KWZvcihwPTA7cDxzOysrcCl7Zm9yKGg9bCplLmdldChwKSxkPTAsbi5zZXQocCxuLmdldChwKStoKnQuZ2V0KHAscCkpLGY9cCsxO2Y8czsrK2Ypbi5zZXQoZixuLmdldChmKStoKnQuZ2V0KGYscCkpLGQrPXQuZ2V0KGYscCkqZS5nZXQoZik7bi5zZXQocCxuLmdldChwKStsKmQpfWVsc2UgZm9yKHA9MDtwPHM7KytwKXtmb3IoaD1sKmUuZ2V0KHApLGQ9MCxmPTA7Zjw9cC0xOysrZiluLnNldChmLG4uZ2V0KGYpK2gqdC5nZXQoZixwKSksZCs9dC5nZXQoZixwKSplLmdldChmKTtuLnNldChwLG4uZ2V0KHApK2gqdC5nZXQocCxwKStsKmQpfXJldHVybiEwfXZhciBvPW4oOTApO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcigpe2NvbnNvbGUuZXJyb3IoXCJTWVIgKHN5bW1ldHJpYyByYW5rIDEgb3BlcmF0aW9uIEEgOj0gYWxwaGEqeCp5JyArIEEpIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7Y29uc29sZS5lcnJvcihcIlNZUiAoc3ltbWV0cmljIHJhbmsgMiBvcGVyYXRpb24gQSA6PSBhbHBoYSp4KnknICsgYWxwaGEqeSp4JyArIEEpIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7Y29uc29sZS5lcnJvcihcIlRCTVYgKHRyaWFuZ3VsYXIgYmFuZGVkIG1hdHJpeCB2ZWN0b3IgbXVsdGlwbHkpIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe2NvbnNvbGUuZXJyb3IoXCJUQlNWICh0cmlhbmd1bGFyIGJhbmRlZCBtYXRyaXggc29sdmVyKSBub3QgeWV0IGltcGxlbWVudGVkXCIpfXQuZXhwb3JzdD1lfSkuY2FsbChlLG4oOTIpKHQpKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXtjb25zb2xlLmVycm9yKFwiVFBTViAodHJpYW5ndWxhciBwYWNrZWQgbWF0cml4IHNvbHZlcikgbm90IHlldCBpbXBsZW1lbnRlZFwiKX10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlLG4pe3ZhciByPW8uZG90LGk9dC5zaGFwZVsxXSxhPTA7aWYobilmb3IoYT1pLTE7YT49MDthLS0pZS5zZXQoYSxyKHQucGljayhhLG51bGwpLmhpKGErMSksZS5oaShhKzEpKSk7ZWxzZSBmb3IoYT0wO2E8aTthKyspZS5zZXQoYSxyKHQucGljayhhLG51bGwpLmxvKGEpLGUubG8oYSkpKTtyZXR1cm4hMH12YXIgbz1uKDkwKTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlLG4pe3ZhciByPW8uZG90LGk9dC5zaGFwZVsxXSxhPTA7aWYobilmb3IoZS5zZXQoMCxlLmdldCgwKS90LmdldCgwLDApKSxhPTE7YTxpO2ErKyllLnNldChhLChlLmdldChhKS1yKHQucGljayhhLG51bGwpLmhpKGEpLGUuaGkoYSkpKS90LmdldChhLGEpKTtlbHNlIGZvcihlLnNldChpLTEsZS5nZXQoaS0xKS90LmdldChpLTEsaS0xKSksYT1pLTI7YT49MDthLS0pZS5zZXQoYSwoZS5nZXQoYSktcih0LnBpY2soYSxudWxsKS5sbyhhKzEpLGUubG8oYSsxKSkpL3QuZ2V0KGEsYSkpO3JldHVybiEwfXZhciBvPW4oOTApO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcigpe3ZhciB0LGUsbixyLHUsbCxjLGYscCxoO2lmKHI9byh7fSxzKSwwPT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBvZiBuZGFycmF5cyB0byBjb25jYXRlbmF0ZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtpZihBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSk/KG49YXJndW1lbnRzWzBdLG8ocixhcmd1bWVudHNbMV18fHt9KSk6Mj09PWFyZ3VtZW50cy5sZW5ndGgmJihuPWFyZ3VtZW50c1sxXSx0PWFyZ3VtZW50c1swXSxvKHIsYXJndW1lbnRzWzJdfHx7fSkpLDA9PT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBvZiBuZGFycmF5cyB0byBjb25jYXRlbmF0ZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtmb3IodT0wO3U8bi5sZW5ndGg7dSsrKWlmKGMpe2lmKG5bdV0uZGltZW5zaW9uIT09Yy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYWxsIGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uYWxpdHlcIik7Zm9yKGw9MTtsPG5bdV0uc2hhcGUubGVuZ3RoO2wrKylpZihuW3VdLnNoYXBlW2xdIT09Y1tsXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IG4tMSBkaW1lbnNpb25zIG9mIGNvbmNhdGVuYXRlZCByb3dzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplXCIpO2NbMF0rPW5bdV0uc2hhcGVbMF19ZWxzZSBjPW5bdV0uc2hhcGUuc2xpY2UoMCk7aWYodCl7aWYoY1swXSE9PXQuc2hhcGVbMF0pdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgZGltZW5zaW9uIG9mIG91dHB1dCBhcnJheSBtdXN0IG1hdGNoIHRoZSB0b3RhbCBudW1iZXIgb2YgY29uY2F0ZW5hdGVkIHJvd3NcIil9ZWxzZSB0PWEuemVyb3MoYyxyLmR0eXBlKTtmb3IobD0wLGY9MDtsPG4ubGVuZ3RoO2wrKyllPW5bbF0scD1lLnNoYXBlWzBdLGg9dC5sbyhmKS5oaShwKSxpLmFzc2lnbihoLGUpLGYrPXA7cmV0dXJuIHR9dC5leHBvcnRzPXI7dmFyIG89big2MjMpLGk9bigzKSxhPW4oMTkwKSxzPXtkdHlwZTpcImRvdWJsZVwifX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlKXtyZXR1cm5cIm5hdGl2ZVwiPT09ZVsxXT9bdCxcImQwPVwiLHQsXCIubGVuZ3RoLFwiLHQsXCJkMT1cIix0LFwiWzBdLmxlbmd0aCxcIl0uam9pbihcIlwiKTpbdCxcImQwPVwiLHQsXCIuc2hhcGVbMF0sXCIsdCxcImQxPVwiLHQsXCIuc2hhcGVbMV0sXCIsdCxcInMwPVwiLHQsXCIuc3RyaWRlWzBdLFwiLHQsXCJzMT1cIix0LFwiLnN0cmlkZVsxXSxcIix0LFwibz1cIix0LFwiLm9mZnNldCxcIix0LFwiZD1cIix0LFwiLmRhdGEsXCJdLmpvaW4oXCJcIil9ZnVuY3Rpb24gbyh0LGUsbixyLG8saSl7dmFyIGE9W107cmV0dXJuXCJuYXRpdmVcIj09PW5bMV0/dFswXSYmKHI/YS5wdXNoKFwidmFyIFwiLGUsXCJwPVwiLGUsXCJbXCIscixcIl07XCIpOmEucHVzaChcInZhciBcIixlLFwicD1cIixlLFwiWzBdO1wiKSk6ciYmbz9pP2EucHVzaChcInZhciBcIixlLFwidDA9XCIsZSxcInNcIix0WzBdLFwiLFwiLGUsXCJ0MT1cIixlLFwic1wiLHRbMV0sXCItXCIsZSxcInNcIix0WzBdLFwiKlwiLGksXCIsXCIsZSxcInA9XCIsZSxcIm8rXCIscixcIipcIixlLFwiczArXCIsbyxcIipcIixlLFwiczE7XCIpOmEucHVzaChcInZhciBcIixlLFwidDA9XCIsZSxcInNcIix0WzBdLFwiLFwiLGUsXCJwPVwiLGUsXCJvK1wiLHIsXCIqXCIsZSxcInMwK1wiLG8sXCIqXCIsZSxcInMxO1wiKTpyP2EucHVzaChcInZhciBcIixlLFwidDA9XCIsZSxcInNcIix0WzBdLFwiLFwiLGUsXCJwPVwiLGUsXCJvK1wiLHIsXCIqXCIsZSxcInMwO1wiKTpvP2EucHVzaChcInZhciBcIixlLFwidDA9XCIsZSxcInNcIix0WzBdLFwiLFwiLGUsXCJwPVwiLGUsXCJvK1wiLG8sXCIqXCIsZSxcInMxO1wiKTphLnB1c2goXCJ2YXIgXCIsZSxcInQwPVwiLGUsXCJzXCIsdFswXSxcIixcIixlLFwidDE9XCIsZSxcInNcIix0WzFdLFwiLVwiLGUsXCJzXCIsdFswXSxcIipcIixlLFwiZFwiLHRbMF0sXCIsXCIsZSxcInA9XCIsZSxcIm87XCIpLGF9ZnVuY3Rpb24gaSh0LGUsbixyLG8pe3ZhciBpPVtdO3JldHVyblwibmF0aXZlXCI9PT1uWzFdP3RbMF0mJjE9PT1yJiZpLnB1c2goZSxcInA9XCIsZSxcIltcIixvLFwiKzFdXCIpOmkucHVzaChlLFwicCs9XCIsZSxcInRcIixyLFwiO1wiKSxpfWZ1bmN0aW9uIGEodCxlLG4scixvLGkpe3ZhciBhPVtdO3JldHVyblwibmF0aXZlXCI9PT1uWzFdP3RbMF0/YS5wdXNoKGUsXCJwW1wiLG8sXCJdPVwiLGksXCI7XCIpOmEucHVzaChlLFwiW1wiLHIsXCJdW1wiLG8sXCJdPVwiLGksXCI7XCIpOlwiZ2VuZXJpY1wiPT09blsxXT9hLnB1c2goZSxcImQuc2V0KFwiLGUsXCJwLFwiLGksXCIpO1wiKTphLnB1c2goZSxcImRbXCIsZSxcInBdPVwiLGksXCI7XCIpLGF9ZnVuY3Rpb24gcyh0LGUsbixyLG8pe3ZhciBpPVtdO3JldHVyblwibmF0aXZlXCI9PT1uWzFdP3RbMF0/aS5wdXNoKGUsXCJwW1wiLG8sXCJdXCIpOmkucHVzaChlLFwiW1wiLHIsXCJdW1wiLG8sXCJdXCIpOlwiZ2VuZXJpY1wiPT09blsxXT9pLnB1c2goZSxcImQuZ2V0KFwiLGUsXCJwKVwiKTppLnB1c2goZSxcImRbXCIsZSxcInBdXCIpLGkuam9pbihcIlwiKX1mdW5jdGlvbiB1KHQsZSxuLHIsdSl7dmFyIGw9W10sYz1cInJcIj09PXRbMF0/WzEsMF06WzAsMV0sZj1bMSwwXSxwPVswLDFdLGg9W1wiaVwiLFwialwiXTtyZXR1cm4gbC5wdXNoLmFwcGx5KGwsbyhjLFwib1wiLHQpKSxjWzFdPyhsLnB1c2goXCJmb3Ioaj0wO2o8b2QxOysrail7XCIpLGwucHVzaChcImZvcihpPTA7aTxvZDA7KytpKXtcIikpOihsLnB1c2goXCJmb3IoaT0wO2k8b2QwOysraSl7XCIpLGwucHVzaChcImZvcihqPTA7ajxvZDE7KytqKXtcIikpLGwucHVzaC5hcHBseShsLG8oZixcImFcIixlLFwiaVwiKSksbC5wdXNoLmFwcGx5KGwsbyhwLFwiYlwiLG4sdm9pZCAwLFwialwiKSksbC5wdXNoKFwidmFyIHI9MC4wO1wiLFwiZm9yKGs9MDtrPGFkMTsrK2spe1wiLFwicis9XCIscyhmLFwiYVwiLGUsXCJpXCIsXCJrXCIpLFwiKlwiLHMocCxcImJcIixuLFwia1wiLFwialwiKSxcIjtcIiksbC5wdXNoLmFwcGx5KGwsaShmLFwiYVwiLGUsMCxcImtcIikpLGwucHVzaC5hcHBseShsLGkocCxcImJcIixuLDAsXCJrXCIpKSxsLnB1c2goXCJ9XCIpLHImJmwucHVzaChcInIqPUE7XCIpLHUmJmwucHVzaChcInIrPUIqXCIscyhjLFwib1wiLHQsXCJpXCIsXCJqXCIpLFwiO1wiKSxsLnB1c2guYXBwbHkobCxhKGMsXCJvXCIsdCxcImlcIixcImpcIixcInJcIikpLGwucHVzaC5hcHBseShsLGkoYyxcIm9cIix0LDAsaFsxXSkpLGwucHVzaChcIn1cIiksbC5wdXNoLmFwcGx5KGwsaShjLFwib1wiLHQsMSxoWzBdKSksbC5wdXNoKFwifVwiKSxsfWZ1bmN0aW9uIGwodCxlKXt2YXIgbixyPVtdLHU9XCJyXCI9PT10WzBdP1sxLDBdOlswLDFdO3JldHVybiBlJiZyLnB1c2goXCJpZihCIT09MS4wKXtcIiksci5wdXNoLmFwcGx5KHIsbyh1LFwib1wiLHQpKSx1WzBdPyhyLnB1c2goXCJmb3IoaT0wO2k8b2QwOysraSl7Zm9yKGo9MDtqPG9kMTsrK2ope1wiKSxuPVtcImlcIixcImpcIl0pOihyLnB1c2goXCJmb3Ioaj0wO2o8b2QxOysrail7Zm9yKGk9MDtpPG9kMDsrK2kpe1wiKSxuPVtcImpcIixcImlcIl0pLGU/ci5wdXNoLmFwcGx5KHIsYSh1LFwib1wiLHQsXCJpXCIsXCJqXCIsXCJCKlwiK3ModSxcIm9cIix0LFwiaVwiLFwialwiKSkpOnIucHVzaC5hcHBseShyLGEodSxcIm9cIix0LFwiaVwiLFwialwiLFwiMFwiKSksci5wdXNoLmFwcGx5KHIsaSh1LFwib1wiLHQsMCxuWzFdKSksci5wdXNoKFwifVwiKSxyLnB1c2guYXBwbHkocixpKHUsXCJvXCIsdCwxLG5bMF0pKSxyLnB1c2goXCJ9XCIpLGUmJnIucHVzaChcIn1cIikscn1mdW5jdGlvbiBjKHQsZSxuLHIsdSl7dmFyIGM9W10sZj1bXCJvZDBcIixcIm9kMVwiLFwiYWQxXCJdLGg9WzEsMF0sZD1bMSwwXSx2PVswLDFdO2MucHVzaC5hcHBseShjLGwodCx1KSk7Zm9yKHZhciBtPTA7bTwzOysrbSljLnB1c2goXCJmb3IodmFyIGlcIixtLFwiPVwiLGZbbV0sXCI7aVwiLG0sXCI+MDspe1wiLFwidmFyIHdcIixtLFwiPVwiLHAsXCI7XCIsXCJpZihpXCIsbSxcIjxcIixwLFwiKXtcIixcIndcIixtLFwiPWlcIixtLFwiO1wiLFwiaVwiLG0sXCI9MDtcIixcIn1lbHNle1wiLFwiaVwiLG0sXCItPVwiLHAsXCI7XCIsXCJ9XCIpO2MucHVzaC5hcHBseShjLG8oaCxcIm9cIix0LFwiaTBcIixcImkxXCIsXCJ3MVwiKSksYy5wdXNoKFwiZm9yKGk9MDtpPHcwOysraSl7Zm9yKGo9MDtqPHcxOysrail7dmFyIHI9MC4wO1wiKSxjLnB1c2guYXBwbHkoYyxvKGQsXCJhXCIsZSxcIihpMCtpKVwiLFwiaTJcIikpLGMucHVzaC5hcHBseShjLG8odixcImJcIixuLFwiaTJcIixcIihpMStqKVwiKSksYy5wdXNoKFwiZm9yKGs9MDtrPHcyOysrayl7XCIpLGMucHVzaChcInIrPVwiLHMoZCxcImFcIixlLFwiKGkwK2kpXCIsXCIoaTIraylcIiksXCIqXCIscyh2LFwiYlwiLG4sXCIoaTIraylcIixcIihpMStqKVwiKSxcIjtcIiksYy5wdXNoLmFwcGx5KGMsaShkLFwiYVwiLGUsMCxcIihpMitrKVwiKSksYy5wdXNoLmFwcGx5KGMsaSh2LFwiYlwiLG4sMCxcIihpMitrKVwiKSksYy5wdXNoKFwifVwiKTt2YXIgXz1cInJcIjtyZXR1cm4gciYmKF89XCJBKnJcIiksYy5wdXNoLmFwcGx5KGMsYShoLFwib1wiLHQsXCIoaTAraSlcIixcIihpMStqKVwiLF8rXCIrXCIrcyhoLFwib1wiLHQsXCIoaTAraSlcIixcIihpMStqKVwiKSkpLGMucHVzaC5hcHBseShjLGkoaCxcIm9cIix0LDAsXCIoaTErailcIikpLGMucHVzaChcIn1cIiksYy5wdXNoLmFwcGx5KGMsaShoLFwib1wiLHQsMSxcIihpMCtpKVwiKSksYy5wdXNoKFwifX19fVwiKSxjfWZ1bmN0aW9uIGYodCxlLG4sbyxpKXt2YXIgYT1bXCJnZW1tXCIsdFswXSx0WzFdLFwiYVwiLGVbMF0sZVsxXSxcImJcIixuWzBdLG5bMV0sbz9cImFscGhhXCI6XCJcIixpP1wiYmV0YVwiOlwiXCJdLmpvaW4oXCJcIikscz1bXCJmdW5jdGlvbiBcIixhLFwiKG8sYSxiLEEsQil7XCIsXCJ2YXIgXCIscihcIm9cIix0KSxyKFwiYVwiLGUpLHIoXCJiXCIsbiksXCJpLGosaztcIl07XCJyXCI9PT1lWzBdJiZcImNcIj09PW5bMF0/cy5wdXNoLmFwcGx5KHMsdSh0LGUsbixvLGkpKTpzLnB1c2guYXBwbHkocyxjKHQsZSxuLG8saSkpLHMucHVzaChcIn1yZXR1cm4gXCIsYSk7dmFyIGw9bmV3IEZ1bmN0aW9uKHMuam9pbihcIlwiKSk7cmV0dXJuIGwoKX10LmV4cG9ydHM9Zjt2YXIgcD0zMn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXt2YXIgdCxlLG4scjtpZigyPT09YXJndW1lbnRzLmxlbmd0aD8oZT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0pOjM9PT1hcmd1bWVudHMubGVuZ3RoJiYobj1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0pLCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBFcnJvcihcInNlY29uZCBhcmd1bWVudCBvZiB0aWxlIG11c3QgYmUgYW4gYXJyYXkgb2YgcmVwZXRpdGlvbiBjb3VudHMgZm9yIGVhY2ggZGltZW5zaW9uXCIpO3ZhciBhPWUuc2hhcGUuc2xpY2UoMCkscz1hLnNsaWNlKDApLHU9TWF0aC5tYXgocy5sZW5ndGgsci5sZW5ndGgpO2Zvcih0PTA7dDx1O3QrKylpZihhW3RdPXZvaWQgMD09PWFbdF0/MTphW3RdLHJbdF09dm9pZCAwPT09clt0XT8xOnJbdF0sc1t0XT0odm9pZCAwPT09c1t0XT8xOnNbdF0pKnJbdF0sMD09PXNbdF0pdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIHRpbGVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm9cIik7bnx8KG49by56ZXJvcyhzLGUuZHR5cGUpKTt2YXIgbD0xO2Zvcih0PTA7dDxyLmxlbmd0aDt0KyspbCo9clt0XTt2YXIgYz1uZXcgQXJyYXkoci5sZW5ndGgpO2Zvcih0PTA7dDxyLmxlbmd0aDt0KyspY1t0XT0wO3ZhciBmPXMuc2xpY2UoMCk7Zm9yKGg9MDtoPHMubGVuZ3RoO2grKylmW2hdPWg8ZS5kaW1lbnNpb24/bnVsbDowO2Zvcih0PTA7dDxsO3QrKyl7Zm9yKGg9ZS5kaW1lbnNpb247aDxzLmxlbmd0aDtoKyspZltoXT1jW2hdO3ZhciBwPW4ucGljay5hcHBseShuLGYpO2lmKHA9cC5sby5hcHBseShwLGMpLHA9cC5oaS5hcHBseShwLGUuc2hhcGUpLGkuYXNzaWduKHAsZSksdD09PWwtMSlicmVhaztmb3IodmFyIGg9dS0xO2g+PTAmJihjW2hdKz1hW2hdLGNbaF09PT1zW2hdKTspY1toXT0wLGgtLX1yZXR1cm4gbn12YXIgbz1uKDE5MCksaT1uKDMpO3QuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz0nLy8gMkQgY29udm9sdXRpb24gZnJhZ21lbnQgc2hhZGVyIC0gYmFzZWQgb24gaW0yY29sICsgZ2VtbSBpbXBsZW1lbnRhdGlvblxcbi8vIFRoZSBpbnB1dCB0ZXh0dXJlLCBYLCBpcyBhbHJlYWR5IGNvbmZpZ3VyZWQgYXMgY29sdW1uIG1hdHJpeCwgYWZ0ZXJcXG4vLyBpbnB1dF90cmFuc2Zvcm0uZ2xzbCBpcyBydW4gb24gaXQgaWYgbmVjZXNzYXJ5LiBUaGUgb3V0cHV0IHRleHR1cmUgaXMgaW4gY29sdW1uXFxuLy8gbWF0cml4IGNvbmZpZ3VyYXRpb24sIGFuZCB3aWxsIG5lZWQgdG8gYmUgcmVzaGFwZWQgb3IgdHJhbnNmb3JtZWQgcHJpb3IgdG8gdGhlXFxuLy8gbmV4dCBsYXllci5cXG5cXG4vLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgYWRhcHRlZCBmcm9tIHdlYmxhcywgc3BlY2lmaWNhbGx5IHRoZSBzZ2VtbSBwYXJ0cy5cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2F5bG9uZmxpbm4vd2VibGFzXFxuLy9cXG4vLyBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4vL1xcbi8vIENvcHlyaWdodCAoYykgMjAxNSBXYXlsb24gRmxpbm5cXG4vLyBNb2RpZmllZCBieSBMZW9uIENoZW4sIDIwMTdcXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxcbi8vIFNPRlRXQVJFLlxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiBvdXRUZXg7XFxudW5pZm9ybSBzYW1wbGVyMkQgWDtcXG51bmlmb3JtIHNhbXBsZXIyRCBXO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGI7XFxudW5pZm9ybSBpbnQgaW5wdXRDb2xzO1xcbnVuaWZvcm0gaW50IG91dHB1dENvbHM7XFxudW5pZm9ybSBpbnQgaW5wdXRDb2xQYWQ7XFxudW5pZm9ybSBpbnQgb3V0cHV0Q29sUGFkO1xcbnVuaWZvcm0gaW50IHJlbHU7XFxuXFxuLy8gc3VtIG9mIHByb2R1Y3RzIGJldHdlZW4gZWxlbWVudHMgaW4gcm93IGkgKGZyb20gWCkgeCBjb2wgaiAoZnJvbSBCKVxcbi8vXFxuLy8gQ2FsY3VsYXRlIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHRoZSByb3cgKGZyb20gWCkgYW5kIGNvbHVtbiAoZnJvbSBCKVxcbi8vIGlkZW50aWZpZWQgYnkgdGhlIHBhc3NlZCBpbmRlY2VzIChvdXRwdXQgdGV4dHVyZSBjb29yZGluYXRlIHNwYWNlKS5cXG4vLyBXZSBsb29wIG92ZXIgZWxlbWVudHMgaW4gdGhlIHJvdyBhbmQgY29sdW1uIGFuZCBzdW0gdGhlIHByb2R1Y3RcXG4vLyB1c2luZyB0aGUgZ2xzbCBgZG90YCBmdW5jdGlvbiB0byBwcm9jZXNzIGZvdXIgZWxlbWVudHMgYXQgYSB0aW1lLlxcbi8vIFRoaXMgZm91ciBlbGVtZW50IG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGF0IHRoZSBtYXRyaXggQiBiZVxcbi8vIHRyYW5zcG9zZWQgYmVmb3JlIHRleGVsIHBhY2tpbmcgYW5kIHRoYXQgYm90aCBtYXRyaWNlcyBiZSBwYWRkZWRcXG4vLyAod2l0aCB6ZXJvcykgdG8gYSBtdWx0aXBsZSBvZiBmb3VyICg0KSBpbiB0aGVpciBzaGFyZWQgZGltZW5zaW9uLlxcbmZsb2F0IGRvdF9yb3djb2wgKGZsb2F0IHksIGZsb2F0IHgsIHNhbXBsZXIyRCBYLCBzYW1wbGVyMkQgVywgaW50IEspIHtcXG4gIGZsb2F0IGRlbHRhX3QgPSAxLiAvIGZsb2F0KEspOyAvLyBzcGFjZSAob24gdGV4dHVyZSkgYmV0d2VlbiBlbGVtZW50c1xcbiAgZmxvYXQgc3VtID0gMC47IC8vIHN1bSBmb3IgdGhpcyByb3cvY29sdW1uIHBhaXJcXG4gIGZsb2F0IHogPSAwLjUgKiAoNC4wICogZGVsdGFfdCk7Ly8gcG9zaXRpb24gZm9yIHNoYXJlZCBkaW1lbnNpb24gb24gc291cmNlIHRleHR1cmVzXFxuXFxuICBmb3IgKGludCBsID0gMDsgbCA8IDQwOTY7ICsrbCkge1xcbiAgICBpZiAobCA+PSBLIC8gNCkgYnJlYWs7IC8vIHN0b3Agd2hlbiB3ZSBmaW5pc2ggdGhlIHJvdy9jb2x1bW5cXG4gICAgLy8gbCBpcyBpbiBwaXhlbCBzcGFjZSwgc28gd2UgZGl2aWRlIGJ5IGZvdXJcXG5cXG4gICAgLy8gcmV0cmlldmUgbmV4dCBmb3VyIGVsZW1lbnRzIGZyb20gZWFjaCB0ZXh0dXJlXFxuICAgIHZlYzQgYV9payA9IHRleHR1cmUyRChYLCB2ZWMyKHosIHkpKTtcXG4gICAgdmVjNCBiX2tqID0gdGV4dHVyZTJEKFcsIHZlYzIoeiwgeCkpO1xcblxcbiAgICAvLyB1c2UgYGRvdGAgdG8gcHJvY2VzcyBmb3VyIGVsZW1lbnRzIGF0IGEgdGltZVxcbiAgICBzdW0gKz0gZG90KGFfaWssIGJfa2opO1xcbiAgICB6ICs9ICg0LjAgKiBkZWx0YV90KTsgLy8gKHogKyAwLjUpKmRlbHRhXFxuICB9XFxuICByZXR1cm4gc3VtO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcbiAgLy8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcbiAgLy8gdGV4dHVyZSBjb29yZGluYXRlLiBUaGVzZSBtYXAgZGlyZWN0bHkgdG8gaW5wdXQgdGV4dHVyZSBzcGFjZSB3aGVuXFxuICAvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuICBmbG9hdCByb3dfdCA9IG91dFRleC55O1xcbiAgZmxvYXQgY29sX3QgPSBvdXRUZXgueDtcXG4gIHZlYzQgYl92ID0gdGV4dHVyZTJEKGIsIHZlYzIoY29sX3QsIDAuNSkpO1xcblxcbiAgdmVjNCBzdW1fdiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gIGZsb2F0IGNvbCA9IChjb2xfdCAqIGZsb2F0KG91dHB1dENvbHMgKyBvdXRwdXRDb2xQYWQpIC0gMi4wKTsgLy8gaW5kZXggb2YgZmlyc3QgZWxlbWVudCBpbiBwaXhlbCAobWF0cml4IHNwYWNlKVxcbiAgc3VtX3YuciA9IGRvdF9yb3djb2wocm93X3QsIChjb2wgKyAwLjUpIC8gZmxvYXQob3V0cHV0Q29scyksIFgsIFcsIGlucHV0Q29scyArIGlucHV0Q29sUGFkKTtcXG4gIC8vIGluIHRoZSBwYWRkaW5nIHJlZ2lvbj9cXG4gIGlmIChvdXRwdXRDb2xQYWQgPiAwICYmIChjb2wgKyA0LjApID4gZmxvYXQob3V0cHV0Q29scykpIHtcXG4gICAgLy8gcGFkXFxuICAgIGlmIChvdXRwdXRDb2xQYWQgPCAzKSB7XFxuICAgICAgc3VtX3YuZyA9IGRvdF9yb3djb2wocm93X3QsIChjb2wgKyAxLjUpIC8gZmxvYXQob3V0cHV0Q29scyksIFgsIFcsIGlucHV0Q29scyArIGlucHV0Q29sUGFkKTtcXG4gICAgfVxcbiAgICBpZiAob3V0cHV0Q29sUGFkIDwgMikge1xcbiAgICAgIHN1bV92LmIgPSBkb3Rfcm93Y29sKHJvd190LCAoY29sICsgMi41KSAvIGZsb2F0KG91dHB1dENvbHMpLCBYLCBXLCBpbnB1dENvbHMgKyBpbnB1dENvbFBhZCk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHN1bV92LmcgPSBkb3Rfcm93Y29sKHJvd190LCAoY29sICsgMS41KSAvIGZsb2F0KG91dHB1dENvbHMpLCBYLCBXLCBpbnB1dENvbHMgKyBpbnB1dENvbFBhZCk7XFxuICAgIHN1bV92LmIgPSBkb3Rfcm93Y29sKHJvd190LCAoY29sICsgMi41KSAvIGZsb2F0KG91dHB1dENvbHMpLCBYLCBXLCBpbnB1dENvbHMgKyBpbnB1dENvbFBhZCk7XFxuICAgIHN1bV92LmEgPSBkb3Rfcm93Y29sKHJvd190LCAoY29sICsgMy41KSAvIGZsb2F0KG91dHB1dENvbHMpLCBYLCBXLCBpbnB1dENvbHMgKyBpbnB1dENvbFBhZCk7XFxuICB9XFxuXFxuICBpZiAocmVsdSA9PSAxKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IG1heChzdW1fdiArIGJfdiwgMC4wKTtcXG4gIH0gZWxzZSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHN1bV92ICsgYl92O1xcbiAgfVxcbn1cXG4nfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1cIi8vIFRyYW5zZm9ybSBpbnB1dCBtYXRyaXggWCBiYXNlZCBvbiBpbmRleCBtYXBwaW5ncywgaW5kZXhNYXBwaW5nUm93IGFuZCBpbmRleE1hcHBpbmdDb2wuXFxuLy8gVGhpcyBpcyBhbiBleHRlbnNpb24gb2Ygd2VibGFzLlxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93YXlsb25mbGlubi93ZWJsYXNcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgb3V0VGV4O1xcbnVuaWZvcm0gc2FtcGxlcjJEIFg7XFxudW5pZm9ybSBzYW1wbGVyMkQgaW5kZXhNYXBwaW5nUm93O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGluZGV4TWFwcGluZ0NvbDtcXG51bmlmb3JtIGludCBpbnB1dFJvd3M7XFxudW5pZm9ybSBpbnQgaW5wdXRDb2xzO1xcbnVuaWZvcm0gaW50IG91dHB1dENvbHM7XFxudW5pZm9ybSBpbnQgaW5wdXRDb2xQYWQ7XFxudW5pZm9ybSBpbnQgb3V0cHV0Q29sUGFkO1xcblxcbmZsb2F0IHNlbGVjdF9pbmRleCh2ZWM0IHYsIGludCBpbmRleCkge1xcbiAgZmxvYXQgdmFsID0gMC4wO1xcbiAgaWYgKGluZGV4ID09IDApIHtcXG4gICAgdmFsID0gdi5yO1xcbiAgfSBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuICAgIHZhbCA9IHYuZztcXG4gIH0gZWxzZSBpZiAoaW5kZXggPT0gMikge1xcbiAgICB2YWwgPSB2LmI7XFxuICB9IGVsc2UgaWYgKGluZGV4ID09IDMpIHtcXG4gICAgdmFsID0gdi5hO1xcbiAgfVxcbiAgcmV0dXJuIHZhbDtcXG59XFxuXFxudm9pZCBmaXhfcGFkKGlub3V0IHZlYzQgdiwgaW50IHBhZCkge1xcbiAgdi5hID0gMC4wO1xcbiAgaWYgKHBhZCA9PSAyKSB7XFxuICAgIHYuYiA9IDAuMDtcXG4gIH0gZWxzZSBpZiAocGFkID09IDMpIHtcXG4gICAgdi5iID0gMC4wO1xcbiAgICB2LmcgPSAwLjA7XFxuICB9XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIChtYXRyaXggc3BhY2UpXFxuICBmbG9hdCBjb2wgPSBmbG9vcihvdXRUZXgueCAqIGZsb2F0KG91dHB1dENvbHMgKyBvdXRwdXRDb2xQYWQpIC0gMS41KTtcXG5cXG4gIHZlYzQgcm93SW5kaWNlcyA9IHRleHR1cmUyRChpbmRleE1hcHBpbmdSb3csIHZlYzIob3V0VGV4LngsIG91dFRleC55KSk7XFxuICB2ZWM0IGNvbEluZGljZXMgPSB0ZXh0dXJlMkQoaW5kZXhNYXBwaW5nQ29sLCB2ZWMyKG91dFRleC54LCBvdXRUZXgueSkpO1xcblxcbiAgZmxvYXQgcm93SW5kZXg7XFxuICBmbG9hdCBjb2xJbmRleDtcXG4gIGZsb2F0IGlucHV0Q29vcmRYO1xcbiAgZmxvYXQgaW5wdXRDb29yZFk7XFxuICB2ZWMyIGlucHV0Q29vcmRzO1xcbiAgaW50IGlucHV0Q2hhbm5lbDtcXG4gIHZlYzQgbWFwcGVkVmFsdWVzID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgcm93SW5kZXggPSBzZWxlY3RfaW5kZXgocm93SW5kaWNlcywgaSk7XFxuICAgIGNvbEluZGV4ID0gc2VsZWN0X2luZGV4KGNvbEluZGljZXMsIGkpO1xcblxcbiAgICBpZiAocm93SW5kZXggIT0gLTEuMCAmJiBjb2xJbmRleCAhPSAtMS4wKSB7XFxuICAgICAgaW5wdXRDb29yZFggPSAoZmxvYXQoY29sSW5kZXgpICsgMC41KSAvIGZsb2F0KGlucHV0Q29scyArIGlucHV0Q29sUGFkKTtcXG4gICAgICBpbnB1dENvb3JkWSA9IChmbG9hdChyb3dJbmRleCkgKyAwLjUpIC8gZmxvYXQoaW5wdXRSb3dzKTtcXG4gICAgICBpbnB1dENvb3JkcyA9IHZlYzIoaW5wdXRDb29yZFgsIGlucHV0Q29vcmRZKTtcXG4gICAgICBpbnB1dENoYW5uZWwgPSBpbnQobW9kKGNvbEluZGV4LCA0LjApKTtcXG4gICAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgICBtYXBwZWRWYWx1ZXMuciA9IHNlbGVjdF9pbmRleCh0ZXh0dXJlMkQoWCwgaW5wdXRDb29yZHMpLCBpbnB1dENoYW5uZWwpO1xcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSAxKSB7XFxuICAgICAgICBtYXBwZWRWYWx1ZXMuZyA9IHNlbGVjdF9pbmRleCh0ZXh0dXJlMkQoWCwgaW5wdXRDb29yZHMpLCBpbnB1dENoYW5uZWwpO1xcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSAyKSB7XFxuICAgICAgICBtYXBwZWRWYWx1ZXMuYiA9IHNlbGVjdF9pbmRleCh0ZXh0dXJlMkQoWCwgaW5wdXRDb29yZHMpLCBpbnB1dENoYW5uZWwpO1xcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSAzKSB7XFxuICAgICAgICBtYXBwZWRWYWx1ZXMuYSA9IHNlbGVjdF9pbmRleCh0ZXh0dXJlMkQoWCwgaW5wdXRDb29yZHMpLCBpbnB1dENoYW5uZWwpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBzZXQgcGFkIHZhbHVlcyB0byAwLjAsIGlmIGluIHBhZGRlZCByZWdpb24gb2Ygb3V0cHV0IHRleHR1cmVcXG4gICAgaWYgKG91dHB1dENvbFBhZCA+IDAgJiYgY29sICsgNC4wID4gZmxvYXQob3V0cHV0Q29scykpIHtcXG4gICAgICBmaXhfcGFkKG1hcHBlZFZhbHVlcywgb3V0cHV0Q29sUGFkKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gbWFwcGVkVmFsdWVzO1xcbn1cXG5cIn0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9XCIvLyBNZXJnZSBvcC5cXG4vLyBNb2RlczogJ3N1bScsICdtdWwnLCAnYXZlJywgJ21heCdcXG4vLyBUaGlzIGlzIGFuIGV4dGVuc2lvbiBvZiB3ZWJsYXMuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dheWxvbmZsaW5uL3dlYmxhc1xcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiBvdXRUZXg7XFxudW5pZm9ybSBzYW1wbGVyMkQgaW5wdXRzWzhdOyAvLyBhcnJheSBsZW5ndGggbXVzdCBiZSBmaXhlZFxcbnVuaWZvcm0gaW50IG51bUlucHV0cztcXG51bmlmb3JtIGludCBtb2RlQ29kZTtcXG51bmlmb3JtIGludCBvdXRwdXRDb2xzO1xcbnVuaWZvcm0gaW50IG91dHB1dENvbFBhZDtcXG5cXG52b2lkIGZpeF9wYWQoaW5vdXQgdmVjNCB2LCBpbnQgcGFkKSB7XFxuICB2LmEgPSAwLjA7XFxuICBpZiAocGFkID09IDIpIHtcXG4gICAgdi5iID0gMC4wO1xcbiAgfSBlbHNlIGlmIChwYWQgPT0gMykge1xcbiAgICB2LmIgPSAwLjA7XFxuICAgIHYuZyA9IDAuMDtcXG4gIH1cXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG4gIGZsb2F0IGNvbCA9IGZsb29yKG91dFRleC54ICogZmxvYXQob3V0cHV0Q29scyArIG91dHB1dENvbFBhZCkgLSAxLjUpO1xcblxcbiAgdmVjNCBtZXJnZVZhbHVlcyA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gIGlmIChtb2RlQ29kZSA9PSAxKSB7XFxuICAgIC8vIG11bFxcbiAgICBtZXJnZVZhbHVlcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG4gIH0gZWxzZSBpZiAobW9kZUNvZGUgPT0gNCkge1xcbiAgICAvLyBtYXhcXG4gICAgY29uc3QgZmxvYXQgbWluID0gLTEuMGUrMDg7XFxuICAgIG1lcmdlVmFsdWVzID0gdmVjNChtaW4sIG1pbiwgbWluLCBtaW4pO1xcbiAgfVxcblxcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcXG4gICAgaWYgKGkgPj0gbnVtSW5wdXRzKSB7XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG5cXG4gICAgaWYgKG1vZGVDb2RlID09IDAgfHwgbW9kZUNvZGUgPT0gMykge1xcbiAgICAgIC8vIHN1bVxcbiAgICAgIC8vIGF2ZVxcbiAgICAgIG1lcmdlVmFsdWVzID0gbWVyZ2VWYWx1ZXMgKyB0ZXh0dXJlMkQoaW5wdXRzW2ldLCB2ZWMyKG91dFRleC54LCBvdXRUZXgueSkpO1xcbiAgICB9IGVsc2UgaWYgKG1vZGVDb2RlID09IDEpIHtcXG4gICAgICAvLyBtdWxcXG4gICAgICBtZXJnZVZhbHVlcyA9IG1lcmdlVmFsdWVzICogdGV4dHVyZTJEKGlucHV0c1tpXSwgdmVjMihvdXRUZXgueCwgb3V0VGV4LnkpKTtcXG4gICAgfSBlbHNlIGlmIChtb2RlQ29kZSA9PSA0KSB7XFxuICAgICAgLy8gbWF4XFxuICAgICAgbWVyZ2VWYWx1ZXMgPSBtYXgobWVyZ2VWYWx1ZXMsIHRleHR1cmUyRChpbnB1dHNbaV0sIHZlYzIob3V0VGV4LngsIG91dFRleC55KSkpO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAobW9kZUNvZGUgPT0gMykge1xcbiAgICAvLyBhdmVcXG4gICAgbWVyZ2VWYWx1ZXMgPSBtZXJnZVZhbHVlcyAvIGZsb2F0KG51bUlucHV0cyk7XFxuICB9XFxuXFxuICAvLyBzZXQgcGFkIHZhbHVlcyB0byAwLjAsIGlmIGluIHBhZGRlZCByZWdpb24gb2Ygb3V0cHV0IHRleHR1cmVcXG4gIGlmIChvdXRwdXRDb2xQYWQgPiAwICYmIGNvbCArIDQuMCA+IGZsb2F0KG91dHB1dENvbHMpKSB7XFxuICAgIGZpeF9wYWQobWVyZ2VWYWx1ZXMsIG91dHB1dENvbFBhZCk7XFxuICB9XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBtZXJnZVZhbHVlcztcXG59XFxuXCI7XG59LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPVwiLy8gTWVyZ2Ugb3AuXFxuLy8gTW9kZXM6ICdjb25jYXQnXFxuLy8gVGhpcyBpcyBhbiBleHRlbnNpb24gb2Ygd2VibGFzLlxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93YXlsb25mbGlubi93ZWJsYXNcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgb3V0VGV4O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGlucHV0c1s4XTsgLy8gYXJyYXkgbGVuZ3RoIG11c3QgYmUgZml4ZWRcXG51bmlmb3JtIGludCBudW1JbnB1dHM7XFxudW5pZm9ybSBpbnQgaW5wdXRDaGFubmVsU3RhcnRJbmRpY2VzWzhdO1xcbnVuaWZvcm0gaW50IG91dHB1dFJvd3M7XFxudW5pZm9ybSBpbnQgb3V0cHV0Q29scztcXG51bmlmb3JtIGludCBvdXRwdXRDb2xQYWQ7XFxuXFxudm9pZCBmaXhfcGFkKGlub3V0IHZlYzQgdiwgaW50IHBhZCkge1xcbiAgdi5hID0gMC4wO1xcbiAgaWYgKHBhZCA9PSAyKSB7XFxuICAgIHYuYiA9IDAuMDtcXG4gIH0gZWxzZSBpZiAocGFkID09IDMpIHtcXG4gICAgdi5iID0gMC4wO1xcbiAgICB2LmcgPSAwLjA7XFxuICB9XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIChtYXRyaXggc3BhY2UpXFxuICBmbG9hdCBjb2wgPSBmbG9vcihvdXRUZXgueCAqIGZsb2F0KG91dHB1dENvbHMgKyBvdXRwdXRDb2xQYWQpIC0gMC41KTtcXG5cXG4gIHZlYzQgb3V0VmFsdWVzID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgaW50IHJvdyA9IGludChmbG9vcihvdXRUZXgueSAqIGZsb2F0KG91dHB1dFJvd3MpKSk7XFxuICBmbG9hdCBpbnB1dENvb3JkWTtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XFxuICAgIGlmIChpID49IG51bUlucHV0cykge1xcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuXFxuICAgIGlmIChpID09IG51bUlucHV0cyAtIDEpIHtcXG4gICAgICBpbnB1dENvb3JkWSA9ICgwLjUgKyBmbG9vcihvdXRUZXgueSAqIGZsb2F0KG91dHB1dFJvd3MpKSAtIGZsb2F0KGlucHV0Q2hhbm5lbFN0YXJ0SW5kaWNlc1tpXSkpIC8gZmxvYXQob3V0cHV0Um93cyAtIGlucHV0Q2hhbm5lbFN0YXJ0SW5kaWNlc1tpXSk7XFxuICAgICAgb3V0VmFsdWVzID0gdGV4dHVyZTJEKGlucHV0c1tpXSwgdmVjMihvdXRUZXgueCwgaW5wdXRDb29yZFkpKTtcXG4gICAgICBicmVhaztcXG4gICAgfSBlbHNlIGlmIChyb3cgPj0gaW5wdXRDaGFubmVsU3RhcnRJbmRpY2VzW2ldICYmIHJvdyA8IGlucHV0Q2hhbm5lbFN0YXJ0SW5kaWNlc1tpICsgMV0pIHtcXG4gICAgICBpbnB1dENvb3JkWSA9ICgwLjUgKyBmbG9vcihvdXRUZXgueSAqIGZsb2F0KG91dHB1dFJvd3MpKSAtIGZsb2F0KGlucHV0Q2hhbm5lbFN0YXJ0SW5kaWNlc1tpXSkpIC8gZmxvYXQoaW5wdXRDaGFubmVsU3RhcnRJbmRpY2VzW2kgKyAxXSAtIGlucHV0Q2hhbm5lbFN0YXJ0SW5kaWNlc1tpXSk7XFxuICAgICAgb3V0VmFsdWVzID0gdGV4dHVyZTJEKGlucHV0c1tpXSwgdmVjMihvdXRUZXgueCwgaW5wdXRDb29yZFkpKTtcXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gc2V0IHBhZCB2YWx1ZXMgdG8gMC4wLCBpZiBpbiBwYWRkZWQgcmVnaW9uIG9mIG91dHB1dCB0ZXh0dXJlXFxuICBpZiAob3V0cHV0Q29sUGFkID4gMCAmJiBjb2wgKyA0LjAgPiBmbG9hdChvdXRwdXRDb2xzKSkge1xcbiAgICBmaXhfcGFkKG91dFZhbHVlcywgb3V0cHV0Q29sUGFkKTtcXG4gIH1cXG5cXG4gIGdsX0ZyYWdDb2xvciA9IG91dFZhbHVlcztcXG59XFxuXCJ9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPVwiLy8gQmF0Y2ggbm9ybWFsaXphdGlvbiBvcC5cXG4vLyBUaGlzIGlzIGFuIGV4dGVuc2lvbiBvZiB3ZWJsYXMuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dheWxvbmZsaW5uL3dlYmxhc1xcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiBvdXRUZXg7XFxudW5pZm9ybSBzYW1wbGVyMkQgWDtcXG51bmlmb3JtIHNhbXBsZXIyRCBnYW1tYTtcXG51bmlmb3JtIHNhbXBsZXIyRCBiZXRhO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1lYW47XFxudW5pZm9ybSBzYW1wbGVyMkQgc3RkO1xcbnVuaWZvcm0gZmxvYXQgZXBzaWxvbjtcXG51bmlmb3JtIGludCBvdXRwdXRDb2xzO1xcbnVuaWZvcm0gaW50IG91dHB1dENvbFBhZDtcXG5cXG52b2lkIGZpeF9wYWQoaW5vdXQgdmVjNCB2LCBpbnQgcGFkKSB7XFxuICB2LmEgPSAwLjA7XFxuICBpZiAocGFkID09IDIpIHtcXG4gICAgdi5iID0gMC4wO1xcbiAgfSBlbHNlIGlmIChwYWQgPT0gMykge1xcbiAgICB2LmIgPSAwLjA7XFxuICAgIHYuZyA9IDAuMDtcXG4gIH1cXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG4gIGZsb2F0IGNvbCA9IGZsb29yKG91dFRleC54ICogZmxvYXQob3V0cHV0Q29scyArIG91dHB1dENvbFBhZCkgLSAxLjUpO1xcblxcbiAgdmVjNCBfeCA9IHRleHR1cmUyRChYLCB2ZWMyKG91dFRleC54LCBvdXRUZXgueSkpO1xcbiAgdmVjNCBfbWVhbiA9IHRleHR1cmUyRChtZWFuLCB2ZWMyKG91dFRleC54LCAwLjUpKTtcXG4gIHZlYzQgX3N0ZCA9IHRleHR1cmUyRChzdGQsIHZlYzIob3V0VGV4LngsIDAuNSkpO1xcbiAgdmVjNCBfZ2FtbWEgPSB0ZXh0dXJlMkQoZ2FtbWEsIHZlYzIob3V0VGV4LngsIDAuNSkpO1xcbiAgdmVjNCBfYmV0YSA9IHRleHR1cmUyRChiZXRhLCB2ZWMyKG91dFRleC54LCAwLjUpKTtcXG4gIHZlYzQgc3VtVmFsdWVzID0gX2JldGEgKyBfZ2FtbWEgKiAoX3ggLSBfbWVhbikgLyBzcXJ0KF9zdGQgKyBlcHNpbG9uKTtcXG5cXG4gIC8vIHNldCBwYWQgdmFsdWVzIHRvIDAuMCwgaWYgaW4gcGFkZGVkIHJlZ2lvbiBvZiBvdXRwdXQgdGV4dHVyZVxcbiAgaWYgKG91dHB1dENvbFBhZCA+IDAgJiYgY29sICsgNC4wID4gZmxvYXQob3V0cHV0Q29scykpIHtcXG4gICAgZml4X3BhZChzdW1WYWx1ZXMsIG91dHB1dENvbFBhZCk7XFxuICB9XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBzdW1WYWx1ZXM7XFxufVxcblwifSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1cIi8vIDJEIEF2ZXJhZ2UgUG9vbGluZyBvcC5cXG4vLyBUaGlzIGlzIGFuIGV4dGVuc2lvbiBvZiB3ZWJsYXMuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dheWxvbmZsaW5uL3dlYmxhc1xcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiBvdXRUZXg7XFxudW5pZm9ybSBzYW1wbGVyMkQgWDtcXG51bmlmb3JtIHNhbXBsZXIyRCBwb29sSW5kZXhNYXBwaW5nO1xcbnVuaWZvcm0gaW50IGlucHV0Um93cztcXG51bmlmb3JtIGludCBjaGFubmVscztcXG51bmlmb3JtIGludCBjaGFubmVsc1BhZDtcXG51bmlmb3JtIGludCBwb29sRWxlbWVudHM7XFxudW5pZm9ybSBpbnQgcG9vbEVsZW1lbnRzUGFkO1xcblxcbmZsb2F0IHNlbGVjdF9pbmRleCh2ZWM0IHYsIGludCBpbmRleCkge1xcbiAgZmxvYXQgdmFsID0gMC4wO1xcbiAgaWYgKGluZGV4ID09IDApIHtcXG4gICAgdmFsID0gdi5yO1xcbiAgfSBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuICAgIHZhbCA9IHYuZztcXG4gIH0gZWxzZSBpZiAoaW5kZXggPT0gMikge1xcbiAgICB2YWwgPSB2LmI7XFxuICB9IGVsc2UgaWYgKGluZGV4ID09IDMpIHtcXG4gICAgdmFsID0gdi5hO1xcbiAgfVxcbiAgcmV0dXJuIHZhbDtcXG59XFxuXFxudm9pZCBmaXhfcGFkKGlub3V0IHZlYzQgdiwgaW50IHBhZCkge1xcbiAgdi5hID0gMC4wO1xcbiAgaWYgKHBhZCA9PSAyKSB7XFxuICAgIHYuYiA9IDAuMDtcXG4gIH0gZWxzZSBpZiAocGFkID09IDMpIHtcXG4gICAgdi5iID0gMC4wO1xcbiAgICB2LmcgPSAwLjA7XFxuICB9XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIChtYXRyaXggc3BhY2UpXFxuICBmbG9hdCBjb2wgPSBmbG9vcihvdXRUZXgueCAqIGZsb2F0KGNoYW5uZWxzICsgY2hhbm5lbHNQYWQpIC0gMS41KTtcXG5cXG4gIGZsb2F0IHBvb2xJbmRleENvb3JkWDtcXG4gIHZlYzQgcG9vbEluZGljZXM7XFxuICBpbnQgcG9vbEluZGV4UkdCQTtcXG4gIGZsb2F0IHBvb2xJbmRleDtcXG4gIHZlYzQgbWFwcGVkVmFsdWVzO1xcbiAgZmxvYXQgaW5wdXRDb29yZFk7XFxuICB2ZWM0IGN1cnJlbnRTdW0gPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICBpbnQgcG9vbEVsZW1lbnRzRWZmZWN0aXZlID0gcG9vbEVsZW1lbnRzO1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAxMDA7IGkgKz0gMSkge1xcbiAgICBpZiAoaSA+PSBwb29sRWxlbWVudHMpIHtcXG4gICAgICBicmVhaztcXG4gICAgfVxcblxcbiAgICBwb29sSW5kZXhDb29yZFggPSAoZmxvYXQoaSkgKyAwLjUpIC8gZmxvYXQocG9vbEVsZW1lbnRzICsgcG9vbEVsZW1lbnRzUGFkKTtcXG4gICAgcG9vbEluZGljZXMgPSB0ZXh0dXJlMkQocG9vbEluZGV4TWFwcGluZywgdmVjMihwb29sSW5kZXhDb29yZFgsIG91dFRleC55KSk7XFxuICAgIHBvb2xJbmRleFJHQkEgPSBpbnQobW9kKGZsb2F0KGkpLCA0LjApKTtcXG4gICAgcG9vbEluZGV4ID0gc2VsZWN0X2luZGV4KHBvb2xJbmRpY2VzLCBwb29sSW5kZXhSR0JBKTtcXG5cXG4gICAgaWYgKHBvb2xJbmRleCAhPSAtMS4wKSB7XFxuICAgICAgaW5wdXRDb29yZFkgPSAocG9vbEluZGV4ICsgMC41KSAvIGZsb2F0KGlucHV0Um93cyk7XFxuICAgICAgbWFwcGVkVmFsdWVzID0gdGV4dHVyZTJEKFgsIHZlYzIob3V0VGV4LngsIGlucHV0Q29vcmRZKSk7XFxuICAgICAgY3VycmVudFN1bSA9IGN1cnJlbnRTdW0gKyBtYXBwZWRWYWx1ZXM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcG9vbEVsZW1lbnRzRWZmZWN0aXZlID0gcG9vbEVsZW1lbnRzRWZmZWN0aXZlIC0gMTtcXG4gICAgfVxcbiAgfVxcblxcbiAgY3VycmVudFN1bSA9IGN1cnJlbnRTdW0gLyBmbG9hdChwb29sRWxlbWVudHNFZmZlY3RpdmUpO1xcblxcbiAgLy8gc2V0IHBhZCB2YWx1ZXMgdG8gMC4wLCBpZiBpbiBwYWRkZWQgcmVnaW9uIG9mIG91dHB1dCB0ZXh0dXJlXFxuICBpZiAoY2hhbm5lbHNQYWQgPiAwICYmIGNvbCArIDQuMCA+IGZsb2F0KGNoYW5uZWxzKSkge1xcbiAgICBmaXhfcGFkKG1hcHBlZFZhbHVlcywgY2hhbm5lbHNQYWQpO1xcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gY3VycmVudFN1bTtcXG59XFxuXCJ9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPVwiLy8gMkQgTWF4IFBvb2xpbmcgb3AuXFxuLy8gVGhpcyBpcyBhbiBleHRlbnNpb24gb2Ygd2VibGFzLlxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93YXlsb25mbGlubi93ZWJsYXNcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgb3V0VGV4O1xcbnVuaWZvcm0gc2FtcGxlcjJEIFg7XFxudW5pZm9ybSBzYW1wbGVyMkQgcG9vbEluZGV4TWFwcGluZztcXG51bmlmb3JtIGludCBpbnB1dFJvd3M7XFxudW5pZm9ybSBpbnQgY2hhbm5lbHM7XFxudW5pZm9ybSBpbnQgY2hhbm5lbHNQYWQ7XFxudW5pZm9ybSBpbnQgcG9vbEVsZW1lbnRzO1xcbnVuaWZvcm0gaW50IHBvb2xFbGVtZW50c1BhZDtcXG5cXG5mbG9hdCBzZWxlY3RfaW5kZXgodmVjNCB2LCBpbnQgaW5kZXgpIHtcXG4gIGZsb2F0IHZhbCA9IDAuMDtcXG4gIGlmIChpbmRleCA9PSAwKSB7XFxuICAgIHZhbCA9IHYucjtcXG4gIH0gZWxzZSBpZiAoaW5kZXggPT0gMSkge1xcbiAgICB2YWwgPSB2Lmc7XFxuICB9IGVsc2UgaWYgKGluZGV4ID09IDIpIHtcXG4gICAgdmFsID0gdi5iO1xcbiAgfSBlbHNlIGlmIChpbmRleCA9PSAzKSB7XFxuICAgIHZhbCA9IHYuYTtcXG4gIH1cXG4gIHJldHVybiB2YWw7XFxufVxcblxcbnZvaWQgZml4X3BhZChpbm91dCB2ZWM0IHYsIGludCBwYWQpIHtcXG4gIHYuYSA9IDAuMDtcXG4gIGlmIChwYWQgPT0gMikge1xcbiAgICB2LmIgPSAwLjA7XFxuICB9IGVsc2UgaWYgKHBhZCA9PSAzKSB7XFxuICAgIHYuYiA9IDAuMDtcXG4gICAgdi5nID0gMC4wO1xcbiAgfVxcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgLy8gaW5kZXggb2YgZmlyc3QgZWxlbWVudCBpbiBwaXhlbCAobWF0cml4IHNwYWNlKVxcbiAgZmxvYXQgY29sID0gZmxvb3Iob3V0VGV4LnggKiBmbG9hdChjaGFubmVscyArIGNoYW5uZWxzUGFkKSAtIDEuNSk7XFxuXFxuICBmbG9hdCBwb29sSW5kZXhDb29yZFg7XFxuICB2ZWM0IHBvb2xJbmRpY2VzO1xcbiAgaW50IHBvb2xJbmRleFJHQkE7XFxuICBmbG9hdCBwb29sSW5kZXg7XFxuICB2ZWM0IG1hcHBlZFZhbHVlcztcXG4gIGZsb2F0IGlucHV0Q29vcmRZO1xcbiAgY29uc3QgZmxvYXQgbWluID0gLTEuMGUrMDg7XFxuICB2ZWM0IGN1cnJlbnRNYXggPSB2ZWM0KG1pbiwgbWluLCBtaW4sIG1pbik7XFxuICBmb3IgKGludCBpID0gMDsgaSA8IDEwMDsgaSArPSAxKSB7XFxuICAgIGlmIChpID49IHBvb2xFbGVtZW50cykge1xcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuXFxuICAgIHBvb2xJbmRleENvb3JkWCA9IChmbG9hdChpKSArIDAuNSkgLyBmbG9hdChwb29sRWxlbWVudHMgKyBwb29sRWxlbWVudHNQYWQpO1xcbiAgICBwb29sSW5kaWNlcyA9IHRleHR1cmUyRChwb29sSW5kZXhNYXBwaW5nLCB2ZWMyKHBvb2xJbmRleENvb3JkWCwgb3V0VGV4LnkpKTtcXG4gICAgcG9vbEluZGV4UkdCQSA9IGludChtb2QoZmxvYXQoaSksIDQuMCkpO1xcbiAgICBwb29sSW5kZXggPSBzZWxlY3RfaW5kZXgocG9vbEluZGljZXMsIHBvb2xJbmRleFJHQkEpO1xcblxcbiAgICBpZiAocG9vbEluZGV4ICE9IC0xLjApIHtcXG4gICAgICBpbnB1dENvb3JkWSA9IChwb29sSW5kZXggKyAwLjUpIC8gZmxvYXQoaW5wdXRSb3dzKTtcXG4gICAgICBtYXBwZWRWYWx1ZXMgPSB0ZXh0dXJlMkQoWCwgdmVjMihvdXRUZXgueCwgaW5wdXRDb29yZFkpKTtcXG4gICAgfVxcblxcbiAgICBjdXJyZW50TWF4ID0gbWF4KGN1cnJlbnRNYXgsIG1hcHBlZFZhbHVlcyk7XFxuICB9XFxuXFxuICAvLyBzZXQgcGFkIHZhbHVlcyB0byAwLjAsIGlmIGluIHBhZGRlZCByZWdpb24gb2Ygb3V0cHV0IHRleHR1cmVcXG4gIGlmIChjaGFubmVsc1BhZCA+IDAgJiYgY29sICsgNC4wID4gZmxvYXQoY2hhbm5lbHMpKSB7XFxuICAgIGZpeF9wYWQobWFwcGVkVmFsdWVzLCBjaGFubmVsc1BhZCk7XFxuICB9XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBjdXJyZW50TWF4O1xcbn1cXG5cIn0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9XCIvLyBDb3B5IHRleHR1cmVcXG4vLyBUaGlzIGlzIGFuIGV4dGVuc2lvbiBvZiB3ZWJsYXMuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dheWxvbmZsaW5uL3dlYmxhc1xcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiBvdXRUZXg7XFxudW5pZm9ybSBzYW1wbGVyMkQgc291cmNlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoc291cmNlLCB2ZWMyKG91dFRleC54LCBvdXRUZXgueSkpO1xcbn1cXG5cIn0sZnVuY3Rpb24odCxlLG4peyhmdW5jdGlvbihlLG4peyFmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSxuLHIpe3ZhciBvPWUmJmUucHJvdG90eXBlIGluc3RhbmNlb2YgaT9lOmksYT1PYmplY3QuY3JlYXRlKG8ucHJvdG90eXBlKSxzPW5ldyBoKHJ8fFtdKTtyZXR1cm4gYS5faW52b2tlPWModCxuLHMpLGF9ZnVuY3Rpb24gbyh0LGUsbil7dHJ5e3JldHVybnt0eXBlOlwibm9ybWFsXCIsYXJnOnQuY2FsbChlLG4pfX1jYXRjaCh0KXtyZXR1cm57dHlwZTpcInRocm93XCIsYXJnOnR9fX1mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gcygpe31mdW5jdGlvbiB1KHQpe1tcIm5leHRcIixcInRocm93XCIsXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9pbnZva2UoZSx0KX19KX1mdW5jdGlvbiBsKHQpe2Z1bmN0aW9uIGUobixyLGksYSl7dmFyIHM9byh0W25dLHQscik7aWYoXCJ0aHJvd1wiIT09cy50eXBlKXt2YXIgdT1zLmFyZyxsPXUudmFsdWU7cmV0dXJuIGwmJlwib2JqZWN0XCI9PXR5cGVvZiBsJiZnLmNhbGwobCxcIl9fYXdhaXRcIik/UHJvbWlzZS5yZXNvbHZlKGwuX19hd2FpdCkudGhlbihmdW5jdGlvbih0KXtlKFwibmV4dFwiLHQsaSxhKX0sZnVuY3Rpb24odCl7ZShcInRocm93XCIsdCxpLGEpfSk6UHJvbWlzZS5yZXNvbHZlKGwpLnRoZW4oZnVuY3Rpb24odCl7dS52YWx1ZT10LGkodSl9LGEpfWEocy5hcmcpfWZ1bmN0aW9uIHIodCxuKXtmdW5jdGlvbiByKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIsbyl7ZSh0LG4scixvKX0pfXJldHVybiBpPWk/aS50aGVuKHIscik6cigpfVwib2JqZWN0XCI9PXR5cGVvZiBuJiZuLmRvbWFpbiYmKGU9bi5kb21haW4uYmluZChlKSk7dmFyIGk7dGhpcy5faW52b2tlPXJ9ZnVuY3Rpb24gYyh0LGUsbil7dmFyIHI9VDtyZXR1cm4gZnVuY3Rpb24oaSxhKXtpZihyPT09Uyl0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO2lmKHI9PT1QKXtpZihcInRocm93XCI9PT1pKXRocm93IGE7cmV0dXJuIHYoKX1mb3IoOzspe3ZhciBzPW4uZGVsZWdhdGU7aWYocyl7aWYoXCJyZXR1cm5cIj09PWl8fFwidGhyb3dcIj09PWkmJnMuaXRlcmF0b3JbaV09PT1tKXtuLmRlbGVnYXRlPW51bGw7dmFyIHU9cy5pdGVyYXRvci5yZXR1cm47aWYodSl7dmFyIGw9byh1LHMuaXRlcmF0b3IsYSk7aWYoXCJ0aHJvd1wiPT09bC50eXBlKXtpPVwidGhyb3dcIixhPWwuYXJnO2NvbnRpbnVlfX1pZihcInJldHVyblwiPT09aSljb250aW51ZX12YXIgbD1vKHMuaXRlcmF0b3JbaV0scy5pdGVyYXRvcixhKTtpZihcInRocm93XCI9PT1sLnR5cGUpe24uZGVsZWdhdGU9bnVsbCxpPVwidGhyb3dcIixhPWwuYXJnO2NvbnRpbnVlfWk9XCJuZXh0XCIsYT1tO3ZhciBjPWwuYXJnO2lmKCFjLmRvbmUpcmV0dXJuIHI9TyxjO25bcy5yZXN1bHROYW1lXT1jLnZhbHVlLG4ubmV4dD1zLm5leHRMb2Msbi5kZWxlZ2F0ZT1udWxsfWlmKFwibmV4dFwiPT09aSluLnNlbnQ9bi5fc2VudD1hO2Vsc2UgaWYoXCJ0aHJvd1wiPT09aSl7aWYocj09PVQpdGhyb3cgcj1QLGE7bi5kaXNwYXRjaEV4Y2VwdGlvbihhKSYmKGk9XCJuZXh0XCIsYT1tKX1lbHNlXCJyZXR1cm5cIj09PWkmJm4uYWJydXB0KFwicmV0dXJuXCIsYSk7cj1TO3ZhciBsPW8odCxlLG4pO2lmKFwibm9ybWFsXCI9PT1sLnR5cGUpe3I9bi5kb25lP1A6Tzt2YXIgYz17dmFsdWU6bC5hcmcsZG9uZTpuLmRvbmV9O2lmKGwuYXJnIT09TSlyZXR1cm4gYztuLmRlbGVnYXRlJiZcIm5leHRcIj09PWkmJihhPW0pfWVsc2VcInRocm93XCI9PT1sLnR5cGUmJihyPVAsaT1cInRocm93XCIsYT1sLmFyZyl9fX1mdW5jdGlvbiBmKHQpe3ZhciBlPXt0cnlMb2M6dFswXX07MSBpbiB0JiYoZS5jYXRjaExvYz10WzFdKSwyIGluIHQmJihlLmZpbmFsbHlMb2M9dFsyXSxlLmFmdGVyTG9jPXRbM10pLHRoaXMudHJ5RW50cmllcy5wdXNoKGUpfWZ1bmN0aW9uIHAodCl7dmFyIGU9dC5jb21wbGV0aW9ufHx7fTtlLnR5cGU9XCJub3JtYWxcIixkZWxldGUgZS5hcmcsdC5jb21wbGV0aW9uPWV9ZnVuY3Rpb24gaCh0KXt0aGlzLnRyeUVudHJpZXM9W3t0cnlMb2M6XCJyb290XCJ9XSx0LmZvckVhY2goZix0aGlzKSx0aGlzLnJlc2V0KCEwKX1mdW5jdGlvbiBkKHQpe2lmKHQpe3ZhciBlPXRbYl07aWYoZSlyZXR1cm4gZS5jYWxsKHQpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQubmV4dClyZXR1cm4gdDtpZighaXNOYU4odC5sZW5ndGgpKXt2YXIgbj0tMSxyPWZ1bmN0aW9uIGUoKXtmb3IoOysrbjx0Lmxlbmd0aDspaWYoZy5jYWxsKHQsbikpcmV0dXJuIGUudmFsdWU9dFtuXSxlLmRvbmU9ITEsZTtyZXR1cm4gZS52YWx1ZT1tLGUuZG9uZT0hMCxlfTtyZXR1cm4gci5uZXh0PXJ9fXJldHVybntuZXh0OnZ9fWZ1bmN0aW9uIHYoKXtyZXR1cm57dmFsdWU6bSxkb25lOiEwfX12YXIgbSxfPU9iamVjdC5wcm90b3R5cGUsZz1fLmhhc093blByb3BlcnR5LHk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxiPXkuaXRlcmF0b3J8fFwiQEBpdGVyYXRvclwiLHc9eS50b1N0cmluZ1RhZ3x8XCJAQHRvU3RyaW5nVGFnXCIseD1cIm9iamVjdFwiPT10eXBlb2YgdCxFPWUucmVnZW5lcmF0b3JSdW50aW1lO2lmKEUpcmV0dXJuIHZvaWQoeCYmKHQuZXhwb3J0cz1FKSk7RT1lLnJlZ2VuZXJhdG9yUnVudGltZT14P3QuZXhwb3J0czp7fSxFLndyYXA9cjt2YXIgVD1cInN1c3BlbmRlZFN0YXJ0XCIsTz1cInN1c3BlbmRlZFlpZWxkXCIsUz1cImV4ZWN1dGluZ1wiLFA9XCJjb21wbGV0ZWRcIixNPXt9LGo9e307altiXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt2YXIgQT1PYmplY3QuZ2V0UHJvdG90eXBlT2YsQz1BJiZBKEEoZChbXSkpKTtDJiZDIT09XyYmZy5jYWxsKEMsYikmJihqPUMpO3ZhciBrPXMucHJvdG90eXBlPWkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaik7YS5wcm90b3R5cGU9ay5jb25zdHJ1Y3Rvcj1zLHMuY29uc3RydWN0b3I9YSxzW3ddPWEuZGlzcGxheU5hbWU9XCJHZW5lcmF0b3JGdW5jdGlvblwiLEUuaXNHZW5lcmF0b3JGdW5jdGlvbj1mdW5jdGlvbih0KXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZ0LmNvbnN0cnVjdG9yO3JldHVybiEhZSYmKGU9PT1hfHxcIkdlbmVyYXRvckZ1bmN0aW9uXCI9PT0oZS5kaXNwbGF5TmFtZXx8ZS5uYW1lKSl9LEUubWFyaz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LHMpOih0Ll9fcHJvdG9fXz1zLHcgaW4gdHx8KHRbd109XCJHZW5lcmF0b3JGdW5jdGlvblwiKSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShrKSx0fSxFLmF3cmFwPWZ1bmN0aW9uKHQpe3JldHVybntfX2F3YWl0OnR9fSx1KGwucHJvdG90eXBlKSxFLkFzeW5jSXRlcmF0b3I9bCxFLmFzeW5jPWZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBpPW5ldyBsKHIodCxlLG4sbykpO3JldHVybiBFLmlzR2VuZXJhdG9yRnVuY3Rpb24oZSk/aTppLm5leHQoKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRvbmU/dC52YWx1ZTppLm5leHQoKX0pfSx1KGspLGtbd109XCJHZW5lcmF0b3JcIixrLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJbb2JqZWN0IEdlbmVyYXRvcl1cIn0sRS5rZXlzPWZ1bmN0aW9uKHQpe3ZhciBlPVtdO2Zvcih2YXIgbiBpbiB0KWUucHVzaChuKTtyZXR1cm4gZS5yZXZlcnNlKCksZnVuY3Rpb24gbigpe2Zvcig7ZS5sZW5ndGg7KXt2YXIgcj1lLnBvcCgpO2lmKHIgaW4gdClyZXR1cm4gbi52YWx1ZT1yLG4uZG9uZT0hMSxufXJldHVybiBuLmRvbmU9ITAsbn19LEUudmFsdWVzPWQsaC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmgscmVzZXQ6ZnVuY3Rpb24odCl7aWYodGhpcy5wcmV2PTAsdGhpcy5uZXh0PTAsdGhpcy5zZW50PXRoaXMuX3NlbnQ9bSx0aGlzLmRvbmU9ITEsdGhpcy5kZWxlZ2F0ZT1udWxsLHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHApLCF0KWZvcih2YXIgZSBpbiB0aGlzKVwidFwiPT09ZS5jaGFyQXQoMCkmJmcuY2FsbCh0aGlzLGUpJiYhaXNOYU4oK2Uuc2xpY2UoMSkpJiYodGhpc1tlXT1tKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgdD10aGlzLnRyeUVudHJpZXNbMF0sZT10LmNvbXBsZXRpb247aWYoXCJ0aHJvd1wiPT09ZS50eXBlKXRocm93IGUuYXJnO3JldHVybiB0aGlzLnJ2YWx9LGRpc3BhdGNoRXhjZXB0aW9uOmZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXtyZXR1cm4gaS50eXBlPVwidGhyb3dcIixpLmFyZz10LG4ubmV4dD1lLCEhcn1pZih0aGlzLmRvbmUpdGhyb3cgdDtmb3IodmFyIG49dGhpcyxyPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtyPj0wOy0tcil7dmFyIG89dGhpcy50cnlFbnRyaWVzW3JdLGk9by5jb21wbGV0aW9uO2lmKFwicm9vdFwiPT09by50cnlMb2MpcmV0dXJuIGUoXCJlbmRcIik7aWYoby50cnlMb2M8PXRoaXMucHJldil7dmFyIGE9Zy5jYWxsKG8sXCJjYXRjaExvY1wiKSxzPWcuY2FsbChvLFwiZmluYWxseUxvY1wiKTtpZihhJiZzKXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gZShvLmNhdGNoTG9jLCEwKTtpZih0aGlzLnByZXY8by5maW5hbGx5TG9jKXJldHVybiBlKG8uZmluYWxseUxvYyl9ZWxzZSBpZihhKXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gZShvLmNhdGNoTG9jLCEwKX1lbHNle2lmKCFzKXRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO2lmKHRoaXMucHJldjxvLmZpbmFsbHlMb2MpcmV0dXJuIGUoby5maW5hbGx5TG9jKX19fX0sYWJydXB0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIHI9dGhpcy50cnlFbnRyaWVzW25dO2lmKHIudHJ5TG9jPD10aGlzLnByZXYmJmcuY2FsbChyLFwiZmluYWxseUxvY1wiKSYmdGhpcy5wcmV2PHIuZmluYWxseUxvYyl7dmFyIG89cjticmVha319byYmKFwiYnJlYWtcIj09PXR8fFwiY29udGludWVcIj09PXQpJiZvLnRyeUxvYzw9ZSYmZTw9by5maW5hbGx5TG9jJiYobz1udWxsKTt2YXIgaT1vP28uY29tcGxldGlvbjp7fTtyZXR1cm4gaS50eXBlPXQsaS5hcmc9ZSxvP3RoaXMubmV4dD1vLmZpbmFsbHlMb2M6dGhpcy5jb21wbGV0ZShpKSxNfSxjb21wbGV0ZTpmdW5jdGlvbih0LGUpe2lmKFwidGhyb3dcIj09PXQudHlwZSl0aHJvdyB0LmFyZztcImJyZWFrXCI9PT10LnR5cGV8fFwiY29udGludWVcIj09PXQudHlwZT90aGlzLm5leHQ9dC5hcmc6XCJyZXR1cm5cIj09PXQudHlwZT8odGhpcy5ydmFsPXQuYXJnLHRoaXMubmV4dD1cImVuZFwiKTpcIm5vcm1hbFwiPT09dC50eXBlJiZlJiYodGhpcy5uZXh0PWUpfSxmaW5pc2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIG49dGhpcy50cnlFbnRyaWVzW2VdO2lmKG4uZmluYWxseUxvYz09PXQpcmV0dXJuIHRoaXMuY29tcGxldGUobi5jb21wbGV0aW9uLG4uYWZ0ZXJMb2MpLHAobiksTX19LGNhdGNoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7ZT49MDstLWUpe3ZhciBuPXRoaXMudHJ5RW50cmllc1tlXTtpZihuLnRyeUxvYz09PXQpe3ZhciByPW4uY29tcGxldGlvbjtpZihcInRocm93XCI9PT1yLnR5cGUpe3ZhciBvPXIuYXJnO3Aobil9cmV0dXJuIG99fXRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKX0sZGVsZWdhdGVZaWVsZDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuZGVsZWdhdGU9e2l0ZXJhdG9yOmQodCkscmVzdWx0TmFtZTplLG5leHRMb2M6bn0sTX19fShcIm9iamVjdFwiPT10eXBlb2YgZT9lOlwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3c/d2luZG93Olwib2JqZWN0XCI9PXR5cGVvZiBzZWxmP3NlbGY6dGhpcyl9KS5jYWxsKGUsbigzOCksbigxMzEpKX0sZnVuY3Rpb24odCxlLG4peyhmdW5jdGlvbih0LGUpeyFmdW5jdGlvbih0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7XCJmdW5jdGlvblwiIT10eXBlb2YgdCYmKHQ9bmV3IEZ1bmN0aW9uKFwiXCIrdCkpO2Zvcih2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT1hcmd1bWVudHNbbisxXTt2YXIgcj17Y2FsbGJhY2s6dCxhcmdzOmV9O3JldHVybiB2W2RdPXIsaChkKSxkKyt9ZnVuY3Rpb24gbyh0KXtkZWxldGUgdlt0XX1mdW5jdGlvbiBpKHQpe3ZhciBlPXQuY2FsbGJhY2sscj10LmFyZ3M7c3dpdGNoKHIubGVuZ3RoKXtjYXNlIDA6ZSgpO2JyZWFrO2Nhc2UgMTplKHJbMF0pO2JyZWFrO2Nhc2UgMjplKHJbMF0sclsxXSk7YnJlYWs7Y2FzZSAzOmUoclswXSxyWzFdLHJbMl0pO2JyZWFrO2RlZmF1bHQ6ZS5hcHBseShuLHIpfX1mdW5jdGlvbiBhKHQpe2lmKG0pc2V0VGltZW91dChhLDAsdCk7ZWxzZXt2YXIgZT12W3RdO2lmKGUpe209ITA7dHJ5e2koZSl9ZmluYWxseXtvKHQpLG09ITF9fX19ZnVuY3Rpb24gcygpe2g9ZnVuY3Rpb24odCl7ZS5uZXh0VGljayhmdW5jdGlvbigpe2EodCl9KX19ZnVuY3Rpb24gdSgpe2lmKHQucG9zdE1lc3NhZ2UmJiF0LmltcG9ydFNjcmlwdHMpe3ZhciBlPSEwLG49dC5vbm1lc3NhZ2U7cmV0dXJuIHQub25tZXNzYWdlPWZ1bmN0aW9uKCl7ZT0hMX0sdC5wb3N0TWVzc2FnZShcIlwiLFwiKlwiKSx0Lm9ubWVzc2FnZT1uLGV9fWZ1bmN0aW9uIGwoKXt2YXIgZT1cInNldEltbWVkaWF0ZSRcIitNYXRoLnJhbmRvbSgpK1wiJFwiLG49ZnVuY3Rpb24obil7bi5zb3VyY2U9PT10JiZcInN0cmluZ1wiPT10eXBlb2Ygbi5kYXRhJiYwPT09bi5kYXRhLmluZGV4T2YoZSkmJmEoK24uZGF0YS5zbGljZShlLmxlbmd0aCkpfTt0LmFkZEV2ZW50TGlzdGVuZXI/dC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLG4sITEpOnQuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIixuKSxoPWZ1bmN0aW9uKG4pe3QucG9zdE1lc3NhZ2UoZStuLFwiKlwiKX19ZnVuY3Rpb24gYygpe3ZhciB0PW5ldyBNZXNzYWdlQ2hhbm5lbDt0LnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbih0KXt2YXIgZT10LmRhdGE7YShlKX0saD1mdW5jdGlvbihlKXt0LnBvcnQyLnBvc3RNZXNzYWdlKGUpfX1mdW5jdGlvbiBmKCl7dmFyIHQ9Xy5kb2N1bWVudEVsZW1lbnQ7aD1mdW5jdGlvbihlKXt2YXIgbj1fLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7bi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXthKGUpLG4ub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsdC5yZW1vdmVDaGlsZChuKSxuPW51bGx9LHQuYXBwZW5kQ2hpbGQobil9fWZ1bmN0aW9uIHAoKXtoPWZ1bmN0aW9uKHQpe3NldFRpbWVvdXQoYSwwLHQpfX1pZighdC5zZXRJbW1lZGlhdGUpe3ZhciBoLGQ9MSx2PXt9LG09ITEsXz10LmRvY3VtZW50LGc9T2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7Zz1nJiZnLnNldFRpbWVvdXQ/Zzp0LFwiW29iamVjdCBwcm9jZXNzXVwiPT09e30udG9TdHJpbmcuY2FsbCh0LnByb2Nlc3MpP3MoKTp1KCk/bCgpOnQuTWVzc2FnZUNoYW5uZWw/YygpOl8mJlwib25yZWFkeXN0YXRlY2hhbmdlXCJpbiBfLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik/ZigpOnAoKSxnLnNldEltbWVkaWF0ZT1yLGcuY2xlYXJJbW1lZGlhdGU9b319KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP1widW5kZWZpbmVkXCI9PXR5cGVvZiB0P3RoaXM6dDpzZWxmKX0pLmNhbGwoZSxuKDM4KSxuKDEzMSkpfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3RoaXMuX2lkPXQsdGhpcy5fY2xlYXJGbj1lfXZhciBvPUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtlLnNldFRpbWVvdXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIoby5jYWxsKHNldFRpbWVvdXQsd2luZG93LGFyZ3VtZW50cyksY2xlYXJUaW1lb3V0KX0sZS5zZXRJbnRlcnZhbD1mdW5jdGlvbigpe3JldHVybiBuZXcgcihvLmNhbGwoc2V0SW50ZXJ2YWwsd2luZG93LGFyZ3VtZW50cyksY2xlYXJJbnRlcnZhbCl9LGUuY2xlYXJUaW1lb3V0PWUuY2xlYXJJbnRlcnZhbD1mdW5jdGlvbih0KXt0JiZ0LmNsb3NlKCl9LHIucHJvdG90eXBlLnVucmVmPXIucHJvdG90eXBlLnJlZj1mdW5jdGlvbigpe30sci5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LHRoaXMuX2lkKX0sZS5lbnJvbGw9ZnVuY3Rpb24odCxlKXtjbGVhclRpbWVvdXQodC5faWRsZVRpbWVvdXRJZCksdC5faWRsZVRpbWVvdXQ9ZX0sZS51bmVucm9sbD1mdW5jdGlvbih0KXtjbGVhclRpbWVvdXQodC5faWRsZVRpbWVvdXRJZCksdC5faWRsZVRpbWVvdXQ9LTF9LGUuX3VucmVmQWN0aXZlPWUuYWN0aXZlPWZ1bmN0aW9uKHQpe2NsZWFyVGltZW91dCh0Ll9pZGxlVGltZW91dElkKTt2YXIgZT10Ll9pZGxlVGltZW91dDtlPj0wJiYodC5faWRsZVRpbWVvdXRJZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5fb25UaW1lb3V0JiZ0Ll9vblRpbWVvdXQoKX0sZSkpfSxuKDYyMCksZS5zZXRJbW1lZGlhdGU9c2V0SW1tZWRpYXRlLGUuY2xlYXJJbW1lZGlhdGU9Y2xlYXJJbW1lZGlhdGV9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24odCxyKXtmdW5jdGlvbiBvKHQpe2lmKHQpe3ZhciBlPXQubGVuZ3RofHx0LmJ5dGVMZW5ndGgsbj1nLmxvZzIoZSk7eFtuXS5wdXNoKHQpfX1mdW5jdGlvbiBpKHQpe28odC5idWZmZXIpfWZ1bmN0aW9uIGEodCl7dmFyIHQ9Zy5uZXh0UG93Mih0KSxlPWcubG9nMih0KSxuPXhbZV07cmV0dXJuIG4ubGVuZ3RoPjA/bi5wb3AoKTpuZXcgQXJyYXlCdWZmZXIodCl9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSh0KSwwLHQpfWZ1bmN0aW9uIHUodCl7cmV0dXJuIG5ldyBVaW50MTZBcnJheShhKDIqdCksMCx0KX1mdW5jdGlvbiBsKHQpe3JldHVybiBuZXcgVWludDMyQXJyYXkoYSg0KnQpLDAsdCl9ZnVuY3Rpb24gYyh0KXtyZXR1cm4gbmV3IEludDhBcnJheShhKHQpLDAsdCl9ZnVuY3Rpb24gZih0KXtyZXR1cm4gbmV3IEludDE2QXJyYXkoYSgyKnQpLDAsdCl9ZnVuY3Rpb24gcCh0KXtyZXR1cm4gbmV3IEludDMyQXJyYXkoYSg0KnQpLDAsdCl9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhKDQqdCksMCx0KX1mdW5jdGlvbiBkKHQpe3JldHVybiBuZXcgRmxvYXQ2NEFycmF5KGEoOCp0KSwwLHQpfWZ1bmN0aW9uIHYodCl7cmV0dXJuIGI/bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGEodCksMCx0KTpzKHQpfWZ1bmN0aW9uIG0odCl7cmV0dXJuIG5ldyBEYXRhVmlldyhhKHQpLDAsdCl9ZnVuY3Rpb24gXyh0KXt0PWcubmV4dFBvdzIodCk7dmFyIGU9Zy5sb2cyKHQpLG49RVtlXTtyZXR1cm4gbi5sZW5ndGg+MD9uLnBvcCgpOm5ldyByKHQpfXZhciBnPW4oMjYzKSx5PW4oMTY3KTt0Ll9fVFlQRURBUlJBWV9QT09MfHwodC5fX1RZUEVEQVJSQVlfUE9PTD17VUlOVDg6eShbMzIsMF0pLFVJTlQxNjp5KFszMiwwXSksVUlOVDMyOnkoWzMyLDBdKSxJTlQ4OnkoWzMyLDBdKSxJTlQxNjp5KFszMiwwXSksSU5UMzI6eShbMzIsMF0pLEZMT0FUOnkoWzMyLDBdKSxET1VCTEU6eShbMzIsMF0pLERBVEE6eShbMzIsMF0pLFVJTlQ4Qzp5KFszMiwwXSksQlVGRkVSOnkoWzMyLDBdKX0pO3ZhciBiPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OENsYW1wZWRBcnJheSx3PXQuX19UWVBFREFSUkFZX1BPT0w7dy5VSU5UOEN8fCh3LlVJTlQ4Qz15KFszMiwwXSkpLHcuQlVGRkVSfHwody5CVUZGRVI9eShbMzIsMF0pKTt2YXIgeD13LkRBVEEsRT13LkJVRkZFUjtlLmZyZWU9ZnVuY3Rpb24odCl7aWYoci5pc0J1ZmZlcih0KSlFW2cubG9nMih0Lmxlbmd0aCldLnB1c2godCk7ZWxzZXtpZihcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIhPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkmJih0PXQuYnVmZmVyKSwhdClyZXR1cm47dmFyIGU9dC5sZW5ndGh8fHQuYnl0ZUxlbmd0aCxuPTB8Zy5sb2cyKGUpO3hbbl0ucHVzaCh0KX19LGUuZnJlZVVpbnQ4PWUuZnJlZVVpbnQxNj1lLmZyZWVVaW50MzI9ZS5mcmVlSW50OD1lLmZyZWVJbnQxNj1lLmZyZWVJbnQzMj1lLmZyZWVGbG9hdDMyPWUuZnJlZUZsb2F0PWUuZnJlZUZsb2F0NjQ9ZS5mcmVlRG91YmxlPWUuZnJlZVVpbnQ4Q2xhbXBlZD1lLmZyZWVEYXRhVmlldz1pLGUuZnJlZUFycmF5QnVmZmVyPW8sZS5mcmVlQnVmZmVyPWZ1bmN0aW9uKHQpe0VbZy5sb2cyKHQubGVuZ3RoKV0ucHVzaCh0KX0sZS5tYWxsb2M9ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lfHxcImFycmF5YnVmZmVyXCI9PT1lKXJldHVybiBhKHQpO3N3aXRjaChlKXtjYXNlXCJ1aW50OFwiOnJldHVybiBzKHQpO2Nhc2VcInVpbnQxNlwiOnJldHVybiB1KHQpO2Nhc2VcInVpbnQzMlwiOnJldHVybiBsKHQpO2Nhc2VcImludDhcIjpyZXR1cm4gYyh0KTtjYXNlXCJpbnQxNlwiOnJldHVybiBmKHQpO2Nhc2VcImludDMyXCI6cmV0dXJuIHAodCk7Y2FzZVwiZmxvYXRcIjpjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIGgodCk7Y2FzZVwiZG91YmxlXCI6Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBkKHQpO2Nhc2VcInVpbnQ4X2NsYW1wZWRcIjpyZXR1cm4gdih0KTtjYXNlXCJidWZmZXJcIjpyZXR1cm4gXyh0KTtjYXNlXCJkYXRhXCI6Y2FzZVwiZGF0YXZpZXdcIjpyZXR1cm4gbSh0KTtkZWZhdWx0OnJldHVybiBudWxsfXJldHVybiBudWxsfSxlLm1hbGxvY0FycmF5QnVmZmVyPWEsZS5tYWxsb2NVaW50OD1zLGUubWFsbG9jVWludDE2PXUsZS5tYWxsb2NVaW50MzI9bCxlLm1hbGxvY0ludDg9YyxlLm1hbGxvY0ludDE2PWYsZS5tYWxsb2NJbnQzMj1wLGUubWFsbG9jRmxvYXQzMj1lLm1hbGxvY0Zsb2F0PWgsZS5tYWxsb2NGbG9hdDY0PWUubWFsbG9jRG91YmxlPWQsZS5tYWxsb2NVaW50OENsYW1wZWQ9dixlLm1hbGxvY0RhdGFWaWV3PW0sZS5tYWxsb2NCdWZmZXI9XyxlLmNsZWFyQ2FjaGU9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PDMyOysrdCl3LlVJTlQ4W3RdLmxlbmd0aD0wLHcuVUlOVDE2W3RdLmxlbmd0aD0wLHcuVUlOVDMyW3RdLmxlbmd0aD0wLHcuSU5UOFt0XS5sZW5ndGg9MCx3LklOVDE2W3RdLmxlbmd0aD0wLHcuSU5UMzJbdF0ubGVuZ3RoPTAsdy5GTE9BVFt0XS5sZW5ndGg9MCx3LkRPVUJMRVt0XS5sZW5ndGg9MCx3LlVJTlQ4Q1t0XS5sZW5ndGg9MCx4W3RdLmxlbmd0aD0wLEVbdF0ubGVuZ3RoPTB9fSkuY2FsbChlLG4oMzgpLG4oMjY1KS5CdWZmZXIpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCxlKXtpZighZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUpcmV0dXJuIHQ7Zm9yKHZhciBuPU9iamVjdC5rZXlzKGUpLHI9bi5sZW5ndGg7ci0tOyl0W25bcl1dPWVbbltyXV07cmV0dXJuIHR9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixyOyFmdW5jdGlvbihlKXt0LmV4cG9ydHM9ZSgpfShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiB0KGUsbixvKXtmdW5jdGlvbiBpKHMsdSl7aWYoIW5bc10pe2lmKCFlW3NdKXt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZyO2lmKCF1JiZsKXJldHVybiByKHMsITApO2lmKGEpcmV0dXJuIGEocywhMCk7dmFyIGM9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitzK1wiJ1wiKTt0aHJvdyBjLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsY312YXIgZj1uW3NdPXtleHBvcnRzOnt9fTtlW3NdWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciBuPWVbc11bMV1bdF07cmV0dXJuIGkobj9uOnQpfSxmLGYuZXhwb3J0cyx0LGUsbixvKX1yZXR1cm4gbltzXS5leHBvcnRzfWZvcih2YXIgYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZyLHM9MDtzPG8ubGVuZ3RoO3MrKylpKG9bc10pO3JldHVybiBpfSh7MTpbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7ZnVuY3Rpb24gZShlLG4scixvLGksYSxzLHUpe2lmKG51bGwhPXUmJnUubGVuZ3RoIT1uKXRocm93IG5ldyBFcnJvcihcIk9ubHkgdmVjdG9yIEMgd2l0aCBsZW5ndGggbWF0Y2hpbmcgcm93cyBpbiBBIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCIpO3ZhciBsLGM9aSxmPXU7bD12KHIsbixhKTt2YXIgcD10LmNyZWF0ZURhdGFUZXh0dXJlKGUscixjKSxoPXQuY3JlYXRlRGF0YVRleHR1cmUobixyLGwpLGQ9bnVsbDtudWxsIT1mJiYoZD10LmNyZWF0ZURhdGFUZXh0dXJlKDEsbixmKSk7dmFyIF89dC5jcmVhdGVPdXRwdXRUZXh0dXJlKGUsbik7cmV0dXJuIG0uY2FsY3VsYXRlKGUsbixyLG8scCxoLHMsZCxfKSxyYXdCdWZmZXI9dC5yZWFkRGF0YShlLG4pLHQuY29udGV4dC5kZWxldGVUZXh0dXJlKHApLHQuY29udGV4dC5kZWxldGVUZXh0dXJlKGgpLG51bGwhPWQmJnQuY29udGV4dC5kZWxldGVUZXh0dXJlKGQpLHQuY29udGV4dC5kZWxldGVUZXh0dXJlKF8pLG5ldyBGbG9hdDMyQXJyYXkocmF3QnVmZmVyKX1mdW5jdGlvbiBuKGUsbixvLGkpe3ZhciBhLHMsdT1vO3IoaSk/cz1pOihzPW5ldyBGbG9hdDMyQXJyYXkoZSkscy5maWxsKGkpKTt2YXIgbD10LmNyZWF0ZURhdGFUZXh0dXJlKDEsZSx1KSxjPXQuY3JlYXRlRGF0YVRleHR1cmUoMSxlLHMpLGY9dC5jcmVhdGVPdXRwdXRUZXh0dXJlKDEsZSk7cmV0dXJuIF8uY2FsY3VsYXRlKGUsbixsLGMsZiksYT10LnJlYWREYXRhKDEsZSksdC5jb250ZXh0LmRlbGV0ZVRleHR1cmUobCksdC5jb250ZXh0LmRlbGV0ZVRleHR1cmUoYyksdC5jb250ZXh0LmRlbGV0ZVRleHR1cmUoZiksbmV3IEZsb2F0MzJBcnJheShhKX1mdW5jdGlvbiByKHQpe3JldHVyblwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9ZnVuY3Rpb24gbyhlLG4scixvLGkpe3ZhciBhLHM9aSx1PXQuY3JlYXRlRGF0YVRleHR1cmUoZSxuLHMpLGw9dC5jcmVhdGVPdXRwdXRUZXh0dXJlKGUsbik7cmV0dXJuIGcuY2FsY3VsYXRlKGUsbixyLG8sdSxsKSxhPXQucmVhZERhdGEoZSxuKSx0LmNvbnRleHQuZGVsZXRlVGV4dHVyZSh1KSx0LmNvbnRleHQuZGVsZXRlVGV4dHVyZShsKSxuZXcgRmxvYXQzMkFycmF5KGEpfWZ1bmN0aW9uIGYoZSxuLHIsbyxpKXt2YXIgYSxzPWksdT10LmNyZWF0ZURhdGFUZXh0dXJlKGUsbixzKSxsPXQuY3JlYXRlT3V0cHV0VGV4dHVyZShlLG4pO3JldHVybiBnLmNhbGN1bGF0ZShlLG4sMS9vLC0xKnIvbyx1LGwpLGE9dC5yZWFkRGF0YShlLG4pLHQuY29udGV4dC5kZWxldGVUZXh0dXJlKHUpLHQuY29udGV4dC5kZWxldGVUZXh0dXJlKGwpLG5ldyBGbG9hdDMyQXJyYXkoYSl9ZnVuY3Rpb24gcChlLG4scixvLGksYSl7dmFyIHM9dC5jcmVhdGVEYXRhVGV4dHVyZShlLG4qcixhKSx1PU1hdGguZmxvb3IoKG4tbykvaSkrMSxsPU1hdGguZmxvb3IoKGUtbykvaSkrMSxjPXQuY3JlYXRlT3V0cHV0VGV4dHVyZShsLHUqcik7cmV0dXJuIHkuY2FsY3VsYXRlKGUsbixyLG8saSxzLGMpLHJhd0J1ZmZlcj10LnJlYWREYXRhKGwsdSpyKSx0LmNvbnRleHQuZGVsZXRlVGV4dHVyZShzKSx0LmNvbnRleHQuZGVsZXRlVGV4dHVyZShjKSxuZXcgRmxvYXQzMkFycmF5KHJhd0J1ZmZlcil9ZnVuY3Rpb24gaChlLG4scixvLGkpe3I9bnVsbCE9cj9yOk51bWJlci5NSU5fVkFMVUUsbz1udWxsIT1vP286TnVtYmVyLk1BWF9WQUxVRTt2YXIgYSxzPWksdT10LmNyZWF0ZURhdGFUZXh0dXJlKGUsbixzKSxsPXQuY3JlYXRlT3V0cHV0VGV4dHVyZShlLG4pO3JldHVybiBiLmNhbGN1bGF0ZShlLG4scixvLHUsbCksYT10LnJlYWREYXRhKGUsbiksdC5jb250ZXh0LmRlbGV0ZVRleHR1cmUodSksdC5jb250ZXh0LmRlbGV0ZVRleHR1cmUobCksbmV3IEZsb2F0MzJBcnJheShhKX1mdW5jdGlvbiBkKHQsZSxuKXt2YXIgcixvLGk9W107bj8oaVsxXT10Lmxlbmd0aCxpWzBdPXRbMF0ubGVuZ3RoKTooaVswXT10Lmxlbmd0aCxpWzFdPXRbMF0ubGVuZ3RoKSxvPWlbMV0sZT1lfHxGbG9hdDMyQXJyYXkscj1uZXcgZShpWzBdKmlbMV0pO2Zvcih2YXIgYT0wO2E8aVswXTsrK2EpZm9yKHZhciBzPTA7czxpWzFdOysrcyluP3JbYSpvK3NdPXRbc11bYV06clthKm8rc109dFthXVtzXTtyZXR1cm4gcn1mdW5jdGlvbiB2KHQsZSxuKXtmb3IodmFyIHI9bmV3IG4uY29uc3RydWN0b3IodCplKSxvPTA7dD5vO28rKylmb3IodmFyIGk9MDtlPmk7aSsrKXJbaSp0K29dPW5bbyplK2ldO3JldHVybiByfXZhciBtPW5ldyBhKHQpLF89bmV3IHModCksZz1uZXcgdSh0KSx5PW5ldyBsKHQpLGI9bmV3IGModCk7cmV0dXJue3NheHB5Om4sc3NjYWw6byxzZ2VtbTplLHNzdGQ6ZixzZHduczpwLHNjbG1wOmgscGlwZWxpbmU6aSxncHU6e2dsOnQsc2dlbW06aS5zZ2VtbWNhbGN1bGF0b3IuY2FsY3VsYXRlLmJpbmQoaS5zZ2VtbWNhbGN1bGF0b3IpLHNzY2FsOmkuc3NjYWxjYWxjdWxhdG9yLmNhbGN1bGF0ZS5iaW5kKGkuc3NjYWxjYWxjdWxhdG9yKSxzY2xtcDppLnNjbG1wY2FsY3VsYXRvci5jYWxjdWxhdGUuYmluZChpLnNjbG1wY2FsY3VsYXRvciksc2R3bnM6aS5zZHduc2NhbGN1bGF0b3IuY2FsY3VsYXRlLmJpbmQoaS5zZHduc2NhbGN1bGF0b3IpLGVuY29kZTp0LmVuY29kZS5iaW5kKHQpfSx1dGlsOntmcm9tQXJyYXk6ZCx0cmFuc3Bvc2U6dn19fXZhciBvPXQoXCIuL2xpYi9nbG9iYWxzXCIpLGk9dChcIi4vbGliL3BpcGVsaW5lXCIpLGE9dChcIi4vbGliL3NnZW1tY2FsY3VsYXRvclwiKSxzPXQoXCIuL2xpYi9zYXhweWNhbGN1bGF0b3JcIiksdT10KFwiLi9saWIvc3NjYWxjYWxjdWxhdG9yXCIpLGw9dChcIi4vbGliL3Nkd25zY2FsY3VsYXRvclwiKSxjPXQoXCIuL2xpYi9zY2xtcGNhbGN1bGF0b3JcIik7by5nbD9lLmV4cG9ydHM9cihvLmdsKTplLmV4cG9ydHM9bnVsbH0se1wiLi9saWIvZ2xvYmFsc1wiOjIsXCIuL2xpYi9waXBlbGluZVwiOjMsXCIuL2xpYi9zYXhweWNhbGN1bGF0b3JcIjo0LFwiLi9saWIvc2NsbXBjYWxjdWxhdG9yXCI6NSxcIi4vbGliL3Nkd25zY2FsY3VsYXRvclwiOjYsXCIuL2xpYi9zZ2VtbWNhbGN1bGF0b3JcIjo3LFwiLi9saWIvc3NjYWxjYWxjdWxhdG9yXCI6OX1dLDI6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcixvPXQoXCIuL3dlYmdsXCIpO3RyeXtyPW5ldyBvfWNhdGNoKHQpe3I9bnVsbCxjb25zb2xlLmxvZyhcIk5vIHN1cHBvcnQgZm9yIFdlYkdMIVwiKX1lLmV4cG9ydHM9e2dsOnJ9fSx7XCIuL3dlYmdsXCI6MTF9XSwzOltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtmdW5jdGlvbiBlKHQsZSxuKXt2YXIgcj1uLnNoYXBlWzBdLG89bi5zaGFwZVsxXSxpPW5ldyBmKFtyLG9dLG51bGwpO3JldHVybiB2LmNhbGN1bGF0ZShyLG8sdCxlLG4udGV4dHVyZSxpLnRleHR1cmUpLGl9ZnVuY3Rpb24gbih0LGUsbixyLG8pe2lmKG4uc2hhcGVbMV0hPT1lLnNoYXBlWzFdKXRocm93IG5ldyBFcnJvcihcIlNlY29uZCBkaW1lbnNpb24gbXVzdCBiZSBvZiBzYW1lIHNpemUgZm9yIGlucHV0IFRlbnNvcnMgKHNlY29uZCBUZW5zb3IgaXMgdHJhbnNwb3NlZCkuXCIpO3ZhciBpLGE9ZS5zaGFwZVswXSxzPW4uc2hhcGVbMF0sdT1lLnNoYXBlWzFdO2k9bz9vLnRleHR1cmU6bnVsbDt2YXIgbD1uZXcgZihbYSxzXSxudWxsKTtyZXR1cm4gaC5jYWxjdWxhdGUoYSxzLHUsdCxlLnRleHR1cmUsbi50ZXh0dXJlLHIsaSxsLnRleHR1cmUpLGx9ZnVuY3Rpb24gcih0LGUsbixyKXtpZihyLnNoYXBlWzFdJXQhPT0wKXRocm93IG5ldyBFcnJvcihcIlNlY29uZCBkaW1lbnNpb24gb2YgdGVuc29yIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBjaGFubmVsc1wiKTt2YXIgbz1yLnNoYXBlWzBdLGk9ci5zaGFwZVsxXS90LGE9TWF0aC5mbG9vcigoby1lKS9uKSsxLHM9TWF0aC5mbG9vcigoaS1lKS9uKSsxLHU9bmV3IGYoW2Escyp0XSxudWxsKTtyZXR1cm4gbS5jYWxjdWxhdGUobyxpLHQsZSxuLHIudGV4dHVyZSx1LnRleHR1cmUpLHV9ZnVuY3Rpb24gbyh0LGUsbil7dD1udWxsIT10P3Q6TnVtYmVyLk1JTl9WQUxVRSxlPW51bGwhPWU/ZTpOdW1iZXIuTUFYX1ZBTFVFO3ZhciByPW4uc2hhcGVbMF0sbz1uLnNoYXBlWzFdLGk9bmV3IGYoW3Isb10sbnVsbCk7cmV0dXJuIF8uY2FsY3VsYXRlKHIsbyx0LGUsbi50ZXh0dXJlLGkudGV4dHVyZSksaX1mdW5jdGlvbiBwKHQsZSxuLHIsbyl7aWYoby5zaGFwZVsxXSV0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgZGltZW5zaW9uIG9mIHRlbnNvciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgY2hhbm5lbHNcIik7dmFyIGksYSxzPW8uc2hhcGVbMF0sdT1vLnNoYXBlWzFdL3Q7cj8oaT1NYXRoLmNlaWwoKHUrMipyLWUpL24pKzEsYT1NYXRoLmNlaWwoKHMrMipyLWUpL24pKzEpOihyPTAsaT1NYXRoLmNlaWwoKHUtZSkvbikrMSxhPU1hdGguY2VpbCgocy1lKS9uKSsxKTt2YXIgbD1lKmUqdCxjPWEqaSxwPWwsaD1uZXcgZihbYyxwXSxudWxsKTtyZXR1cm4gZy5jYWxjdWxhdGUocyx1LHQsYyxwLGksZSxuLHIsby50ZXh0dXJlLGgudGV4dHVyZSksaH12YXIgaD1uZXcgaSh0LCExKSxkPW5ldyBhKHQsITEpLHY9bmV3IHModCwhMSksbT1uZXcgdSh0LCExKSxfPW5ldyBsKHQsITEpLGc9bmV3IGModCwhMSk7cmV0dXJue1RlbnNvcjpmLHNzY2FsOmUsc2dlbW06bixzZHduczpyLHNjbG1wOm8sc2xva246cCxzZ2VtbWNhbGN1bGF0b3I6aCxzYXhweWNhbGN1bGF0b3I6ZCxzc2NhbGNhbGN1bGF0b3I6dixzZHduc2NhbGN1bGF0b3I6bSxzY2xtcGNhbGN1bGF0b3I6XyxzbG9rbmNhbGN1bGF0b3I6Z319dmFyIG89dChcIi4vZ2xvYmFsc1wiKSxpPXQoXCIuL3NnZW1tY2FsY3VsYXRvclwiKSxhPXQoXCIuL3NheHB5Y2FsY3VsYXRvclwiKSxzPXQoXCIuL3NzY2FsY2FsY3VsYXRvclwiKSx1PXQoXCIuL3Nkd25zY2FsY3VsYXRvclwiKSxsPXQoXCIuL3NjbG1wY2FsY3VsYXRvclwiKSxjPXQoXCIuL3Nsb2tuY2FsY3VsYXRvclwiKSxmPXQoXCIuL3RlbnNvclwiKTtvLmdsP2UuZXhwb3J0cz1yKG8uZ2wpOmUuZXhwb3J0cz1udWxsfSx7XCIuL2dsb2JhbHNcIjoyLFwiLi9zYXhweWNhbGN1bGF0b3JcIjo0LFwiLi9zY2xtcGNhbGN1bGF0b3JcIjo1LFwiLi9zZHduc2NhbGN1bGF0b3JcIjo2LFwiLi9zZ2VtbWNhbGN1bGF0b3JcIjo3LFwiLi9zbG9rbmNhbGN1bGF0b3JcIjo4LFwiLi9zc2NhbGNhbGN1bGF0b3JcIjo5LFwiLi90ZW5zb3JcIjoxMH1dLDQ6W2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dGhpcy53ZWJnbD10LHRoaXMuc3RhbmRhbG9uZT1lfHwhMDt2YXIgbj1cInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiAgICAgIG91dFRleDtcXHQvLyB0ZXh0dXJlIGNvb3JkcyBvZiByb3cvY29sdW1uIHRvIGNhbGN1bGF0ZVxcbnVuaWZvcm0gc2FtcGxlcjJEIFg7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgQVxcbnVuaWZvcm0gc2FtcGxlcjJEIFk7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgdHJhbnNwb3NlIG9mIEJcXG51bmlmb3JtIGludCAgICAgICBOO1xcbnVuaWZvcm0gZmxvYXQgICAgIGE7IFxcdFxcdC8vIGNvZWZmaWNpZW50IHRvIG11bHRpcGxpY2F0aW9uXFxuXFxuLy8gUmVuZGVyIGZsb2F0IHRvIGJ5dGVzIGFjY29yZGluZyB0byBJRUVFIDc1NCBGbG9hdGluZyBQb2ludFxcbnZlYzQgZW5jb2RlX2Zsb2F0XzE1NDAyNTkxMzAoZmxvYXQgdmFsKSB7XFxuXFxuXFx0Ly8gVE9ETzogY29ycmVjdGx5IGhhbmRsZSBkZW5vcm1hbCBudW1iZXJzXFxuXFx0Ly8gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTIvMDQvbnVtYmVyLWVuY29kaW5nLmh0bWxcXG5cXHRmbG9hdCBhID0gYWJzKHZhbCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIGFic29sdXRlIHZhbHVlICsgc2lnblxcblxcdGZsb2F0IGV4cCA9IGZsb29yKGxvZzIoYSkpOyAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHBvd2VycyBvZiAyXFxuXFx0ZmxvYXQgbWFudCA9IHBvdygyLixsb2cyKGEpLWV4cCkgKiBwb3coMi4sMjMuKTsgIC8vIG11bHRpcGx5IHRvIGZpbGwgMjQgYml0cyAoaW1wbGllZCBsZWFkaW5nIDEpXFxuXFx0ZmxvYXQgbWFudDEgPSBmbG9vcihtYW50IC8gMjU2LiAvIDI1Ni4pOyAgICAvLyBmaXJzdCA4IGJpdHMgb2YgbWFudGlzc2FcXG5cXHRmbG9hdCBtYW50MiA9IG1vZChmbG9vcihtYW50IC8gMjU2LiksMjU2Lik7IC8vIHNlY29uZCA4IGJpdHNcXG5cXHRmbG9hdCBtYW50MyA9IG1vZChtYW50LDI1Ni4pOyAgICAgICAgICAgICAgIC8vIHRoaXJkIDggYml0c1xcblxcblxcdGhpZ2hwIGZsb2F0IHNpZ24gPSAxMjguLTEyOC4qKGEvdmFsKTtcXHRcXHRcXHQvLyBzaWduIGJpdCBpcyAyNTYgb3IgMFxcblxcdGhpZ2hwIGZsb2F0IGUgPSAoc2lnbitleHArMTI3LikvNTEwLjtcXHRcXHQvLyBleHBvbmVudCBhbmQgc2lnblxcblxcdGhpZ2hwIGZsb2F0IG0xID0gKG1hbnQxLSgxMjguKigxLi1tb2QoZXhwKzEyNy4sMi4pKSkpLzI1NS47IC8vIGhhbmRsZSBsZWFkaW5nIGJpdFxcblxcdGhpZ2hwIGZsb2F0IG0yID0gKG1hbnQyKS8yNTUuO1xcdFxcdFxcdFxcdC8vIG1pZGRsZSBwYXJ0XFxuXFx0aGlnaHAgZmxvYXQgbTMgPSAobWFudDMrLjUpLzI1NS47XFx0XFx0XFx0Ly8gc2NhbGUgdG8gMCAtIDI1NVxcblxcblxcdHJldHVybiB2ZWM0KG0zLG0yLG0xLGUpO1xcbn1cXG5cXG4vLyBzZWxlY3QgYW4gZWxlbWVudCBmcm9tIGEgdmVjdG9yIGJhc2VkIG9uIGluZGV4XFxuZmxvYXQgc2VsZWN0X2luZGV4XzE2MDQxNTA1NTkodmVjNCB2LCBpbnQgaW5kZXgpe1xcblxcdGZsb2F0IHZhbDtcXG5cXHRpZiAoaW5kZXggPT0gMCkge1xcblxcdFxcdHZhbCA9IHYucjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMSkge1xcblxcdFxcdHZhbCA9IHYuZztcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMikge1xcblxcdFxcdHZhbCA9IHYuYjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMyl7XFxuXFx0XFx0dmFsID0gdi5hO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0Ly8gc2hvdWxkIG5ldmVyIGJlIGhlcmVcXG5cXHRcXHR2YWwgPSAwLjA7XFxuXFx0fVxcblxcblxcdHJldHVybiB2YWw7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0Ly8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcblxcdC8vIHRleHR1cmUgY29vcmRpbmF0ZS4gVGhlc2UgbWFwIGRpcmVjdGx5IHRvIGlucHV0IHRleHR1cmUgc3BhY2Ugd2hlblxcblxcdC8vIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGFyZSB0aGUgc2FtZS5cXG4gXFx0ZmxvYXQgcm93ID0gb3V0VGV4Lnk7XFxuXFx0ZmxvYXQgY29sID0gb3V0VGV4Lng7XFxuXFxuXFx0Ly8gZGlyZWN0IHVzYWdlIG9mIGNvbCByZXF1aXJlcyBvdXRwdXQgYmUgcGFkZGVkIGV4YWN0bHkgbGlrZSBpbnB1dFxcblxcdHZlYzQgeCA9IHRleHR1cmUyRCggWCwgdmVjMihjb2wsIHJvdykpO1xcblxcdHZlYzQgeSA9IHRleHR1cmUyRCggWSwgdmVjMihjb2wsIHJvdykpO1xcblxcdHZlYzQgc3VtX3YgPSAoYSAqIHgpICsgeTtcXG5cXHRpbnQgY2hhbm5lbCA9IGludChtb2QoY29sICogZmxvYXQoTiksIDQuMCApKTtcXG5cXHRmbG9hdCBzdW0gPSBzZWxlY3RfaW5kZXhfMTYwNDE1MDU1OShzdW1fdiwgY2hhbm5lbCk7XFxuXFxuXFx0aWYgKHN1bSA9PSAwLikge1xcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4sMC4sMC4sMC4pO1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuIFxcdC8vIG91dHB1dCB2ZWM0IHdpdGggYnl0ZXMgZm9yIGFuIElFRUU3NTQgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlclxcblxcdGdsX0ZyYWdDb2xvciA9IGVuY29kZV9mbG9hdF8xNTQwMjU5MTMwKHN1bSk7XFxufVxcblwiO3RoaXMuc3RhbmRhbG9uZT90aGlzLnByb2dyYW09dGhpcy53ZWJnbC5jcmVhdGVQcm9ncmFtKG4pOnRoaXMucHJvZ3JhbT10aGlzLndlYmdsLmNyZWF0ZVByb2dyYW0ocCl9dChcIi4vd2ViZ2xcIik7ZS5leHBvcnRzPXIsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8wPVwiWFwiLHIuVEVYVFVSRV9VTklGT1JNX05BTUVfMT1cIllcIixyLkxFTkdUSF9VTklGT1JNX05BTUU9XCJOXCIsci5DT0VGRklDSUVOVF9VTklGT1JNX05BTUU9XCJhXCIsci5wcm90b3R5cGUuY2FsY3VsYXRlPWZ1bmN0aW9uKHQsZSxuLG8saSl7dmFyIGE9dGhpcy53ZWJnbC5jb250ZXh0O3RoaXMud2ViZ2wuc2VsZWN0UHJvZ3JhbSh0aGlzLnByb2dyYW0pLHRoaXMuYmluZElucHV0VGV4dHVyZShuLGEuVEVYVFVSRTAsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8wKSx0aGlzLmJpbmRJbnB1dFRleHR1cmUobyxhLlRFWFRVUkUxLHIuVEVYVFVSRV9VTklGT1JNX05BTUVfMSk7dmFyIHM9dGhpcy53ZWJnbC5nZXRQYWQodCk7dGhpcy5iaW5kVW5pZm9ybXModCtzLGUpLHRoaXMud2ViZ2wuYmluZE91dHB1dFRleHR1cmUoMSx0K3MsaSksYS5kcmF3RWxlbWVudHMoYS5UUklBTkdMRVMsNixhLlVOU0lHTkVEX1NIT1JULDApLHRoaXMud2ViZ2wudW5iaW5kSW5wdXRUZXh0dXJlKGEuVEVYVFVSRTApLHRoaXMud2ViZ2wudW5iaW5kSW5wdXRUZXh0dXJlKGEuVEVYVFVSRTEpfSxyLnByb3RvdHlwZS5iaW5kSW5wdXRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLndlYmdsLmNvbnRleHQsbz10aGlzLnByb2dyYW07ci5hY3RpdmVUZXh0dXJlKGUpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpO3ZhciBpPXIuZ2V0VW5pZm9ybUxvY2F0aW9uKG8sbik7ci51bmlmb3JtMWkoaSxlLXIuVEVYVFVSRTApfSxyLnByb3RvdHlwZS5iaW5kVW5pZm9ybXM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLndlYmdsLmNvbnRleHQsbz1uLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5MRU5HVEhfVU5JRk9STV9OQU1FKSxpPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLkNPRUZGSUNJRU5UX1VOSUZPUk1fTkFNRSk7bi51bmlmb3JtMWkobyx0KSxuLnVuaWZvcm0xZihpLGUpfX0se1wiLi93ZWJnbFwiOjExfV0sNTpbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlKXt0aGlzLndlYmdsPXQsdGhpcy5zdGFuZGFsb25lPW51bGw9PWV8fGU7dmFyIG49XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgICAgICBvdXRUZXg7XFx0Ly8gdGV4dHVyZSBjb29yZHMgb2Ygcm93L2NvbHVtbiB0byBjYWxjdWxhdGVcXG51bmlmb3JtIHNhbXBsZXIyRCBYO1xcdFxcdC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIEFcXG51bmlmb3JtIGludCAgICAgICBOO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zXFxudW5pZm9ybSBpbnQgICAgICAgcGFkO1xcdFxcdC8vIGFkZGl0aW9uYWwgY29sdW1ucyB0byBuZWFyZXN0IG11bHRpcGxlIG9mIGZvdXJcXG51bmlmb3JtIGZsb2F0ICAgICBhOyBcXHRcXHQvLyBsb3dlciBib3VuZFxcbnVuaWZvcm0gZmxvYXQgICAgIGI7IFxcdFxcdC8vIHVwcGVyIGJvdW5kXFxuXFxuLy8gUmVuZGVyIGZsb2F0IHRvIGJ5dGVzIGFjY29yZGluZyB0byBJRUVFIDc1NCBGbG9hdGluZyBQb2ludFxcbnZlYzQgZW5jb2RlX2Zsb2F0XzE2MDQxNTA1NTkoZmxvYXQgdmFsKSB7XFxuXFxuXFx0Ly8gVE9ETzogY29ycmVjdGx5IGhhbmRsZSBkZW5vcm1hbCBudW1iZXJzXFxuXFx0Ly8gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTIvMDQvbnVtYmVyLWVuY29kaW5nLmh0bWxcXG5cXHRmbG9hdCBhID0gYWJzKHZhbCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIGFic29sdXRlIHZhbHVlICsgc2lnblxcblxcdGZsb2F0IGV4cCA9IGZsb29yKGxvZzIoYSkpOyAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHBvd2VycyBvZiAyXFxuXFx0ZmxvYXQgbWFudCA9IHBvdygyLixsb2cyKGEpLWV4cCkgKiBwb3coMi4sMjMuKTsgIC8vIG11bHRpcGx5IHRvIGZpbGwgMjQgYml0cyAoaW1wbGllZCBsZWFkaW5nIDEpXFxuXFx0ZmxvYXQgbWFudDEgPSBmbG9vcihtYW50IC8gMjU2LiAvIDI1Ni4pOyAgICAvLyBmaXJzdCA4IGJpdHMgb2YgbWFudGlzc2FcXG5cXHRmbG9hdCBtYW50MiA9IG1vZChmbG9vcihtYW50IC8gMjU2LiksMjU2Lik7IC8vIHNlY29uZCA4IGJpdHNcXG5cXHRmbG9hdCBtYW50MyA9IG1vZChtYW50LDI1Ni4pOyAgICAgICAgICAgICAgIC8vIHRoaXJkIDggYml0c1xcblxcblxcdGhpZ2hwIGZsb2F0IHNpZ24gPSAxMjguLTEyOC4qKGEvdmFsKTtcXHRcXHRcXHQvLyBzaWduIGJpdCBpcyAyNTYgb3IgMFxcblxcdGhpZ2hwIGZsb2F0IGUgPSAoc2lnbitleHArMTI3LikvNTEwLjtcXHRcXHQvLyBleHBvbmVudCBhbmQgc2lnblxcblxcdGhpZ2hwIGZsb2F0IG0xID0gKG1hbnQxLSgxMjguKigxLi1tb2QoZXhwKzEyNy4sMi4pKSkpLzI1NS47IC8vIGhhbmRsZSBsZWFkaW5nIGJpdFxcblxcdGhpZ2hwIGZsb2F0IG0yID0gKG1hbnQyKS8yNTUuO1xcdFxcdFxcdFxcdC8vIG1pZGRsZSBwYXJ0XFxuXFx0aGlnaHAgZmxvYXQgbTMgPSAobWFudDMrLjUpLzI1NS47XFx0XFx0XFx0Ly8gc2NhbGUgdG8gMCAtIDI1NVxcblxcblxcdHJldHVybiB2ZWM0KG0zLG0yLG0xLGUpO1xcbn1cXG5cXG4vLyBzZWxlY3QgYW4gZWxlbWVudCBmcm9tIGEgdmVjdG9yIGJhc2VkIG9uIGluZGV4XFxuZmxvYXQgc2VsZWN0X2luZGV4XzE1NDAyNTkxMzAodmVjNCB2LCBpbnQgaW5kZXgpe1xcblxcdGZsb2F0IHZhbDtcXG5cXHRpZiAoaW5kZXggPT0gMCkge1xcblxcdFxcdHZhbCA9IHYucjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMSkge1xcblxcdFxcdHZhbCA9IHYuZztcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMikge1xcblxcdFxcdHZhbCA9IHYuYjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMyl7XFxuXFx0XFx0dmFsID0gdi5hO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0Ly8gc2hvdWxkIG5ldmVyIGJlIGhlcmVcXG5cXHRcXHR2YWwgPSAwLjA7XFxuXFx0fVxcblxcblxcdHJldHVybiB2YWw7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0Ly8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcblxcdC8vIHRleHR1cmUgY29vcmRpbmF0ZS4gVGhlc2UgbWFwIGRpcmVjdGx5IHRvIGlucHV0IHRleHR1cmUgc3BhY2Ugd2hlblxcblxcdC8vIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGFyZSB0aGUgc2FtZS5cXG5cXHRmbG9hdCByb3cgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2wgPSBvdXRUZXgueDtcXG5cXG5cXHQvLyByZXR1cm4gMC4wIGlmIGluIHBhZGRlZCByZWdpb24gb2Ygb3V0cHV0IHRleHR1cmVcXG5cXHRpZihjb2wgKiBmbG9hdChOICsgcGFkKSA+IGZsb2F0KE4pICkge1xcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4sMC4sMC4sMC4pO1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0Ly8gZGlyZWN0IHVzYWdlIG9mIGNvbCByZXF1aXJlcyBvdXRwdXQgYmUgcGFkZGVkIGV4YWN0bHkgbGlrZSBpbnB1dFxcblxcdHZlYzQgeCA9IHRleHR1cmUyRCggWCwgdmVjMihjb2wsIHJvdykpO1xcblxcdHZlYzQgdmFsID0gY2xhbXAoeCwgYSwgYik7XFxuXFxuXFx0Ly8gc2VsZWN0IGFuZCBvdXRwdXQgY2hhbm5lbCAoc3RhbmRhbG9uZSB2ZXJzaW9uIG9ubHkpXFxuXFx0aW50IGNoYW5uZWwgPSBpbnQobW9kKGNvbCAqIGZsb2F0KE4gKyBwYWQpLCA0LjApKTtcXG5cXHRmbG9hdCBzdW0gPSBzZWxlY3RfaW5kZXhfMTU0MDI1OTEzMCh2YWwsIGNoYW5uZWwpO1xcblxcblxcdGlmIChzdW0gPT0gMC4pIHtcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLDAuLDAuLDAuKTtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIG91dHB1dCB2ZWM0IHdpdGggYnl0ZXMgZm9yIGFuIElFRUU3NTQgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlclxcblxcdGdsX0ZyYWdDb2xvciA9IGVuY29kZV9mbG9hdF8xNjA0MTUwNTU5KHN1bSk7XFxufVxcblwiLHI9XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgICAgICBvdXRUZXg7XFx0Ly8gdGV4dHVyZSBjb29yZHMgb2Ygcm93L2NvbHVtbiB0byBjYWxjdWxhdGVcXG51bmlmb3JtIHNhbXBsZXIyRCBYO1xcdFxcdC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIEFcXG51bmlmb3JtIGludCAgICAgICBOO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zXFxudW5pZm9ybSBpbnQgICAgICAgcGFkO1xcdFxcdC8vIGFkZGl0aW9uYWwgY29sdW1ucyB0byBuZWFyZXN0IG11bHRpcGxlIG9mIGZvdXJcXG51bmlmb3JtIGZsb2F0ICAgICBhOyBcXHRcXHQvLyBsb3dlciBib3VuZFxcbnVuaWZvcm0gZmxvYXQgICAgIGI7IFxcdFxcdC8vIHVwcGVyIGJvdW5kXFxuXFxuLy8gc2V0IHBhZCB2YWx1ZXMgdG8gMC4wLCBpZiBpbiBwYWRkZWQgcmVnaW9uIG9mIG91dHB1dCB0ZXh0dXJlXFxudm9pZCBmaXhfcGFkXzE1NDAyNTkxMzAoaW5vdXQgdmVjNCB2LCBpbnQgcGFkKXtcXG5cXHR2LmEgPSAwLjA7XFxuXFx0aWYocGFkID09IDIpe1xcblxcdFxcdHYuYiA9IDAuMDtcXG5cXHR9IGVsc2UgaWYocGFkID09IDMpe1xcblxcdFxcdHYuYiA9IDAuMDtcXG5cXHRcXHR2LmcgPSAwLjA7XFxuXFx0fVxcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUuIFRoZXNlIG1hcCBkaXJlY3RseSB0byBpbnB1dCB0ZXh0dXJlIHNwYWNlIHdoZW5cXG5cXHQvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcdGZsb2F0IGNvbCA9IChjb2xfdCAqIGZsb2F0KE4gKyBwYWQpIC0gMi4wKTsgLy8gaW5kZXggb2YgZmlyc3QgZWxlbWVudCBpbiBwaXhlbCAobWF0cml4IHNwYWNlKVxcblxcblxcdC8vIGRpcmVjdCB1c2FnZSBvZiBjb2wgcmVxdWlyZXMgb3V0cHV0IGJlIHBhZGRlZCBleGFjdGx5IGxpa2UgaW5wdXRcXG5cXHR2ZWM0IHggPSB0ZXh0dXJlMkQoIFgsIHZlYzIoY29sX3QsIHJvd190KSk7XFxuXFx0dmVjNCB2YWxfdiA9IGNsYW1wKHgsIGEsIGIpO1xcblxcblxcdC8vIGlzIGxhc3QgZWxlbWVudCBpbiBwaXhlbCBwYXN0IHJvdyBsZW5ndGg/XFxuXFx0aWYocGFkID4gMCAmJiAoY29sICsgNC4wKSA+IGZsb2F0KE4pICkge1xcblxcdFxcdC8vIGZpeCBlbGVtZW50cyBpbiBwYWRkZWQgcmVnaW9uXFxuXFx0XFx0Zml4X3BhZF8xNTQwMjU5MTMwKHZhbF92LCBwYWQpO1xcblxcdH1cXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2YWxfdjtcXG59XFxuXCI7XG50aGlzLnN0YW5kYWxvbmU/dGhpcy5wcm9ncmFtPXRoaXMud2ViZ2wuY3JlYXRlUHJvZ3JhbShuKTp0aGlzLnByb2dyYW09dGhpcy53ZWJnbC5jcmVhdGVQcm9ncmFtKHIpfXQoXCIuL3dlYmdsXCIpO2UuZXhwb3J0cz1yLHIuVEVYVFVSRV9VTklGT1JNX05BTUVfMD1cIlhcIixyLkxFTkdUSF9VTklGT1JNX05BTUU9XCJOXCIsci5MT1dFUl9VTklGT1JNX05BTUU9XCJhXCIsci5VUFBFUl9VTklGT1JNX05BTUU9XCJiXCIsci5wcm90b3R5cGUuY2FsY3VsYXRlPWZ1bmN0aW9uKHQsZSxuLG8saSxhKXtuPW51bGwhPW4/bjpOdW1iZXIuTUlOX1ZBTFVFLG89bnVsbCE9bz9vOk51bWJlci5NQVhfVkFMVUU7dmFyIHM9dGhpcy53ZWJnbC5jb250ZXh0O3RoaXMud2ViZ2wuc2VsZWN0UHJvZ3JhbSh0aGlzLnByb2dyYW0pLHRoaXMuYmluZElucHV0VGV4dHVyZShpLHMuVEVYVFVSRTAsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8wKTt2YXIgdT10aGlzLndlYmdsLmdldFBhZChlKTt0aGlzLmJpbmRVbmlmb3JtcyhlLHUsbixvKSx0aGlzLnN0YW5kYWxvbmU/dGhpcy53ZWJnbC5iaW5kT3V0cHV0VGV4dHVyZSh0LGUrdSxhKTp0aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKHQsKGUrdSkvNCxhKSxzLmRyYXdFbGVtZW50cyhzLlRSSUFOR0xFUyw2LHMuVU5TSUdORURfU0hPUlQsMCksdGhpcy53ZWJnbC51bmJpbmRJbnB1dFRleHR1cmUocy5URVhUVVJFMCl9LHIucHJvdG90eXBlLmJpbmRJbnB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMud2ViZ2wuY29udGV4dCxvPXRoaXMucHJvZ3JhbTtyLmFjdGl2ZVRleHR1cmUoZSksci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfMkQsdCk7dmFyIGk9ci5nZXRVbmlmb3JtTG9jYXRpb24obyxuKTtyLnVuaWZvcm0xaShpLGUtci5URVhUVVJFMCl9LHIucHJvdG90eXBlLmJpbmRVbmlmb3Jtcz1mdW5jdGlvbih0LGUsbixvKXt2YXIgaT10aGlzLndlYmdsLmNvbnRleHQsYT1pLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5MRU5HVEhfVU5JRk9STV9OQU1FKSxzPWkuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLlVQUEVSX1VOSUZPUk1fTkFNRSksdT1pLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5MT1dFUl9VTklGT1JNX05BTUUpLGw9aS5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwicGFkXCIpO2kudW5pZm9ybTFpKGEsdCksaS51bmlmb3JtMWkobCxlKSxpLnVuaWZvcm0xZih1LG4pLGkudW5pZm9ybTFmKHMsbyl9fSx7XCIuL3dlYmdsXCI6MTF9XSw2OltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3RoaXMud2ViZ2w9dCx0aGlzLnN0YW5kYWxvbmU9bnVsbD09ZXx8ZTt2YXIgbj1cIi8vIFRPRE86IHVucm9sbCBsb29wIGZvciBzdHJpZGUgPT0gZmFjdG9yIGFuZCBzbWFsbCB2YWx1ZXMgKDIsIDMpXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyICAgICAgb3V0VGV4OyAgLy8gdGV4dHVyZSBjb29yZHMgb2Ygcm93L2NvbHVtbiB0byBjYWxjdWxhdGVcXG51bmlmb3JtIHNhbXBsZXIyRCBYOyAgICAgICAvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIHBhZGRlZCBBXFxudW5pZm9ybSBpbnQgICAgICAgZmFjdG9yOyAgLy8gd2lkdGggb2YgaW1hZ2UgcGF0Y2hcXG51bmlmb3JtIGZsb2F0ICAgICBzdHJpZGU7ICAvLyB3aWR0aCBiZXR3ZWVuIGltYWdlIHBhdGNoZXNcXG51bmlmb3JtIGZsb2F0ICAgICBDOyAgICAgICAvLyBudW1iZXIgb2YgY2hhbm5lbHNcXG51bmlmb3JtIGZsb2F0ICAgICBNO1xcbnVuaWZvcm0gZmxvYXQgICAgIE47XFxudW5pZm9ybSBmbG9hdCAgICAgTl9vdXQ7XFxudW5pZm9ybSBmbG9hdCAgICAgTV9vdXQ7XFxuXFxuLy8gUmVuZGVyIGZsb2F0IHRvIGJ5dGVzIGFjY29yZGluZyB0byBJRUVFIDc1NCBGbG9hdGluZyBQb2ludFxcbnZlYzQgZW5jb2RlX2Zsb2F0XzE1NDAyNTkxMzAoZmxvYXQgdmFsKSB7XFxuXFxuXFx0Ly8gVE9ETzogY29ycmVjdGx5IGhhbmRsZSBkZW5vcm1hbCBudW1iZXJzXFxuXFx0Ly8gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTIvMDQvbnVtYmVyLWVuY29kaW5nLmh0bWxcXG5cXHRmbG9hdCBhID0gYWJzKHZhbCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIGFic29sdXRlIHZhbHVlICsgc2lnblxcblxcdGZsb2F0IGV4cCA9IGZsb29yKGxvZzIoYSkpOyAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHBvd2VycyBvZiAyXFxuXFx0ZmxvYXQgbWFudCA9IHBvdygyLixsb2cyKGEpLWV4cCkgKiBwb3coMi4sMjMuKTsgIC8vIG11bHRpcGx5IHRvIGZpbGwgMjQgYml0cyAoaW1wbGllZCBsZWFkaW5nIDEpXFxuXFx0ZmxvYXQgbWFudDEgPSBmbG9vcihtYW50IC8gMjU2LiAvIDI1Ni4pOyAgICAvLyBmaXJzdCA4IGJpdHMgb2YgbWFudGlzc2FcXG5cXHRmbG9hdCBtYW50MiA9IG1vZChmbG9vcihtYW50IC8gMjU2LiksMjU2Lik7IC8vIHNlY29uZCA4IGJpdHNcXG5cXHRmbG9hdCBtYW50MyA9IG1vZChtYW50LDI1Ni4pOyAgICAgICAgICAgICAgIC8vIHRoaXJkIDggYml0c1xcblxcblxcdGhpZ2hwIGZsb2F0IHNpZ24gPSAxMjguLTEyOC4qKGEvdmFsKTtcXHRcXHRcXHQvLyBzaWduIGJpdCBpcyAyNTYgb3IgMFxcblxcdGhpZ2hwIGZsb2F0IGUgPSAoc2lnbitleHArMTI3LikvNTEwLjtcXHRcXHQvLyBleHBvbmVudCBhbmQgc2lnblxcblxcdGhpZ2hwIGZsb2F0IG0xID0gKG1hbnQxLSgxMjguKigxLi1tb2QoZXhwKzEyNy4sMi4pKSkpLzI1NS47IC8vIGhhbmRsZSBsZWFkaW5nIGJpdFxcblxcdGhpZ2hwIGZsb2F0IG0yID0gKG1hbnQyKS8yNTUuO1xcdFxcdFxcdFxcdC8vIG1pZGRsZSBwYXJ0XFxuXFx0aGlnaHAgZmxvYXQgbTMgPSAobWFudDMrLjUpLzI1NS47XFx0XFx0XFx0Ly8gc2NhbGUgdG8gMCAtIDI1NVxcblxcblxcdHJldHVybiB2ZWM0KG0zLG0yLG0xLGUpO1xcbn1cXG5cXG4vLyBzZWxlY3QgYW4gZWxlbWVudCBmcm9tIGEgdmVjdG9yIGJhc2VkIG9uIGluZGV4XFxuZmxvYXQgc2VsZWN0X2luZGV4XzE2MDQxNTA1NTkodmVjNCB2LCBpbnQgaW5kZXgpe1xcblxcdGZsb2F0IHZhbDtcXG5cXHRpZiAoaW5kZXggPT0gMCkge1xcblxcdFxcdHZhbCA9IHYucjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMSkge1xcblxcdFxcdHZhbCA9IHYuZztcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMikge1xcblxcdFxcdHZhbCA9IHYuYjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMyl7XFxuXFx0XFx0dmFsID0gdi5hO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0Ly8gc2hvdWxkIG5ldmVyIGJlIGhlcmVcXG5cXHRcXHR2YWwgPSAwLjA7XFxuXFx0fVxcblxcblxcdHJldHVybiB2YWw7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0Ly8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcblxcdC8vIHRleHR1cmUgY29vcmRpbmF0ZSBhbmQgdHJhbnNsYXRlIHRvIG91dHB1dCBwaXhlbCBzcGFjZS5cXG5cXHRmbG9hdCByb3cgPSBmbG9vcihvdXRUZXgueSAqIE1fb3V0KTsgICAvLyByb3cgb24gb3V0cHV0IHRleHR1cmUgKG1hdHJpeCBzcGFjZSlcXG5cXHRmbG9hdCBjb2wgPSBmbG9vcihvdXRUZXgueCAqIE5fb3V0KTsgLy8gY29sdW1uIG9uIG91dHB1dCB0ZXh0dXJlIChtYXRyaXggc3BhY2UpXFxuXFx0ZmxvYXQgdmNvbCA9IGZsb29yKGNvbCAvIEMpOyAgIC8vIHZpcnR1YWwgY29sdW1uIG9uIG91dHB1dCB0ZXh0dXJlIChtYXRyaXggc3BhY2UpXFxuXFx0ZmxvYXQgdmNoYW5uZWwgPSBmbG9vcihtb2QoY29sLCBDKSk7IC8vIHZpcnR1YWwgY2hhbm5lbCBvbiBvdXRwdXQgdGV4dHVyZVxcblxcblxcdGNvbnN0IGZsb2F0IG1pbiA9IC0xLjBlKzA4O1xcblxcdHZlYzQgY3VycmVudE1heCA9IHZlYzQobWluLCBtaW4sIG1pbiwgbWluKTtcXG5cXG5cXHRmbG9hdCBkZWx0YVkgPSAxLjAvTTtcXG5cXHRmbG9hdCBkZWx0YVggPSAxLjAvTjtcXG5cXHRmbG9hdCB5ID0gKChyb3cgKiBzdHJpZGUpICsgMC41KSpkZWx0YVk7IC8vIHRleHR1cmUgcG9zaXRpb24gb2YgaW5wdXQgcm93XFxuXFx0ZmxvYXQgeDtcXG5cXHRmbG9hdCB6ID0gdmNoYW5uZWwgKiBkZWx0YVg7XFxuXFx0Zm9yIChpbnQgaSA9IDA7IGkgPCAxMDA7IGkgKz0gMSkge1xcblxcdFxcdGlmIChpID49IGZhY3Rvcikge1xcblxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdH1cXG5cXHRcXHR4ID0gKCh2Y29sICogc3RyaWRlICogQykgKyAwLjUpICogZGVsdGFYOyAvLyB0ZXh0dXJlIHBvc2l0aW9uIG9mIGlucHV0IGNvbHVtblxcblxcblxcdFxcdGZvciAoaW50IGogPSAwOyBqIDwgMTAwOyBqICs9IDEpIHtcXG5cXHRcXHRcXHRpZiAoaiA+PSBmYWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmVjMiBjb29yZHMgPSB2ZWMyKHggKyB6LCB5KTtcXG5cXHRcXHRcXHR2ZWM0IHhfdiA9IHRleHR1cmUyRChYLCBjb29yZHMpO1xcblxcdFxcdFxcdGN1cnJlbnRNYXggPSBtYXgoY3VycmVudE1heCwgeF92KTtcXG5cXG5cXHRcXHRcXHR4ICs9IChkZWx0YVggKiBDKTtcXG5cXHRcXHR9XFxuXFx0XFx0eSArPSBkZWx0YVk7XFxuXFx0fVxcblxcdGludCBjaGFuID0gaW50KG1vZChvdXRUZXgueCAqIE5fb3V0LCA0LjAgKSk7XFxuXFx0ZmxvYXQgdmFsID0gc2VsZWN0X2luZGV4XzE2MDQxNTA1NTkoY3VycmVudE1heCwgaW50KGNoYW4pKTtcXG5cXHRpZiAodmFsID09IDAuKSB7XFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCgwLiwwLiwwLiwwLik7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSBlbmNvZGVfZmxvYXRfMTU0MDI1OTEzMCh2YWwpO1xcbn1cXG5cIjtwPVwiLy8gVE9ETzogdW5yb2xsIGxvb3AgZm9yIHN0cmlkZSA9PSBmYWN0b3IgYW5kIHNtYWxsIHZhbHVlcyAoMiwgMylcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgICAgICBvdXRUZXg7ICAvLyB0ZXh0dXJlIGNvb3JkcyBvZiByb3cvY29sdW1uIHRvIGNhbGN1bGF0ZVxcbnVuaWZvcm0gc2FtcGxlcjJEIFg7ICAgICAgIC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIEFcXG51bmlmb3JtIGludCAgICAgICBmYWN0b3I7ICAvLyB3aWR0aCBvZiBpbWFnZSBwYXRjaFxcbnVuaWZvcm0gZmxvYXQgICAgIHN0cmlkZTsgIC8vIHdpZHRoIGJldHdlZW4gaW1hZ2UgcGF0Y2hlc1xcbnVuaWZvcm0gZmxvYXQgICAgIEM7ICAgICAgIC8vIG51bWJlciBvZiBjaGFubmVsc1xcbnVuaWZvcm0gZmxvYXQgICAgIE07XFxudW5pZm9ybSBmbG9hdCAgICAgTjtcXG51bmlmb3JtIGZsb2F0ICAgICBOX291dDtcXG51bmlmb3JtIGZsb2F0ICAgICBNX291dDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUgYW5kIHRyYW5zbGF0ZSB0byBvdXRwdXQgcGl4ZWwgc3BhY2UuXFxuXFx0ZmxvYXQgcm93ID0gZmxvb3Iob3V0VGV4LnkgKiBNX291dCk7ICAgLy8gcm93IG9uIG91dHB1dCB0ZXh0dXJlIChwaXhlbCBzcGFjZSlcXG5cXHRmbG9hdCBjb2wgPSBmbG9vcihvdXRUZXgueCAqIE5fb3V0KTsgLy8gY29sdW1uIG9uIG91dHB1dCB0ZXh0dXJlIChtYXRyaXggc3BhY2UpXFxuXFx0ZmxvYXQgdmNvbCA9IGZsb29yKGNvbCAvIEMpOyAgIC8vIHZpcnR1YWwgY29sdW1uIG9uIG91dHB1dCB0ZXh0dXJlIChtYXRyaXggc3BhY2UpXFxuXFx0ZmxvYXQgdmNoYW5uZWwgPSBmbG9vcihtb2QoY29sLCBDKSk7IC8vIHZpcnR1YWwgY2hhbm5lbCBvbiBvdXRwdXQgdGV4dHVyZVxcblxcblxcdGNvbnN0IGZsb2F0IG1pbiA9IC0xLjBlKzA4O1xcblxcdHZlYzQgY3VycmVudE1heCA9IHZlYzQobWluLCBtaW4sIG1pbiwgbWluKTtcXG5cXG5cXHRmbG9hdCBkZWx0YVkgPSAxLjAvTTtcXG5cXHRmbG9hdCBkZWx0YVggPSAxLjAvTjtcXG5cXHRmbG9hdCB5ID0gKChyb3cgKiBzdHJpZGUpICsgMC41KSpkZWx0YVk7IC8vIHRleHR1cmUgcG9zaXRpb24gb2YgaW5wdXQgcm93XFxuXFx0ZmxvYXQgeDtcXG5cXHRmbG9hdCB6ID0gdmNoYW5uZWwgKiBkZWx0YVg7XFxuXFx0Zm9yIChpbnQgaSA9IDA7IGkgPCAxMDA7IGkgKz0gMSkge1xcblxcdFxcdGlmIChpID49IGZhY3Rvcikge1xcblxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdH1cXG5cXHRcXHR4ID0gKCh2Y29sICogc3RyaWRlICogQykgKyAwLjUpICogZGVsdGFYOyAvLyB0ZXh0dXJlIHBvc2l0aW9uIG9mIGlucHV0IGNvbHVtblxcblxcblxcdFxcdGZvciAoaW50IGogPSAwOyBqIDwgMTAwOyBqICs9IDEpIHtcXG5cXHRcXHRcXHRpZiAoaiA+PSBmYWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmVjMiBjb29yZHMgPSB2ZWMyKHggKyB6LCB5KTtcXG5cXHRcXHRcXHR2ZWM0IHhfdiA9IHRleHR1cmUyRChYLCBjb29yZHMpO1xcblxcdFxcdFxcdGN1cnJlbnRNYXggPSBtYXgoY3VycmVudE1heCwgeF92KTtcXG5cXG5cXHRcXHRcXHR4ICs9IChkZWx0YVggKiBDKTtcXG5cXHRcXHR9XFxuXFx0XFx0eSArPSBkZWx0YVk7XFxuXFx0fVxcblxcblxcdGdsX0ZyYWdDb2xvciA9IGN1cnJlbnRNYXg7XFxufVxcblwiLHRoaXMuc3RhbmRhbG9uZT90aGlzLnByb2dyYW09dGhpcy53ZWJnbC5jcmVhdGVQcm9ncmFtKG4pOnRoaXMucHJvZ3JhbT10aGlzLndlYmdsLmNyZWF0ZVByb2dyYW0ocCl9dmFyIG89dChcIi4vd2ViZ2xcIik7ZS5leHBvcnRzPXIsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8wPVwiWFwiLHIuSU5QVVRfUk9XX0NPVU5UX1VOSUZPUk1fTkFNRT1cIk1cIixyLklOUFVUX0NPTFVNTl9DT1VOVF9VTklGT1JNX05BTUU9XCJOXCIsci5PVVRQVVRfUk9XX0NPVU5UX1VOSUZPUk1fTkFNRT1cIk1fb3V0XCIsci5PVVRQVVRfQ09MVU1OX0NPVU5UX1VOSUZPUk1fTkFNRT1cIk5fb3V0XCIsci5GQUNUT1JfVU5JRk9STV9OQU1FPVwiZmFjdG9yXCIsci5TVFJJREVfVU5JRk9STV9OQU1FPVwic3RyaWRlXCIsci5DSEFOTkVMX0NPVU5UX1VOSUZPUk1fTkFNRT1cIkNcIixyLnByb3RvdHlwZS5jYWxjdWxhdGU9ZnVuY3Rpb24odCxlLG4saSxhLHMsdSl7aWYobiVvLkNPTVBPTkVOVFNfUEVSX1RFWEVMIT0wKXRocm93IG5ldyBFcnJvcihcIkNoYW5uZWwgY291bnQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIFwiK28uQ09NUE9ORU5UU19QRVJfVEVYRUwpO3ZhciBsPXRoaXMud2ViZ2wuY29udGV4dCxjPShNYXRoLmZsb29yKChlLWkpL2EpKzEpKm4sZj1NYXRoLmZsb29yKCh0LWkpL2EpKzE7dGhpcy53ZWJnbC5zZWxlY3RQcm9ncmFtKHRoaXMucHJvZ3JhbSksdGhpcy5iaW5kSW5wdXRUZXh0dXJlKHMsbC5URVhUVVJFMCxyLlRFWFRVUkVfVU5JRk9STV9OQU1FXzApLHRoaXMuYmluZFVuaWZvcm1zKHQsZSpuLGYsYyxpLGEsbiksdGhpcy5zdGFuZGFsb25lP3RoaXMud2ViZ2wuYmluZE91dHB1dFRleHR1cmUoZixjLHUpOnRoaXMud2ViZ2wuYmluZE91dHB1dFRleHR1cmUoZixjL28uQ09NUE9ORU5UU19QRVJfVEVYRUwsdSksbC5kcmF3RWxlbWVudHMobC5UUklBTkdMRVMsNixsLlVOU0lHTkVEX1NIT1JULDApLHRoaXMud2ViZ2wudW5iaW5kSW5wdXRUZXh0dXJlKGwuVEVYVFVSRTApfSxyLnByb3RvdHlwZS5iaW5kSW5wdXRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLndlYmdsLmNvbnRleHQsbz10aGlzLnByb2dyYW07ci5hY3RpdmVUZXh0dXJlKGUpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpO3ZhciBpPXIuZ2V0VW5pZm9ybUxvY2F0aW9uKG8sbik7ci51bmlmb3JtMWkoaSxlLXIuVEVYVFVSRTApfSxyLnByb3RvdHlwZS5iaW5kVW5pZm9ybXM9ZnVuY3Rpb24odCxlLG4sbyxpLGEscyl7dmFyIHU9dGhpcy53ZWJnbC5jb250ZXh0LGw9dS5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLHIuSU5QVVRfUk9XX0NPVU5UX1VOSUZPUk1fTkFNRSksYz11LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5JTlBVVF9DT0xVTU5fQ09VTlRfVU5JRk9STV9OQU1FKSxmPXUuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLk9VVFBVVF9ST1dfQ09VTlRfVU5JRk9STV9OQU1FKSxwPXUuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLk9VVFBVVF9DT0xVTU5fQ09VTlRfVU5JRk9STV9OQU1FKSxoPXUuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLkZBQ1RPUl9VTklGT1JNX05BTUUpLGQ9dS5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLHIuU1RSSURFX1VOSUZPUk1fTkFNRSksdj11LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5DSEFOTkVMX0NPVU5UX1VOSUZPUk1fTkFNRSk7dS51bmlmb3JtMWYobCx0KSx1LnVuaWZvcm0xZihjLGUpLHUudW5pZm9ybTFmKGYsbiksdS51bmlmb3JtMWYocCxvKSx1LnVuaWZvcm0xaShoLGkpLHUudW5pZm9ybTFmKGQsYSksdS51bmlmb3JtMWYodixzKX19LHtcIi4vd2ViZ2xcIjoxMX1dLDc6W2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7dGhpcy53ZWJnbD10LHRoaXMuc3RhbmRhbG9uZT1udWxsPT1lfHxlO3ZhciBuPVwiLy8gZnJhZ21lbnQgc2hhZGVyIHRoYXQgY2FsY3VsYXRlcyB0aGUgbWF0cml4IHByb2R1Y3QgYW5kIHJlbmRlcnMgZWFjaFxcbi8vIGVsZW1lbnQgdG8gdGhlIGJ5dGVzIHJlcHJlc2VudGluZyBhIDMyLWJpdCBJRUVFNzU0IGZsb2F0aW5nIHBvaW50IGluXFxuLy8gdGhlIG91dHB1dCBSR0JBIGNhbnZhcy5cXG4vLyByZWFkUGl4ZWwgaXMgdXNlZCB0byByZWFkIHRoZSBieXRlcy5cXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgICAgICBvdXRUZXg7XFx0Ly8gdGV4dHVyZSBjb29yZHMgb2Ygcm93L2NvbHVtbiB0byBjYWxjdWxhdGVcXG51bmlmb3JtIHNhbXBsZXIyRCBBO1xcdFxcdC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIEFcXG51bmlmb3JtIHNhbXBsZXIyRCBCX3Q7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgdHJhbnNwb3NlIG9mIEJcXG51bmlmb3JtIGludCAgICAgICBLO1xcdFxcdC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiBzaGFyZWQgZGltZW5zaW9uXFxudW5pZm9ybSBpbnQgICAgICAgTjtcXHRcXHQvLyBudW1iZXIgb2YgY29sdW1ucyBpbiBvdXRwdXRcXG51bmlmb3JtIGludCAgICAgICBwYWQ7XFx0XFx0Ly9cXG51bmlmb3JtIGZsb2F0ICAgICBhbHBoYTsgXFx0Ly8gY29lZmZpY2llbnQgdG8gbXVsdGlwbGljYXRpb25cXG5cXG4vLyBzdW0gb2YgcHJvZHVjdHMgYmV0d2VlbiBlbGVtZW50cyBpbiByb3cgaSAoZnJvbSBBKSB4IGNvbCBqIChmcm9tIEIpXFxuXFxuLy8gQ2FsY3VsYXRlIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHRoZSByb3cgKGZyb20gQSkgYW5kIGNvbHVtbiAoZnJvbSBCKVxcbi8vIGlkZW50aWZpZWQgYnkgdGhlIHBhc3NlZCBpbmRlY2VzIChvdXRwdXQgdGV4dHVyZSBjb29yZGluYXRlIHNwYWNlKS5cXG4vLyBXZSBsb29wIG92ZXIgZWxlbWVudHMgaW4gdGhlIHJvdyBhbmQgY29sdW1uIGFuZCBzdW0gdGhlIHByb2R1Y3RcXG4vLyB1c2luZyB0aGUgZ2xzbCBgZG90YCBmdW5jdGlvbiB0byBwcm9jZXNzIGZvdXIgZWxlbWVudHMgYXQgYSB0aW1lLlxcbi8vIFRoaXMgZm91ciBlbGVtZW50IG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGF0IHRoZSBtYXRyaXggQiBiZVxcbi8vIHRyYW5zcG9zZWQgYmVmb3JlIHRleGVsIHBhY2tpbmcgYW5kIHRoYXQgYm90aCBtYXRyaWNlcyBiZSBwYWRkZWRcXG4vLyAod2l0aCB6ZXJvcykgdG8gYSBtdWx0aXBsZSBvZiBmb3VyICg0KSBpbiB0aGVpciBzaGFyZWQgZGltZW5zaW9uLlxcbmZsb2F0IGRvdF9yb3djb2xfMTU0MDI1OTEzMChmbG9hdCB5LCBmbG9hdCB4LCBzYW1wbGVyMkQgQSwgc2FtcGxlcjJEIEJfdCwgaW50IEspIHtcXG5cXHRmbG9hdCBkZWx0YV90ID0gMS4vZmxvYXQoSyk7Ly8gc3BhY2UgKG9uIHRleHR1cmUpIGJldHdlZW4gZWxlbWVudHNcXG5cXHRmbG9hdCBzdW0gPSAwLjtcXHRcXHRcXHQvLyBzdW0gZm9yIHRoaXMgcm93L2NvbHVtbiBwYWlyXFxuXFx0ZmxvYXQgeiA9IDAuNSAqICg0LjAgKiBkZWx0YV90KTsvLyBwb3NpdGlvbiBmb3Igc2hhcmVkIGRpbWVuc2lvbiBvbiBzb3VyY2UgdGV4dHVyZXNcXG5cXG5cXHRmb3IgKGludCBsPTAgOyBsPDQwOTYgOyArK2wpIHtcXG5cXHRcXHRpZihsID49IEsgLyA0KSBicmVhazsgICAgLy8gc3RvcCB3aGVuIHdlIGZpbmlzaCB0aGUgcm93L2NvbHVtblxcblxcdFxcdC8vIGwgaXMgaW4gcGl4ZWwgc3BhY2UsIHNvIHdlIGRpdmlkZSBieSBmb3VyXFxuXFxuXFx0XFx0Ly8gcmV0cmlldmUgbmV4dCBmb3VyIGVsZW1lbnRzIGZyb20gZWFjaCB0ZXh0dXJlXFxuXFx0XFx0dmVjNCBhX2lrID0gdGV4dHVyZTJEKCAgQSwgdmVjMih6LCB5KSk7XFxuXFx0XFx0dmVjNCBiX2tqID0gdGV4dHVyZTJEKEJfdCwgdmVjMih6LCB4KSk7XFxuXFxuXFx0Ly8gdXNlIGBkb3RgIHRvIHByb2Nlc3MgZm91ciBlbGVtZW50cyBhdCBhIHRpbWVcXG5cXHRcXHRzdW0gKz0gIGRvdChhX2lrLCBiX2tqKTtcXG5cXHRcXHR6ICs9ICg0LjAgKiBkZWx0YV90KTsgICAgICAvLyAoeiArIDAuNSkqZGVsdGFcXG5cXHR9XFxuXFx0cmV0dXJuIHN1bTtcXG59XFxuXFxuLy8gUmVuZGVyIGZsb2F0IHRvIGJ5dGVzIGFjY29yZGluZyB0byBJRUVFIDc1NCBGbG9hdGluZyBQb2ludFxcbnZlYzQgZW5jb2RlX2Zsb2F0XzE2MDQxNTA1NTkoZmxvYXQgdmFsKSB7XFxuXFxuXFx0Ly8gVE9ETzogY29ycmVjdGx5IGhhbmRsZSBkZW5vcm1hbCBudW1iZXJzXFxuXFx0Ly8gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTIvMDQvbnVtYmVyLWVuY29kaW5nLmh0bWxcXG5cXHRmbG9hdCBhID0gYWJzKHZhbCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIGFic29sdXRlIHZhbHVlICsgc2lnblxcblxcdGZsb2F0IGV4cCA9IGZsb29yKGxvZzIoYSkpOyAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHBvd2VycyBvZiAyXFxuXFx0ZmxvYXQgbWFudCA9IHBvdygyLixsb2cyKGEpLWV4cCkgKiBwb3coMi4sMjMuKTsgIC8vIG11bHRpcGx5IHRvIGZpbGwgMjQgYml0cyAoaW1wbGllZCBsZWFkaW5nIDEpXFxuXFx0ZmxvYXQgbWFudDEgPSBmbG9vcihtYW50IC8gMjU2LiAvIDI1Ni4pOyAgICAvLyBmaXJzdCA4IGJpdHMgb2YgbWFudGlzc2FcXG5cXHRmbG9hdCBtYW50MiA9IG1vZChmbG9vcihtYW50IC8gMjU2LiksMjU2Lik7IC8vIHNlY29uZCA4IGJpdHNcXG5cXHRmbG9hdCBtYW50MyA9IG1vZChtYW50LDI1Ni4pOyAgICAgICAgICAgICAgIC8vIHRoaXJkIDggYml0c1xcblxcblxcdGhpZ2hwIGZsb2F0IHNpZ24gPSAxMjguLTEyOC4qKGEvdmFsKTtcXHRcXHRcXHQvLyBzaWduIGJpdCBpcyAyNTYgb3IgMFxcblxcdGhpZ2hwIGZsb2F0IGUgPSAoc2lnbitleHArMTI3LikvNTEwLjtcXHRcXHQvLyBleHBvbmVudCBhbmQgc2lnblxcblxcdGhpZ2hwIGZsb2F0IG0xID0gKG1hbnQxLSgxMjguKigxLi1tb2QoZXhwKzEyNy4sMi4pKSkpLzI1NS47IC8vIGhhbmRsZSBsZWFkaW5nIGJpdFxcblxcdGhpZ2hwIGZsb2F0IG0yID0gKG1hbnQyKS8yNTUuO1xcdFxcdFxcdFxcdC8vIG1pZGRsZSBwYXJ0XFxuXFx0aGlnaHAgZmxvYXQgbTMgPSAobWFudDMrLjUpLzI1NS47XFx0XFx0XFx0Ly8gc2NhbGUgdG8gMCAtIDI1NVxcblxcblxcdHJldHVybiB2ZWM0KG0zLG0yLG0xLGUpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUuIFRoZXNlIG1hcCBkaXJlY3RseSB0byBpbnB1dCB0ZXh0dXJlIHNwYWNlIHdoZW5cXG5cXHQvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcblxcdC8vIHN1bSByb3cgeCBjb2wgZm9yIHRoZSBwYXNzZWQgcGl4ZWxcXG5cXHRmbG9hdCBzdW0gPSBhbHBoYSAqIGRvdF9yb3djb2xfMTU0MDI1OTEzMChyb3dfdCwgY29sX3QgKiBmbG9hdChOICsgcGFkKS9mbG9hdChOKSwgQSwgQl90LCBLKTtcXG5cXG5cXHRpZiAoc3VtID09IDAuKSB7XFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCgwLiwwLiwwLiwwLik7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHQvLyBvdXRwdXQgdmVjNCB3aXRoIGJ5dGVzIGZvciBhbiBJRUVFNzU0IDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXJcXG5cXHRnbF9GcmFnQ29sb3IgPSBlbmNvZGVfZmxvYXRfMTYwNDE1MDU1OShzdW0pO1xcbn1cXG5cIixyPVwiLy8gZnJhZ21lbnQgc2hhZGVyIHRoYXQgY2FsY3VsYXRlcyB0aGUgbWF0cml4IHByb2R1Y3QgKHdpdGggYWRkaXRpdmUgJ0MnIHRlcm0pXFxuLy8gYW5kIHJlbmRlcnMgZWFjaCBlbGVtZW50IHRvIHRoZSBieXRlcyByZXByZXNlbnRpbmcgYSAzMi1iaXQgSUVFRTc1NCBmbG9hdGluZ1xcbi8vIHBvaW50IGluIHRoZSBvdXRwdXQgUkdCQSBjYW52YXMuXFxuLy8gcmVhZFBpeGVsIGlzIHVzZWQgdG8gcmVhZCB0aGUgYnl0ZXMuXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyICAgICAgb3V0VGV4O1xcdC8vIHRleHR1cmUgY29vcmRzIG9mIHJvdy9jb2x1bW4gdG8gY2FsY3VsYXRlXFxudW5pZm9ybSBzYW1wbGVyMkQgQTtcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIHBhZGRlZCBBXFxudW5pZm9ybSBzYW1wbGVyMkQgQl90O1xcdFxcdC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIHRyYW5zcG9zZSBvZiBCXFxudW5pZm9ybSBzYW1wbGVyMkQgQztcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIENcXG51bmlmb3JtIGludCAgICAgICBLO1xcdFxcdC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiBzaGFyZWQgZGltZW5zaW9uXFxudW5pZm9ybSBpbnQgICAgICAgTjtcXHRcXHQvLyBudW1iZXIgb2YgY29sdW1ucyBpbiBvdXRwdXRcXG51bmlmb3JtIGludCAgICAgICBwYWQ7XFx0XFx0Ly9cXG51bmlmb3JtIGZsb2F0ICAgICBhbHBoYTsgXFx0Ly8gY29lZmZpY2llbnQgdG8gbXVsdGlwbGljYXRpb25cXG51bmlmb3JtIGZsb2F0ICAgICBiZXRhOyBcXHQvLyBjb2VmZmljaWVudCB0byBhZGRpdGl2ZSB0ZXJtXFxuXFxuLy8gc3VtIG9mIHByb2R1Y3RzIGJldHdlZW4gZWxlbWVudHMgaW4gcm93IGkgKGZyb20gQSkgeCBjb2wgaiAoZnJvbSBCKVxcblxcbi8vIENhbGN1bGF0ZSB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGUgcm93IChmcm9tIEEpIGFuZCBjb2x1bW4gKGZyb20gQilcXG4vLyBpZGVudGlmaWVkIGJ5IHRoZSBwYXNzZWQgaW5kZWNlcyAob3V0cHV0IHRleHR1cmUgY29vcmRpbmF0ZSBzcGFjZSkuXFxuLy8gV2UgbG9vcCBvdmVyIGVsZW1lbnRzIGluIHRoZSByb3cgYW5kIGNvbHVtbiBhbmQgc3VtIHRoZSBwcm9kdWN0XFxuLy8gdXNpbmcgdGhlIGdsc2wgYGRvdGAgZnVuY3Rpb24gdG8gcHJvY2VzcyBmb3VyIGVsZW1lbnRzIGF0IGEgdGltZS5cXG4vLyBUaGlzIGZvdXIgZWxlbWVudCBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCB0aGUgbWF0cml4IEIgYmVcXG4vLyB0cmFuc3Bvc2VkIGJlZm9yZSB0ZXhlbCBwYWNraW5nIGFuZCB0aGF0IGJvdGggbWF0cmljZXMgYmUgcGFkZGVkXFxuLy8gKHdpdGggemVyb3MpIHRvIGEgbXVsdGlwbGUgb2YgZm91ciAoNCkgaW4gdGhlaXIgc2hhcmVkIGRpbWVuc2lvbi5cXG5mbG9hdCBkb3Rfcm93Y29sXzE1NDAyNTkxMzAoZmxvYXQgeSwgZmxvYXQgeCwgc2FtcGxlcjJEIEEsIHNhbXBsZXIyRCBCX3QsIGludCBLKSB7XFxuXFx0ZmxvYXQgZGVsdGFfdCA9IDEuL2Zsb2F0KEspOy8vIHNwYWNlIChvbiB0ZXh0dXJlKSBiZXR3ZWVuIGVsZW1lbnRzXFxuXFx0ZmxvYXQgc3VtID0gMC47XFx0XFx0XFx0Ly8gc3VtIGZvciB0aGlzIHJvdy9jb2x1bW4gcGFpclxcblxcdGZsb2F0IHogPSAwLjUgKiAoNC4wICogZGVsdGFfdCk7Ly8gcG9zaXRpb24gZm9yIHNoYXJlZCBkaW1lbnNpb24gb24gc291cmNlIHRleHR1cmVzXFxuXFxuXFx0Zm9yIChpbnQgbD0wIDsgbDw0MDk2IDsgKytsKSB7XFxuXFx0XFx0aWYobCA+PSBLIC8gNCkgYnJlYWs7ICAgIC8vIHN0b3Agd2hlbiB3ZSBmaW5pc2ggdGhlIHJvdy9jb2x1bW5cXG5cXHRcXHQvLyBsIGlzIGluIHBpeGVsIHNwYWNlLCBzbyB3ZSBkaXZpZGUgYnkgZm91clxcblxcblxcdFxcdC8vIHJldHJpZXZlIG5leHQgZm91ciBlbGVtZW50cyBmcm9tIGVhY2ggdGV4dHVyZVxcblxcdFxcdHZlYzQgYV9payA9IHRleHR1cmUyRCggIEEsIHZlYzIoeiwgeSkpO1xcblxcdFxcdHZlYzQgYl9raiA9IHRleHR1cmUyRChCX3QsIHZlYzIoeiwgeCkpO1xcblxcblxcdC8vIHVzZSBgZG90YCB0byBwcm9jZXNzIGZvdXIgZWxlbWVudHMgYXQgYSB0aW1lXFxuXFx0XFx0c3VtICs9ICBkb3QoYV9paywgYl9raik7XFxuXFx0XFx0eiArPSAoNC4wICogZGVsdGFfdCk7ICAgICAgLy8gKHogKyAwLjUpKmRlbHRhXFxuXFx0fVxcblxcdHJldHVybiBzdW07XFxufVxcblxcbi8vIFJlbmRlciBmbG9hdCB0byBieXRlcyBhY2NvcmRpbmcgdG8gSUVFRSA3NTQgRmxvYXRpbmcgUG9pbnRcXG52ZWM0IGVuY29kZV9mbG9hdF8xMTE3NTY5NTk5KGZsb2F0IHZhbCkge1xcblxcblxcdC8vIFRPRE86IGNvcnJlY3RseSBoYW5kbGUgZGVub3JtYWwgbnVtYmVyc1xcblxcdC8vIGh0dHA6Ly93d3cuMmFsaXR5LmNvbS8yMDEyLzA0L251bWJlci1lbmNvZGluZy5odG1sXFxuXFx0ZmxvYXQgYSA9IGFicyh2YWwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY29kZSBhYnNvbHV0ZSB2YWx1ZSArIHNpZ25cXG5cXHRmbG9hdCBleHAgPSBmbG9vcihsb2cyKGEpKTsgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBwb3dlcnMgb2YgMlxcblxcdGZsb2F0IG1hbnQgPSBwb3coMi4sbG9nMihhKS1leHApICogcG93KDIuLDIzLik7ICAvLyBtdWx0aXBseSB0byBmaWxsIDI0IGJpdHMgKGltcGxpZWQgbGVhZGluZyAxKVxcblxcdGZsb2F0IG1hbnQxID0gZmxvb3IobWFudCAvIDI1Ni4gLyAyNTYuKTsgICAgLy8gZmlyc3QgOCBiaXRzIG9mIG1hbnRpc3NhXFxuXFx0ZmxvYXQgbWFudDIgPSBtb2QoZmxvb3IobWFudCAvIDI1Ni4pLDI1Ni4pOyAvLyBzZWNvbmQgOCBiaXRzXFxuXFx0ZmxvYXQgbWFudDMgPSBtb2QobWFudCwyNTYuKTsgICAgICAgICAgICAgICAvLyB0aGlyZCA4IGJpdHNcXG5cXG5cXHRoaWdocCBmbG9hdCBzaWduID0gMTI4Li0xMjguKihhL3ZhbCk7XFx0XFx0XFx0Ly8gc2lnbiBiaXQgaXMgMjU2IG9yIDBcXG5cXHRoaWdocCBmbG9hdCBlID0gKHNpZ24rZXhwKzEyNy4pLzUxMC47XFx0XFx0Ly8gZXhwb25lbnQgYW5kIHNpZ25cXG5cXHRoaWdocCBmbG9hdCBtMSA9IChtYW50MS0oMTI4LiooMS4tbW9kKGV4cCsxMjcuLDIuKSkpKS8yNTUuOyAvLyBoYW5kbGUgbGVhZGluZyBiaXRcXG5cXHRoaWdocCBmbG9hdCBtMiA9IChtYW50MikvMjU1LjtcXHRcXHRcXHRcXHQvLyBtaWRkbGUgcGFydFxcblxcdGhpZ2hwIGZsb2F0IG0zID0gKG1hbnQzKy41KS8yNTUuO1xcdFxcdFxcdC8vIHNjYWxlIHRvIDAgLSAyNTVcXG5cXG5cXHRyZXR1cm4gdmVjNChtMyxtMixtMSxlKTtcXG59XFxuXFxuLy8gc2VsZWN0IGFuIGVsZW1lbnQgZnJvbSBhIHZlY3RvciBiYXNlZCBvbiBpbmRleFxcbmZsb2F0IHNlbGVjdF9pbmRleF8xNjA0MTUwNTU5KHZlYzQgdiwgaW50IGluZGV4KXtcXG5cXHRmbG9hdCB2YWw7XFxuXFx0aWYgKGluZGV4ID09IDApIHtcXG5cXHRcXHR2YWwgPSB2LnI7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDEpIHtcXG5cXHRcXHR2YWwgPSB2Lmc7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDIpIHtcXG5cXHRcXHR2YWwgPSB2LmI7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDMpe1xcblxcdFxcdHZhbCA9IHYuYTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdC8vIHNob3VsZCBuZXZlciBiZSBoZXJlXFxuXFx0XFx0dmFsID0gMC4wO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdmFsO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUuIFRoZXNlIG1hcCBkaXJlY3RseSB0byBpbnB1dCB0ZXh0dXJlIHNwYWNlIHdoZW5cXG5cXHQvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcdHZlYzQgY192ZWMgPSB0ZXh0dXJlMkQoQywgdmVjMihjb2xfdCwgMC41KSk7XFxuXFxuXFx0Ly8gc2hvdWxkIGJlIC0wLjUsIGJ1dCB0aGF0IHN1YnRseSBicmVha3MgYXQgemVyb1xcblxcdGZsb2F0IGNvbCA9IGNvbF90ICogZmxvYXQoTiArIHBhZCk7IC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG5cXHRpbnQgY2hhbm5lbCA9IGludChtb2QoY29sLCA0LjAgKSk7XFxuXFx0ZmxvYXQgYyA9IHNlbGVjdF9pbmRleF8xNjA0MTUwNTU5KGNfdmVjLCBjaGFubmVsKTtcXG5cXG5cXHQvLyBzdW0gcm93IHggY29sIGZvciB0aGUgcGFzc2VkIHBpeGVsXFxuXFx0ZmxvYXQgc3VtID0gYWxwaGEgKiBkb3Rfcm93Y29sXzE1NDAyNTkxMzAocm93X3QsIGNvbF90ICogZmxvYXQoTiArIHBhZCkvZmxvYXQoTiksIEEsIEJfdCwgSyk7XFxuXFx0c3VtICs9IGJldGEgKiBjO1xcblxcblxcdGlmIChzdW0gPT0gMC4pIHtcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLDAuLDAuLDAuKTtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIG91dHB1dCB2ZWM0IHdpdGggYnl0ZXMgZm9yIGFuIElFRUU3NTQgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlclxcblxcdGdsX0ZyYWdDb2xvciA9IGVuY29kZV9mbG9hdF8xMTE3NTY5NTk5KHN1bSk7XFxufVxcblwiLG89XCIvLyBmcmFnbWVudCBzaGFkZXIgdGhhdCBjYWxjdWxhdGVzIHRoZSBtYXRyaXggcHJvZHVjdCBhbmQgd3JpdGVzIGVhY2hcXG4vLyBlbGVtZW50IHRvIGEgcGl4ZWwgY29tcG9uZW50IGluIGEgZmxvYXRpbmcgcG9pbnQgdGV4dHVyZS5cXG4vLyB0aGUgb3V0cHV0IFJHQkEgY2FudmFzLlxcbi8vIHJlYWRQaXhlbCBpcyB1c2VkIHRvIHJlYWQgdGhlIGJ5dGVzLlxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiAgICAgIG91dFRleDtcXHQvLyB0ZXh0dXJlIGNvb3JkcyBvZiByb3cvY29sdW1uIHRvIGNhbGN1bGF0ZVxcbnVuaWZvcm0gc2FtcGxlcjJEIEE7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgQVxcbnVuaWZvcm0gc2FtcGxlcjJEIEJfdDtcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIHBhZGRlZCB0cmFuc3Bvc2Ugb2YgQlxcbnVuaWZvcm0gaW50ICAgICAgIEs7XFx0XFx0Ly8gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHNoYXJlZCBkaW1lbnNpb25cXG51bmlmb3JtIGludCAgICAgICBOO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zIGluIG91dHB1dFxcbnVuaWZvcm0gaW50ICAgICAgIHBhZDtcXHRcXHQvL1xcbnVuaWZvcm0gZmxvYXQgICAgIGFscGhhOyBcXHQvLyBjb2VmZmljaWVudCB0byBtdWx0aXBsaWNhdGlvblxcblxcbi8vIHN1bSBvZiBwcm9kdWN0cyBiZXR3ZWVuIGVsZW1lbnRzIGluIHJvdyBpIChmcm9tIEEpIHggY29sIGogKGZyb20gQilcXG5cXG4vLyBDYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdGhlIHJvdyAoZnJvbSBBKSBhbmQgY29sdW1uIChmcm9tIEIpXFxuLy8gaWRlbnRpZmllZCBieSB0aGUgcGFzc2VkIGluZGVjZXMgKG91dHB1dCB0ZXh0dXJlIGNvb3JkaW5hdGUgc3BhY2UpLlxcbi8vIFdlIGxvb3Agb3ZlciBlbGVtZW50cyBpbiB0aGUgcm93IGFuZCBjb2x1bW4gYW5kIHN1bSB0aGUgcHJvZHVjdFxcbi8vIHVzaW5nIHRoZSBnbHNsIGBkb3RgIGZ1bmN0aW9uIHRvIHByb2Nlc3MgZm91ciBlbGVtZW50cyBhdCBhIHRpbWUuXFxuLy8gVGhpcyBmb3VyIGVsZW1lbnQgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgdGhlIG1hdHJpeCBCIGJlXFxuLy8gdHJhbnNwb3NlZCBiZWZvcmUgdGV4ZWwgcGFja2luZyBhbmQgdGhhdCBib3RoIG1hdHJpY2VzIGJlIHBhZGRlZFxcbi8vICh3aXRoIHplcm9zKSB0byBhIG11bHRpcGxlIG9mIGZvdXIgKDQpIGluIHRoZWlyIHNoYXJlZCBkaW1lbnNpb24uXFxuZmxvYXQgZG90X3Jvd2NvbF8xNTQwMjU5MTMwKGZsb2F0IHksIGZsb2F0IHgsIHNhbXBsZXIyRCBBLCBzYW1wbGVyMkQgQl90LCBpbnQgSykge1xcblxcdGZsb2F0IGRlbHRhX3QgPSAxLi9mbG9hdChLKTsvLyBzcGFjZSAob24gdGV4dHVyZSkgYmV0d2VlbiBlbGVtZW50c1xcblxcdGZsb2F0IHN1bSA9IDAuO1xcdFxcdFxcdC8vIHN1bSBmb3IgdGhpcyByb3cvY29sdW1uIHBhaXJcXG5cXHRmbG9hdCB6ID0gMC41ICogKDQuMCAqIGRlbHRhX3QpOy8vIHBvc2l0aW9uIGZvciBzaGFyZWQgZGltZW5zaW9uIG9uIHNvdXJjZSB0ZXh0dXJlc1xcblxcblxcdGZvciAoaW50IGw9MCA7IGw8NDA5NiA7ICsrbCkge1xcblxcdFxcdGlmKGwgPj0gSyAvIDQpIGJyZWFrOyAgICAvLyBzdG9wIHdoZW4gd2UgZmluaXNoIHRoZSByb3cvY29sdW1uXFxuXFx0XFx0Ly8gbCBpcyBpbiBwaXhlbCBzcGFjZSwgc28gd2UgZGl2aWRlIGJ5IGZvdXJcXG5cXG5cXHRcXHQvLyByZXRyaWV2ZSBuZXh0IGZvdXIgZWxlbWVudHMgZnJvbSBlYWNoIHRleHR1cmVcXG5cXHRcXHR2ZWM0IGFfaWsgPSB0ZXh0dXJlMkQoICBBLCB2ZWMyKHosIHkpKTtcXG5cXHRcXHR2ZWM0IGJfa2ogPSB0ZXh0dXJlMkQoQl90LCB2ZWMyKHosIHgpKTtcXG5cXG5cXHQvLyB1c2UgYGRvdGAgdG8gcHJvY2VzcyBmb3VyIGVsZW1lbnRzIGF0IGEgdGltZVxcblxcdFxcdHN1bSArPSAgZG90KGFfaWssIGJfa2opO1xcblxcdFxcdHogKz0gKDQuMCAqIGRlbHRhX3QpOyAgICAgIC8vICh6ICsgMC41KSpkZWx0YVxcblxcdH1cXG5cXHRyZXR1cm4gc3VtO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUuIFRoZXNlIG1hcCBkaXJlY3RseSB0byBpbnB1dCB0ZXh0dXJlIHNwYWNlIHdoZW5cXG5cXHQvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcblxcdHZlYzQgc3VtX3YgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFx0ZmxvYXQgY29sID0gKGNvbF90ICogZmxvYXQoTiArIHBhZCkgLSAyLjApOyAvLyBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIChtYXRyaXggc3BhY2UpXFxuXFx0c3VtX3YuciA9IGFscGhhICogZG90X3Jvd2NvbF8xNTQwMjU5MTMwKHJvd190LCAoY29sICsgMC41KS9mbG9hdChOKSwgQSwgQl90LCBLKTtcXG5cXHQvLyBpcyBsYXN0IGVsZW1lbnQgaW4gcGl4ZWwgcGFzdCByb3cgbGVuZ3RoP1xcblxcdGlmKHBhZCA+IDAgJiYgKGNvbCArIDQuMCkgPiBmbG9hdChOKSApIHtcXG5cXHRcXHQvLyBjb21wdXRlIGVsZW1lbnRzIGluIHBhZGRlZCByZWdpb25cXG5cXHRcXHRpZihwYWQgPCAzKXtcXG5cXHRcXHRcXHRzdW1fdi5nID0gYWxwaGEgKiBkb3Rfcm93Y29sXzE1NDAyNTkxMzAocm93X3QsIChjb2wgKyAxLjUpL2Zsb2F0KE4pLCBBLCBCX3QsIEspO1xcblxcdFxcdH1cXG5cXHRcXHRpZihwYWQgPCAyKXtcXG5cXHRcXHRcXHRzdW1fdi5iID0gYWxwaGEgKiBkb3Rfcm93Y29sXzE1NDAyNTkxMzAocm93X3QsIChjb2wgKyAyLjUpL2Zsb2F0KE4pLCBBLCBCX3QsIEspO1xcblxcdFxcdH1cXG5cXHR9IGVsc2Uge1xcblxcdFxcdHN1bV92LmcgPSBhbHBoYSAqIGRvdF9yb3djb2xfMTU0MDI1OTEzMChyb3dfdCwgKGNvbCArIDEuNSkvZmxvYXQoTiksIEEsIEJfdCwgSyk7XFxuXFx0XFx0c3VtX3YuYiA9IGFscGhhICogZG90X3Jvd2NvbF8xNTQwMjU5MTMwKHJvd190LCAoY29sICsgMi41KS9mbG9hdChOKSwgQSwgQl90LCBLKTtcXG5cXHRcXHRzdW1fdi5hID0gYWxwaGEgKiBkb3Rfcm93Y29sXzE1NDAyNTkxMzAocm93X3QsIChjb2wgKyAzLjUpL2Zsb2F0KE4pLCBBLCBCX3QsIEspO1xcblxcdH1cXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSBzdW1fdjtcXG59XFxuXCIsaT1cIi8vIGZyYWdtZW50IHNoYWRlciB0aGF0IGNhbGN1bGF0ZXMgdGhlIG1hdHJpeCBwcm9kdWN0IGFuZCB3cml0ZXMgZWFjaFxcbi8vIGVsZW1lbnQgdG8gYSBwaXhlbCBjb21wb25lbnQgaW4gYSBmbG9hdGluZyBwb2ludCB0ZXh0dXJlLlxcbi8vIHRoZSBvdXRwdXQgUkdCQSBjYW52YXMuXFxuLy8gcmVhZFBpeGVsIGlzIHVzZWQgdG8gcmVhZCB0aGUgYnl0ZXMuXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyICAgICAgb3V0VGV4O1xcdC8vIHRleHR1cmUgY29vcmRzIG9mIHJvdy9jb2x1bW4gdG8gY2FsY3VsYXRlXFxudW5pZm9ybSBzYW1wbGVyMkQgQTtcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIHBhZGRlZCBBXFxudW5pZm9ybSBzYW1wbGVyMkQgQl90O1xcdFxcdC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIHRyYW5zcG9zZSBvZiBCXFxudW5pZm9ybSBzYW1wbGVyMkQgQztcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIENcXG51bmlmb3JtIGludCAgICAgICBLO1xcdFxcdC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiBzaGFyZWQgZGltZW5zaW9uXFxudW5pZm9ybSBpbnQgICAgICAgTjtcXHRcXHQvLyBudW1iZXIgb2YgY29sdW1ucyBpbiBvdXRwdXRcXG51bmlmb3JtIGludCAgICAgICBwYWQ7XFx0XFx0Ly9cXG51bmlmb3JtIGZsb2F0ICAgICBhbHBoYTsgXFx0Ly8gY29lZmZpY2llbnQgdG8gbXVsdGlwbGljYXRpb25cXG51bmlmb3JtIGZsb2F0ICAgICBiZXRhOyBcXHQvLyBjb2VmZmljaWVudCB0byBhZGRpdGlvblxcblxcbi8vIHN1bSBvZiBwcm9kdWN0cyBiZXR3ZWVuIGVsZW1lbnRzIGluIHJvdyBpIChmcm9tIEEpIHggY29sIGogKGZyb20gQilcXG5cXG4vLyBDYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdGhlIHJvdyAoZnJvbSBBKSBhbmQgY29sdW1uIChmcm9tIEIpXFxuLy8gaWRlbnRpZmllZCBieSB0aGUgcGFzc2VkIGluZGVjZXMgKG91dHB1dCB0ZXh0dXJlIGNvb3JkaW5hdGUgc3BhY2UpLlxcbi8vIFdlIGxvb3Agb3ZlciBlbGVtZW50cyBpbiB0aGUgcm93IGFuZCBjb2x1bW4gYW5kIHN1bSB0aGUgcHJvZHVjdFxcbi8vIHVzaW5nIHRoZSBnbHNsIGBkb3RgIGZ1bmN0aW9uIHRvIHByb2Nlc3MgZm91ciBlbGVtZW50cyBhdCBhIHRpbWUuXFxuLy8gVGhpcyBmb3VyIGVsZW1lbnQgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgdGhlIG1hdHJpeCBCIGJlXFxuLy8gdHJhbnNwb3NlZCBiZWZvcmUgdGV4ZWwgcGFja2luZyBhbmQgdGhhdCBib3RoIG1hdHJpY2VzIGJlIHBhZGRlZFxcbi8vICh3aXRoIHplcm9zKSB0byBhIG11bHRpcGxlIG9mIGZvdXIgKDQpIGluIHRoZWlyIHNoYXJlZCBkaW1lbnNpb24uXFxuZmxvYXQgZG90X3Jvd2NvbF8xNTQwMjU5MTMwKGZsb2F0IHksIGZsb2F0IHgsIHNhbXBsZXIyRCBBLCBzYW1wbGVyMkQgQl90LCBpbnQgSykge1xcblxcdGZsb2F0IGRlbHRhX3QgPSAxLi9mbG9hdChLKTsvLyBzcGFjZSAob24gdGV4dHVyZSkgYmV0d2VlbiBlbGVtZW50c1xcblxcdGZsb2F0IHN1bSA9IDAuO1xcdFxcdFxcdC8vIHN1bSBmb3IgdGhpcyByb3cvY29sdW1uIHBhaXJcXG5cXHRmbG9hdCB6ID0gMC41ICogKDQuMCAqIGRlbHRhX3QpOy8vIHBvc2l0aW9uIGZvciBzaGFyZWQgZGltZW5zaW9uIG9uIHNvdXJjZSB0ZXh0dXJlc1xcblxcblxcdGZvciAoaW50IGw9MCA7IGw8NDA5NiA7ICsrbCkge1xcblxcdFxcdGlmKGwgPj0gSyAvIDQpIGJyZWFrOyAgICAvLyBzdG9wIHdoZW4gd2UgZmluaXNoIHRoZSByb3cvY29sdW1uXFxuXFx0XFx0Ly8gbCBpcyBpbiBwaXhlbCBzcGFjZSwgc28gd2UgZGl2aWRlIGJ5IGZvdXJcXG5cXG5cXHRcXHQvLyByZXRyaWV2ZSBuZXh0IGZvdXIgZWxlbWVudHMgZnJvbSBlYWNoIHRleHR1cmVcXG5cXHRcXHR2ZWM0IGFfaWsgPSB0ZXh0dXJlMkQoICBBLCB2ZWMyKHosIHkpKTtcXG5cXHRcXHR2ZWM0IGJfa2ogPSB0ZXh0dXJlMkQoQl90LCB2ZWMyKHosIHgpKTtcXG5cXG5cXHQvLyB1c2UgYGRvdGAgdG8gcHJvY2VzcyBmb3VyIGVsZW1lbnRzIGF0IGEgdGltZVxcblxcdFxcdHN1bSArPSAgZG90KGFfaWssIGJfa2opO1xcblxcdFxcdHogKz0gKDQuMCAqIGRlbHRhX3QpOyAgICAgIC8vICh6ICsgMC41KSpkZWx0YVxcblxcdH1cXG5cXHRyZXR1cm4gc3VtO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUuIFRoZXNlIG1hcCBkaXJlY3RseSB0byBpbnB1dCB0ZXh0dXJlIHNwYWNlIHdoZW5cXG5cXHQvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcdHZlYzQgY192ID0gdGV4dHVyZTJEKEMsIHZlYzIoY29sX3QsIDAuNSkpO1xcblxcblxcdHZlYzQgc3VtX3YgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFx0ZmxvYXQgY29sID0gKGNvbF90ICogZmxvYXQoTiArIHBhZCkgLSAyLjApOyAvLyBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIChtYXRyaXggc3BhY2UpXFxuXFx0c3VtX3YuciA9IGFscGhhICogZG90X3Jvd2NvbF8xNTQwMjU5MTMwKHJvd190LCAoY29sICsgMC41KS9mbG9hdChOKSwgQSwgQl90LCBLKTtcXG5cXHQvLyBpbiB0aGUgcGFkZGluZyByZWdpb24/XFxuXFx0aWYocGFkID4gMCAmJiAoY29sICsgNC4wKSA+IGZsb2F0KE4pICkge1xcblxcdFxcdC8vIHBhZFxcblxcdFxcdGlmKHBhZCA8IDMpe1xcblxcdFxcdFxcdHN1bV92LmcgPSBhbHBoYSAqIGRvdF9yb3djb2xfMTU0MDI1OTEzMChyb3dfdCwgKGNvbCArIDEuNSkvZmxvYXQoTiksIEEsIEJfdCwgSyk7XFxuXFx0XFx0fVxcblxcdFxcdGlmKHBhZCA8IDIpe1xcblxcdFxcdFxcdHN1bV92LmIgPSBhbHBoYSAqIGRvdF9yb3djb2xfMTU0MDI1OTEzMChyb3dfdCwgKGNvbCArIDIuNSkvZmxvYXQoTiksIEEsIEJfdCwgSyk7XFxuXFx0XFx0fVxcblxcdH0gZWxzZSB7XFxuXFx0XFx0c3VtX3YuZyA9IGFscGhhICogZG90X3Jvd2NvbF8xNTQwMjU5MTMwKHJvd190LCAoY29sICsgMS41KS9mbG9hdChOKSwgQSwgQl90LCBLKTtcXG5cXHRcXHRzdW1fdi5iID0gYWxwaGEgKiBkb3Rfcm93Y29sXzE1NDAyNTkxMzAocm93X3QsIChjb2wgKyAyLjUpL2Zsb2F0KE4pLCBBLCBCX3QsIEspO1xcblxcdFxcdHN1bV92LmEgPSBhbHBoYSAqIGRvdF9yb3djb2xfMTU0MDI1OTEzMChyb3dfdCwgKGNvbCArIDMuNSkvZmxvYXQoTiksIEEsIEJfdCwgSyk7XFxuXFx0fVxcblxcblxcdGdsX0ZyYWdDb2xvciA9IHN1bV92ICsgYmV0YSpjX3Y7XFxufVxcblwiO3RoaXMuc3RhbmRhbG9uZT8odGhpcy5wcm9ncmFtXz10aGlzLndlYmdsLmNyZWF0ZVByb2dyYW0obiksdGhpcy5wcm9ncmFtX2M9dGhpcy53ZWJnbC5jcmVhdGVQcm9ncmFtKHIpKToodGhpcy5wcm9ncmFtXz10aGlzLndlYmdsLmNyZWF0ZVByb2dyYW0obyksdGhpcy5wcm9ncmFtX2M9dGhpcy53ZWJnbC5jcmVhdGVQcm9ncmFtKGkpKX10KFwiLi93ZWJnbFwiKTtlLmV4cG9ydHM9cixyLlRFWFRVUkVfVU5JRk9STV9OQU1FXzA9XCJBXCIsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8xPVwiQl90XCIsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8yPVwiQ1wiLHIuU0hBUkVEX0xFTkdUSF9VTklGT1JNX05BTUU9XCJLXCIsci5DT0xVTU5fQ09VTlRfVU5JRk9STV9OQU1FPVwiTlwiLHIuUEFEX1VOSUZPUk1fTkFNRT1cInBhZFwiLHIuQUxQSEFfVU5JRk9STV9OQU1FPVwiYWxwaGFcIixyLkJFVEFfVU5JRk9STV9OQU1FPVwiYmV0YVwiLHIucHJvdG90eXBlLmNhbGN1bGF0ZT1mdW5jdGlvbih0LGUsbixvLGksYSxzLHUsbCl7dmFyIGM9dGhpcy53ZWJnbC5jb250ZXh0O251bGwhPXU/dGhpcy5wcm9ncmFtPXRoaXMucHJvZ3JhbV9jOihzPW51bGwsdGhpcy5wcm9ncmFtPXRoaXMucHJvZ3JhbV8pLHRoaXMud2ViZ2wuc2VsZWN0UHJvZ3JhbSh0aGlzLnByb2dyYW0pLHRoaXMuYmluZElucHV0VGV4dHVyZShpLGMuVEVYVFVSRTAsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8wKSx0aGlzLmJpbmRJbnB1dFRleHR1cmUoYSxjLlRFWFRVUkUxLHIuVEVYVFVSRV9VTklGT1JNX05BTUVfMSksbnVsbCE9dSYmdGhpcy5iaW5kSW5wdXRUZXh0dXJlKHUsYy5URVhUVVJFMixyLlRFWFRVUkVfVU5JRk9STV9OQU1FXzIpO3ZhciBmPXRoaXMud2ViZ2wuZ2V0UGFkKG4pLHA9dGhpcy53ZWJnbC5nZXRQYWQoZSk7dGhpcy5iaW5kVW5pZm9ybXMoZSxuK2YscCxvLHMpLHRoaXMuc3RhbmRhbG9uZT90aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKHQsZStwLGwpOnRoaXMud2ViZ2wuYmluZE91dHB1dFRleHR1cmUodCwoZStwKS80LGwpLGMuZHJhd0VsZW1lbnRzKGMuVFJJQU5HTEVTLDYsYy5VTlNJR05FRF9TSE9SVCwwKSx0aGlzLndlYmdsLnVuYmluZElucHV0VGV4dHVyZShjLlRFWFRVUkUwKSx0aGlzLndlYmdsLnVuYmluZElucHV0VGV4dHVyZShjLlRFWFRVUkUxKSx0aGlzLndlYmdsLnVuYmluZElucHV0VGV4dHVyZShjLlRFWFRVUkUyKX0sci5wcm90b3R5cGUuYmluZElucHV0VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy53ZWJnbC5jb250ZXh0LG89dGhpcy5wcm9ncmFtO3IuYWN0aXZlVGV4dHVyZShlKSxyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KTt2YXIgaT1yLmdldFVuaWZvcm1Mb2NhdGlvbihvLG4pO3IudW5pZm9ybTFpKGksZS1yLlRFWFRVUkUwKX0sci5wcm90b3R5cGUuYmluZFVuaWZvcm1zPWZ1bmN0aW9uKHQsZSxuLG8saSl7dmFyIGE9dGhpcy53ZWJnbC5jb250ZXh0LHM9YS5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLHIuU0hBUkVEX0xFTkdUSF9VTklGT1JNX05BTUUpLHU9YS5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLHIuQUxQSEFfVU5JRk9STV9OQU1FKSxsPWEuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLkJFVEFfVU5JRk9STV9OQU1FKSxjPWEuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLkNPTFVNTl9DT1VOVF9VTklGT1JNX05BTUUpLGY9Zj1hLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5QQURfVU5JRk9STV9OQU1FKTthLnVuaWZvcm0xZihsLGkpLGEudW5pZm9ybTFpKGMsdCksYS51bmlmb3JtMWkoZixuKSxhLnVuaWZvcm0xaShzLGUpLGEudW5pZm9ybTFmKHUsbyl9fSx7XCIuL3dlYmdsXCI6MTF9XSw4OltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3RoaXMud2ViZ2w9dCx0aGlzLnN0YW5kYWxvbmU9bnVsbD09ZXx8ZTt2YXIgbj1cInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiAgICAgIG91dFRleDsgIC8vIHRleHR1cmUgY29vcmRzIG9mIHJvdy9jb2x1bW4gdG8gY2FsY3VsYXRlXFxudW5pZm9ybSBzYW1wbGVyMkQgWDsgICAgICAgLy8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgQVxcbnVuaWZvcm0gZmxvYXQgICAgIGZhY3RvcjsgIC8vIHdpZHRoIG9mIGltYWdlIHBhdGNoXFxudW5pZm9ybSBmbG9hdCAgICAgc3RyaWRlOyAgLy8gd2lkdGggYmV0d2VlbiBpbWFnZSBwYXRjaGVzXFxudW5pZm9ybSBmbG9hdCAgICAgbWFyZ2luO1xcbnVuaWZvcm0gZmxvYXQgICAgIE5fcDsgICAgIC8vIHBhdGNoZXMgYWNyb3NzXFxudW5pZm9ybSBmbG9hdCAgICAgTTtcXG51bmlmb3JtIGZsb2F0ICAgICBOO1xcbnVuaWZvcm0gZmxvYXQgICAgIHBhZDtcXG51bmlmb3JtIGZsb2F0ICAgICBNX2luO1xcbnVuaWZvcm0gZmxvYXQgICAgIE5faW47XFxudW5pZm9ybSBmbG9hdCAgICAgQzsgICAgICAgLy8gbnVtYmVyIG9mIGNoYW5uZWxzIGluIGlucHV0XFxudW5pZm9ybSBmbG9hdCAgICAgcGFkX2luO1xcblxcbi8vIHNlbGVjdCBhbiBlbGVtZW50IGZyb20gYSB2ZWN0b3IgYmFzZWQgb24gaW5kZXhcXG5mbG9hdCBzZWxlY3RfaW5kZXhfMTU0MDI1OTEzMCh2ZWM0IHYsIGludCBpbmRleCl7XFxuXFx0ZmxvYXQgdmFsO1xcblxcdGlmIChpbmRleCA9PSAwKSB7XFxuXFx0XFx0dmFsID0gdi5yO1xcblxcdH0gZWxzZSBpZihpbmRleCA9PSAxKSB7XFxuXFx0XFx0dmFsID0gdi5nO1xcblxcdH0gZWxzZSBpZihpbmRleCA9PSAyKSB7XFxuXFx0XFx0dmFsID0gdi5iO1xcblxcdH0gZWxzZSBpZihpbmRleCA9PSAzKXtcXG5cXHRcXHR2YWwgPSB2LmE7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHQvLyBzaG91bGQgbmV2ZXIgYmUgaGVyZVxcblxcdFxcdHZhbCA9IDAuMDtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHZhbDtcXG59XFxuXFxuLy8gdHJhbnNsYXRlIGEgbGluZWFyIGluZGV4IGludG8geCwgeSBjb29yZGluYXRlcyBmb3IgYSBtYXRyaXhcXG52ZWMyIGxpbmVhcl9pbmRleF9jb29yZHNfMTYwNDE1MDU1OShmbG9hdCBsaW5lYXJfaW5kZXgsIGZsb2F0IHJvd19sZW5ndGgpe1xcblxcdHZlYzIgY29vcmRzO1xcblxcblxcdGNvb3Jkcy54ID0gZmxvb3IobW9kKGxpbmVhcl9pbmRleCArIDAuNSwgcm93X2xlbmd0aCkpOyAvLyBjb2x1bW5cXG5cXHRjb29yZHMueSA9IGZsb29yKChsaW5lYXJfaW5kZXggKyAwLjUpIC8gcm93X2xlbmd0aCk7IC8vIHJvd1xcblxcblxcdHJldHVybiBjb29yZHM7XFxufVxcblxcbi8vIHNldCBwYWQgdmFsdWVzIHRvIDAuMCwgaWYgaW4gcGFkZGVkIHJlZ2lvbiBvZiBvdXRwdXQgdGV4dHVyZVxcbnZvaWQgZml4X3BhZF8xMTE3NTY5NTk5KGlub3V0IHZlYzQgdiwgaW50IHBhZCl7XFxuXFx0di5hID0gMC4wO1xcblxcdGlmKHBhZCA9PSAyKXtcXG5cXHRcXHR2LmIgPSAwLjA7XFxuXFx0fSBlbHNlIGlmKHBhZCA9PSAzKXtcXG5cXHRcXHR2LmIgPSAwLjA7XFxuXFx0XFx0di5nID0gMC4wO1xcblxcdH1cXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXG5cXHQvLyBnZXQgdGhlIGltcGxpZWQgcm93IGFuZCBjb2x1bW4gZnJvbSAueSBhbmQgLnggb2YgcGFzc2VkIChvdXRwdXQpXFxuXFx0Ly8gdGV4dHVyZSBjb29yZGluYXRlXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcblxcdC8vIHJvdyBjb3JyZXNwb25kcyB0byBwYXRjaFxcblxcdGZsb2F0IHJvdyA9IGZsb29yKHJvd190ICogTSkgKyAwLjU7XFxuXFx0Ly8gY29sdW1uIGNvcnJlc3BvbmRzIHRvIHBsYWNlbWVudCBpbiBwYXRjaFxcblxcdGZsb2F0IGNvbF8wID0gZmxvb3IoY29sX3QgKiAoTiArIHBhZCkgLSAxLjUpOyAvLyBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIG91dHB1dCBwaXhlbCAobWF0cml4IHNwYWNlKVxcblxcblxcdC8vIE5fcCA9IHBhdGNoZXMgYWNyb3NzXFxuXFx0ZmxvYXQgY29sX3BhdGNoID0gZmxvb3IobW9kKHJvdywgTl9wKSk7IC8vIGNvbHVtbiBpbmRleCBpbiBncmlkIG9mIHBhdGNoZXNcXG5cXHRmbG9hdCByb3dfcGF0Y2ggPSBmbG9vcihyb3cgLyBOX3ApOyAvLyByb3cgaW5kZXggaW4gZ3JpZCBvZiBwYXRjaGVzXFxuXFx0ZmxvYXQgY29sX2luXzAgPSAoY29sX3BhdGNoICogc3RyaWRlIC0gbWFyZ2luKSAqIEM7IC8vIGlucHV0IGNvbHVtbiBpbmRleCBvZiBsZWZ0IGVsZW1lbnQgaW4gcGF0Y2hcXG5cXHRmbG9hdCByb3dfaW5fMCA9IHJvd19wYXRjaCAqIHN0cmlkZSAtIG1hcmdpbjsgLy8gaW5wdXQgcm93IGluZGV4IG9mIHRvcCBlbGVtZW50IGluIHBhdGNoXFxuXFxuXFx0dmVjNCBwaXhlbF9pbjtcXG5cXHR2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXHR2ZWMyIGNvb3JkcyA9IGxpbmVhcl9pbmRleF9jb29yZHNfMTYwNDE1MDU1OShjb2xfMCwgZmFjdG9yICogQyk7IC8vIGNvb3JkcyBpbnNpZGUgcGF0Y2hcXG5cXHR2ZWMyIG5jb29yZHM7XFxuXFx0aW50IGNoYW5uZWxfaW4gPSBpbnQobW9kKGNvbF9pbl8wICsgY29vcmRzLngsIDQuMCkpO1xcblxcdHZlYzIgc2NhbGVfaW4gPSB2ZWMyKDEuMC8oTl9pbiArIHBhZF9pbiksIDEuMC9NX2luKTsgLy8gc2NhbGUgZnJvbSBtYXRyaXggdG8gaW5wdXQgdGV4dHVyZSBjb29yZHNcXG5cXHR2ZWMyIG9mZnNldF9pbiA9IHZlYzIoY29sX2luXzAgKyAyLjAgLSBmbG9hdChjaGFubmVsX2luKSwgcm93X2luXzAgKyAwLjUpOyAvLyBvZmZzZXQgaW50byBwYXRjaCAoYW5kIHBpeGVsKVxcblxcblxcdGNvbnN0IHZlYzIgcGl4ZWxfc2NhbGUgPSB2ZWMyKDEuMC80LjAsIDEuMCk7IC8vIHNjYWxlIGZyb20gbWF0cml4IHRvIHBpeGVsIGNvb3Jkc1xcblxcblxcdHBpeGVsX2luID0gdGV4dHVyZTJEKFgsIChjb29yZHMgKyBvZmZzZXRfaW4pICogc2NhbGVfaW4pO1xcblxcblxcdC8vIGdvIHRocm91Z2ggY2hhbm5lbHMgZm9yIGN1cnJlbnQgb3V0cHV0IHBpeGVsXFxuXFx0Zm9yKGludCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IDQ7IGNoYW5uZWwrKyl7XFxuXFxuXFx0XFx0Ly8gYXJlIHdlIG9uIGEgbmV3IGlucHV0IHBpeGVsP1xcblxcdFxcdG5jb29yZHMgPSBsaW5lYXJfaW5kZXhfY29vcmRzXzE2MDQxNTA1NTkoY29sXzAgKyBmbG9hdChjaGFubmVsKSwgZmFjdG9yICogQyk7XFxuXFxuXFx0XFx0Ly8gYXJlIHdlIGluIHRoZSBtYXJnaW4gb3Igb3V0c2lkZSB0aGUgaW5wdXQgdGV4dHVyZT9cXG5cXHRcXHRpZigoY29sX2luXzAgKyBuY29vcmRzLnggKyAwLjUgPCAwLjApIHx8IChyb3dfaW5fMCArIG5jb29yZHMueSArIDAuNSA8IDAuMCkgfHxcXG5cXHRcXHQgICAoY29sX2luXzAgKyBuY29vcmRzLnggKyAwLjUpID4gKE5faW4pIHx8IHJvd19pbl8wICsgbmNvb3Jkcy55ICsgMC41ID4gTV9pbil7XFxuXFx0XFx0XFx0Ly8geWVzLCBjcmVhdGUgYSB2aXJ0dWFsIHBpeGVsXFxuXFx0XFx0XFx0cGl4ZWxfaW4gPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0fSBlbHNlIGlmKGZsb29yKG5jb29yZHMgKiBwaXhlbF9zY2FsZSkgIT0gZmxvb3IoY29vcmRzICogcGl4ZWxfc2NhbGUpKXtcXG5cXHRcXHRcXHQvLyBubywgZ2V0IHRoZSBnZXQgdGhlIG5leHQgcmVhbCBwaXhlbFxcblxcdFxcdFxcdGNvb3JkcyA9IG5jb29yZHM7XFxuXFx0XFx0XFx0b2Zmc2V0X2luLnggKz0gZmxvYXQoY2hhbm5lbF9pbik7XFxuXFx0XFx0XFx0Y2hhbm5lbF9pbiA9IDA7XFxuXFx0XFx0XFx0cGl4ZWxfaW4gPSB0ZXh0dXJlMkQoWCwgKGNvb3JkcyArIG9mZnNldF9pbikgKiBzY2FsZV9pbik7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmKGNoYW5uZWwgPT0gMCl7XFxuXFx0XFx0XFx0cmVzdWx0LnIgPSBzZWxlY3RfaW5kZXhfMTU0MDI1OTEzMChwaXhlbF9pbiwgY2hhbm5lbF9pbik7XFxuXFx0XFx0fSBlbHNlIGlmKGNoYW5uZWwgPT0gMSl7XFxuXFx0XFx0XFx0cmVzdWx0LmcgPSBzZWxlY3RfaW5kZXhfMTU0MDI1OTEzMChwaXhlbF9pbiwgY2hhbm5lbF9pbik7XFxuXFx0XFx0fSBlbHNlIGlmKGNoYW5uZWwgPT0gMil7XFxuXFx0XFx0XFx0cmVzdWx0LmIgPSBzZWxlY3RfaW5kZXhfMTU0MDI1OTEzMChwaXhlbF9pbiwgY2hhbm5lbF9pbik7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRyZXN1bHQuYSA9IHNlbGVjdF9pbmRleF8xNTQwMjU5MTMwKHBpeGVsX2luLCBjaGFubmVsX2luKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y2hhbm5lbF9pbisrO1xcblxcdFxcdG9mZnNldF9pbi54IC09IDEuMDtcXG5cXHR9XFxuXFxuXFx0Ly8gZml4IHBhZGRlZCByZWdpb25cXG5cXHRpZihwYWQgPiAwLjAgJiYgY29sXzAgKyA0LjAgPiBOICkge1xcblxcdFxcdGZpeF9wYWRfMTExNzU2OTU5OShyZXN1bHQsIGludChwYWQpKTtcXG5cXHR9XFxuXFxuXFx0Ly9nbF9GcmFnQ29sb3IgPSB2ZWM0KHJvd19pbl8wLCBjb2xfaW5fMCwgY2hhbm5lbF9pbiwgTl9wKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSByZXN1bHQ7XFxufVxcblwiO3RoaXMuc3RhbmRhbG9uZT90aGlzLnByb2dyYW09dGhpcy53ZWJnbC5jcmVhdGVQcm9ncmFtKHMpOnRoaXMucHJvZ3JhbT10aGlzLndlYmdsLmNyZWF0ZVByb2dyYW0obil9dChcIi4vd2ViZ2xcIik7ZS5leHBvcnRzPXIsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8wPVwiWFwiLHIuU1RSSURFX1VOSUZPUk1fTkFNRT1cInN0cmlkZVwiLHIuS0VSTkVMX1dJRFRIX1VOSUZPUk1fTkFNRT1cImZhY3RvclwiLHIucHJvdG90eXBlLmNhbGN1bGF0ZT1mdW5jdGlvbih0LGUsbixvLGksYSxzLHUsbCxjLGYpe3ZhciBwPXRoaXMud2ViZ2wuY29udGV4dCxoPXRoaXMud2ViZ2wuZ2V0UGFkKGUqbiksZD10aGlzLndlYmdsLmdldFBhZChpKTt0aGlzLndlYmdsLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKSx0aGlzLmJpbmRJbnB1dFRleHR1cmUoYyxwLlRFWFRVUkUwLHIuVEVYVFVSRV9VTklGT1JNX05BTUVfMCksdGhpcy5iaW5kVW5pZm9ybXMobyxpLGQsdCxlKm4sbixoLGEscyx1LGwpLHRoaXMuc3RhbmRhbG9uZT90aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKG8saStkLGYpOnRoaXMud2ViZ2wuYmluZE91dHB1dFRleHR1cmUobywoaStkKS80LGYpLHAuZHJhd0VsZW1lbnRzKHAuVFJJQU5HTEVTLDYscC5VTlNJR05FRF9TSE9SVCwwKSx0aGlzLndlYmdsLnVuYmluZElucHV0VGV4dHVyZShwLlRFWFRVUkUwKX0sci5wcm90b3R5cGUuYmluZElucHV0VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy53ZWJnbC5jb250ZXh0LG89dGhpcy5wcm9ncmFtO3IuYWN0aXZlVGV4dHVyZShlKSxyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KTt2YXIgaT1yLmdldFVuaWZvcm1Mb2NhdGlvbihvLG4pO3IudW5pZm9ybTFpKGksZS1yLlRFWFRVUkUwKX0sci5wcm90b3R5cGUuYmluZFVuaWZvcm1zPWZ1bmN0aW9uKHQsZSxuLG8saSxhLHMsdSxsLGMsZil7dmFyIHA9dGhpcy53ZWJnbC5jb250ZXh0LGg9cC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwiTVwiKSxkPXAuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIk5cIiksdj1wLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sXCJDXCIpLG09cC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwiTV9pblwiKSxfPXAuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIk5faW5cIiksZz1wLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5TVFJJREVfVU5JRk9STV9OQU1FKSx5PXAuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLktFUk5FTF9XSURUSF9VTklGT1JNX05BTUUpLGI9cC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwicGFkXCIpLHc9cC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwicGFkX2luXCIpLHg9cC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwiTl9wXCIpO21hcmdpbl9nbD1wLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sXCJtYXJnaW5cIikscC51bmlmb3JtMWYoaCx0KSxwLnVuaWZvcm0xZihkLGUpLHAudW5pZm9ybTFmKGIsbikscC51bmlmb3JtMWYobSxvKSxwLnVuaWZvcm0xZihfLGkpLHAudW5pZm9ybTFmKHYsYSkscC51bmlmb3JtMWYodyxzKSxwLnVuaWZvcm0xZih4LHUpLHAudW5pZm9ybTFmKHksbCkscC51bmlmb3JtMWYoZyxjKSxwLnVuaWZvcm0xZihtYXJnaW5fZ2wsZil9fSx7XCIuL3dlYmdsXCI6MTF9XSw5OltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe3RoaXMud2ViZ2w9dCx0aGlzLnN0YW5kYWxvbmU9bnVsbD09ZXx8ZTt2YXIgbj1cInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiAgICAgIG91dFRleDtcXHQvLyB0ZXh0dXJlIGNvb3JkcyBvZiByb3cvY29sdW1uIHRvIGNhbGN1bGF0ZVxcbnVuaWZvcm0gc2FtcGxlcjJEIFg7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgWFxcbnVuaWZvcm0gaW50ICAgICAgIE47XFx0XFx0Ly8gbnVtYmVyIG9mIGNvbHVtbnNcXG51bmlmb3JtIGludCAgICAgICBwYWQ7XFx0XFx0Ly8gYWRkaXRpb25hbCBjb2x1bW5zIHRvIG5lYXJlc3QgbXVsdGlwbGUgb2YgZm91clxcbnVuaWZvcm0gZmxvYXQgICAgIGI7IFxcdFxcdC8vIGFkZGl0aXZlIHRlcm1cXG51bmlmb3JtIGZsb2F0ICAgICBhOyBcXHRcXHQvLyBtdWx0aXBsaWNhdGl2ZSB0ZXJtXFxuXFxuLy8gUmVuZGVyIGZsb2F0IHRvIGJ5dGVzIGFjY29yZGluZyB0byBJRUVFIDc1NCBGbG9hdGluZyBQb2ludFxcbnZlYzQgZW5jb2RlX2Zsb2F0XzE1NDAyNTkxMzAoZmxvYXQgdmFsKSB7XFxuXFxuXFx0Ly8gVE9ETzogY29ycmVjdGx5IGhhbmRsZSBkZW5vcm1hbCBudW1iZXJzXFxuXFx0Ly8gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTIvMDQvbnVtYmVyLWVuY29kaW5nLmh0bWxcXG5cXHRmbG9hdCBhID0gYWJzKHZhbCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIGFic29sdXRlIHZhbHVlICsgc2lnblxcblxcdGZsb2F0IGV4cCA9IGZsb29yKGxvZzIoYSkpOyAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHBvd2VycyBvZiAyXFxuXFx0ZmxvYXQgbWFudCA9IHBvdygyLixsb2cyKGEpLWV4cCkgKiBwb3coMi4sMjMuKTsgIC8vIG11bHRpcGx5IHRvIGZpbGwgMjQgYml0cyAoaW1wbGllZCBsZWFkaW5nIDEpXFxuXFx0ZmxvYXQgbWFudDEgPSBmbG9vcihtYW50IC8gMjU2LiAvIDI1Ni4pOyAgICAvLyBmaXJzdCA4IGJpdHMgb2YgbWFudGlzc2FcXG5cXHRmbG9hdCBtYW50MiA9IG1vZChmbG9vcihtYW50IC8gMjU2LiksMjU2Lik7IC8vIHNlY29uZCA4IGJpdHNcXG5cXHRmbG9hdCBtYW50MyA9IG1vZChtYW50LDI1Ni4pOyAgICAgICAgICAgICAgIC8vIHRoaXJkIDggYml0c1xcblxcblxcdGhpZ2hwIGZsb2F0IHNpZ24gPSAxMjguLTEyOC4qKGEvdmFsKTtcXHRcXHRcXHQvLyBzaWduIGJpdCBpcyAyNTYgb3IgMFxcblxcdGhpZ2hwIGZsb2F0IGUgPSAoc2lnbitleHArMTI3LikvNTEwLjtcXHRcXHQvLyBleHBvbmVudCBhbmQgc2lnblxcblxcdGhpZ2hwIGZsb2F0IG0xID0gKG1hbnQxLSgxMjguKigxLi1tb2QoZXhwKzEyNy4sMi4pKSkpLzI1NS47IC8vIGhhbmRsZSBsZWFkaW5nIGJpdFxcblxcdGhpZ2hwIGZsb2F0IG0yID0gKG1hbnQyKS8yNTUuO1xcdFxcdFxcdFxcdC8vIG1pZGRsZSBwYXJ0XFxuXFx0aGlnaHAgZmxvYXQgbTMgPSAobWFudDMrLjUpLzI1NS47XFx0XFx0XFx0Ly8gc2NhbGUgdG8gMCAtIDI1NVxcblxcblxcdHJldHVybiB2ZWM0KG0zLG0yLG0xLGUpO1xcbn1cXG5cXG4vLyBzZWxlY3QgYW4gZWxlbWVudCBmcm9tIGEgdmVjdG9yIGJhc2VkIG9uIGluZGV4XFxuZmxvYXQgc2VsZWN0X2luZGV4XzE2MDQxNTA1NTkodmVjNCB2LCBpbnQgaW5kZXgpe1xcblxcdGZsb2F0IHZhbDtcXG5cXHRpZiAoaW5kZXggPT0gMCkge1xcblxcdFxcdHZhbCA9IHYucjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMSkge1xcblxcdFxcdHZhbCA9IHYuZztcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMikge1xcblxcdFxcdHZhbCA9IHYuYjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMyl7XFxuXFx0XFx0dmFsID0gdi5hO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0Ly8gc2hvdWxkIG5ldmVyIGJlIGhlcmVcXG5cXHRcXHR2YWwgPSAwLjA7XFxuXFx0fVxcblxcblxcdHJldHVybiB2YWw7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0Ly8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcblxcdC8vIHRleHR1cmUgY29vcmRpbmF0ZS4gVGhlc2UgbWFwIGRpcmVjdGx5IHRvIGlucHV0IHRleHR1cmUgc3BhY2Ugd2hlblxcblxcdC8vIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGFyZSB0aGUgc2FtZS5cXG4gXFx0ZmxvYXQgcm93ID0gb3V0VGV4Lnk7XFxuXFx0ZmxvYXQgY29sID0gb3V0VGV4Lng7XFxuXFxuXFx0Ly8gZGlyZWN0IHVzYWdlIG9mIGNvbCByZXF1aXJlcyBvdXRwdXQgYmUgcGFkZGVkIGV4YWN0bHkgbGlrZSBpbnB1dFxcblxcdHZlYzQgeCA9IHRleHR1cmUyRCggWCwgdmVjMihjb2wsIHJvdykpO1xcblxcdHZlYzQgc3VtX3YgPSAoYSAqIHgpICsgYjtcXG5cXHRpbnQgY2hhbm5lbCA9IGludChtb2QoY29sICogZmxvYXQoTiArIHBhZCksIDQuMCApKTtcXG5cXHRmbG9hdCBzdW0gPSBzZWxlY3RfaW5kZXhfMTYwNDE1MDU1OShzdW1fdiwgY2hhbm5lbCk7XFxuXFxuXFx0aWYgKHN1bSA9PSAwLikge1xcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4sMC4sMC4sMC4pO1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuIFxcdC8vIG91dHB1dCB2ZWM0IHdpdGggYnl0ZXMgZm9yIGFuIElFRUU3NTQgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlclxcblxcdGdsX0ZyYWdDb2xvciA9IGVuY29kZV9mbG9hdF8xNTQwMjU5MTMwKHN1bSk7XFxufVxcblwiLHI9XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgICAgICBvdXRUZXg7XFx0Ly8gdGV4dHVyZSBjb29yZHMgb2Ygcm93L2NvbHVtbiB0byBjYWxjdWxhdGVcXG51bmlmb3JtIHNhbXBsZXIyRCBYO1xcdFxcdC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIFhcXG51bmlmb3JtIGludCAgICAgICBOO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zXFxudW5pZm9ybSBpbnQgICAgICAgcGFkO1xcdFxcdC8vIGFkZGl0aW9uYWwgY29sdW1ucyB0byBuZWFyZXN0IG11bHRpcGxlIG9mIGZvdXJcXG51bmlmb3JtIGZsb2F0ICAgICBiOyBcXHRcXHQvLyBhZGRpdGl2ZSB0ZXJtXFxudW5pZm9ybSBmbG9hdCAgICAgYTsgXFx0XFx0Ly8gbXVsdGlwbGljYXRpdmUgdGVybVxcblxcbi8vIHNldCBwYWQgdmFsdWVzIHRvIDAuMCwgaWYgaW4gcGFkZGVkIHJlZ2lvbiBvZiBvdXRwdXQgdGV4dHVyZVxcbnZvaWQgZml4X3BhZF8xNTQwMjU5MTMwKGlub3V0IHZlYzQgdiwgaW50IHBhZCl7XFxuXFx0di5hID0gMC4wO1xcblxcdGlmKHBhZCA9PSAyKXtcXG5cXHRcXHR2LmIgPSAwLjA7XFxuXFx0fSBlbHNlIGlmKHBhZCA9PSAzKXtcXG5cXHRcXHR2LmIgPSAwLjA7XFxuXFx0XFx0di5nID0gMC4wO1xcblxcdH1cXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXG5cXHQvLyBnZXQgdGhlIGltcGxpZWQgcm93IGFuZCBjb2x1bW4gZnJvbSAueSBhbmQgLnggb2YgcGFzc2VkIChvdXRwdXQpXFxuXFx0Ly8gdGV4dHVyZSBjb29yZGluYXRlLiBUaGVzZSBtYXAgZGlyZWN0bHkgdG8gaW5wdXQgdGV4dHVyZSBzcGFjZSB3aGVuXFxuXFx0Ly8gdGhlIHJlbGV2YW50IGRpbWVuc2lvbnMgYXJlIHRoZSBzYW1lLlxcblxcdGZsb2F0IHJvd190ID0gb3V0VGV4Lnk7XFxuXFx0ZmxvYXQgY29sX3QgPSBvdXRUZXgueDtcXG5cXHRmbG9hdCBjb2wgPSAoY29sX3QgKiBmbG9hdChOICsgcGFkKSAtIDIuMCk7IC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG5cXG5cXHQvLyBkaXJlY3QgdXNhZ2Ugb2YgY29sIHJlcXVpcmVzIG91dHB1dCBiZSBwYWRkZWQgZXhhY3RseSBsaWtlIGlucHV0XFxuXFx0dmVjNCB4ID0gdGV4dHVyZTJEKCBYLCB2ZWMyKGNvbF90LCByb3dfdCkpO1xcblxcdHZlYzQgc3VtX3YgPSAoYSAqIHgpICsgYjtcXG5cXG5cXHQvLyBmaXggcGFkZGVkIHJlZ2lvblxcblxcdGlmKHBhZCA+IDAgJiYgY29sICsgNC4wID4gZmxvYXQoTikgKSB7XFxuXFx0XFx0Zml4X3BhZF8xNTQwMjU5MTMwKHN1bV92LCBwYWQpO1xcblxcdH1cXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSBzdW1fdjtcXG59XFxuXCI7XG50aGlzLnN0YW5kYWxvbmU/dGhpcy5wcm9ncmFtPXRoaXMud2ViZ2wuY3JlYXRlUHJvZ3JhbShuKTp0aGlzLnByb2dyYW09dGhpcy53ZWJnbC5jcmVhdGVQcm9ncmFtKHIpfXQoXCIuL3dlYmdsXCIpO2UuZXhwb3J0cz1yLHIuVEVYVFVSRV9VTklGT1JNX05BTUVfMD1cIlhcIixyLkxFTkdUSF9VTklGT1JNX05BTUU9XCJOXCIsci5BRERfVU5JRk9STV9OQU1FPVwiYlwiLHIuTVVMX1VOSUZPUk1fTkFNRT1cImFcIixyLnByb3RvdHlwZS5jYWxjdWxhdGU9ZnVuY3Rpb24odCxlLG4sbyxpLGEpe3ZhciBzPXRoaXMud2ViZ2wuY29udGV4dCx1PXRoaXMud2ViZ2wuZ2V0UGFkKGUpO3RoaXMud2ViZ2wuc2VsZWN0UHJvZ3JhbSh0aGlzLnByb2dyYW0pLHRoaXMuYmluZElucHV0VGV4dHVyZShpLHMuVEVYVFVSRTAsci5URVhUVVJFX1VOSUZPUk1fTkFNRV8wKSx0aGlzLmJpbmRVbmlmb3JtcyhlLHUsbixvKSx0aGlzLnN0YW5kYWxvbmU/dGhpcy53ZWJnbC5iaW5kT3V0cHV0VGV4dHVyZSh0LGUrdSxhKTp0aGlzLndlYmdsLmJpbmRPdXRwdXRUZXh0dXJlKHQsKGUrdSkvNCxhKSxzLmRyYXdFbGVtZW50cyhzLlRSSUFOR0xFUyw2LHMuVU5TSUdORURfU0hPUlQsMCksdGhpcy53ZWJnbC51bmJpbmRJbnB1dFRleHR1cmUocy5URVhUVVJFMCl9LHIucHJvdG90eXBlLmJpbmRJbnB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMud2ViZ2wuY29udGV4dCxvPXRoaXMucHJvZ3JhbTtyLmFjdGl2ZVRleHR1cmUoZSksci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfMkQsdCk7dmFyIGk9ci5nZXRVbmlmb3JtTG9jYXRpb24obyxuKTtyLnVuaWZvcm0xaShpLGUtci5URVhUVVJFMCl9LHIucHJvdG90eXBlLmJpbmRVbmlmb3Jtcz1mdW5jdGlvbih0LGUsbixvKXt2YXIgaT10aGlzLndlYmdsLmNvbnRleHQsYT1pLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sci5MRU5HVEhfVU5JRk9STV9OQU1FKSxzPWkuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxyLkFERF9VTklGT1JNX05BTUUpLHU9aS5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLHIuTVVMX1VOSUZPUk1fTkFNRSksbD1pLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sXCJwYWRcIik7aS51bmlmb3JtMWkoYSx0KSxpLnVuaWZvcm0xaShsLGUpLGkudW5pZm9ybTFmKHUsbiksaS51bmlmb3JtMWYocyxvKX19LHtcIi4vd2ViZ2xcIjoxMX1dLDEwOltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUpe2lmKDIhPXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk9ubHkgVGVuc29yIG9mIG9yZGVyIHR3byAobWF0cml4KSBpcyBzdXBwb3J0ZWQgcmlnaHQgbm93LlwiKTt2YXIgbj10WzBdLHI9dFsxXTt0aGlzLnRleHR1cmU9aS5jcmVhdGVEYXRhVGV4dHVyZShuLHIsZSksdGhpcy5zaGFwZT1bbixyXSx0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ109XCJUZW5zb3JcIn12YXIgbz10KFwiLi9nbG9iYWxzXCIpLGk9by5nbDtlLmV4cG9ydHM9cixyLnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24oKXtpLmNvbnRleHQuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpLHRoaXMudGV4dHVyZT1udWxsLHRoaXMuc2hhcGU9bnVsbH0sci5wcm90b3R5cGUudHJhbnNmZXI9ZnVuY3Rpb24odCl7dmFyIGUsbixyPXRoaXMuc2hhcGVbMF0sbz10aGlzLnNoYXBlWzFdO3JldHVybiBlPWkuY3JlYXRlT3V0cHV0VGV4dHVyZShyLG8pLGkuZW5jb2RlKHIsbyx0aGlzLnRleHR1cmUsZSksbj1uZXcgRmxvYXQzMkFycmF5KGkucmVhZERhdGEocixvKSksaS5jb250ZXh0LmRlbGV0ZVRleHR1cmUoZSksdHx8dGhpcy5kZWxldGUoKSxufSxyLnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zaGFwZVswXSxvPXRoaXMuc2hhcGVbMV0sYT10WzBdLHM9dFsxXSx1PW5ldyByKHQsbnVsbCk7cmV0dXJuIGkucmVzaGFwZShuLG8sYSxzLHRoaXMudGV4dHVyZSx1LnRleHR1cmUpLGV8fHRoaXMuZGVsZXRlKCksdX0sci5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc2hhcGVbMF0sbj10aGlzLnNoYXBlWzFdLG89bmV3IHIoW24sZV0sbnVsbCk7cmV0dXJuIGkudHJhbnNwb3NlKGUsbix0aGlzLnRleHR1cmUsby50ZXh0dXJlKSx0fHx0aGlzLmRlbGV0ZSgpLG99LHIucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zaGFwZVswXSxvPXRoaXMuc2hhcGVbMV07aWYobyUyIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJyb3cgY291bnQgbXVzdCBiZSBtdWx0aXBsZSBvZiB0d28uXCIpO3ZhciBhPW5ldyByKFtuLG8vMl0sbnVsbCkscz1uZXcgcihbbixvLzJdLG51bGwpO3JldHVybiBpLnN1Ym1hdHJpeChvLG4sby8yLHQsMCx0aGlzLnRleHR1cmUsYS50ZXh0dXJlKSxpLnN1Ym1hdHJpeChvLG4sby8yLHQsMSx0aGlzLnRleHR1cmUscy50ZXh0dXJlKSxlfHx0aGlzLmRlbGV0ZSgpLFthLHNdfSxyLmNvbWJpbmU9ZnVuY3Rpb24odCxlLG4sbyl7dmFyIGE9dC5zaGFwZVswXSxzPXQuc2hhcGVbMV07aWYodC5zaGFwZVsxXSE9PWUuc2hhcGVbMV18fHQuc2hhcGVbMF0hPT1lLnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcInJvdyBhbmQgY29sdW1uIGNvdW50cyBtdXN0IGJlIGVxdWFsLlwiKTtpZihuJTQhPT0wKXRocm93IG5ldyBFcnJvcihcInN0cmlkZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgZm91clwiKTt2YXIgdT1uZXcgcihbYSwyKnNdLG51bGwpO3JldHVybiBpLmNvbWJpbmUoYSxzLG4sdC50ZXh0dXJlLGUudGV4dHVyZSx1LnRleHR1cmUpLG98fCh0LmRlbGV0ZSgpLGUuZGVsZXRlKCkpLHV9fSx7XCIuL2dsb2JhbHNcIjoyfV0sMTE6W2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlLG47aWYodD10fHx7fSxcInVuZGVmaW5lZFwiPT10eXBlb2YgdC5jYW52YXM/dGhpcy5jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTp0aGlzLmNhbnZhcz10LmNhbnZhcyxlPXtwcmVtdWx0aXBsaWVkQWxwaGE6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExfSx0aGlzLmNvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLGUpLG51bGw9PXRoaXMuY29udGV4dCl0aHJvdyBuZXcgRXJyb3IoXCJObyBzdXBwb3J0IGZvciBXZWJnbC5cIik7dHJ5e249dGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0XCIpfWNhdGNoKHQpe31udWxsPT1uPyhjb25zb2xlLmxvZyhcIk5vIHN1cHBvcnQgZm9yIE9FU190ZXh0dXJlX2Zsb2F0IGV4dGVuc2lvbiFcIiksdGhpcy5oYXNGbG9hdD0hMSk6dGhpcy5oYXNGbG9hdD0hMDt2YXIgcj10aGlzLmNvbnRleHQuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KHRoaXMuY29udGV4dC5GUkFHTUVOVF9TSEFERVIsdGhpcy5jb250ZXh0LkhJR0hfRkxPQVQpO3RoaXMuaGFzSGlnaFByZWNpc2lvbj0wIT1yLnByZWNpc2lvbix0aGlzLmhhc0hpZ2hQcmVjaXNpb24mJih0aGlzLmhpZ2hwPXIpO3ZhciBvPVwiLy8gdmVydGV4IHNoYWRlciBmb3IgYSBzaW5nbGUgcXVhZFxcbi8vIHdvcmsgaXMgcGVyZm9ybWVkIGluIHRoZSBvcGVyYXRpb24gc3BlY2lmaWMgdGV4dHVyZSBzaGFkZXJcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3M7XFxuYXR0cmlidXRlIHZlYzIgdGV4O1xcbnZhcnlpbmcgdmVjMiAgIG91dFRleDtcXG52b2lkIG1haW4odm9pZClcXG57XFxuXFx0Ly8ganVzdCBwYXNzIHRoZSBwb3NpdGlvbiBhbmQgdGV4dHVyZSBjb29yZHNcXG5cXHRnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLCAxLjApO1xcblxcdG91dFRleCA9IHRleDtcXG59XFxuXCI7dGhpcy52ZXJ0ZXhTaGFkZXI9dGhpcy5jb250ZXh0LmNyZWF0ZVNoYWRlcih0aGlzLmNvbnRleHQuVkVSVEVYX1NIQURFUiksdGhpcy5jb250ZXh0LnNoYWRlclNvdXJjZSh0aGlzLnZlcnRleFNoYWRlcixvKSx0aGlzLmNvbnRleHQuY29tcGlsZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7dmFyIGk9XCJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgICAgICBvdXRUZXg7XFx0Ly8gdGV4dHVyZSBjb29yZHMgb2Ygcm93L2NvbHVtbiB0byBjYWxjdWxhdGVcXG51bmlmb3JtIHNhbXBsZXIyRCBBO1xcdFxcdC8vIHRleHR1cmUgd2l0aCBkYXRhIGZyb20gcGFkZGVkIEFcXG51bmlmb3JtIGludCAgICAgICBOO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zIGluIG91dHB1dFxcbnVuaWZvcm0gaW50ICAgICAgIHBhZDtcXHRcXHQvL1xcblxcbi8vIFJlbmRlciBmbG9hdCB0byBieXRlcyBhY2NvcmRpbmcgdG8gSUVFRSA3NTQgRmxvYXRpbmcgUG9pbnRcXG52ZWM0IGVuY29kZV9mbG9hdF8xNTQwMjU5MTMwKGZsb2F0IHZhbCkge1xcblxcblxcdC8vIFRPRE86IGNvcnJlY3RseSBoYW5kbGUgZGVub3JtYWwgbnVtYmVyc1xcblxcdC8vIGh0dHA6Ly93d3cuMmFsaXR5LmNvbS8yMDEyLzA0L251bWJlci1lbmNvZGluZy5odG1sXFxuXFx0ZmxvYXQgYSA9IGFicyh2YWwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY29kZSBhYnNvbHV0ZSB2YWx1ZSArIHNpZ25cXG5cXHRmbG9hdCBleHAgPSBmbG9vcihsb2cyKGEpKTsgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBwb3dlcnMgb2YgMlxcblxcdGZsb2F0IG1hbnQgPSBwb3coMi4sbG9nMihhKS1leHApICogcG93KDIuLDIzLik7ICAvLyBtdWx0aXBseSB0byBmaWxsIDI0IGJpdHMgKGltcGxpZWQgbGVhZGluZyAxKVxcblxcdGZsb2F0IG1hbnQxID0gZmxvb3IobWFudCAvIDI1Ni4gLyAyNTYuKTsgICAgLy8gZmlyc3QgOCBiaXRzIG9mIG1hbnRpc3NhXFxuXFx0ZmxvYXQgbWFudDIgPSBtb2QoZmxvb3IobWFudCAvIDI1Ni4pLDI1Ni4pOyAvLyBzZWNvbmQgOCBiaXRzXFxuXFx0ZmxvYXQgbWFudDMgPSBtb2QobWFudCwyNTYuKTsgICAgICAgICAgICAgICAvLyB0aGlyZCA4IGJpdHNcXG5cXG5cXHRoaWdocCBmbG9hdCBzaWduID0gMTI4Li0xMjguKihhL3ZhbCk7XFx0XFx0XFx0Ly8gc2lnbiBiaXQgaXMgMjU2IG9yIDBcXG5cXHRoaWdocCBmbG9hdCBlID0gKHNpZ24rZXhwKzEyNy4pLzUxMC47XFx0XFx0Ly8gZXhwb25lbnQgYW5kIHNpZ25cXG5cXHRoaWdocCBmbG9hdCBtMSA9IChtYW50MS0oMTI4LiooMS4tbW9kKGV4cCsxMjcuLDIuKSkpKS8yNTUuOyAvLyBoYW5kbGUgbGVhZGluZyBiaXRcXG5cXHRoaWdocCBmbG9hdCBtMiA9IChtYW50MikvMjU1LjtcXHRcXHRcXHRcXHQvLyBtaWRkbGUgcGFydFxcblxcdGhpZ2hwIGZsb2F0IG0zID0gKG1hbnQzKy41KS8yNTUuO1xcdFxcdFxcdC8vIHNjYWxlIHRvIDAgLSAyNTVcXG5cXG5cXHRyZXR1cm4gdmVjNChtMyxtMixtMSxlKTtcXG59XFxuXFxuLy8gc2VsZWN0IGFuIGVsZW1lbnQgZnJvbSBhIHZlY3RvciBiYXNlZCBvbiBpbmRleFxcbmZsb2F0IHNlbGVjdF9pbmRleF8xNjA0MTUwNTU5KHZlYzQgdiwgaW50IGluZGV4KXtcXG5cXHRmbG9hdCB2YWw7XFxuXFx0aWYgKGluZGV4ID09IDApIHtcXG5cXHRcXHR2YWwgPSB2LnI7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDEpIHtcXG5cXHRcXHR2YWwgPSB2Lmc7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDIpIHtcXG5cXHRcXHR2YWwgPSB2LmI7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDMpe1xcblxcdFxcdHZhbCA9IHYuYTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdC8vIHNob3VsZCBuZXZlciBiZSBoZXJlXFxuXFx0XFx0dmFsID0gMC4wO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdmFsO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUuIFRoZXNlIG1hcCBkaXJlY3RseSB0byBpbnB1dCB0ZXh0dXJlIHNwYWNlIHdoZW5cXG5cXHQvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcblxcdHZlYzQgdmFsX3YgPSB0ZXh0dXJlMkQoQSwgdmVjMihjb2xfdCAqIGZsb2F0KE4pL2Zsb2F0KE4gKyBwYWQpLCByb3dfdCkpO1xcblxcdGludCBjaGFubmVsID0gaW50KG1vZChjb2xfdCAqIGZsb2F0KE4pLCA0LjAgKSk7XFxuXFx0ZmxvYXQgdmFsID0gc2VsZWN0X2luZGV4XzE2MDQxNTA1NTkodmFsX3YsIGNoYW5uZWwpO1xcblxcblxcdGlmICh2YWwgPT0gMC4pIHtcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLDAuLDAuLDAuKTtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcbiBcXHQvLyBvdXRwdXQgdmVjNCB3aXRoIGJ5dGVzIGZvciBhbiBJRUVFNzU0IDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXJcXG5cXHRnbF9GcmFnQ29sb3IgPSBlbmNvZGVfZmxvYXRfMTU0MDI1OTEzMCh2YWwpO1xcbn1cXG5cIixhPVwiXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyICAgICAgb3V0VGV4O1xcdC8vIHRleHR1cmUgY29vcmRzIG9mIHJvdy9jb2x1bW4gdG8gY2FsY3VsYXRlXFxudW5pZm9ybSBzYW1wbGVyMkQgQTtcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIHBhZGRlZCBBXFxudW5pZm9ybSBpbnQgICAgICAgTTtcXHRcXHQvLyBudW1iZXIgb2Ygcm93cyBpbiBvdXRwdXRcXG51bmlmb3JtIGludCAgICAgICBOO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zIGluIG91dHB1dFxcbnVuaWZvcm0gaW50ICAgICAgIG1wYWQ7XFx0XFx0Ly9cXG51bmlmb3JtIGludCAgICAgICBucGFkO1xcdFxcdC8vXFxuXFxuLy8gc2VsZWN0IGFuIGVsZW1lbnQgZnJvbSBhIHZlY3RvciBiYXNlZCBvbiBpbmRleFxcbmZsb2F0IHNlbGVjdF9pbmRleF8xNTQwMjU5MTMwKHZlYzQgdiwgaW50IGluZGV4KXtcXG5cXHRmbG9hdCB2YWw7XFxuXFx0aWYgKGluZGV4ID09IDApIHtcXG5cXHRcXHR2YWwgPSB2LnI7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDEpIHtcXG5cXHRcXHR2YWwgPSB2Lmc7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDIpIHtcXG5cXHRcXHR2YWwgPSB2LmI7XFxuXFx0fSBlbHNlIGlmKGluZGV4ID09IDMpe1xcblxcdFxcdHZhbCA9IHYuYTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdC8vIHNob3VsZCBuZXZlciBiZSBoZXJlXFxuXFx0XFx0dmFsID0gMC4wO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdmFsO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcblxcdC8vIGdldCB0aGUgaW1wbGllZCByb3cgYW5kIGNvbHVtbiBmcm9tIC55IGFuZCAueCBvZiBwYXNzZWQgKG91dHB1dClcXG5cXHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGUuIFRoZXNlIG1hcCBkaXJlY3RseSB0byBpbnB1dCB0ZXh0dXJlIHNwYWNlIHdoZW5cXG5cXHQvLyB0aGUgcmVsZXZhbnQgZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUuXFxuXFx0ZmxvYXQgcm93X3QgPSBvdXRUZXgueTtcXG5cXHRmbG9hdCBjb2xfdCA9IG91dFRleC54O1xcblxcdGZsb2F0IGNvbCA9IChjb2xfdCAqIGZsb2F0KE4gKyBucGFkKSAtIDIuMCk7IC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG5cXG5cXHQvLyBnZXQgcm93cyBpbiB0aGUgaW5wdXQsIGVhY2ggY29udGFpbmluZyBvbmUgZWxlbWVudCBpbiB0aGUgb3V0cHV0XFxuXFx0dmVjNCByb3dfMSA9IHRleHR1cmUyRChBLCB2ZWMyKChyb3dfdCAqIGZsb2F0KE0pKS9mbG9hdChNICsgbXBhZCksIChjb2wgKyAwLjUpL2Zsb2F0KE4pKSk7XFxuXFx0dmVjNCByb3dfMiA9IHRleHR1cmUyRChBLCB2ZWMyKChyb3dfdCAqIGZsb2F0KE0pKS9mbG9hdChNICsgbXBhZCksIChjb2wgKyAxLjUpL2Zsb2F0KE4pKSk7XFxuXFx0dmVjNCByb3dfMyA9IHRleHR1cmUyRChBLCB2ZWMyKChyb3dfdCAqIGZsb2F0KE0pKS9mbG9hdChNICsgbXBhZCksIChjb2wgKyAyLjUpL2Zsb2F0KE4pKSk7XFxuXFx0dmVjNCByb3dfNCA9IHRleHR1cmUyRChBLCB2ZWMyKChyb3dfdCAqIGZsb2F0KE0pKS9mbG9hdChNICsgbXBhZCksIChjb2wgKyAzLjUpL2Zsb2F0KE4pKSk7XFxuXFxuXFx0Ly8gcGFja2FnZSBpbnRvIG91dHB1dCB2ZWN0b3JcXG5cXHRpbnQgY2hhbm5lbCA9IGludChtb2Qocm93X3QgKiBmbG9hdChNKSwgNC4wICkpO1xcblxcblxcdHZlYzQgY29sX3YgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7IC8vIHZlYzQgcmVwcmVzZW50aW5nIGZvdXIgZWxlbWVudHMgaW4gYSBjb2x1bW4gaW4gdGhlIGlucHV0XFxuXFxuXFx0Ly8gZXh0cmFjdCByZWxldmVudCBlbGVtZW50IGZyb20gZWFjaCBpbnB1dCByb3dcXG5cXHRjb2xfdi5yID0gc2VsZWN0X2luZGV4XzE1NDAyNTkxMzAocm93XzEsIGNoYW5uZWwpO1xcblxcdGlmKG5wYWQgPiAwICYmIChjb2wgKyA0LjApID4gZmxvYXQoTikgKSB7XFxuXFx0XFx0Ly8gY29tcHV0ZSBlbGVtZW50cyBpbiBwYWRkZWQgcmVnaW9uXFxuXFx0XFx0aWYobnBhZCA8IDMpe1xcblxcdFxcdFxcdGNvbF92LmcgPSBzZWxlY3RfaW5kZXhfMTU0MDI1OTEzMChyb3dfMiwgY2hhbm5lbCk7XFxuXFx0XFx0fVxcblxcdFxcdGlmKG5wYWQgPCAyKXtcXG5cXHRcXHRcXHRjb2xfdi5iID0gc2VsZWN0X2luZGV4XzE1NDAyNTkxMzAocm93XzMsIGNoYW5uZWwpO1xcblxcdFxcdH1cXG5cXHR9IGVsc2Uge1xcblxcdFxcdGNvbF92LmcgPSBzZWxlY3RfaW5kZXhfMTU0MDI1OTEzMChyb3dfMiwgY2hhbm5lbCk7XFxuXFx0XFx0Y29sX3YuYiA9IHNlbGVjdF9pbmRleF8xNTQwMjU5MTMwKHJvd18zLCBjaGFubmVsKTtcXG5cXHRcXHRjb2xfdi5hID0gc2VsZWN0X2luZGV4XzE1NDAyNTkxMzAocm93XzQsIGNoYW5uZWwpO1xcblxcdH1cXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2xfdjtcXG59XFxuXCIscz1cIlxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiAgICAgIG91dFRleDtcXHQvLyB0ZXh0dXJlIGNvb3JkcyBvZiByb3cvY29sdW1uIHRvIGNhbGN1bGF0ZVxcbnVuaWZvcm0gc2FtcGxlcjJEIEE7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgQVxcbnVuaWZvcm0gZmxvYXQgICAgIE07XFx0XFx0Ly8gbnVtYmVyIG9mIHJvd3MgaW4gb3V0cHV0XFxudW5pZm9ybSBmbG9hdCAgICAgTjtcXHRcXHQvLyBudW1iZXIgb2YgY29sdW1ucyBpbiBvdXRwdXRcXG51bmlmb3JtIGZsb2F0ICAgICBwYWQ7XFx0XFx0Ly8gY29sdW1uIHBhZGRpbmcgaW4gb3V0cHV0XFxudW5pZm9ybSBmbG9hdCAgICAgTV9pbjtcXHRcXHQvLyBudW1iZXIgb2Ygcm93cyBpbiBpbnB1dFxcbnVuaWZvcm0gZmxvYXQgICAgIE5faW47XFx0XFx0Ly8gbnVtYmVyIG9mIGNvbHVtbnMgaW4gaW5wdXRcXG51bmlmb3JtIGZsb2F0ICAgICBwYWRfaW47XFx0Ly8gY29sdW1uIHBhZGRpbmcgaW4gaW5wdXRcXG5cXG4vKiBudW1iZXIgb2YgaW5wdXQgcGl4ZWxzXFxuICAgb3JpZ2luIGluZGV4IChjaGFubmVsKSBmb3IgZWFjaFxcbiAgIHRlcm1pbmF0aW9uIGluZGV4IChjaGFubmVsKSBmb3IgZWFjaFxcbiAgIGRlc3RpbmF0aW9uIG9yaWdpbiBpbmRleCAoY2hhbm5lbCkgZm9yIGVhY2hcXG4gKi9cXG4vLyBzZWxlY3QgYW4gZWxlbWVudCBmcm9tIGEgdmVjdG9yIGJhc2VkIG9uIGluZGV4XFxuZmxvYXQgc2VsZWN0X2luZGV4XzE1NDAyNTkxMzAodmVjNCB2LCBpbnQgaW5kZXgpe1xcblxcdGZsb2F0IHZhbDtcXG5cXHRpZiAoaW5kZXggPT0gMCkge1xcblxcdFxcdHZhbCA9IHYucjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMSkge1xcblxcdFxcdHZhbCA9IHYuZztcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMikge1xcblxcdFxcdHZhbCA9IHYuYjtcXG5cXHR9IGVsc2UgaWYoaW5kZXggPT0gMyl7XFxuXFx0XFx0dmFsID0gdi5hO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0Ly8gc2hvdWxkIG5ldmVyIGJlIGhlcmVcXG5cXHRcXHR2YWwgPSAwLjA7XFxuXFx0fVxcblxcblxcdHJldHVybiB2YWw7XFxufVxcblxcbi8vIHNldCBwYWQgdmFsdWVzIHRvIDAuMCwgaWYgaW4gcGFkZGVkIHJlZ2lvbiBvZiBvdXRwdXQgdGV4dHVyZVxcbnZvaWQgZml4X3BhZF8xNjA0MTUwNTU5KGlub3V0IHZlYzQgdiwgaW50IHBhZCl7XFxuXFx0di5hID0gMC4wO1xcblxcdGlmKHBhZCA9PSAyKXtcXG5cXHRcXHR2LmIgPSAwLjA7XFxuXFx0fSBlbHNlIGlmKHBhZCA9PSAzKXtcXG5cXHRcXHR2LmIgPSAwLjA7XFxuXFx0XFx0di5nID0gMC4wO1xcblxcdH1cXG59XFxuXFxuLy8gdHJhbnNsYXRlIGEgbGluZWFyIGluZGV4IGludG8geCwgeSBjb29yZGluYXRlcyBmb3IgYSBtYXRyaXhcXG52ZWMyIGxpbmVhcl9pbmRleF9jb29yZHNfMTExNzU2OTU5OShmbG9hdCBsaW5lYXJfaW5kZXgsIGZsb2F0IHJvd19sZW5ndGgpe1xcblxcdHZlYzIgY29vcmRzO1xcblxcblxcdGNvb3Jkcy54ID0gZmxvb3IobW9kKGxpbmVhcl9pbmRleCArIDAuNSwgcm93X2xlbmd0aCkpOyAvLyBjb2x1bW5cXG5cXHRjb29yZHMueSA9IGZsb29yKChsaW5lYXJfaW5kZXggKyAwLjUpIC8gcm93X2xlbmd0aCk7IC8vIHJvd1xcblxcblxcdHJldHVybiBjb29yZHM7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0Ly8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcblxcdC8vIHRleHR1cmUgY29vcmRpbmF0ZS4gVGhlc2UgbWFwIGRpcmVjdGx5IHRvIGlucHV0IHRleHR1cmUgc3BhY2Ugd2hlblxcblxcdC8vIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGFyZSB0aGUgc2FtZS5cXG5cXHRmbG9hdCByb3dfdCA9IG91dFRleC55O1xcblxcdGZsb2F0IGNvbF90ID0gb3V0VGV4Lng7XFxuXFxuXFx0ZmxvYXQgcm93ID0gZmxvb3Iocm93X3QgKiBNKTtcXG5cXHRmbG9hdCBjb2xfMCA9IChjb2xfdCAqIChOICsgcGFkKSAtIDIuMCk7IC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG5cXHQvL2Zsb2F0IGNvbF8wID0gZmxvb3IoY29sX3QgKiAoTiArIHBhZCkvNC4wKSo0LjA7IC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG5cXHRmbG9hdCBsaW5faW5kZXhfMCA9IHJvdyAqIE4gKyBjb2xfMDsgLy8gbGluZWFyaXplZCBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIGluIG91dHB1dFxcblxcblxcdHZlYzQgcGl4ZWxfaW4gPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFx0dmVjNCByZXN1bHQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFx0dmVjMiBjb29yZHMgPSBsaW5lYXJfaW5kZXhfY29vcmRzXzExMTc1Njk1OTkobGluX2luZGV4XzAsIE5faW4pO1xcblxcdHZlYzIgbmNvb3JkcztcXG5cXHRpbnQgY2hhbm5lbF9pbiA9IGludChtb2QoY29vcmRzLngsIDQuMCkpO1xcblxcblxcdHZlYzIgc2NhbGVfaW4gPSB2ZWMyKDEuMC8oTl9pbiArIHBhZF9pbiksIDEuMC9NX2luKTsgLy8gc2NhbGUgZnJvbSBtYXRyaXggdG8gaW5wdXQgdGV4dHVyZSBjb29yZHNcXG5cXHR2ZWMyIG9mZnNldF9pbiA9IHZlYzIoMC41LCAwLjUpOyAvLyBtb3ZlIGF3YXkgZnJvbSBlZGdlIG9mIHBpeGVsXFxuXFx0Y29uc3QgdmVjMiBwaXhlbF9zY2FsZSA9IHZlYzIoMS4wLzQuMCwgMS4wKTsgLy8gc2NhbGUgZnJvbSBtYXRyaXggdG8gcGl4ZWwgY29vcmRzXFxuXFxuXFx0cGl4ZWxfaW4gPSB0ZXh0dXJlMkQoQSwgKGNvb3JkcyArIG9mZnNldF9pbikgKiBzY2FsZV9pbik7XFxuXFxuXFx0Ly8gZ28gdGhyb3VnaCBjaGFubmVscyBmb3IgY3VycmVudCBvdXRwdXQgcGl4ZWxcXG5cXHRmb3IoaW50IGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgNDsgY2hhbm5lbCsrKXtcXG5cXG5cXHRcXHQvLyBhcmUgd2Ugb24gYSBuZXcgaW5wdXQgcGl4ZWw/XFxuXFx0XFx0bmNvb3JkcyA9IGxpbmVhcl9pbmRleF9jb29yZHNfMTExNzU2OTU5OShsaW5faW5kZXhfMCArIGZsb2F0KGNoYW5uZWwpLCBOX2luKTtcXG5cXHRcXHRpZihmbG9vcihuY29vcmRzICogcGl4ZWxfc2NhbGUpICE9IGZsb29yKGNvb3JkcyAqIHBpeGVsX3NjYWxlKSl7XFxuXFx0XFx0XFx0Y29vcmRzID0gbmNvb3JkcztcXG5cXHRcXHRcXHRwaXhlbF9pbiA9IHRleHR1cmUyRChBLCAoY29vcmRzICsgb2Zmc2V0X2luKSAqIHNjYWxlX2luKTtcXG5cXHRcXHRcXHRjaGFubmVsX2luID0gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYoY2hhbm5lbCA9PSAwKXtcXG5cXHRcXHRcXHRyZXN1bHQuciA9IHNlbGVjdF9pbmRleF8xNTQwMjU5MTMwKHBpeGVsX2luLCBjaGFubmVsX2luKTtcXG5cXHRcXHR9IGVsc2UgaWYoY2hhbm5lbCA9PSAxKXtcXG5cXHRcXHRcXHRyZXN1bHQuZyA9IHNlbGVjdF9pbmRleF8xNTQwMjU5MTMwKHBpeGVsX2luLCBjaGFubmVsX2luKTtcXG5cXHRcXHR9IGVsc2UgaWYoY2hhbm5lbCA9PSAyKXtcXG5cXHRcXHRcXHRyZXN1bHQuYiA9IHNlbGVjdF9pbmRleF8xNTQwMjU5MTMwKHBpeGVsX2luLCBjaGFubmVsX2luKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJlc3VsdC5hID0gc2VsZWN0X2luZGV4XzE1NDAyNTkxMzAocGl4ZWxfaW4sIGNoYW5uZWxfaW4pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjaGFubmVsX2luKys7XFxuXFx0fVxcblxcblxcdC8vIGFyZSB3ZSBpbiB0aGUgcGFkZGVkIChvdXRwdXQpIHJlZ2lvbj9cXG5cXHRpZihwYWQgPiAwLjAgJiYgY29sXzAgKyAzLjUgPiBOICkge1xcblxcdFxcdGZpeF9wYWRfMTYwNDE1MDU1OShyZXN1bHQsIGludChwYWQpKTtcXG5cXHR9XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gcmVzdWx0O1xcbn1cXG5cIix1PVwiXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyICAgICAgb3V0VGV4O1xcdC8vIHRleHR1cmUgY29vcmRzIG9mIHJvdy9jb2x1bW4gdG8gY2FsY3VsYXRlXFxudW5pZm9ybSBzYW1wbGVyMkQgQTtcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIHBhZGRlZCBBXFxudW5pZm9ybSBmbG9hdCAgICAgTTtcXHRcXHQvLyBudW1iZXIgb2Ygcm93cyBpbiBvdXRwdXRcXG51bmlmb3JtIGZsb2F0ICAgICBOO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zIGluIG91dHB1dFxcbnVuaWZvcm0gZmxvYXQgICAgIE1faW47XFx0XFx0Ly8gbnVtYmVyIG9mIHJvd3MgaW4gaW5wdXRcXG51bmlmb3JtIGZsb2F0ICAgICBOX2luO1xcdFxcdC8vIG51bWJlciBvZiBjb2x1bW5zIGluIGlucHV0XFxuXFxuLy8gdHJhbnNsYXRlIGEgbGluZWFyIGluZGV4IGludG8geCwgeSBjb29yZGluYXRlcyBmb3IgYSBtYXRyaXhcXG52ZWMyIGxpbmVhcl9pbmRleF9jb29yZHNfMTU0MDI1OTEzMChmbG9hdCBsaW5lYXJfaW5kZXgsIGZsb2F0IHJvd19sZW5ndGgpe1xcblxcdHZlYzIgY29vcmRzO1xcblxcblxcdGNvb3Jkcy54ID0gZmxvb3IobW9kKGxpbmVhcl9pbmRleCArIDAuNSwgcm93X2xlbmd0aCkpOyAvLyBjb2x1bW5cXG5cXHRjb29yZHMueSA9IGZsb29yKChsaW5lYXJfaW5kZXggKyAwLjUpIC8gcm93X2xlbmd0aCk7IC8vIHJvd1xcblxcblxcdHJldHVybiBjb29yZHM7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0Ly8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcblxcdC8vIHRleHR1cmUgY29vcmRpbmF0ZS4gVGhlc2UgbWFwIGRpcmVjdGx5IHRvIGlucHV0IHRleHR1cmUgc3BhY2Ugd2hlblxcblxcdC8vIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGFyZSB0aGUgc2FtZS5cXG5cXHRmbG9hdCByb3dfdCA9IG91dFRleC55O1xcblxcdGZsb2F0IGNvbF90ID0gb3V0VGV4Lng7XFxuXFxuXFx0ZmxvYXQgcm93ID0gZmxvb3Iocm93X3QgKiBNKTtcXG5cXHRmbG9hdCBjb2xfMCA9IGZsb29yKGNvbF90ICogTiAtIDEuNSk7IC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG1hdHJpeCBzcGFjZSlcXG5cXHRmbG9hdCBsaW5faW5kZXhfMCA9IHJvdyAqIE4gKyBjb2xfMDsgLy8gbGluZWFyaXplZCBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIGluIG91dHB1dFxcblxcblxcdHZlYzQgcmVzdWx0O1xcblxcdHZlYzIgY29vcmRzID0gbGluZWFyX2luZGV4X2Nvb3Jkc18xNTQwMjU5MTMwKGxpbl9pbmRleF8wLCBOX2luKTtcXG5cXG5cXHR2ZWMyIHNjYWxlX2luID0gdmVjMigxLjAvTl9pbiwgMS4wL01faW4pOyAvLyBzY2FsZSBmcm9tIG1hdHJpeCB0byBpbnB1dCB0ZXh0dXJlIGNvb3Jkc1xcblxcdHZlYzIgb2Zmc2V0X2luID0gdmVjMigwLjUsIDAuNSk7IC8vIG1vdmUgYXdheSBmcm9tIGVkZ2Ugb2YgcGl4ZWxcXG5cXG5cXHRyZXN1bHQgPSB0ZXh0dXJlMkQoQSwgKGNvb3JkcyArIG9mZnNldF9pbikgKiBzY2FsZV9pbik7XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gcmVzdWx0O1xcbn1cXG5cIixsPVwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyICAgICAgb3V0VGV4O1xcdC8vIHRleHR1cmUgY29vcmRzIG9mIHJvdy9jb2x1bW4gdG8gY2FsY3VsYXRlXFxudW5pZm9ybSBzYW1wbGVyMkQgWDtcXHRcXHQvLyB0ZXh0dXJlIHdpdGggZGF0YSBmcm9tIHBhZGRlZCBYXFxudW5pZm9ybSBmbG9hdCAgICAgTjtcXHRcXHQvLyBudW1iZXIgb2YgY29sdW1uc1xcbnVuaWZvcm0gZmxvYXQgICAgIHBhZDtcXHRcXHQvLyBhZGRpdGlvbmFsIGNvbHVtbnMgdG8gbmVhcmVzdCBtdWx0aXBsZSBvZiBmb3VyXFxudW5pZm9ybSBmbG9hdCAgICAgTl9pbjtcXHRcXHQvLyBudW1iZXIgb2YgY29sdW1ucyAoaW5wdXQpXFxudW5pZm9ybSBmbG9hdCAgICAgcGFkX2luO1xcdC8vIGFkZGl0aW9uYWwgY29sdW1ucyB0byBuZWFyZXN0IG11bHRpcGxlIG9mIGZvdXIgKGlucHV0KVxcbnVuaWZvcm0gZmxvYXQgICAgIHN0cmlkZTtcXG51bmlmb3JtIGZsb2F0ICAgICBvZmZzZXQ7ICAgLy8gemVybyBvciBvbmVcXG5cXG4vLyBzZXQgcGFkIHZhbHVlcyB0byAwLjAsIGlmIGluIHBhZGRlZCByZWdpb24gb2Ygb3V0cHV0IHRleHR1cmVcXG52b2lkIGZpeF9wYWRfMTU0MDI1OTEzMChpbm91dCB2ZWM0IHYsIGludCBwYWQpe1xcblxcdHYuYSA9IDAuMDtcXG5cXHRpZihwYWQgPT0gMil7XFxuXFx0XFx0di5iID0gMC4wO1xcblxcdH0gZWxzZSBpZihwYWQgPT0gMyl7XFxuXFx0XFx0di5iID0gMC4wO1xcblxcdFxcdHYuZyA9IDAuMDtcXG5cXHR9XFxufVxcblxcbi8qIGpvaW4gcGFydHMgb2YgdHdvIHBpeGVscyBpbnRvIG9uZSwgc2VsZWN0aW5nIGZvdXIgY29udGluZ3VvdXMgZWxlbWVudHNcXG4gIHN0YXJ0aW5nIGF0IGNoYW5uZWwuXFxuKi9cXG52b2lkIGpvaW5fcGl4ZWxzXzE2MDQxNTA1NTkoaW5vdXQgdmVjNCB4LCB2ZWM0IHgwLCB2ZWM0IHgxLCBmbG9hdCBjaGFubmVsKXtcXG5cXHRpZihjaGFubmVsID09IDEuMCl7XFxuXFx0XFx0eC5yZ2IgPSB4MC5nYmE7XFxuXFx0XFx0eC5hID0geDEucjtcXG5cXHR9IGVsc2UgaWYoY2hhbm5lbCA9PSAyLjApe1xcblxcdFxcdHgucmcgPSB4MC5iYTtcXG5cXHRcXHR4LmJhID0geDEucmc7XFxuXFx0fSBlbHNlIGlmKGNoYW5uZWwgPT0gMy4wKXtcXG5cXHRcXHR4LnIgPSB4MC5hO1xcblxcdFxcdHguZ2JhID0geDEucmdiO1xcblxcdH1cXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXG5cXHQvLyBnZXQgdGhlIGltcGxpZWQgcm93IGFuZCBjb2x1bW4gZnJvbSAueSBhbmQgLnggb2YgcGFzc2VkIChvdXRwdXQpXFxuXFx0Ly8gdGV4dHVyZSBjb29yZGluYXRlLiBUaGVzZSBtYXAgZGlyZWN0bHkgdG8gaW5wdXQgdGV4dHVyZSBzcGFjZSB3aGVuXFxuXFx0Ly8gdGhlIHJlbGV2YW50IGRpbWVuc2lvbnMgYXJlIHRoZSBzYW1lLlxcblxcdGZsb2F0IHJvd190ID0gb3V0VGV4Lnk7XFxuXFx0ZmxvYXQgY29sX3QgPSBvdXRUZXgueDtcXG5cXHRmbG9hdCBjb2wgPSBmbG9vcihjb2xfdCAqIChOICsgcGFkKSAtIDEuNSk7IC8vIGluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gcGl4ZWwgKG91dHB1dCBtYXRyaXggc3BhY2UpXFxuXFxuXFx0ZmxvYXQgc3RyaXBlID0gZmxvb3IoY29sIC8gc3RyaWRlKTtcXG5cXHRmbG9hdCBzdWJfY29sID0gZmxvb3IobW9kKGNvbCwgc3RyaWRlKSk7XFxuXFxuXFx0ZmxvYXQgY29sX2luID0gKG9mZnNldCArICgyLjAgKiBzdHJpcGUpKSAqIHN0cmlkZSArIHN1Yl9jb2w7XFxuXFxuXFx0dmVjNCB4O1xcblxcdGZsb2F0IGNoYW5uZWwgPSBtb2QoY29sX2luLCA0LjApOyAvLyBjaGFubmVsIGluIHRoZSBpbnB1dCBvZiBmaXJzdCBlbGVtZW50IGluIG91dHB1dFxcblxcblxcdC8vIGFyZSB3ZSBhdCB0aGUgYmVnZ2luaW5nIG9mIGFuIGlucHV0IHBpeGVsP1xcblxcdGlmKGNoYW5uZWwgPT0gMC4wKXtcXG5cXHRcXHQvLyB5ZXMsIHNlbGVjdCB0aGUgd2hvbGUgdGhpbmdcXG5cXHRcXHR4ID0gdGV4dHVyZTJEKCBYLCB2ZWMyKChjb2xfaW4gKyAyLjAgLSBjaGFubmVsKSAvIChOX2luICsgcGFkX2luKSAsIHJvd190KSk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHQvLyBubywgc2VsZWN0IHBhcnRzIGZyb20gdHdvIHBpeGVsc1xcblxcdFxcdHZlYzQgeDAsIHgxO1xcblxcdFxcdHgwID0gdGV4dHVyZTJEKCBYLCB2ZWMyKChjb2xfaW4gKyAyLjAgLSBjaGFubmVsKSAvIChOX2luICsgcGFkX2luKSAsIHJvd190KSk7XFxuXFx0XFx0eDEgPSB0ZXh0dXJlMkQoIFgsIHZlYzIoKGNvbF9pbiArIDYuMCAtIGNoYW5uZWwpIC8gKE5faW4gKyBwYWRfaW4pICwgcm93X3QpKTtcXG5cXG5cXHRcXHRqb2luX3BpeGVsc18xNjA0MTUwNTU5KHgsIHgwLCB4MSwgY2hhbm5lbCk7XFxuXFxuXFx0fVxcblxcblxcdC8vIGZpeCBwYWRkZWQgcmVnaW9uXFxuXFx0aWYocGFkID4gMC4wICYmIGNvbCArIDQuMCA+IE4gKSB7XFxuXFx0XFx0Zml4X3BhZF8xNTQwMjU5MTMwKHgsIGludChwYWQpKTtcXG5cXHR9XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0geDtcXG59XFxuXCIsYz1cInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiAgICAgIG91dFRleDtcXHQvLyB0ZXh0dXJlIGNvb3JkcyBvZiByb3cvY29sdW1uIHRvIGNhbGN1bGF0ZVxcbnVuaWZvcm0gc2FtcGxlcjJEIEE7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgQVxcbnVuaWZvcm0gc2FtcGxlcjJEIEI7XFx0XFx0Ly8gdGV4dHVyZSB3aXRoIGRhdGEgZnJvbSBwYWRkZWQgQlxcbnVuaWZvcm0gZmxvYXQgICAgIE5faW47XFx0XFx0Ly8gbnVtYmVyIG9mIGNvbHVtbnNcXG51bmlmb3JtIGZsb2F0ICAgICBwYWRfaW47XFx0Ly8gYWRkaXRpb25hbCBjb2x1bW5zIHRvIG5lYXJlc3QgbXVsdGlwbGUgb2YgZm91clxcbnVuaWZvcm0gZmxvYXQgICAgIHN0cmlkZTtcXG5cXG4vLyBzZXQgcGFkIHZhbHVlcyB0byAwLjAsIGlmIGluIHBhZGRlZCByZWdpb24gb2Ygb3V0cHV0IHRleHR1cmVcXG52b2lkIGZpeF9wYWRfMTU0MDI1OTEzMChpbm91dCB2ZWM0IHYsIGludCBwYWQpe1xcblxcdHYuYSA9IDAuMDtcXG5cXHRpZihwYWQgPT0gMil7XFxuXFx0XFx0di5iID0gMC4wO1xcblxcdH0gZWxzZSBpZihwYWQgPT0gMyl7XFxuXFx0XFx0di5iID0gMC4wO1xcblxcdFxcdHYuZyA9IDAuMDtcXG5cXHR9XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0Ly8gZ2V0IHRoZSBpbXBsaWVkIHJvdyBhbmQgY29sdW1uIGZyb20gLnkgYW5kIC54IG9mIHBhc3NlZCAob3V0cHV0KVxcblxcdC8vIHRleHR1cmUgY29vcmRpbmF0ZS4gVGhlc2UgbWFwIGRpcmVjdGx5IHRvIGlucHV0IHRleHR1cmUgc3BhY2Ugd2hlblxcblxcdC8vIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGFyZSB0aGUgc2FtZS5cXG5cXHRmbG9hdCByb3dfdCA9IG91dFRleC55O1xcblxcdGZsb2F0IGNvbF90ID0gb3V0VGV4Lng7XFxuXFx0ZmxvYXQgTiA9IE5faW4gKiAyLjA7XFxuXFx0ZmxvYXQgcGFkID0gbW9kKE4sIDQuMCk7XFxuXFx0ZmxvYXQgY29sID0gZmxvb3IoY29sX3QgKiAoTiArIHBhZCkgLSAxLjUpOyAvLyBpbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHBpeGVsIChvdXRwdXQgbWF0cml4IHNwYWNlKVxcblxcblxcdGZsb2F0IHN0cmlwZSA9IGZsb29yKGNvbCAvIHN0cmlkZSk7XFxuXFx0ZmxvYXQgc3ViX2NvbCA9IGZsb29yKG1vZChjb2wsIHN0cmlkZSkpO1xcblxcblxcdGZsb2F0IHRleF9zZWxlY3QgPSBtb2Qoc3RyaXBlLCAyLjApO1xcblxcdGZsb2F0IGNvbF9pbiA9IGZsb29yKHN0cmlwZSAvIDIuMCkgKiBzdHJpZGUgKyBzdWJfY29sO1xcblxcblxcdHZlYzQgeDtcXG5cXHRmbG9hdCBjaGFubmVsID0gbW9kKGNvbF9pbiwgNC4wKTsgLy8gY2hhbm5lbCBpbiB0aGUgaW5wdXQgb2YgZmlyc3QgZWxlbWVudCBpbiBvdXRwdXRcXG5cXG5cXHQvLyB3aGljaCBpbnB1dCB0ZXh0dXJlIGFyZSB3ZSBnZXR0aW5nIHRoaXMgcGl4ZWwgZnJvbT9cXG5cXHRpZih0ZXhfc2VsZWN0ID09IDAuMCl7XFxuXFx0XFx0eCA9IHRleHR1cmUyRCggQSwgdmVjMigoY29sX2luICsgMi4wKSAvIChOX2luICsgcGFkX2luKSAsIHJvd190KSk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR4ID0gdGV4dHVyZTJEKCBCLCB2ZWMyKChjb2xfaW4gKyAyLjApIC8gKE5faW4gKyBwYWRfaW4pICwgcm93X3QpKTtcXG5cXHR9XFxuXFxuXFx0Ly8gZml4IHBhZGRlZCByZWdpb25cXG5cXHRpZihwYWQgPiAwLjAgJiYgY29sICsgNC4wID4gTiApIHtcXG5cXHRcXHRmaXhfcGFkXzE1NDAyNTkxMzAoeCwgaW50KHBhZCkpO1xcblxcdH1cXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSB4O1xcbn1cXG5cIjt0aGlzLmVuY29kZV9wcm9ncmFtPXRoaXMuY3JlYXRlUHJvZ3JhbShpKSx0aGlzLnRyYW5zcG9zZV9wcm9ncmFtPXRoaXMuY3JlYXRlUHJvZ3JhbShhKSx0aGlzLnJlc2hhcGVfcHJvZ3JhbT10aGlzLmNyZWF0ZVByb2dyYW0ocyksdGhpcy5yZXNoYXBlX3NpbXBsZV9wcm9ncmFtPXRoaXMuY3JlYXRlUHJvZ3JhbSh1KSx0aGlzLnN1Ym1hdHJpeF9wcm9ncmFtPXRoaXMuY3JlYXRlUHJvZ3JhbShsKSx0aGlzLmNvbWJpbmVfcHJvZ3JhbT10aGlzLmNyZWF0ZVByb2dyYW0oYyl9ZS5leHBvcnRzPXIsci5DT01QT05FTlRTX1BFUl9URVhFTD00LHIuUE9TSVRJT05fVU5JRk9STV9OQU1FPVwicG9zXCIsci5URVhUVVJFX1VOSUZPUk1fTkFNRT1cInRleFwiLHIucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnByb2dyYW09dGhpcy5lbmNvZGVfcHJvZ3JhbSx0aGlzLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKTt2YXIgbz10aGlzLmdldFBhZChlKSxpPXRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwiTlwiKSxhPXRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwicGFkXCIpO3RoaXMuY29udGV4dC51bmlmb3JtMWkoaSxlKSx0aGlzLmNvbnRleHQudW5pZm9ybTFpKGEsbyksdGhpcy5iaW5kSW5wdXRUZXh0dXJlKG4sdGhpcy5jb250ZXh0LlRFWFRVUkUwLFwiQVwiKSx0aGlzLmJpbmRPdXRwdXRUZXh0dXJlKHQsZSxyKSx0aGlzLmNvbnRleHQuZHJhd0VsZW1lbnRzKHRoaXMuY29udGV4dC5UUklBTkdMRVMsNix0aGlzLmNvbnRleHQuVU5TSUdORURfU0hPUlQsMCksdGhpcy51bmJpbmRJbnB1dFRleHR1cmUodGhpcy5jb250ZXh0LlRFWFRVUkUwKX0sci5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMucHJvZ3JhbT10aGlzLnRyYW5zcG9zZV9wcm9ncmFtLHRoaXMuc2VsZWN0UHJvZ3JhbSh0aGlzLnByb2dyYW0pO3ZhciBvPXRoaXMuZ2V0UGFkKGUpLGk9dGhpcy5nZXRQYWQodCksYT10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIk5cIikscz10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIm5wYWRcIiksdT10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIk1cIiksbD10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIm1wYWRcIik7dGhpcy5jb250ZXh0LnVuaWZvcm0xaShhLHQpLHRoaXMuY29udGV4dC51bmlmb3JtMWkocyxpKSx0aGlzLmNvbnRleHQudW5pZm9ybTFpKHUsZSksdGhpcy5jb250ZXh0LnVuaWZvcm0xaShsLG8pLHRoaXMuYmluZElucHV0VGV4dHVyZShuLHRoaXMuY29udGV4dC5URVhUVVJFMCxcIkFcIiksdGhpcy5iaW5kT3V0cHV0VGV4dHVyZShlLCh0K2kpLzQsciksdGhpcy5jb250ZXh0LmRyYXdFbGVtZW50cyh0aGlzLmNvbnRleHQuVFJJQU5HTEVTLDYsdGhpcy5jb250ZXh0LlVOU0lHTkVEX1NIT1JULDApLHRoaXMudW5iaW5kSW5wdXRUZXh0dXJlKHRoaXMuY29udGV4dC5URVhUVVJFMCl9LHIucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlLG4scixvLGkpe3ZhciBhPXRoaXMuZ2V0UGFkKGUpLHM9dGhpcy5nZXRQYWQocik7MD09YSYmMD09cz90aGlzLnByb2dyYW09dGhpcy5yZXNoYXBlX3NpbXBsZV9wcm9ncmFtOih0aGlzLnByb2dyYW09dGhpcy5yZXNoYXBlX3Byb2dyYW0sY29uc29sZS5sb2coXCIjIFdBUk5JTkc6IHVzaW5nIHNsb3cgcmVzaGFwZSBzaGFkZXIuXCIpKSx0aGlzLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKTt2YXIgdT10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIk1cIiksbD10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIk5cIiksYz10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcInBhZFwiKSxmPXRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwiTV9pblwiKSxwPXRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwiTl9pblwiKSxoPXRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwicGFkX2luXCIpO3RoaXMuY29udGV4dC51bmlmb3JtMWYodSxuKSx0aGlzLmNvbnRleHQudW5pZm9ybTFmKGwsciksdGhpcy5jb250ZXh0LnVuaWZvcm0xZihjLHMpLHRoaXMuY29udGV4dC51bmlmb3JtMWYoZix0KSx0aGlzLmNvbnRleHQudW5pZm9ybTFmKHAsZSksdGhpcy5jb250ZXh0LnVuaWZvcm0xZihoLGEpLHRoaXMuYmluZElucHV0VGV4dHVyZShvLHRoaXMuY29udGV4dC5URVhUVVJFMCxcIkFcIiksdGhpcy5iaW5kT3V0cHV0VGV4dHVyZShuLChyK3MpLzQsaSksdGhpcy5jb250ZXh0LmRyYXdFbGVtZW50cyh0aGlzLmNvbnRleHQuVFJJQU5HTEVTLDYsdGhpcy5jb250ZXh0LlVOU0lHTkVEX1NIT1JULDApLHRoaXMudW5iaW5kSW5wdXRUZXh0dXJlKHRoaXMuY29udGV4dC5URVhUVVJFMCl9LHIucHJvdG90eXBlLnN1Ym1hdHJpeD1mdW5jdGlvbih0LGUsbixyLG8saSxhKXt0aGlzLnByb2dyYW09dGhpcy5zdWJtYXRyaXhfcHJvZ3JhbSx0aGlzLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKTt2YXIgcz10aGlzLmdldFBhZCh0KSx1PXRoaXMuZ2V0UGFkKG4pLGw9dGhpcy5jb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sXCJOXCIpLGM9dGhpcy5jb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sXCJwYWRcIiksZj10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcIk5faW5cIikscD10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcInBhZF9pblwiKSxoPXRoaXMuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLFwib2Zmc2V0XCIpO3N0cmlkZV9nbD10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcInN0cmlkZVwiKSx0aGlzLmNvbnRleHQudW5pZm9ybTFmKGwsbiksdGhpcy5jb250ZXh0LnVuaWZvcm0xZihjLHUpLHRoaXMuY29udGV4dC51bmlmb3JtMWYoZix0KSx0aGlzLmNvbnRleHQudW5pZm9ybTFmKHAscyksdGhpcy5jb250ZXh0LnVuaWZvcm0xZihzdHJpZGVfZ2wsciksdGhpcy5jb250ZXh0LnVuaWZvcm0xZihoLG8pLHRoaXMuYmluZElucHV0VGV4dHVyZShpLHRoaXMuY29udGV4dC5URVhUVVJFMCxcIlhcIiksdGhpcy5iaW5kT3V0cHV0VGV4dHVyZShlLChuK3UpLzQsYSksdGhpcy5jb250ZXh0LmRyYXdFbGVtZW50cyh0aGlzLmNvbnRleHQuVFJJQU5HTEVTLDYsdGhpcy5jb250ZXh0LlVOU0lHTkVEX1NIT1JULDApLHRoaXMudW5iaW5kSW5wdXRUZXh0dXJlKHRoaXMuY29udGV4dC5URVhUVVJFMCl9LHIucHJvdG90eXBlLmNvbWJpbmU9ZnVuY3Rpb24odCxlLG4scixvLGkpe3RoaXMucHJvZ3JhbT10aGlzLmNvbWJpbmVfcHJvZ3JhbSx0aGlzLnNlbGVjdFByb2dyYW0odGhpcy5wcm9ncmFtKTt2YXIgYT0yKmUscz10aGlzLmdldFBhZChlKSx1PXRoaXMuZ2V0UGFkKGEpLGw9dGhpcy5jb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sXCJOX2luXCIpLGM9dGhpcy5jb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sXCJwYWRfaW5cIiksZj10aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcInN0cmlkZVwiKTt0aGlzLmNvbnRleHQudW5pZm9ybTFmKGwsZSksdGhpcy5jb250ZXh0LnVuaWZvcm0xZihjLHMpLHRoaXMuY29udGV4dC51bmlmb3JtMWYoZixuKSx0aGlzLmJpbmRJbnB1dFRleHR1cmUocix0aGlzLmNvbnRleHQuVEVYVFVSRTAsXCJBXCIpLHRoaXMuYmluZElucHV0VGV4dHVyZShvLHRoaXMuY29udGV4dC5URVhUVVJFMSxcIkJcIiksdGhpcy5iaW5kT3V0cHV0VGV4dHVyZSh0LChhK3UpLzQsaSksdGhpcy5jb250ZXh0LmRyYXdFbGVtZW50cyh0aGlzLmNvbnRleHQuVFJJQU5HTEVTLDYsdGhpcy5jb250ZXh0LlVOU0lHTkVEX1NIT1JULDApLHRoaXMudW5iaW5kSW5wdXRUZXh0dXJlKHRoaXMuY29udGV4dC5URVhUVVJFMCl9LHIucHJvdG90eXBlLmJpbmRJbnB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMuY29udGV4dCxvPXRoaXMucHJvZ3JhbTtyLmFjdGl2ZVRleHR1cmUoZSksci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfMkQsdCk7dmFyIGk9ci5nZXRVbmlmb3JtTG9jYXRpb24obyxuKTtyLnVuaWZvcm0xaShpLGUtci5URVhUVVJFMCl9LHIucHJvdG90eXBlLmNyZWF0ZVByb2dyYW09ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLmNvbnRleHQ7aWYoZT1uLmNyZWF0ZVNoYWRlcihuLkZSQUdNRU5UX1NIQURFUiksbi5zaGFkZXJTb3VyY2UoZSx0KSxuLmNvbXBpbGVTaGFkZXIoZSksMD09bi5nZXRTaGFkZXJQYXJhbWV0ZXIoZSxuLkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBuZXcgRXJyb3Iobi5nZXRTaGFkZXJJbmZvTG9nKGUpKTt2YXIgcj1uLmNyZWF0ZVByb2dyYW0oKTtyZXR1cm4gbi5hdHRhY2hTaGFkZXIocix0aGlzLnZlcnRleFNoYWRlciksbi5hdHRhY2hTaGFkZXIocixlKSxuLmxpbmtQcm9ncmFtKHIpLHJ9LHIucHJvdG90eXBlLnNlbGVjdFByb2dyYW09ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb250ZXh0O2UudXNlUHJvZ3JhbSh0KSx0aGlzLmJpbmRWZXJ0aWNlcyh0KX0sci5wcm90b3R5cGUuYmluZFZlcnRpY2VzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29udGV4dCxuPXQsbz1lLmdldEF0dHJpYkxvY2F0aW9uKG4sci5QT1NJVElPTl9VTklGT1JNX05BTUUpLGk9ZS5jcmVhdGVCdWZmZXIoKTtlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsaSk7dmFyIGE9Wy0xLC0xLDAsMSwtMSwwLDEsMSwwLC0xLDEsMF07ZS5idWZmZXJEYXRhKGUuQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkoYSksZS5TVEFUSUNfRFJBVyksZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKG8sMyxlLkZMT0FULCExLDAsMCksZS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShvKTt2YXIgcz1lLmdldEF0dHJpYkxvY2F0aW9uKG4sci5URVhUVVJFX1VOSUZPUk1fTkFNRSksdT1lLmNyZWF0ZUJ1ZmZlcigpO2UuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUix1KTt2YXIgbD1bMCwwLDEsMCwxLDEsMCwxXTtlLmJ1ZmZlckRhdGEoZS5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShsKSxlLlNUQVRJQ19EUkFXKSxlLnZlcnRleEF0dHJpYlBvaW50ZXIocywyLGUuRkxPQVQsITEsMCwwKSxlLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHMpO3ZhciBjPWUuY3JlYXRlQnVmZmVyKCk7ZS5iaW5kQnVmZmVyKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsYyk7dmFyIGY9WzAsMSwyLDAsMiwzXTtlLmJ1ZmZlckRhdGEoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixuZXcgVWludDE2QXJyYXkoZiksZS5TVEFUSUNfRFJBVyl9LHIucHJvdG90eXBlLmNyZWF0ZURhdGFUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgbz10aGlzLmNvbnRleHQsaT1bMCwwLDAsMF0sYT1lJXIuQ09NUE9ORU5UU19QRVJfVEVYRUwscz0wPT1hPzA6ci5DT01QT05FTlRTX1BFUl9URVhFTC1hLHU9by5jcmVhdGVUZXh0dXJlKCk7aWYoby5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsdSksMD09c3x8bnVsbD09bnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIG4pby50ZXhJbWFnZTJEKG8uVEVYVFVSRV8yRCwwLG8uUkdCQSwoZStzKS9yLkNPTVBPTkVOVFNfUEVSX1RFWEVMLHQsMCxvLlJHQkEsby5GTE9BVCxuKTtlbHNle28udGV4SW1hZ2UyRChvLlRFWFRVUkVfMkQsMCxvLlJHQkEsKGUrcykvci5DT01QT05FTlRTX1BFUl9URVhFTCx0LDAsby5SR0JBLG8uRkxPQVQsbnVsbCk7Zm9yKHZhciBsLGMsZj1lLWEscD1mL3IuQ09NUE9ORU5UU19QRVJfVEVYRUwsaD0wLGQ9bmV3IEZsb2F0MzJBcnJheShpKSx2PTA7dD52O3YrKyloPXYqZSxmdWxsX3RleGVsX3Jvd19lbmQ9aCtmLGw9bmV3IEZsb2F0MzJBcnJheShuLmJ1ZmZlcixoKm4uQllURVNfUEVSX0VMRU1FTlQsZiksZj4wJiZvLnRleFN1YkltYWdlMkQoby5URVhUVVJFXzJELDAsMCx2LHAsMSxvLlJHQkEsby5GTE9BVCxsKSxjPW5ldyBGbG9hdDMyQXJyYXkobi5idWZmZXIsZnVsbF90ZXhlbF9yb3dfZW5kKm4uQllURVNfUEVSX0VMRU1FTlQsYSksZC5zZXQoYyksby50ZXhTdWJJbWFnZTJEKG8uVEVYVFVSRV8yRCwwLHAsdiwxLDEsby5SR0JBLG8uRkxPQVQsZCl9cmV0dXJuIG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsby5URVhUVVJFX1dSQVBfUyxvLkNMQU1QX1RPX0VER0UpLG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsby5URVhUVVJFX1dSQVBfVCxvLkNMQU1QX1RPX0VER0UpLG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsby5URVhUVVJFX01BR19GSUxURVIsby5ORUFSRVNUKSxvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELG8uVEVYVFVSRV9NSU5fRklMVEVSLG8uTkVBUkVTVCksby5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsbnVsbCksdX0sci5wcm90b3R5cGUuY3JlYXRlT3V0cHV0VGV4dHVyZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY29udGV4dCxyPXRoaXMuZ2V0UGFkKGUpLG89bi5jcmVhdGVUZXh0dXJlKCk7cmV0dXJuIG4uYmluZFRleHR1cmUobi5URVhUVVJFXzJELG8pLG4udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxuLlJHQkEsZStyLHQsMCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLG51bGwpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfUyxuLkNMQU1QX1RPX0VER0UpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfVCxuLkNMQU1QX1RPX0VER0UpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX01BR19GSUxURVIsbi5ORUFSRVNUKSxuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9NSU5fRklMVEVSLG4uTkVBUkVTVCksbi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsbnVsbCksb30sci5wcm90b3R5cGUuYmluZE91dHB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMuY29udGV4dDtpZih0aGlzLmNhbnZhcy5oZWlnaHQ9dCx0aGlzLmNhbnZhcy53aWR0aD1lLHIudmlld3BvcnQoMCwwLGUsdCksdGhpcy5mcmFtZWJ1ZmZlcj10aGlzLmZyYW1lYnVmZmVyfHxyLmNyZWF0ZUZyYW1lYnVmZmVyKCksci5iaW5kRnJhbWVidWZmZXIoci5GUkFNRUJVRkZFUix0aGlzLmZyYW1lYnVmZmVyKSxyLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHIuRlJBTUVCVUZGRVIsci5DT0xPUl9BVFRBQ0hNRU5UMCxyLlRFWFRVUkVfMkQsbiwwKSxyLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoci5GUkFNRUJVRkZFUikhPXIuRlJBTUVCVUZGRVJfQ09NUExFVEUpdGhyb3cgbmV3IEVycm9yKFwiQm91bmQgZnJhbWVidWZmZXIgaXMgbm90IGNvbXBsZXRlLlwiKTtyZXR1cm4gdGhpcy5mcmFtZWJ1ZmZlcn0sci5wcm90b3R5cGUudW5iaW5kSW5wdXRUZXh0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29udGV4dDtlLmFjdGl2ZVRleHR1cmUodCksZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCl9LHIucHJvdG90eXBlLnJlYWREYXRhPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5jb250ZXh0O3JldHVybiByYXdidWZmZXI9bmV3IEFycmF5QnVmZmVyKHQqZSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLHByb2Q9bmV3IFVpbnQ4QXJyYXkocmF3YnVmZmVyKSxuLnJlYWRQaXhlbHMoMCwwLGUsdCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLHByb2QpLHJhd2J1ZmZlcn0sci5wcm90b3R5cGUuZ2V0UGFkPWZ1bmN0aW9uKHQpe3ZhciBlPXQlci5DT01QT05FTlRTX1BFUl9URVhFTCxuPTA9PWU/MDpyLkNPTVBPTkVOVFNfUEVSX1RFWEVMLWU7cmV0dXJuIG59fSx7fV19LHt9LFsxXSkoMSl9KX0sZnVuY3Rpb24odCxlLG4pe24oMTk1KSx0LmV4cG9ydHM9bigxOTQpfV0pfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIva2VyYXMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ../~/cwise-compiler/compiler.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar createThunk = __webpack_require__(/*! ./lib/thunk.js */ 9)\r\n\r\nfunction Procedure() {\r\n  this.argTypes = []\r\n  this.shimArgs = []\r\n  this.arrayArgs = []\r\n  this.arrayBlockIndices = []\r\n  this.scalarArgs = []\r\n  this.offsetArgs = []\r\n  this.offsetArgIndex = []\r\n  this.indexArgs = []\r\n  this.shapeArgs = []\r\n  this.funcName = \"\"\r\n  this.pre = null\r\n  this.body = null\r\n  this.post = null\r\n  this.debug = false\r\n}\r\n\r\nfunction compileCwise(user_args) {\r\n  //Create procedure\r\n  var proc = new Procedure()\r\n  \r\n  //Parse blocks\r\n  proc.pre    = user_args.pre\r\n  proc.body   = user_args.body\r\n  proc.post   = user_args.post\r\n\r\n  //Parse arguments\r\n  var proc_args = user_args.args.slice(0)\r\n  proc.argTypes = proc_args\r\n  for(var i=0; i<proc_args.length; ++i) {\r\n    var arg_type = proc_args[i]\r\n    if(arg_type === \"array\" || (typeof arg_type === \"object\" && arg_type.blockIndices)) {\r\n      proc.argTypes[i] = \"array\"\r\n      proc.arrayArgs.push(i)\r\n      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)\r\n      proc.shimArgs.push(\"array\" + i)\r\n      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {\r\n        throw new Error(\"cwise: pre() block may not reference array args\")\r\n      }\r\n      if(i < proc.post.args.length && proc.post.args[i].count>0) {\r\n        throw new Error(\"cwise: post() block may not reference array args\")\r\n      }\r\n    } else if(arg_type === \"scalar\") {\r\n      proc.scalarArgs.push(i)\r\n      proc.shimArgs.push(\"scalar\" + i)\r\n    } else if(arg_type === \"index\") {\r\n      proc.indexArgs.push(i)\r\n      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {\r\n        throw new Error(\"cwise: pre() block may not reference array index\")\r\n      }\r\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\r\n        throw new Error(\"cwise: body() block may not write to array index\")\r\n      }\r\n      if(i < proc.post.args.length && proc.post.args[i].count > 0) {\r\n        throw new Error(\"cwise: post() block may not reference array index\")\r\n      }\r\n    } else if(arg_type === \"shape\") {\r\n      proc.shapeArgs.push(i)\r\n      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {\r\n        throw new Error(\"cwise: pre() block may not write to array shape\")\r\n      }\r\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\r\n        throw new Error(\"cwise: body() block may not write to array shape\")\r\n      }\r\n      if(i < proc.post.args.length && proc.post.args[i].lvalue) {\r\n        throw new Error(\"cwise: post() block may not write to array shape\")\r\n      }\r\n    } else if(typeof arg_type === \"object\" && arg_type.offset) {\r\n      proc.argTypes[i] = \"offset\"\r\n      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })\r\n      proc.offsetArgIndex.push(i)\r\n    } else {\r\n      throw new Error(\"cwise: Unknown argument type \" + proc_args[i])\r\n    }\r\n  }\r\n  \r\n  //Make sure at least one array argument was specified\r\n  if(proc.arrayArgs.length <= 0) {\r\n    throw new Error(\"cwise: No array arguments specified\")\r\n  }\r\n  \r\n  //Make sure arguments are correct\r\n  if(proc.pre.args.length > proc_args.length) {\r\n    throw new Error(\"cwise: Too many arguments in pre() block\")\r\n  }\r\n  if(proc.body.args.length > proc_args.length) {\r\n    throw new Error(\"cwise: Too many arguments in body() block\")\r\n  }\r\n  if(proc.post.args.length > proc_args.length) {\r\n    throw new Error(\"cwise: Too many arguments in post() block\")\r\n  }\r\n\r\n  //Check debug flag\r\n  proc.debug = !!user_args.printCode || !!user_args.debug\r\n  \r\n  //Retrieve name\r\n  proc.funcName = user_args.funcName || \"cwise\"\r\n  \r\n  //Read in block size\r\n  proc.blockSize = user_args.blockSize || 64\r\n\r\n  return createThunk(proc)\r\n}\r\n\r\nmodule.exports = compileCwise\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L2N3aXNlLWNvbXBpbGVyL2NvbXBpbGVyLmpzPzljMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcclxuXHJcbnZhciBjcmVhdGVUaHVuayA9IHJlcXVpcmUoXCIuL2xpYi90aHVuay5qc1wiKVxyXG5cclxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xyXG4gIHRoaXMuYXJnVHlwZXMgPSBbXVxyXG4gIHRoaXMuc2hpbUFyZ3MgPSBbXVxyXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cclxuICB0aGlzLmFycmF5QmxvY2tJbmRpY2VzID0gW11cclxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxyXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXHJcbiAgdGhpcy5vZmZzZXRBcmdJbmRleCA9IFtdXHJcbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxyXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cclxuICB0aGlzLmZ1bmNOYW1lID0gXCJcIlxyXG4gIHRoaXMucHJlID0gbnVsbFxyXG4gIHRoaXMuYm9keSA9IG51bGxcclxuICB0aGlzLnBvc3QgPSBudWxsXHJcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcclxuICAvL0NyZWF0ZSBwcm9jZWR1cmVcclxuICB2YXIgcHJvYyA9IG5ldyBQcm9jZWR1cmUoKVxyXG4gIFxyXG4gIC8vUGFyc2UgYmxvY2tzXHJcbiAgcHJvYy5wcmUgICAgPSB1c2VyX2FyZ3MucHJlXHJcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxyXG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcclxuXHJcbiAgLy9QYXJzZSBhcmd1bWVudHNcclxuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcclxuICBwcm9jLmFyZ1R5cGVzID0gcHJvY19hcmdzXHJcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cclxuICAgIGlmKGFyZ190eXBlID09PSBcImFycmF5XCIgfHwgKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5ibG9ja0luZGljZXMpKSB7XHJcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcImFycmF5XCJcclxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxyXG4gICAgICBwcm9jLmFycmF5QmxvY2tJbmRpY2VzLnB1c2goYXJnX3R5cGUuYmxvY2tJbmRpY2VzID8gYXJnX3R5cGUuYmxvY2tJbmRpY2VzIDogMClcclxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXHJcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgYXJnc1wiKVxyXG4gICAgICB9XHJcbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgYXJnc1wiKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcclxuICAgICAgcHJvYy5zY2FsYXJBcmdzLnB1c2goaSlcclxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxyXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcclxuICAgICAgcHJvYy5pbmRleEFyZ3MucHVzaChpKVxyXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcclxuICAgICAgfVxyXG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxyXG4gICAgICB9XHJcbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xyXG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXHJcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmx2YWx1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXHJcbiAgICAgIH1cclxuICAgICAgaWYoaSA8IHByb2MuYm9keS5hcmdzLmxlbmd0aCAmJiBwcm9jLmJvZHkuYXJnc1tpXS5sdmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcclxuICAgICAgfVxyXG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmx2YWx1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYodHlwZW9mIGFyZ190eXBlID09PSBcIm9iamVjdFwiICYmIGFyZ190eXBlLm9mZnNldCkge1xyXG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxyXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxyXG4gICAgICBwcm9jLm9mZnNldEFyZ0luZGV4LnB1c2goaSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vTWFrZSBzdXJlIGF0IGxlYXN0IG9uZSBhcnJheSBhcmd1bWVudCB3YXMgc3BlY2lmaWVkXHJcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXHJcbiAgfVxyXG4gIFxyXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxyXG4gIGlmKHByb2MucHJlLmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxyXG4gIH1cclxuICBpZihwcm9jLmJvZHkuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxyXG4gIH1cclxuICBpZihwcm9jLnBvc3QuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxyXG4gIH1cclxuXHJcbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXHJcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xyXG4gIFxyXG4gIC8vUmV0cmlldmUgbmFtZVxyXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXHJcbiAgXHJcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcclxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcclxuXHJcbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ../~/cwise-compiler/lib/compile.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar uniq = __webpack_require__(/*! uniq */ 13)\r\n\r\n// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)\r\n// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of \"pointers\" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.\r\nfunction innerFill(order, proc, body) {\r\n  var dimension = order.length\r\n    , nargs = proc.arrayArgs.length\r\n    , has_index = proc.indexArgs.length>0\r\n    , code = []\r\n    , vars = []\r\n    , idx=0, pidx=0, i, j\r\n  for(i=0; i<dimension; ++i) { // Iteration variables\r\n    vars.push([\"i\",i,\"=0\"].join(\"\"))\r\n  }\r\n  //Compute scan deltas\r\n  for(j=0; j<nargs; ++j) {\r\n    for(i=0; i<dimension; ++i) {\r\n      pidx = idx\r\n      idx = order[i]\r\n      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride\r\n        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"p\",idx].join(\"\"))\r\n      } else { // For other dimensions the delta is basically the stride minus something which essentially \"rewinds\" the previous (more inner) dimension\r\n        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"p\",idx,\"-s\",pidx,\"*t\",j,\"p\",pidx,\")\"].join(\"\"))\r\n      }\r\n    }\r\n  }\r\n  code.push(\"var \" + vars.join(\",\"))\r\n  //Scan loop\r\n  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards\r\n    idx = order[i]\r\n    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"))\r\n  }\r\n  //Push body of inner loop\r\n  code.push(body)\r\n  //Advance scan pointers\r\n  for(i=0; i<dimension; ++i) {\r\n    pidx = idx\r\n    idx = order[i]\r\n    for(j=0; j<nargs; ++j) {\r\n      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"))\r\n    }\r\n    if(has_index) {\r\n      if(i > 0) {\r\n        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"))\r\n      }\r\n      code.push([\"++index[\",idx,\"]\"].join(\"\"))\r\n    }\r\n    code.push(\"}\")\r\n  }\r\n  return code.join(\"\\n\")\r\n}\r\n\r\n// Generate \"outer\" loops that loop over blocks of data, applying \"inner\" loops to the blocks by manipulating the local variables in such a way that the inner loop only \"sees\" the current block.\r\n// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.\r\n//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and \"shape\" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.\r\nfunction outerFill(matched, order, proc, body) {\r\n  var dimension = order.length\r\n    , nargs = proc.arrayArgs.length\r\n    , blockSize = proc.blockSize\r\n    , has_index = proc.indexArgs.length > 0\r\n    , code = []\r\n  for(var i=0; i<nargs; ++i) {\r\n    code.push([\"var offset\",i,\"=p\",i].join(\"\"))\r\n  }\r\n  //Generate loops for unmatched dimensions\r\n  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)\r\n  // TODO: It would be nice if the order in which these loops are placed would also be somehow \"optimal\" (at the very least we should check that it really doesn't hurt us if they're not).\r\n  for(var i=matched; i<dimension; ++i) {\r\n    code.push([\"for(var j\"+i+\"=SS[\", order[i], \"]|0;j\", i, \">0;){\"].join(\"\")) // Iterate back to front\r\n    code.push([\"if(j\",i,\"<\",blockSize,\"){\"].join(\"\")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).\r\n    code.push([\"s\",order[i],\"=j\",i].join(\"\"))\r\n    code.push([\"j\",i,\"=0\"].join(\"\"))\r\n    code.push([\"}else{s\",order[i],\"=\",blockSize].join(\"\"))\r\n    code.push([\"j\",i,\"-=\",blockSize,\"}\"].join(\"\"))\r\n    if(has_index) {\r\n      code.push([\"index[\",order[i],\"]=j\",i].join(\"\"))\r\n    }\r\n  }\r\n  for(var i=0; i<nargs; ++i) {\r\n    var indexStr = [\"offset\"+i]\r\n    for(var j=matched; j<dimension; ++j) {\r\n      indexStr.push([\"j\",j,\"*t\",i,\"p\",order[j]].join(\"\"))\r\n    }\r\n    code.push([\"p\",i,\"=(\",indexStr.join(\"+\"),\")\"].join(\"\"))\r\n  }\r\n  code.push(innerFill(order, proc, body))\r\n  for(var i=matched; i<dimension; ++i) {\r\n    code.push(\"}\")\r\n  }\r\n  return code.join(\"\\n\")\r\n}\r\n\r\n//Count the number of compatible inner orders\r\n// This is the length of the longest common prefix of the arrays in orders.\r\n// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.\r\n// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.\r\nfunction countMatches(orders) {\r\n  var matched = 0, dimension = orders[0].length\r\n  while(matched < dimension) {\r\n    for(var j=1; j<orders.length; ++j) {\r\n      if(orders[j][matched] !== orders[0][matched]) {\r\n        return matched\r\n      }\r\n    }\r\n    ++matched\r\n  }\r\n  return matched\r\n}\r\n\r\n//Processes a block according to the given data types\r\n// Replaces variable names by different ones, either \"local\" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.\r\nfunction processBlock(block, proc, dtypes) {\r\n  var code = block.body\r\n  var pre = []\r\n  var post = []\r\n  for(var i=0; i<block.args.length; ++i) {\r\n    var carg = block.args[i]\r\n    if(carg.count <= 0) {\r\n      continue\r\n    }\r\n    var re = new RegExp(carg.name, \"g\")\r\n    var ptrStr = \"\"\r\n    var arrNum = proc.arrayArgs.indexOf(i)\r\n    switch(proc.argTypes[i]) {\r\n      case \"offset\":\r\n        var offArgIndex = proc.offsetArgIndex.indexOf(i)\r\n        var offArg = proc.offsetArgs[offArgIndex]\r\n        arrNum = offArg.array\r\n        ptrStr = \"+q\" + offArgIndex // Adds offset to the \"pointer\" in the array\r\n      case \"array\":\r\n        ptrStr = \"p\" + arrNum + ptrStr\r\n        var localStr = \"l\" + i\r\n        var arrStr = \"a\" + arrNum\r\n        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array\r\n          if(carg.count === 1) { // Argument/array used only once(?)\r\n            if(dtypes[arrNum] === \"generic\") {\r\n              if(carg.lvalue) {\r\n                pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\r\n                code = code.replace(re, localStr)\r\n                post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\r\n              } else {\r\n                code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\r\n              }\r\n            } else {\r\n              code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\r\n            }\r\n          } else if(dtypes[arrNum] === \"generic\") {\r\n            pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\r\n            code = code.replace(re, localStr)\r\n            if(carg.lvalue) {\r\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\r\n            }\r\n          } else {\r\n            pre.push([\"var \", localStr, \"=\", arrStr, \"[\", ptrStr, \"]\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\r\n            code = code.replace(re, localStr)\r\n            if(carg.lvalue) {\r\n              post.push([arrStr, \"[\", ptrStr, \"]=\", localStr].join(\"\"))\r\n            }\r\n          }\r\n        } else { // Argument to body is a \"block\"\r\n          var reStrArr = [carg.name], ptrStrArr = [ptrStr]\r\n          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {\r\n            reStrArr.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\")\r\n            ptrStrArr.push(\"$\" + (j+1) + \"*t\" + arrNum + \"b\" + j) // Matched index times stride\r\n          }\r\n          re = new RegExp(reStrArr.join(\"\"), \"g\")\r\n          ptrStr = ptrStrArr.join(\"+\")\r\n          if(dtypes[arrNum] === \"generic\") {\r\n            /*if(carg.lvalue) {\r\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\r\n              code = code.replace(re, localStr)\r\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\r\n            } else {\r\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\r\n            }*/\r\n            throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\")\r\n          } else {\r\n            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.\r\n            code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\r\n          }\r\n        }\r\n      break\r\n      case \"scalar\":\r\n        code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i))\r\n      break\r\n      case \"index\":\r\n        code = code.replace(re, \"index\")\r\n      break\r\n      case \"shape\":\r\n        code = code.replace(re, \"shape\")\r\n      break\r\n    }\r\n  }\r\n  return [pre.join(\"\\n\"), code, post.join(\"\\n\")].join(\"\\n\").trim()\r\n}\r\n\r\nfunction typeSummary(dtypes) {\r\n  var summary = new Array(dtypes.length)\r\n  var allEqual = true\r\n  for(var i=0; i<dtypes.length; ++i) {\r\n    var t = dtypes[i]\r\n    var digits = t.match(/\\d+/)\r\n    if(!digits) {\r\n      digits = \"\"\r\n    } else {\r\n      digits = digits[0]\r\n    }\r\n    if(t.charAt(0) === 0) {\r\n      summary[i] = \"u\" + t.charAt(1) + digits\r\n    } else {\r\n      summary[i] = t.charAt(0) + digits\r\n    }\r\n    if(i > 0) {\r\n      allEqual = allEqual && summary[i] === summary[i-1]\r\n    }\r\n  }\r\n  if(allEqual) {\r\n    return summary[0]\r\n  }\r\n  return summary.join(\"\")\r\n}\r\n\r\n//Generates a cwise operator\r\nfunction generateCWiseOp(proc, typesig) {\r\n\r\n  //Compute dimension\r\n  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.\r\n  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0\r\n  var orders = new Array(proc.arrayArgs.length)\r\n  var dtypes = new Array(proc.arrayArgs.length)\r\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\r\n    dtypes[i] = typesig[2*i]\r\n    orders[i] = typesig[2*i+1]\r\n  }\r\n  \r\n  //Determine where block and loop indices start and end\r\n  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks\r\n  var loopBegin = [], loopEnd = [] // These indices are iterated over\r\n  var loopOrders = [] // orders restricted to the loop indices\r\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\r\n    if (proc.arrayBlockIndices[i]<0) {\r\n      loopBegin.push(0)\r\n      loopEnd.push(dimension)\r\n      blockBegin.push(dimension)\r\n      blockEnd.push(dimension+proc.arrayBlockIndices[i])\r\n    } else {\r\n      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative\r\n      loopEnd.push(proc.arrayBlockIndices[i]+dimension)\r\n      blockBegin.push(0)\r\n      blockEnd.push(proc.arrayBlockIndices[i])\r\n    }\r\n    var newOrder = []\r\n    for(var j=0; j<orders[i].length; j++) {\r\n      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {\r\n        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.\r\n      }\r\n    }\r\n    loopOrders.push(newOrder)\r\n  }\r\n\r\n  //First create arguments for procedure\r\n  var arglist = [\"SS\"] // SS is the overall shape over which we iterate\r\n  var code = [\"'use strict'\"]\r\n  var vars = []\r\n  \r\n  for(var j=0; j<dimension; ++j) {\r\n    vars.push([\"s\", j, \"=SS[\", j, \"]\"].join(\"\")) // The limits for each dimension.\r\n  }\r\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\r\n    arglist.push(\"a\"+i) // Actual data array\r\n    arglist.push(\"t\"+i) // Strides\r\n    arglist.push(\"p\"+i) // Offset in the array at which the data starts (also used for iterating over the data)\r\n    \r\n    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping\r\n      vars.push([\"t\",i,\"p\",j,\"=t\",i,\"[\",loopBegin[i]+j,\"]\"].join(\"\"))\r\n    }\r\n    \r\n    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration\r\n      vars.push([\"t\",i,\"b\",j,\"=t\",i,\"[\",blockBegin[i]+j,\"]\"].join(\"\"))\r\n    }\r\n  }\r\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\r\n    arglist.push(\"Y\" + i)\r\n  }\r\n  if(proc.shapeArgs.length > 0) {\r\n    vars.push(\"shape=SS.slice(0)\") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)\r\n  }\r\n  if(proc.indexArgs.length > 0) {\r\n    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.\r\n    var zeros = new Array(dimension)\r\n    for(var i=0; i<dimension; ++i) {\r\n      zeros[i] = \"0\"\r\n    }\r\n    vars.push([\"index=[\", zeros.join(\",\"), \"]\"].join(\"\"))\r\n  }\r\n  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations\r\n    var off_arg = proc.offsetArgs[i]\r\n    var init_string = []\r\n    for(var j=0; j<off_arg.offset.length; ++j) {\r\n      if(off_arg.offset[j] === 0) {\r\n        continue\r\n      } else if(off_arg.offset[j] === 1) {\r\n        init_string.push([\"t\", off_arg.array, \"p\", j].join(\"\"))      \r\n      } else {\r\n        init_string.push([off_arg.offset[j], \"*t\", off_arg.array, \"p\", j].join(\"\"))\r\n      }\r\n    }\r\n    if(init_string.length === 0) {\r\n      vars.push(\"q\" + i + \"=0\")\r\n    } else {\r\n      vars.push([\"q\", i, \"=\", init_string.join(\"+\")].join(\"\"))\r\n    }\r\n  }\r\n\r\n  //Prepare this variables\r\n  var thisVars = uniq([].concat(proc.pre.thisVars)\r\n                      .concat(proc.body.thisVars)\r\n                      .concat(proc.post.thisVars))\r\n  vars = vars.concat(thisVars)\r\n  code.push(\"var \" + vars.join(\",\"))\r\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\r\n    code.push(\"p\"+i+\"|=0\")\r\n  }\r\n  \r\n  //Inline prelude\r\n  if(proc.pre.body.length > 3) {\r\n    code.push(processBlock(proc.pre, proc, dtypes))\r\n  }\r\n\r\n  //Process body\r\n  var body = processBlock(proc.body, proc, dtypes)\r\n  var matched = countMatches(loopOrders)\r\n  if(matched < dimension) {\r\n    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.\r\n  } else {\r\n    code.push(innerFill(loopOrders[0], proc, body))\r\n  }\r\n\r\n  //Inline epilog\r\n  if(proc.post.body.length > 3) {\r\n    code.push(processBlock(proc.post, proc, dtypes))\r\n  }\r\n  \r\n  if(proc.debug) {\r\n    console.log(\"-----Generated cwise routine for \", typesig, \":\\n\" + code.join(\"\\n\") + \"\\n----------\")\r\n  }\r\n  \r\n  var loopName = [(proc.funcName||\"unnamed\"), \"_cwise_loop_\", orders[0].join(\"s\"),\"m\",matched,typeSummary(dtypes)].join(\"\")\r\n  var f = new Function([\"function \",loopName,\"(\", arglist.join(\",\"),\"){\", code.join(\"\\n\"),\"} return \", loopName].join(\"\"))\r\n  return f()\r\n}\r\nmodule.exports = generateCWiseOp\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L2N3aXNlLWNvbXBpbGVyL2xpYi9jb21waWxlLmpzPzZhNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcclxuXHJcbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHZlcnkgc2ltcGxlIGxvb3BzIGFuYWxvZ291cyB0byBob3cgeW91IHR5cGljYWxseSB0cmF2ZXJzZSBhcnJheXMgKHRoZSBvdXRlcm1vc3QgbG9vcCBjb3JyZXNwb25kcyB0byB0aGUgc2xvd2VzdCBjaGFuZ2luZyBpbmRleCwgdGhlIGlubmVybW9zdCBsb29wIHRvIHRoZSBmYXN0ZXN0IGNoYW5naW5nIGluZGV4KVxyXG4vLyBUT0RPOiBJZiB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgc3RyaWRlcyAoYW5kIG9mZnNldHMpIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZGVjcmVhc2luZyB0aGUgbnVtYmVyIG9mIFwicG9pbnRlcnNcIiBhbmQgcmVsYXRlZCB2YXJpYWJsZXMuIFRoZSBkcmF3YmFjayBpcyB0aGF0IHRoZSB0eXBlIHNpZ25hdHVyZSB3b3VsZCBiZWNvbWUgbW9yZSBzcGVjaWZpYyBhbmQgdGhhdCB0aGVyZSB3b3VsZCB0aHVzIGJlIGxlc3MgcG90ZW50aWFsIGZvciBjYWNoaW5nLCBidXQgaXQgbWlnaHQgc3RpbGwgYmUgd29ydGggaXQsIGVzcGVjaWFsbHkgd2hlbiBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkge1xyXG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcclxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcclxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoPjBcclxuICAgICwgY29kZSA9IFtdXHJcbiAgICAsIHZhcnMgPSBbXVxyXG4gICAgLCBpZHg9MCwgcGlkeD0wLCBpLCBqXHJcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkgeyAvLyBJdGVyYXRpb24gdmFyaWFibGVzXHJcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxyXG4gIH1cclxuICAvL0NvbXB1dGUgc2NhbiBkZWx0YXNcclxuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcclxuICAgIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcclxuICAgICAgcGlkeCA9IGlkeFxyXG4gICAgICBpZHggPSBvcmRlcltpXVxyXG4gICAgICBpZihpID09PSAwKSB7IC8vIFRoZSBpbm5lcm1vc3QvZmFzdGVzdCBkaW1lbnNpb24ncyBkZWx0YSBpcyBzaW1wbHkgaXRzIHN0cmlkZVxyXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcclxuICAgICAgfSBlbHNlIHsgLy8gRm9yIG90aGVyIGRpbWVuc2lvbnMgdGhlIGRlbHRhIGlzIGJhc2ljYWxseSB0aGUgc3RyaWRlIG1pbnVzIHNvbWV0aGluZyB3aGljaCBlc3NlbnRpYWxseSBcInJld2luZHNcIiB0aGUgcHJldmlvdXMgKG1vcmUgaW5uZXIpIGRpbWVuc2lvblxyXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPSh0XCIsaixcInBcIixpZHgsXCItc1wiLHBpZHgsXCIqdFwiLGosXCJwXCIscGlkeCxcIilcIl0uam9pbihcIlwiKSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxyXG4gIC8vU2NhbiBsb29wXHJcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkgeyAvLyBTdGFydCBhdCBsYXJnZXN0IHN0cmlkZSBhbmQgd29yayB5b3VyIHdheSBpbndhcmRzXHJcbiAgICBpZHggPSBvcmRlcltpXVxyXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXHJcbiAgfVxyXG4gIC8vUHVzaCBib2R5IG9mIGlubmVyIGxvb3BcclxuICBjb2RlLnB1c2goYm9keSlcclxuICAvL0FkdmFuY2Ugc2NhbiBwb2ludGVyc1xyXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcclxuICAgIHBpZHggPSBpZHhcclxuICAgIGlkeCA9IG9yZGVyW2ldXHJcbiAgICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcclxuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxyXG4gICAgfVxyXG4gICAgaWYoaGFzX2luZGV4KSB7XHJcbiAgICAgIGlmKGkgPiAwKSB7XHJcbiAgICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLHBpZHgsXCJdLT1zXCIscGlkeF0uam9pbihcIlwiKSlcclxuICAgICAgfVxyXG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXHJcbiAgICB9XHJcbiAgICBjb2RlLnB1c2goXCJ9XCIpXHJcbiAgfVxyXG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcclxufVxyXG5cclxuLy8gR2VuZXJhdGUgXCJvdXRlclwiIGxvb3BzIHRoYXQgbG9vcCBvdmVyIGJsb2NrcyBvZiBkYXRhLCBhcHBseWluZyBcImlubmVyXCIgbG9vcHMgdG8gdGhlIGJsb2NrcyBieSBtYW5pcHVsYXRpbmcgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGlubmVyIGxvb3Agb25seSBcInNlZXNcIiB0aGUgY3VycmVudCBibG9jay5cclxuLy8gVE9ETzogSWYgdGhpcyBpcyB1c2VkLCB0aGVuIHRoZSBwcmV2aW91cyBkZWNsYXJhdGlvbiAoZG9uZSBieSBnZW5lcmF0ZUN3aXNlT3ApIG9mIHMqIGlzIGVzc2VudGlhbGx5IHVubmVjZXNzYXJ5LlxyXG4vLyAgICAgICBJIGJlbGlldmUgdGhlIHMqIGFyZSBub3QgdXNlZCBlbHNld2hlcmUgKGluIHBhcnRpY3VsYXIsIEkgZG9uJ3QgdGhpbmsgdGhleSdyZSB1c2VkIGluIHRoZSBwcmUvcG9zdCBwYXJ0cyBhbmQgXCJzaGFwZVwiIGlzIGRlZmluZWQgaW5kZXBlbmRlbnRseSksIHNvIGl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIG1ha2UgZGVmaW5pbmcgdGhlIHMqIGRlcGVuZGVudCBvbiB3aGF0IGxvb3AgbWV0aG9kIGlzIGJlaW5nIHVzZWQuXHJcbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xyXG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcclxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcclxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcclxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMFxyXG4gICAgLCBjb2RlID0gW11cclxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XHJcbiAgICBjb2RlLnB1c2goW1widmFyIG9mZnNldFwiLGksXCI9cFwiLGldLmpvaW4oXCJcIikpXHJcbiAgfVxyXG4gIC8vR2VuZXJhdGUgbG9vcHMgZm9yIHVubWF0Y2hlZCBkaW1lbnNpb25zXHJcbiAgLy8gVGhlIG9yZGVyIGluIHdoaWNoIHRoZXNlIGRpbWVuc2lvbnMgYXJlIHRyYXZlcnNlZCBpcyBmYWlybHkgYXJiaXRyYXJ5IChmcm9tIHNtYWxsIHN0cmlkZSB0byBsYXJnZSBzdHJpZGUsIGZvciB0aGUgZmlyc3QgYXJndW1lbnQpXHJcbiAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSBpZiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgbG9vcHMgYXJlIHBsYWNlZCB3b3VsZCBhbHNvIGJlIHNvbWVob3cgXCJvcHRpbWFsXCIgKGF0IHRoZSB2ZXJ5IGxlYXN0IHdlIHNob3VsZCBjaGVjayB0aGF0IGl0IHJlYWxseSBkb2Vzbid0IGh1cnQgdXMgaWYgdGhleSdyZSBub3QpLlxyXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XHJcbiAgICBjb2RlLnB1c2goW1wiZm9yKHZhciBqXCIraStcIj1TU1tcIiwgb3JkZXJbaV0sIFwiXXwwO2pcIiwgaSwgXCI+MDspe1wiXS5qb2luKFwiXCIpKSAvLyBJdGVyYXRlIGJhY2sgdG8gZnJvbnRcclxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKSAvLyBFaXRoZXIgZGVjcmVhc2UgaiBieSBibG9ja1NpemUgKHMgPSBibG9ja1NpemUpLCBvciBzZXQgaXQgdG8gemVybyAoYWZ0ZXIgc2V0dGluZyBzID0gaikuXHJcbiAgICBjb2RlLnB1c2goW1wic1wiLG9yZGVyW2ldLFwiPWpcIixpXS5qb2luKFwiXCIpKVxyXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcclxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxyXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiLT1cIixibG9ja1NpemUsXCJ9XCJdLmpvaW4oXCJcIikpXHJcbiAgICBpZihoYXNfaW5kZXgpIHtcclxuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcclxuICAgIH1cclxuICB9XHJcbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xyXG4gICAgdmFyIGluZGV4U3RyID0gW1wib2Zmc2V0XCIraV1cclxuICAgIGZvcih2YXIgaj1tYXRjaGVkOyBqPGRpbWVuc2lvbjsgKytqKSB7XHJcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXHJcbiAgICB9XHJcbiAgICBjb2RlLnB1c2goW1wicFwiLGksXCI9KFwiLGluZGV4U3RyLmpvaW4oXCIrXCIpLFwiKVwiXS5qb2luKFwiXCIpKVxyXG4gIH1cclxuICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSlcclxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xyXG4gICAgY29kZS5wdXNoKFwifVwiKVxyXG4gIH1cclxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXHJcbn1cclxuXHJcbi8vQ291bnQgdGhlIG51bWJlciBvZiBjb21wYXRpYmxlIGlubmVyIG9yZGVyc1xyXG4vLyBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgY29tbW9uIHByZWZpeCBvZiB0aGUgYXJyYXlzIGluIG9yZGVycy5cclxuLy8gRWFjaCBhcnJheSBpbiBvcmRlcnMgbGlzdHMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvcnJlc3BvbmQgbmRhcnJheSBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIHN0cmlkZS5cclxuLy8gVGhpcyBpcyB0aHVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkaW1lbnNpb25zIHRoYXQgY2FuIGJlIGVmZmljaWVudGx5IHRyYXZlcnNlZCBieSBzaW1wbGUgbmVzdGVkIGxvb3BzIGZvciBhbGwgYXJyYXlzLlxyXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XHJcbiAgdmFyIG1hdGNoZWQgPSAwLCBkaW1lbnNpb24gPSBvcmRlcnNbMF0ubGVuZ3RoXHJcbiAgd2hpbGUobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xyXG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgIGlmKG9yZGVyc1tqXVttYXRjaGVkXSAhPT0gb3JkZXJzWzBdW21hdGNoZWRdKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKyttYXRjaGVkXHJcbiAgfVxyXG4gIHJldHVybiBtYXRjaGVkXHJcbn1cclxuXHJcbi8vUHJvY2Vzc2VzIGEgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBkYXRhIHR5cGVzXHJcbi8vIFJlcGxhY2VzIHZhcmlhYmxlIG5hbWVzIGJ5IGRpZmZlcmVudCBvbmVzLCBlaXRoZXIgXCJsb2NhbFwiIG9uZXMgKHRoYXQgYXJlIHRoZW4gZmVycmllZCBpbiBhbmQgb3V0IG9mIHRoZSBnaXZlbiBhcnJheSkgb3Igb25lcyBtYXRjaGluZyB0aGUgYXJndW1lbnRzIHRoYXQgdGhlIGZ1bmN0aW9uIHBlcmZvcm1pbmcgdGhlIHVsdGltYXRlIGxvb3Agd2lsbCBhY2NlcHQuXHJcbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XHJcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XHJcbiAgdmFyIHByZSA9IFtdXHJcbiAgdmFyIHBvc3QgPSBbXVxyXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgIHZhciBjYXJnID0gYmxvY2suYXJnc1tpXVxyXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXHJcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxyXG4gICAgdmFyIGFyck51bSA9IHByb2MuYXJyYXlBcmdzLmluZGV4T2YoaSlcclxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XHJcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcclxuICAgICAgICB2YXIgb2ZmQXJnSW5kZXggPSBwcm9jLm9mZnNldEFyZ0luZGV4LmluZGV4T2YoaSlcclxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxyXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxyXG4gICAgICAgIHB0clN0ciA9IFwiK3FcIiArIG9mZkFyZ0luZGV4IC8vIEFkZHMgb2Zmc2V0IHRvIHRoZSBcInBvaW50ZXJcIiBpbiB0aGUgYXJyYXlcclxuICAgICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgICAgcHRyU3RyID0gXCJwXCIgKyBhcnJOdW0gKyBwdHJTdHJcclxuICAgICAgICB2YXIgbG9jYWxTdHIgPSBcImxcIiArIGlcclxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cclxuICAgICAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dID09PSAwKSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMganVzdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoaXMgYXJyYXlcclxuICAgICAgICAgIGlmKGNhcmcuY291bnQgPT09IDEpIHsgLy8gQXJndW1lbnQvYXJyYXkgdXNlZCBvbmx5IG9uY2UoPylcclxuICAgICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XHJcbiAgICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gSXMgdGhpcyBuZWNlc3NhcnkgaWYgdGhlIGFyZ3VtZW50IGlzIE9OTFkgdXNlZCBhcyBhbiBsdmFsdWU/IChrZWVwIGluIG1pbmQgdGhhdCB3ZSBjYW4gaGF2ZSBhICs9IHNvbWV0aGluZywgc28gd2Ugd291bGQgYWN0dWFsbHkgbmVlZCB0byBjaGVjayBjYXJnLnJ2YWx1ZSlcclxuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxyXG4gICAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcclxuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XHJcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxyXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xyXG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcclxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcclxuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMgYSBcImJsb2NrXCJcclxuICAgICAgICAgIHZhciByZVN0ckFyciA9IFtjYXJnLm5hbWVdLCBwdHJTdHJBcnIgPSBbcHRyU3RyXVxyXG4gICAgICAgICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dKTsgaisrKSB7XHJcbiAgICAgICAgICAgIHJlU3RyQXJyLnB1c2goXCJcXFxccypcXFxcWyhbXlxcXFxdXSspXFxcXF1cIilcclxuICAgICAgICAgICAgcHRyU3RyQXJyLnB1c2goXCIkXCIgKyAoaisxKSArIFwiKnRcIiArIGFyck51bSArIFwiYlwiICsgaikgLy8gTWF0Y2hlZCBpbmRleCB0aW1lcyBzdHJpZGVcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZVN0ckFyci5qb2luKFwiXCIpLCBcImdcIilcclxuICAgICAgICAgIHB0clN0ciA9IHB0clN0ckFyci5qb2luKFwiK1wiKVxyXG4gICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XHJcbiAgICAgICAgICAgIC8qaWYoY2FyZy5sdmFsdWUpIHtcclxuICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXHJcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXHJcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxyXG4gICAgICAgICAgICB9Ki9cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IEdlbmVyaWMgYXJyYXlzIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBibG9ja3MhXCIpXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IHByb2R1Y2UgYW55IGxvY2FsIHZhcmlhYmxlcywgZXZlbiBpZiB2YXJpYWJsZXMgYXJlIHVzZWQgbXVsdGlwbGUgdGltZXMuIEl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIGRvIHNvLCBidXQgaXQgd291bGQgY29tcGxpY2F0ZSB0aGluZ3MgcXVpdGUgYSBiaXQuXHJcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXHJcbiAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxyXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcclxuICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBcInNoYXBlXCI6XHJcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gW3ByZS5qb2luKFwiXFxuXCIpLCBjb2RlLCBwb3N0LmpvaW4oXCJcXG5cIildLmpvaW4oXCJcXG5cIikudHJpbSgpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHR5cGVTdW1tYXJ5KGR0eXBlcykge1xyXG4gIHZhciBzdW1tYXJ5ID0gbmV3IEFycmF5KGR0eXBlcy5sZW5ndGgpXHJcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxyXG4gIGZvcih2YXIgaT0wOyBpPGR0eXBlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgdmFyIHQgPSBkdHlwZXNbaV1cclxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcclxuICAgIGlmKCFkaWdpdHMpIHtcclxuICAgICAgZGlnaXRzID0gXCJcIlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGlnaXRzID0gZGlnaXRzWzBdXHJcbiAgICB9XHJcbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xyXG4gICAgICBzdW1tYXJ5W2ldID0gXCJ1XCIgKyB0LmNoYXJBdCgxKSArIGRpZ2l0c1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXHJcbiAgICB9XHJcbiAgICBpZihpID4gMCkge1xyXG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxyXG4gICAgfVxyXG4gIH1cclxuICBpZihhbGxFcXVhbCkge1xyXG4gICAgcmV0dXJuIHN1bW1hcnlbMF1cclxuICB9XHJcbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxyXG59XHJcblxyXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ1dpc2VPcChwcm9jLCB0eXBlc2lnKSB7XHJcblxyXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cclxuICAvLyBBcnJheXMgZ2V0IHB1dCBmaXJzdCBpbiB0eXBlc2lnLCBhbmQgdGhlcmUgYXJlIHR3byBlbnRyaWVzIHBlciBhcnJheSAoZHR5cGUgYW5kIG9yZGVyKSwgc28gdGhpcyBnZXRzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgZmlyc3QgYXJyYXkgYXJnLlxyXG4gIHZhciBkaW1lbnNpb24gPSAodHlwZXNpZ1sxXS5sZW5ndGggLSBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSl8MFxyXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxyXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxyXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cclxuICAgIG9yZGVyc1tpXSA9IHR5cGVzaWdbMippKzFdXHJcbiAgfVxyXG4gIFxyXG4gIC8vRGV0ZXJtaW5lIHdoZXJlIGJsb2NrIGFuZCBsb29wIGluZGljZXMgc3RhcnQgYW5kIGVuZFxyXG4gIHZhciBibG9ja0JlZ2luID0gW10sIGJsb2NrRW5kID0gW10gLy8gVGhlc2UgaW5kaWNlcyBhcmUgZXhwb3NlZCBhcyBibG9ja3NcclxuICB2YXIgbG9vcEJlZ2luID0gW10sIGxvb3BFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBpdGVyYXRlZCBvdmVyXHJcbiAgdmFyIGxvb3BPcmRlcnMgPSBbXSAvLyBvcmRlcnMgcmVzdHJpY3RlZCB0byB0aGUgbG9vcCBpbmRpY2VzXHJcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldPDApIHtcclxuICAgICAgbG9vcEJlZ2luLnB1c2goMClcclxuICAgICAgbG9vcEVuZC5wdXNoKGRpbWVuc2lvbilcclxuICAgICAgYmxvY2tCZWdpbi5wdXNoKGRpbWVuc2lvbilcclxuICAgICAgYmxvY2tFbmQucHVzaChkaW1lbnNpb24rcHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvb3BCZWdpbi5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pIC8vIE5vbi1uZWdhdGl2ZVxyXG4gICAgICBsb29wRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXStkaW1lbnNpb24pXHJcbiAgICAgIGJsb2NrQmVnaW4ucHVzaCgwKVxyXG4gICAgICBibG9ja0VuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXHJcbiAgICB9XHJcbiAgICB2YXIgbmV3T3JkZXIgPSBbXVxyXG4gICAgZm9yKHZhciBqPTA7IGo8b3JkZXJzW2ldLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGlmIChsb29wQmVnaW5baV08PW9yZGVyc1tpXVtqXSAmJiBvcmRlcnNbaV1bal08bG9vcEVuZFtpXSkge1xyXG4gICAgICAgIG5ld09yZGVyLnB1c2gob3JkZXJzW2ldW2pdLWxvb3BCZWdpbltpXSkgLy8gSWYgdGhpcyBpcyBhIGxvb3AgaW5kZXgsIHB1dCBpdCBpbiBuZXdPcmRlciwgc3VidHJhY3RpbmcgbG9vcEJlZ2luLCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgbG9vcE9yZGVycyBhcmUgdXNpbmcgYSBjb21tb24gc2V0IG9mIGluZGljZXMuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGxvb3BPcmRlcnMucHVzaChuZXdPcmRlcilcclxuICB9XHJcblxyXG4gIC8vRmlyc3QgY3JlYXRlIGFyZ3VtZW50cyBmb3IgcHJvY2VkdXJlXHJcbiAgdmFyIGFyZ2xpc3QgPSBbXCJTU1wiXSAvLyBTUyBpcyB0aGUgb3ZlcmFsbCBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGVcclxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxyXG4gIHZhciB2YXJzID0gW11cclxuICBcclxuICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xyXG4gICAgdmFycy5wdXNoKFtcInNcIiwgaiwgXCI9U1NbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUaGUgbGltaXRzIGZvciBlYWNoIGRpbWVuc2lvbi5cclxuICB9XHJcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgIGFyZ2xpc3QucHVzaChcImFcIitpKSAvLyBBY3R1YWwgZGF0YSBhcnJheVxyXG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpIC8vIFN0cmlkZXNcclxuICAgIGFyZ2xpc3QucHVzaChcInBcIitpKSAvLyBPZmZzZXQgaW4gdGhlIGFycmF5IGF0IHdoaWNoIHRoZSBkYXRhIHN0YXJ0cyAoYWxzbyB1c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZGF0YSlcclxuICAgIFxyXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgbG9vcGluZ1xyXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixsb29wQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSk7ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBibG9jayBpdGVyYXRpb25cclxuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwiYlwiLGosXCI9dFwiLGksXCJbXCIsYmxvY2tCZWdpbltpXStqLFwiXVwiXS5qb2luKFwiXCIpKVxyXG4gICAgfVxyXG4gIH1cclxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgIGFyZ2xpc3QucHVzaChcIllcIiArIGkpXHJcbiAgfVxyXG4gIGlmKHByb2Muc2hhcGVBcmdzLmxlbmd0aCA+IDApIHtcclxuICAgIHZhcnMucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpIC8vIE1ha2VzIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgYXZhaWxhYmxlIHRvIHRoZSB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIChzbyB5b3UgY2FuIHVzZSB3aWR0aC9oZWlnaHQgZm9yIGV4YW1wbGUpXHJcbiAgfVxyXG4gIGlmKHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDApIHtcclxuICAgIC8vIFByZXBhcmUgYW4gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgKGxvZ2ljYWwpIGluZGljZXMsIGluaXRpYWxpemVkIHRvIGRpbWVuc2lvbiB6ZXJvZXMuXHJcbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxyXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcclxuICAgICAgemVyb3NbaV0gPSBcIjBcIlxyXG4gICAgfVxyXG4gICAgdmFycy5wdXNoKFtcImluZGV4PVtcIiwgemVyb3Muam9pbihcIixcIiksIFwiXVwiXS5qb2luKFwiXCIpKVxyXG4gIH1cclxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHsgLy8gT2Zmc2V0IGFyZ3VtZW50cyB1c2VkIGZvciBzdGVuY2lsIG9wZXJhdGlvbnNcclxuICAgIHZhciBvZmZfYXJnID0gcHJvYy5vZmZzZXRBcmdzW2ldXHJcbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxyXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcclxuICAgICAgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDApIHtcclxuICAgICAgICBjb250aW51ZVxyXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcclxuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtcInRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpICAgICAgXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB2YXJzLnB1c2goXCJxXCIgKyBpICsgXCI9MFwiKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy9QcmVwYXJlIHRoaXMgdmFyaWFibGVzXHJcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcclxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocHJvYy5wb3N0LnRoaXNWYXJzKSlcclxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXHJcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcclxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xyXG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcclxuICB9XHJcbiAgXHJcbiAgLy9JbmxpbmUgcHJlbHVkZVxyXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xyXG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnByZSwgcHJvYywgZHR5cGVzKSlcclxuICB9XHJcblxyXG4gIC8vUHJvY2VzcyBib2R5XHJcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXHJcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMobG9vcE9yZGVycylcclxuICBpZihtYXRjaGVkIDwgZGltZW5zaW9uKSB7XHJcbiAgICBjb2RlLnB1c2gob3V0ZXJGaWxsKG1hdGNoZWQsIGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKSAvLyBUT0RPOiBSYXRoZXIgdGhhbiBwYXNzaW5nIGxvb3BPcmRlcnNbMF0sIGl0IG1pZ2h0IGJlIGludGVyZXN0aW5nIHRvIGxvb2sgYXQgcGFzc2luZyBhbiBvcmRlciB0aGF0IHJlcHJlc2VudHMgdGhlIG1ham9yaXR5IG9mIHRoZSBhcmd1bWVudHMgZm9yIGV4YW1wbGUuXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvZGUucHVzaChpbm5lckZpbGwobG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpXHJcbiAgfVxyXG5cclxuICAvL0lubGluZSBlcGlsb2dcclxuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XHJcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucG9zdCwgcHJvYywgZHR5cGVzKSlcclxuICB9XHJcbiAgXHJcbiAgaWYocHJvYy5kZWJ1Zykge1xyXG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCBjd2lzZSByb3V0aW5lIGZvciBcIiwgdHlwZXNpZywgXCI6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcclxuICB9XHJcbiAgXHJcbiAgdmFyIGxvb3BOYW1lID0gWyhwcm9jLmZ1bmNOYW1lfHxcInVubmFtZWRcIiksIFwiX2N3aXNlX2xvb3BfXCIsIG9yZGVyc1swXS5qb2luKFwic1wiKSxcIm1cIixtYXRjaGVkLHR5cGVTdW1tYXJ5KGR0eXBlcyldLmpvaW4oXCJcIilcclxuICB2YXIgZiA9IG5ldyBGdW5jdGlvbihbXCJmdW5jdGlvbiBcIixsb29wTmFtZSxcIihcIiwgYXJnbGlzdC5qb2luKFwiLFwiKSxcIil7XCIsIGNvZGUuam9pbihcIlxcblwiKSxcIn0gcmV0dXJuIFwiLCBsb29wTmFtZV0uam9pbihcIlwiKSlcclxuICByZXR1cm4gZigpXHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUNXaXNlT3BcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ../~/cwise-compiler/lib/thunk.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n// The function below is called when constructing a cwise function object, and does the following:\r\n// A function object is constructed which accepts as argument a compilation function and returns another function.\r\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\r\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\r\n// The compilation passed to the first function object is used for compiling new functions.\r\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\r\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\r\n// So createThunk roughly works like this:\r\n// function createThunk(proc) {\r\n//   var thunk = function(compileBound) {\r\n//     var CACHED = {}\r\n//     return function(arrays and scalars) {\r\n//       if (dtype and order of arrays in CACHED) {\r\n//         var func = CACHED[dtype and order of arrays]\r\n//       } else {\r\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\r\n//       }\r\n//       return func(arrays and scalars)\r\n//     }\r\n//   }\r\n//   return thunk(compile.bind1(proc))\r\n// }\r\n\r\nvar compile = __webpack_require__(/*! ./compile.js */ 8)\r\n\r\nfunction createThunk(proc) {\r\n  var code = [\"'use strict'\", \"var CACHED={}\"]\r\n  var vars = []\r\n  var thunkName = proc.funcName + \"_cwise_thunk\"\r\n  \r\n  //Build thunk\r\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\r\n  var typesig = []\r\n  var string_typesig = []\r\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\r\n                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(\",\"+proc.arrayBlockIndices[0]+\")\"):\")\"].join(\"\")]\r\n  var shapeLengthConditions = [], shapeConditions = []\r\n  // Process array arguments\r\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\r\n    var j = proc.arrayArgs[i]\r\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\r\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\r\n    typesig.push(\"t\" + j)\r\n    typesig.push(\"r\" + j)\r\n    string_typesig.push(\"t\"+j)\r\n    string_typesig.push(\"r\"+j+\".join()\")\r\n    proc_args.push(\"array\" + j + \".data\")\r\n    proc_args.push(\"array\" + j + \".stride\")\r\n    proc_args.push(\"array\" + j + \".offset|0\")\r\n    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)\r\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))\r\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[i]) + \"]\")\r\n    }\r\n  }\r\n  // Check for shape equality\r\n  if (proc.arrayArgs.length > 1) {\r\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\")\r\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\")\r\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\")\r\n    code.push(\"}\")\r\n  }\r\n  // Process scalar arguments\r\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\r\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\r\n  }\r\n  // Check for cached function (and if not present, generate it)\r\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\r\n  vars.push(\"proc=CACHED[type]\")\r\n  code.push(\"var \" + vars.join(\",\"))\r\n  \r\n  code.push([\"if(!proc){\",\r\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\r\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\r\n\r\n  if(proc.debug) {\r\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\")\r\n  }\r\n  \r\n  //Compile thunk\r\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\r\n  return thunk(compile.bind(undefined, proc))\r\n}\r\n\r\nmodule.exports = createThunk\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L2N3aXNlLWNvbXBpbGVyL2xpYi90aHVuay5qcz81M2I2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXHJcblxyXG4vLyBUaGUgZnVuY3Rpb24gYmVsb3cgaXMgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGEgY3dpc2UgZnVuY3Rpb24gb2JqZWN0LCBhbmQgZG9lcyB0aGUgZm9sbG93aW5nOlxyXG4vLyBBIGZ1bmN0aW9uIG9iamVjdCBpcyBjb25zdHJ1Y3RlZCB3aGljaCBhY2NlcHRzIGFzIGFyZ3VtZW50IGEgY29tcGlsYXRpb24gZnVuY3Rpb24gYW5kIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbi5cclxuLy8gSXQgaXMgdGhpcyBvdGhlciBmdW5jdGlvbiB0aGF0IGlzIGV2ZW50dWFsbHkgcmV0dXJuZWQgYnkgY3JlYXRlVGh1bmssIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBvbmUgdGhhdCBhY3R1YWxseVxyXG4vLyBjaGVja3Mgd2hldGhlciBhIGNlcnRhaW4gcGF0dGVybiBvZiBhcmd1bWVudHMgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBhbmQgY29tcGlsZXMgbmV3IGxvb3BzIGFzIG5lZWRlZC5cclxuLy8gVGhlIGNvbXBpbGF0aW9uIHBhc3NlZCB0byB0aGUgZmlyc3QgZnVuY3Rpb24gb2JqZWN0IGlzIHVzZWQgZm9yIGNvbXBpbGluZyBuZXcgZnVuY3Rpb25zLlxyXG4vLyBPbmNlIHRoaXMgZnVuY3Rpb24gb2JqZWN0IGlzIGNyZWF0ZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGNvbXBpbGUgYXMgYXJndW1lbnQsIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBjb21waWxlXHJcbi8vIGlzIGJvdW5kIHRvIFwicHJvY1wiIChlc3NlbnRpYWxseSBjb250YWluaW5nIGEgcHJlcHJvY2Vzc2VkIHZlcnNpb24gb2YgdGhlIHVzZXIgYXJndW1lbnRzIHRvIGN3aXNlKS5cclxuLy8gU28gY3JlYXRlVGh1bmsgcm91Z2hseSB3b3JrcyBsaWtlIHRoaXM6XHJcbi8vIGZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcclxuLy8gICB2YXIgdGh1bmsgPSBmdW5jdGlvbihjb21waWxlQm91bmQpIHtcclxuLy8gICAgIHZhciBDQUNIRUQgPSB7fVxyXG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5cyBhbmQgc2NhbGFycykge1xyXG4vLyAgICAgICBpZiAoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cyBpbiBDQUNIRUQpIHtcclxuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXVxyXG4vLyAgICAgICB9IGVsc2Uge1xyXG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdID0gY29tcGlsZUJvdW5kKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMpXHJcbi8vICAgICAgIH1cclxuLy8gICAgICAgcmV0dXJuIGZ1bmMoYXJyYXlzIGFuZCBzY2FsYXJzKVxyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuLy8gICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kMShwcm9jKSlcclxuLy8gfVxyXG5cclxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XHJcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIiwgXCJ2YXIgQ0FDSEVEPXt9XCJdXHJcbiAgdmFyIHZhcnMgPSBbXVxyXG4gIHZhciB0aHVua05hbWUgPSBwcm9jLmZ1bmNOYW1lICsgXCJfY3dpc2VfdGh1bmtcIlxyXG4gIFxyXG4gIC8vQnVpbGQgdGh1bmtcclxuICBjb2RlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLCB0aHVua05hbWUsIFwiKFwiLCBwcm9jLnNoaW1BcmdzLmpvaW4oXCIsXCIpLCBcIil7XCJdLmpvaW4oXCJcIikpXHJcbiAgdmFyIHR5cGVzaWcgPSBbXVxyXG4gIHZhciBzdHJpbmdfdHlwZXNpZyA9IFtdXHJcbiAgdmFyIHByb2NfYXJncyA9IFtbXCJhcnJheVwiLHByb2MuYXJyYXlBcmdzWzBdLFwiLnNoYXBlLnNsaWNlKFwiLCAvLyBTbGljZSBzaGFwZSBzbyB0aGF0IHdlIG9ubHkgcmV0YWluIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgKHdoaWNoIGdldHMgcGFzc2VkIHRvIHRoZSBjd2lzZSBvcGVyYXRvciBhcyBTUykuXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdPDA/KFwiLFwiK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbMF0rXCIpXCIpOlwiKVwiXS5qb2luKFwiXCIpXVxyXG4gIHZhciBzaGFwZUxlbmd0aENvbmRpdGlvbnMgPSBbXSwgc2hhcGVDb25kaXRpb25zID0gW11cclxuICAvLyBQcm9jZXNzIGFycmF5IGFyZ3VtZW50c1xyXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXHJcbiAgICB2YXJzLnB1c2goW1widFwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5kdHlwZSxcIixcclxuICAgICAgICAgICAgICAgXCJyXCIsIGosIFwiPWFycmF5XCIsIGosIFwiLm9yZGVyXCJdLmpvaW4oXCJcIikpXHJcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxyXG4gICAgdHlwZXNpZy5wdXNoKFwiclwiICsgailcclxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJ0XCIrailcclxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcclxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5kYXRhXCIpXHJcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuc3RyaWRlXCIpXHJcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcclxuICAgIGlmIChpPjApIHsgLy8gR2F0aGVyIGNvbmRpdGlvbnMgdG8gY2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5IChpZ25vcmluZyBibG9jayBpbmRpY2VzKVxyXG4gICAgICBzaGFwZUxlbmd0aENvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aD09PWFycmF5XCIgKyBqICsgXCIuc2hhcGUubGVuZ3RoK1wiICsgKE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLU1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pKSlcclxuICAgICAgc2hhcGVDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiXT09PWFycmF5XCIgKyBqICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgKyBcIl1cIilcclxuICAgIH1cclxuICB9XHJcbiAgLy8gQ2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5XHJcbiAgaWYgKHByb2MuYXJyYXlBcmdzLmxlbmd0aCA+IDEpIHtcclxuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVMZW5ndGhDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbmFsaXR5IScpXCIpXHJcbiAgICBjb2RlLnB1c2goXCJmb3IodmFyIHNoYXBlSW5kZXg9YXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoLVwiICsgTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIjsgc2hhcGVJbmRleC0tPjA7KSB7XCIpXHJcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBzaGFwZSEnKVwiKVxyXG4gICAgY29kZS5wdXNoKFwifVwiKVxyXG4gIH1cclxuICAvLyBQcm9jZXNzIHNjYWxhciBhcmd1bWVudHNcclxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgIHByb2NfYXJncy5wdXNoKFwic2NhbGFyXCIgKyBwcm9jLnNjYWxhckFyZ3NbaV0pXHJcbiAgfVxyXG4gIC8vIENoZWNrIGZvciBjYWNoZWQgZnVuY3Rpb24gKGFuZCBpZiBub3QgcHJlc2VudCwgZ2VuZXJhdGUgaXQpXHJcbiAgdmFycy5wdXNoKFtcInR5cGU9W1wiLCBzdHJpbmdfdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdLmpvaW4oKVwiXS5qb2luKFwiXCIpKVxyXG4gIHZhcnMucHVzaChcInByb2M9Q0FDSEVEW3R5cGVdXCIpXHJcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcclxuICBcclxuICBjb2RlLnB1c2goW1wiaWYoIXByb2Mpe1wiLFxyXG4gICAgICAgICAgICAgXCJDQUNIRURbdHlwZV09cHJvYz1jb21waWxlKFtcIiwgdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdKX1cIixcclxuICAgICAgICAgICAgIFwicmV0dXJuIHByb2MoXCIsIHByb2NfYXJncy5qb2luKFwiLFwiKSwgXCIpfVwiXS5qb2luKFwiXCIpKVxyXG5cclxuICBpZihwcm9jLmRlYnVnKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIHRodW5rOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXHJcbiAgfVxyXG4gIFxyXG4gIC8vQ29tcGlsZSB0aHVua1xyXG4gIHZhciB0aHVuayA9IG5ldyBGdW5jdGlvbihcImNvbXBpbGVcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxyXG4gIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQodW5kZWZpbmVkLCBwcm9jKSlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaHVua1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2N3aXNlLWNvbXBpbGVyL2xpYi90aHVuay5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ../~/iota-array/iota.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9pb3RhLWFycmF5L2lvdGEuanM/ZDFmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGFcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2lvdGEtYXJyYXkvaW90YS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ../~/is-buffer/index.js ***!
  \*******************************/
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9pcy1idWZmZXIvaW5kZXguanM/NzQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2lzLWJ1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 12 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** ../~/setimmediate/setImmediate.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 2), __webpack_require__(/*! ./../process/browser.js */ 0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzY1MDYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/* unknown exports provided */
/* all exports used */
/*!*************************!*\
  !*** ../~/uniq/uniq.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi91bmlxL3VuaXEuanM/YzNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3VuaXEvdW5pcS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 14 */
/* unknown exports provided */
/* all exports used */
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(/*! vue */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ndarray__ = __webpack_require__(/*! ndarray */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ndarray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_ndarray__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ndarray_ops__ = __webpack_require__(/*! ndarray-ops */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ndarray_ops___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_ndarray_ops__);\nconst KerasJS = __webpack_require__(/*! ../lib/keras */ 6)\r\n\r\n\r\n\r\n\r\nvar app = new __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */]({\r\n    el: '#app',\r\n    data: {\r\n        modelLoading: true,\r\n        model: new KerasJS.Model({\r\n            filepaths: {\r\n                model: 'model/model.json',\r\n                weights: 'model/model_weights.buf',\r\n                metadata: 'model/model_metadata.json',\r\n            },\r\n            gpu: true\r\n        }),\r\n        inputImage: {\r\n            URL: 'sample-data/test_image.png',\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        grayscaleImage: {\r\n            URL: '',\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        resultAA: ''\r\n    },\r\n    methods: {\r\n        onFileChange: function(e) {\r\n            let files = e.target.files || e.dataTransfer.files;\r\n            if (!files.length) {\r\n                return;\r\n            }\r\n            this.createImage(files[0]);\r\n        },\r\n        createImage: function(file) {\r\n            var image = new Image();\r\n            var reader = new FileReader();\r\n            reader.onload = (e) => {\r\n                this.inputImage.URL = e.target.result;\r\n            };\r\n            reader.readAsDataURL(file);\r\n        },\r\n        grayscale: function(imageURL) {\r\n            try {\r\n                // get image\r\n                var canvas = document.createElement(\"canvas\");\r\n                var ctx = canvas.getContext(\"2d\");\r\n                var img = new Image();\r\n                img.src = imageURL;\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n                ctx.drawImage(img, 0, 0);\r\n                var pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n                // update input image info\r\n                this.inputImage.width = img.width;\r\n                this.inputImage.height = img.height;\r\n                // grayscaling\r\n                for (var y = 0; y < pixels.height; y++) {\r\n                    for (var x = 0; x < pixels.width; x++) {\r\n                        var i = (y * 4) * pixels.width + x * 4;\r\n                        var rgb = parseInt((pixels.data[i] + pixels.data[i + 1] + pixels.data[i + 2]) / 3, 10);\r\n                        pixels.data[i] = rgb;\r\n                        pixels.data[i + 1] = rgb;\r\n                        pixels.data[i + 2] = rgb;\r\n                    }\r\n                }\r\n                // update\r\n                ctx.putImageData(pixels, 0, 0, 0, 0, pixels.width, pixels.height);\r\n                return [canvas.toDataURL(), pixels.width, pixels.height];\r\n            } catch (err) {\r\n                console.error('grayscale: ', err.message);\r\n                this.resultAA = err.message;\r\n                return '';\r\n            }\r\n        },\r\n        inputImageLoad: function() {\r\n            let [url, width, height] = this.grayscale(this.inputImage.URL);\r\n            this.grayscaleImage.URL = url;\r\n            this.grayscaleImage.width = width;\r\n            this.grayscaleImage.height = height;\r\n        },\r\n        grayscaleImageLoad: async function() {\r\n            try {\r\n                // get input data\r\n                const canvas = document.createElement(\"canvas\");\r\n                const ctx = canvas.getContext(\"2d\");\r\n                const img = new Image();\r\n                img.src = this.grayscaleImage.URL;\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n                ctx.drawImage(img, 0, 0);\r\n                const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n                // convert ndarray\r\n                let dataTensor = __WEBPACK_IMPORTED_MODULE_1_ndarray___default()(new Float32Array(pixels.data), [pixels.width, pixels.height]);\r\n                // normalization (0.0 ~ 1.0)\r\n                __WEBPACK_IMPORTED_MODULE_2_ndarray_ops___default.a.divseq(dataTensor, 255);\r\n                // calc AA line count\r\n                let lineNum = Math.floor(pixels.height / 18);\r\n                console.log('line count', lineNum);\r\n\r\n                // wait until model is ready\r\n                await this.model.ready();\r\n                console.log('model ready!');\r\n\r\n                // eval\r\n                // for (var i = 0; i < lineNum; i++) {\r\n                //     console.log(dataTensor)\r\n\r\n                //     let lineImage = dataTensor.data.slice(i * 18, i * 18 + 64);\r\n                //     let lineCharList = '';\r\n                //     let start = 0;\r\n                //     let end = 64;\r\n                //     let penalty = 1;\r\n\r\n                //     let width = 64;\r\n                //     while (end <= dataTensor.shape[1]) {\r\n                //         // lineImage.T\r\n                //         let patch = ndarray(new Float32Array(lineImage), [1, 64, 64]);\r\n                //         // predict\r\n                //         const inputData = {\r\n                //             'input_1': new Float32Array(patch.data)\r\n                //         };\r\n                //         const outputData = await this.model.predict(inputData);\r\n                //         console.log(outputData);\r\n\r\n                //         end += width;\r\n                //         await this.sleep(100);\r\n                //         console.log('processing: ', i, ', ', end);\r\n                //     }\r\n                // }\r\n            } catch (err) {\r\n                console.error('model: ', err.message);\r\n                this.resultAA = err.message;\r\n            }\r\n        },\r\n        sleep: async function (ms) {\r\n            return new Promise(resolve => setTimeout(resolve, ms));\r\n        }\r\n    },\r\n    computed: {\r\n        loadingProgress: function() {\r\n            return this.model.getLoadingProgress();\r\n        }\r\n    }\r\n})//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/Yzk5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBLZXJhc0pTID0gcmVxdWlyZSgnLi4vbGliL2tlcmFzJylcclxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXHJcbmltcG9ydCBuZGFycmF5IGZyb20gJ25kYXJyYXknO1xyXG5pbXBvcnQgb3BzIGZyb20gJ25kYXJyYXktb3BzJztcclxuXHJcbnZhciBhcHAgPSBuZXcgVnVlKHtcclxuICAgIGVsOiAnI2FwcCcsXHJcbiAgICBkYXRhOiB7XHJcbiAgICAgICAgbW9kZWxMb2FkaW5nOiB0cnVlLFxyXG4gICAgICAgIG1vZGVsOiBuZXcgS2VyYXNKUy5Nb2RlbCh7XHJcbiAgICAgICAgICAgIGZpbGVwYXRoczoge1xyXG4gICAgICAgICAgICAgICAgbW9kZWw6ICdtb2RlbC9tb2RlbC5qc29uJyxcclxuICAgICAgICAgICAgICAgIHdlaWdodHM6ICdtb2RlbC9tb2RlbF93ZWlnaHRzLmJ1ZicsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogJ21vZGVsL21vZGVsX21ldGFkYXRhLmpzb24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBncHU6IHRydWVcclxuICAgICAgICB9KSxcclxuICAgICAgICBpbnB1dEltYWdlOiB7XHJcbiAgICAgICAgICAgIFVSTDogJ3NhbXBsZS1kYXRhL3Rlc3RfaW1hZ2UucG5nJyxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3JheXNjYWxlSW1hZ2U6IHtcclxuICAgICAgICAgICAgVVJMOiAnJyxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzdWx0QUE6ICcnXHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIG9uRmlsZUNoYW5nZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBsZXQgZmlsZXMgPSBlLnRhcmdldC5maWxlcyB8fCBlLmRhdGFUcmFuc2Zlci5maWxlcztcclxuICAgICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUltYWdlKGZpbGVzWzBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZUltYWdlOiBmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0SW1hZ2UuVVJMID0gZS50YXJnZXQucmVzdWx0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdyYXlzY2FsZTogZnVuY3Rpb24oaW1hZ2VVUkwpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGdldCBpbWFnZVxyXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBpbWFnZVVSTDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpbnB1dCBpbWFnZSBpbmZvXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0SW1hZ2Uud2lkdGggPSBpbWcud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0SW1hZ2UuaGVpZ2h0ID0gaW1nLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIC8vIGdyYXlzY2FsaW5nXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBpeGVscy5oZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGl4ZWxzLndpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAoeSAqIDQpICogcGl4ZWxzLndpZHRoICsgeCAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZ2IgPSBwYXJzZUludCgocGl4ZWxzLmRhdGFbaV0gKyBwaXhlbHMuZGF0YVtpICsgMV0gKyBwaXhlbHMuZGF0YVtpICsgMl0pIC8gMywgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbHMuZGF0YVtpXSA9IHJnYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzLmRhdGFbaSArIDFdID0gcmdiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbHMuZGF0YVtpICsgMl0gPSByZ2I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlXHJcbiAgICAgICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKHBpeGVscywgMCwgMCwgMCwgMCwgcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbY2FudmFzLnRvRGF0YVVSTCgpLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHRdO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dyYXlzY2FsZTogJywgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRBQSA9IGVyci5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnB1dEltYWdlTG9hZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGxldCBbdXJsLCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuZ3JheXNjYWxlKHRoaXMuaW5wdXRJbWFnZS5VUkwpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXlzY2FsZUltYWdlLlVSTCA9IHVybDtcclxuICAgICAgICAgICAgdGhpcy5ncmF5c2NhbGVJbWFnZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXlzY2FsZUltYWdlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdyYXlzY2FsZUltYWdlTG9hZDogYXN5bmMgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgaW5wdXQgZGF0YVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIGltZy5zcmMgPSB0aGlzLmdyYXlzY2FsZUltYWdlLlVSTDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbmRhcnJheVxyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFUZW5zb3IgPSBuZGFycmF5KG5ldyBGbG9hdDMyQXJyYXkocGl4ZWxzLmRhdGEpLCBbcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0XSk7XHJcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uICgwLjAgfiAxLjApXHJcbiAgICAgICAgICAgICAgICBvcHMuZGl2c2VxKGRhdGFUZW5zb3IsIDI1NSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjYWxjIEFBIGxpbmUgY291bnRcclxuICAgICAgICAgICAgICAgIGxldCBsaW5lTnVtID0gTWF0aC5mbG9vcihwaXhlbHMuaGVpZ2h0IC8gMTgpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2xpbmUgY291bnQnLCBsaW5lTnVtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIG1vZGVsIGlzIHJlYWR5XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1vZGVsLnJlYWR5KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbW9kZWwgcmVhZHkhJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZXZhbFxyXG4gICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lTnVtOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhkYXRhVGVuc29yKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vICAgICBsZXQgbGluZUltYWdlID0gZGF0YVRlbnNvci5kYXRhLnNsaWNlKGkgKiAxOCwgaSAqIDE4ICsgNjQpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGxldCBsaW5lQ2hhckxpc3QgPSAnJztcclxuICAgICAgICAgICAgICAgIC8vICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGxldCBlbmQgPSA2NDtcclxuICAgICAgICAgICAgICAgIC8vICAgICBsZXQgcGVuYWx0eSA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gICAgIGxldCB3aWR0aCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHdoaWxlIChlbmQgPD0gZGF0YVRlbnNvci5zaGFwZVsxXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvLyBsaW5lSW1hZ2UuVFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgcGF0Y2ggPSBuZGFycmF5KG5ldyBGbG9hdDMyQXJyYXkobGluZUltYWdlKSwgWzEsIDY0LCA2NF0pO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvLyBwcmVkaWN0XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnN0IGlucHV0RGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICdpbnB1dF8xJzogbmV3IEZsb2F0MzJBcnJheShwYXRjaC5kYXRhKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjb25zdCBvdXRwdXREYXRhID0gYXdhaXQgdGhpcy5tb2RlbC5wcmVkaWN0KGlucHV0RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKG91dHB1dERhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZW5kICs9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBhd2FpdCB0aGlzLnNsZWVwKDEwMCk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9jZXNzaW5nOiAnLCBpLCAnLCAnLCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdtb2RlbDogJywgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRBQSA9IGVyci5tZXNzYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzbGVlcDogYXN5bmMgZnVuY3Rpb24gKG1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBsb2FkaW5nUHJvZ3Jlc3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRMb2FkaW5nUHJvZ3Jlc3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9hcHAuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);